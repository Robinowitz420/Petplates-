This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: **/.next/**, **/node_modules/**, **/*.xml, **/*scraper/**, **/lib/data/**, **/data/**, **/scripts/**, **/__tests__/**, **/*.test.ts, **/app/blog/**, **/app/about/**, **/app/contact/**, **/app/faq/**, **/app/privacy/**, **/components/village/**, **/app/village/**, **/lib/stores/villageStore.ts, **/*.csv, **/*.py, **/*.mjs, **/*.js, **/*.backup, **/*.json, **/*.md, **/*.txt, **/*.sh, **/*.ps1
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitattributes
.github/workflows/deploy.yml
.github/workflows/main.yml
.gitignore
.husky/pre-commit
.no-cursor-worktrees
app/api/amazon/purchase-confirmation/route.ts
app/api/purchases/route.ts
app/api/recipes/generate/route.ts
app/api/recommendations/route.ts
app/asin-verification/page.tsx
app/category/[category]/page.tsx
app/dashboard/page.tsx
app/diagnostics/image-inversion/page.tsx
app/forum/gallery/page.tsx
app/forum/page.tsx
app/globals.css
app/layout.tsx
app/meal-plans/page.tsx
app/nutrition-guide/page.tsx
app/page.tsx
app/pets/[id]/page.tsx
app/profile/page.tsx
app/profile/pet/[id]/custom-meals/[mealId]/page.tsx
app/profile/pet/[id]/custom-meals/page.tsx
app/profile/pet/[id]/meal-plan/page.tsx
app/profile/pet/[id]/page.tsx
app/profile/pet/[id]/recipe-builder/page.tsx
app/profile/pet/[id]/saved-recipes/page.tsx
app/recipe/[id]/page.tsx
app/recipes/recommended/[id]/page.tsx
app/robots.ts
app/sign-in/[[...sign-in]]/page.tsx
app/sign-up/[[...sign-up]]/page.tsx
app/sitemap.ts
app/subscribe/page.tsx
components/ABTestDashboard.tsx
components/BadgeToggle.tsx
components/CompatibilityBadge.tsx
components/CompatibilityPanel.tsx
components/ConfirmModal.tsx
components/CostComparison.tsx
components/CreatePetModal.tsx
components/EmailCaptureModal.tsx
components/EmojiIcon.tsx
components/ErrorBoundary.tsx
components/ErrorBoundaryWrapper.tsx
components/FeedingLogger.tsx
components/FireworksAnimation.tsx
components/Footer.tsx
components/HealthConcernsDropdown.tsx
components/Image.tsx
components/IngredientPicker.tsx
components/InteractiveStarRating.tsx
components/LoadingSpinner.tsx
components/MascotAvatar.tsx
components/MascotIcon.tsx
components/mascots/FarmerFluff.tsx
components/mascots/MascotAnimation.tsx
components/mascots/ProfessorPurrfessor.tsx
components/mascots/PuppyPreper.tsx
components/mascots/RobinRedroute.tsx
components/mascots/SherlockShells.tsx
components/MealBuilderWizard.tsx
components/MealCompleteView.tsx
components/MealCompositionList.tsx
components/MultiPetShoppingModal.tsx
components/Navigation.tsx
components/NutritionDashboard.tsx
components/OfflineBanner.tsx
components/OneClickCheckoutModal.tsx
components/PetBadges.tsx
components/PetVillageWidget.tsx
components/ProfileSelector.tsx
components/PurchaseConfirmationModal.tsx
components/QuickPreviewModal.tsx
components/RatingBreakdown.tsx
components/RatingDistribution.tsx
components/RecipeCard.tsx
components/RecipeRatingSection.tsx
components/RecipeScoreModal.tsx
components/ScoringProgress.tsx
components/SEOHead.tsx
components/ShoppingList.tsx
components/ShoppingListSummary.tsx
components/SocialProof.tsx
components/StarRating.tsx
components/SuggestedIngredients.tsx
components/Tooltip.tsx
components/TrustBadges.tsx
components/ValidationMessages.tsx
components/VillageBackground.tsx
components/VillageBuildings.tsx
components/VillagePlaceholder.tsx
components/VillageScene.tsx
config/deploy.yml
config/firestore.rules
config/globals.d.ts
config/tailwind.config.ts
config/vitest.config.ts
hooks/useAsyncOperation.ts
hooks/useOfflineDetector.ts
hooks/useProgressiveMealCount.ts
lib/analyzeCustomMeal.ts
lib/applyModifiers.ts
lib/audit/RecipeNutritionalAudit.ts
lib/audit/RecipePalatabilityAudit.ts
lib/audit/RecipeVarietyAudit.ts
lib/competitors/balanceit-analysis.ts
lib/generator/AmazonLinkAudit.ts
lib/generator/AutoClassifyLinks.ts
lib/generator/BirdDebug.ts
lib/generator/BirdDetailedDebug.ts
lib/generator/BirdTest.ts
lib/generator/CheckBirdIngredients.ts
lib/generator/CombinatoricsPruning.ts
lib/generator/CommercialPriorEnforcement.ts
lib/generator/ComprehensiveAudit.ts
lib/generator/DebugProteinRole.ts
lib/generator/GenerateVerificationList.ts
lib/generator/Phase1_5_AutoClassify.ts
lib/generator/QuickTest.ts
lib/generator/RecipeBuilder.ts
lib/generator/RecipeCompositionValidator.ts
lib/generator/RecipeConstraintRules.ts
lib/generator/RecipePMIScoring.ts
lib/generator/RecipePriorScoring.ts
lib/generator/VerifyAmazonLinks.ts
lib/hooks/useChunkedRecipeScoring.ts
lib/meal-plan-generator.ts
lib/modifierRules.ts
lib/nutrition/nutritionHistory.ts
lib/portionCalc.ts
lib/quoteGenerator.ts
lib/recipe-generator-legacy.ts
lib/recipe-generator-v3.ts
lib/recipe-generator.ts
lib/scoreRecipe.ts
lib/seo/metadata.ts
lib/services/amazonPurchaseTracker.ts
lib/services/brandBasedVetter.ts
lib/services/firestoreService.ts
lib/services/unifiedVettingService.ts
lib/state/villageStore.ts
lib/types.ts
lib/types/aliasGroups.ts
lib/types/badges.ts
lib/types/index.ts
lib/types/retailValidation.ts
lib/utils/abTesting.ts
lib/utils/affiliateLinks.ts
lib/utils/allIngredients.ts
lib/utils/auth.ts
lib/utils/badgeChecker.ts
lib/utils/badgeStorage.ts
lib/utils/beep.ts
lib/utils/buyLinkValidation.ts
lib/utils/convertCustomMealToRecipe.ts
lib/utils/customMealStorage.ts
lib/utils/customMealStorageFirebase.ts
lib/utils/diversityTracker.ts
lib/utils/emojiMapping.ts
lib/utils/enhancedCompatibilityScoring.ts
lib/utils/errorHandler.ts
lib/utils/firebaseConfig.ts
lib/utils/getAmazonBuyLink.ts
lib/utils/healthConcernMatching.ts
lib/utils/imageMapping.ts
lib/utils/improvedCompatibilityScoring.ts
lib/utils/ingredientCompatibility.ts
lib/utils/ingredientNameNormalizer.ts
lib/utils/ingredientRegistry.ts
lib/utils/ingredientSuggestions.ts
lib/utils/ingredientWhitelists.ts
lib/utils/localStorageSafe.ts
lib/utils/logger.ts
lib/utils/mascotImageMapping.ts
lib/utils/mealCalculator.ts
lib/utils/mealCountCalculator.ts
lib/utils/mealEstimation.ts
lib/utils/mealImageAssignment.ts
lib/utils/mealNameGenerator.ts
lib/utils/nutritionalRecommendations.ts
lib/utils/nutritionFallbacks.ts
lib/utils/organicCount.ts
lib/utils/petPurchaseTracking.ts
lib/utils/petRatingSystem.ts
lib/utils/petStorage.ts
lib/utils/petUtils.ts
lib/utils/priceValidation.ts
lib/utils/purchaseLinks.ts
lib/utils/purchaseTracking.ts
lib/utils/ratings.ts
lib/utils/recipeIngredients.ts
lib/utils/recipeRecommendations.ts
lib/utils/recipeScoring.ts
lib/utils/scoringDiagnostics.ts
lib/utils/scoringTransparency.ts
lib/utils/telemetry.ts
lib/utils/validation.ts
lib/validation/asinClusterer.ts
lib/validation/enhancedRetailValidator.ts
lib/validation/petSchema.ts
lib/validation/retailSpecDefinitions.ts
lib/validation/retailValidator.ts
lib/validation/tokenEquivalence.ts
middleware.tsx
PetPlates
src/utils/nutrition-data.ts
tailwind.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitattributes">
*.exe filter=lfs diff=lfs merge=lfs -text
</file>

<file path=".github/workflows/deploy.yml">
name: Deploy Next.js to GitHub Pages

on:
  push:
    branches:
      - main

permissions:
  contents: write

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Setup Node.js environment
        uses: actions/setup-node@v3
        with:
          node-version: 20

      - name: Install dependencies
        run: npm install

      - name: Build static site
        run: npm run build

      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./out
</file>

<file path=".github/workflows/main.yml">
name: Deploy Next.js to GitHub Pages

on:
  push:
    branches:
      - main

permissions:
  contents: write

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Setup Node.js environment
        uses: actions/setup-node@v3
        with:
          node-version: 20

      - name: Install dependencies
        run: npm install

      - name: Build static site
        run: npm run build

      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./out
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
node_modules/
/.pnp
.pnp.js
.yarn/install-state.gz

# testing
/coverage

# next.js
.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local
.env

# vercel
.vercel/

# typescript
*.tsbuildinfo
next-env.d.ts

# clerk configuration (can include secrets)
/.clerk/

# generated images
images/
.vercel

# Auto-generated validation artifacts
.validation-output.log
.pre-commit-validation.log

# Keep manual review CSVs (tracked for audit trail)
# PHASE_*_MANUAL_REVIEW.csv - NOT ignored, these are tracked
# AUTO_CLASSIFICATION_REPORT.md - NOT ignored, these are tracked
</file>

<file path=".husky/pre-commit">
#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

# Pre-commit hook for validating CSV and artifact changes
# Only runs if validation-related files are staged

echo "üîç Checking for validation-related changes..."

# Check if any validation files are staged
VALIDATION_FILES=$(git diff --cached --name-only | grep -E '(lib/validation|lib/data/vetted-products|retailSpecDefinitions)')

if [ -n "$VALIDATION_FILES" ]; then
  echo "üìã Validation files changed, running Phase 1.5 classifier..."
  
  # Run the classifier
  npx tsx lib/generator/Phase1_5_AutoClassify.ts > .pre-commit-validation.log 2>&1
  
  # Check if it succeeded
  if [ $? -eq 0 ]; then
    echo "‚úÖ Validation passed"
    
    # Stage the generated CSV if it exists
    if [ -f "PHASE_1_5_MANUAL_REVIEW.csv" ]; then
      git add PHASE_1_5_MANUAL_REVIEW.csv
      echo "üìä Staged updated PHASE_1_5_MANUAL_REVIEW.csv"
    fi
  else
    echo "‚ùå Validation failed - check .pre-commit-validation.log"
    exit 1
  fi
fi

# Check if CSV files are being committed
CSV_FILES=$(git diff --cached --name-only | grep '\.csv$')

if [ -n "$CSV_FILES" ]; then
  echo "‚ö†Ô∏è  CSV files being committed:"
  echo "$CSV_FILES"
  echo ""
  echo "Make sure these are intentional changes, not auto-generated artifacts."
  echo "Press Enter to continue or Ctrl+C to abort..."
  read
fi

echo "‚úÖ Pre-commit checks passed"
</file>

<file path=".no-cursor-worktrees">
disable
</file>

<file path="app/api/amazon/purchase-confirmation/route.ts">
import { NextRequest, NextResponse } from 'next/server';

/**
 * Webhook endpoint to receive purchase confirmations from Amazon
 * Validates purchase confirmations and updates tracking
 * 
 * Note: This is a placeholder implementation.
 * In production, this would:
 * 1. Verify the webhook signature from Amazon
 * 2. Validate the purchase data
 * 3. Update the database with confirmed purchases
 * 4. Trigger village level updates
 */
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { 
      userId, 
      orderId, 
      items, 
      signature, 
      timestamp 
    } = body;

    // TODO: Verify webhook signature
    // const isValid = verifyAmazonWebhookSignature(signature, body, timestamp);
    // if (!isValid) {
    //   return NextResponse.json({ error: 'Invalid signature' }, { status: 401 });
    // }

    // TODO: Validate purchase data
    if (!userId || !orderId || !items || !Array.isArray(items)) {
      return NextResponse.json(
        { error: 'Invalid purchase data' },
        { status: 400 }
      );
    }

    // TODO: Update database with confirmed purchases
    // For each item in items:
    //   - Find pending purchase record
    //   - Mark as confirmed
    //   - Add amazonOrderId
    //   - Update village level if threshold reached

    // Placeholder response
    return NextResponse.json({
      success: true,
      message: 'Purchase confirmation received',
      userId,
      orderId,
      itemsCount: items.length,
      note: 'Purchase confirmation is currently handled client-side. This endpoint is ready for Amazon Associates API integration.'
    });
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to process purchase confirmation' },
      { status: 500 }
    );
  }
}

/**
 * Verify Amazon webhook signature
 * This would implement proper signature verification in production
 */
function verifyAmazonWebhookSignature(
  signature: string,
  body: any,
  timestamp: string
): boolean {
  // TODO: Implement Amazon webhook signature verification
  // This would use the secret key to verify the signature
  return true; // Placeholder
}
</file>

<file path="app/api/purchases/route.ts">
import { NextRequest, NextResponse } from 'next/server';

/**
 * GET: Returns current purchase count and village level
 * POST: Manually confirm a purchase (for testing/fallback)
 */
export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const userId = searchParams.get('userId');

    if (!userId) {
      return NextResponse.json(
        { error: 'userId is required' },
        { status: 400 }
      );
    }

    // In a real implementation, this would query a database
    // For now, return a placeholder response
    // The actual data is stored in localStorage on the client side
    return NextResponse.json({
      message: 'Purchase data is stored client-side in localStorage',
      userId,
      note: 'Use getPurchaseStats() from lib/utils/purchaseTracking.ts on the client side'
    });
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to fetch purchase data' },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { userId, ingredientId, ingredientName, amazonOrderId } = body;

    if (!userId || !ingredientId || !ingredientName) {
      return NextResponse.json(
        { error: 'userId, ingredientId, and ingredientName are required' },
        { status: 400 }
      );
    }

    // In a real implementation, this would update a database
    // For now, return a success response
    // The actual confirmation is handled client-side via confirmPurchase()
    return NextResponse.json({
      success: true,
      message: 'Purchase confirmed',
      userId,
      ingredientId,
      ingredientName,
      amazonOrderId,
      note: 'Purchase confirmation is handled client-side via confirmPurchase() from lib/utils/purchaseTracking.ts'
    });
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to confirm purchase' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/recipes/generate/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { generateRecipesForPet } from '@/lib/recipe-generator-v3';
import type { Pet } from '@/lib/types';

export const runtime = 'nodejs';

interface RecipeRequest {
  species?: string;
  count?: number;
  petProfile?: {
    name?: string;
    weight?: string;
    weightKg?: number;
    age?: string;
    allergies?: string[];
    healthConcerns?: string[];
  };
}

/**
 * Generate recipes dynamically based on pet species
 * POST /api/recipes/generate
 * Body: { species: 'dogs' | 'cats' | 'birds' | 'reptiles' | 'pocket-pets', count?: number, petProfile?: {...} }
 */
export async function POST(request: NextRequest) {
  try {
    const body: RecipeRequest = await request.json();
    const { species = 'dogs', count = 50, petProfile } = body;

    // Create a mock pet for recipe generation
    const mockPet: any = {
      id: `mock-${species}-${Date.now()}`,
      name: petProfile?.name || 'Your Pet',
      type: species,
      breed: 'Mixed',
      age: petProfile?.age || 'adult',
      weight: petProfile?.weight || '10',
      weightKg: petProfile?.weightKg || 10,
      allergies: petProfile?.allergies || [],
      healthConcerns: petProfile?.healthConcerns || [],
    };

    // Generate recipes using pragmatic system
    console.log('[API] Generating recipes for pet:', {
      name: mockPet.name,
      type: mockPet.type,
      healthConcerns: mockPet.healthConcerns,
      allergies: mockPet.allergies,
    });
    
    const recipes = generateRecipesForPet(
      {
        pet: mockPet as Pet,
      },
      count
    );

    console.log('[API] Generated recipes count:', recipes?.length || 0);

    const generatedRecipes = recipes.map((recipe: any, index: number) => ({
      ...recipe,
      id: recipe.id || `generated-${species}-${index}-${Date.now()}`,
      generatedAt: new Date().toISOString(),
    }));

    if (generatedRecipes.length === 0) {
      console.error('[API] No recipes generated - returning 500');
      return NextResponse.json(
        { error: 'Failed to generate any recipes', species, attemptedCount: count, petProfile: mockPet },
        { status: 500 }
      );
    }

    // Sort by overall score (best first)
    generatedRecipes.sort((a: any, b: any) => (b.scores?.overall || 0) - (a.scores?.overall || 0));

    return NextResponse.json({
      success: true,
      recipes: generatedRecipes,
      stats: {
        total: generatedRecipes.length,
        avgScore: (generatedRecipes.reduce((sum: number, r: any) => sum + (r.scores?.overall || 0), 0) / generatedRecipes.length).toFixed(1),
      },
    });
  } catch (error) {
    console.error('Recipe generation error:', error);
    return NextResponse.json(
      { error: 'Failed to generate recipes', details: String(error) },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/recommendations/route.ts">
import { NextResponse } from 'next/server';
import { generateModifiedRecommendations } from '@/lib/applyModifiers';
import { PetNutritionProfile } from '@/lib/types';
import { getRecommendedRecipes } from '@/lib/utils/recipeRecommendations';

const normalizeValue = (value?: string | null) => {
  const normalized = (value || '').trim().toLowerCase();
  // Replace multiple consecutive non-alphanumeric chars with single dash
  return normalized.replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
};

export async function POST(request: Request) {
  try {
    const body = await request.json();
    const { profile, recipeIds, limit, minCompatibilityScore } = body;

    // API request received

    if (!profile || !profile.species || !profile.ageGroup || !profile.weightKg) {
      return NextResponse.json(
        { error: 'Missing required profile fields (species, ageGroup, weightKg).' },
        { status: 400 }
      );
    }

    const bannedIngredients = (profile.bannedIngredients || []).map(normalizeValue);
    
    const normalizedProfile: PetNutritionProfile = {
      species: profile.species,
      ageGroup: normalizeValue(profile.ageGroup),
      weightKg: Number(profile.weightKg),
      breed: profile.breed || null,
      healthConcerns: (profile.healthConcerns || []).map(normalizeValue),
      allergies: (profile.allergies || []).map(normalizeValue),
      caloriesPerKgOverride: profile.caloriesPerKgOverride
        ? Number(profile.caloriesPerKgOverride)
        : undefined,
      petName: profile.petName,
    };
    
    // Helper to check if recipe contains banned ingredients
    const hasBannedIngredient = (recipe: any): boolean => {
      if (bannedIngredients.length === 0) return false;
      const recipeIngredients = (recipe.ingredients || []).map((ing: any) => {
        const name = typeof ing === 'string' ? ing : ing.name;
        return normalizeValue(name);
      });
      return bannedIngredients.some((banned: string) => 
        recipeIngredients.some((ing: string) => ing.includes(banned) || banned.includes(ing))
      );
    };

    // Helper to check if recipe contains allergens
    const hasAllergen = (recipe: any): boolean => {
      const allergies = normalizedProfile.allergies || [];
      if (allergies.length === 0) return false;
      const recipeIngredients = (recipe.ingredients || []).map((ing: any) => {
        const name = typeof ing === 'string' ? ing : ing.name;
        return normalizeValue(name);
      });
      return allergies.some((allergy: string) => 
        recipeIngredients.some((ing: string) => ing.includes(allergy) || allergy.includes(ing))
      );
    };

    if (Number.isNaN(normalizedProfile.weightKg) || normalizedProfile.weightKg <= 0) {
      return NextResponse.json(
        { error: 'weightKg must be a positive number.' },
        { status: 400 }
      );
    }

    let results: any[] = [];
    
    try {
      results = generateModifiedRecommendations({
        profile: normalizedProfile,
        recipeIds: recipeIds || [],
        limit: limit ?? 50,
        minCompatibilityScore: minCompatibilityScore ?? 30,
      });
      
      // Filter out recipes with banned ingredients and allergens
      results = results.filter(result => {
        const recipe = result.recipe;
        return !hasBannedIngredient(recipe) && !hasAllergen(recipe);
      });
    } catch (error) {
      // Error in generateModifiedRecommendations - handled below
      // Continue to fallback
    }

    // Fallback: If no results, use tiered recommendation system
    if (!Array.isArray(results) || results.length === 0) {
      const petForRecommendations = {
        id: '',
        name: normalizedProfile.petName || '',
        type: normalizedProfile.species,
        breed: normalizedProfile.breed || '',
        age: normalizedProfile.ageGroup,
        healthConcerns: normalizedProfile.healthConcerns || []
      };
      
      const tieredRecs = getRecommendedRecipes(petForRecommendations, limit ?? 10, true);
      
      // Filter out recipes with banned ingredients
      const filteredRecs = tieredRecs.filter(rec => !hasBannedIngredient(rec.recipe));
      
      // Convert tiered recommendations to ModifiedRecipeResult format
      results = filteredRecs.map(rec => ({
        recipe: rec.recipe,
        adjustedIngredients: rec.recipe.ingredients,
        appliedRules: [],
        nutritionChanges: {},
        portionPlan: {
          dailyGrams: normalizedProfile.weightKg * 20, // Rough estimate
          multiplier: 1,
          mealsPerDay: 2,
          notes: []
        },
        shoppingList: rec.recipe.ingredients.map(ing => ({
          name: ing.name,
          amount: ing.amount,
          asinLink: ing.asinLink || '',
          notes: '',
          category: 'Ingredient'
        })),
        explanation: `Recommended for ${normalizedProfile.petName || 'your pet'}: ${rec.tierLabel}`,
        weeklyPlan: [],
        score: rec.score,
        _tierLabel: rec.tierLabel,
        _warning: rec.warning,
        _healthMatch: rec.healthConcernMatch
      }));
    }
    
    // FALLBACK 2: If still empty, show general recipes for the species
    if (!Array.isArray(results) || results.length === 0) {
      // Both recommendation methods failed - using general recipes
      const generalRecipes = recipes
        .filter(r => {
          // Try to match by species (normalized)
          const normalizeSpecies = (s: string) => s.toLowerCase().replace(/s$/, '');
          const speciesMatch = normalizeSpecies(r.category) === normalizeSpecies(normalizedProfile.species);
          // Also filter out banned ingredients
          return speciesMatch && !hasBannedIngredient(r);
        })
        .slice(0, limit ?? 5)
        .map(r => ({
          recipe: r,
          adjustedIngredients: r.ingredients,
          appliedRules: [],
          nutritionChanges: {},
          portionPlan: {
            dailyGrams: normalizedProfile.weightKg * 20,
            multiplier: 1,
            mealsPerDay: 2,
            notes: ['General recommendation - consult vet']
          },
          shoppingList: r.ingredients.map(ing => ({
            name: ing.name,
            amount: ing.amount,
            asinLink: ing.asinLink || '',
            notes: 'General recommendation - consult vet',
            category: 'Ingredient'
          })),
          explanation: `${r.name} - General recommendation for ${normalizedProfile.petName || 'your pet'}. Please consult your veterinarian.`,
          weeklyPlan: [],
          score: 30, // Low score to indicate it's a general recommendation
          _tierLabel: 'General Recommendation',
          _warning: 'General recommendation - consult vet',
          _healthMatch: undefined
        }));
      
      results = generalRecipes;
    }

    // API returning recipes
    const totalFound = results.length;

    return NextResponse.json({ 
      results,
      totalFound,
      metadata: {
        filteredByCompatibility: true,
        minCompatibilityScore: minCompatibilityScore ?? 30,
        filteredByBannedIngredients: bannedIngredients.length > 0,
        filteredByAllergies: (normalizedProfile.allergies || []).length > 0,
      }
    });
  } catch (error) {
    console.error('Recommendation engine failure:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { error: `Unable to generate recommendations: ${errorMessage}` },
      { status: 500 }
    );
  }
}
</file>

<file path="app/asin-verification/page.tsx">
'use client';

import React, { useState, useEffect } from 'react';
import { Search, CheckCircle, AlertCircle, Edit2, ExternalLink, Download } from 'lucide-react';

// Import the real vetted products data
import { VETTED_PRODUCTS } from '@/lib/data/vetted-products';
import { INITIAL_VERIFICATION_STATE } from '@/lib/data/verification-state';

// Import automated correction suggestions (if available)
let AUTOMATED_CORRECTIONS = {};
try {
  const correctionsPath = './lib/data/vetted-products-CORRECTED.txt';
  // We'll load this dynamically if it exists
} catch (e) {
  // File doesn't exist yet
}

function extractASIN(url: string) {
  const match = url.match(/\/dp\/([A-Z0-9]{10})/);
  return match ? match[1] : null;
}

export default function ASINVerificationPage() {
  const [products, setProducts] = useState<any[]>([]);
  const [filter, setFilter] = useState('all');
  const [editingId, setEditingId] = useState<string | null>(null);
  const [editData, setEditData] = useState<any>({});
  const [searchQuery, setSearchQuery] = useState('');

  useEffect(() => {
    // Convert vetted products to array format with initial verification state
    const productArray = Object.entries(VETTED_PRODUCTS).map(([ingredient, data]: [string, any]) => {
      const verificationState = INITIAL_VERIFICATION_STATE.find(v => v.ingredient === ingredient);

      return {
        id: ingredient,
        ingredient,
        productName: data.productName,
        amazonLink: data.asinLink || data.amazonLink,
        vetNote: data.vetNote,
        category: data.category,
        asin: extractASIN(data.asinLink || data.amazonLink),
        verified: verificationState?.verified || false,
        needsReview: verificationState?.needsReview || true,
        autoVerified: verificationState?.autoVerified || false,
        commissionRate: data.commissionRate,
        species: data.species,
        costTier: data.costTier
      };
    });
    setProducts(productArray);
  }, []);

  const filteredProducts = products.filter(p => {
    if (filter === 'needs-review') return p.needsReview;
    if (filter === 'verified') return p.verified;
    if (filter === 'auto-verified') return p.autoVerified;
    if (searchQuery) {
      return p.ingredient.toLowerCase().includes(searchQuery.toLowerCase()) ||
             p.productName.toLowerCase().includes(searchQuery.toLowerCase()) ||
             (p.category && p.category.toLowerCase().includes(searchQuery.toLowerCase()));
    }
    return true;
  });

  const startEdit = (product: any) => {
    setEditingId(product.id);
    setEditData({
      productName: product.productName,
      asin: product.asin,
      vetNote: product.vetNote
    });
  };

  const saveEdit = (id: string) => {
    setProducts(products.map(p => {
      if (p.id === id) {
        return {
          ...p,
          productName: editData.productName,
          asin: editData.asin,
          amazonLink: `https://www.amazon.com/dp/${editData.asin}?tag=robinfrench-20`,
          vetNote: editData.vetNote,
          verified: true,
          needsReview: false
        };
      }
      return p;
    }));
    setEditingId(null);
  };

  const markVerified = (id: string) => {
    setProducts(products.map(p =>
      p.id === id ? { ...p, verified: true, needsReview: false } : p
    ));
  };

  const exportCorrections = () => {
    const corrections = products
      .filter(p => p.verified)
      .map(p => ({
        ingredient: p.ingredient,
        productName: p.productName,
        asin: p.asin,
        amazonLink: p.amazonLink,
        vetNote: p.vetNote,
        category: p.category,
        commissionRate: p.commissionRate,
        species: p.species,
        costTier: p.costTier
      }));

    const tsCode = `// Corrected products - ${new Date().toISOString()}\n` +
      `export const CORRECTED_PRODUCTS: Record<string, any> = {\n` +
      corrections.map(c =>
        `  '${c.ingredient}': {\n` +
        `    productName: '${c.productName}',\n` +
        `    asinLink: '${c.amazonLink}',\n` +
        `    vetNote: '${c.vetNote}',\n` +
        `    category: '${c.category}',\n` +
        `    commissionRate: ${c.commissionRate},\n` +
        `    species: ${JSON.stringify(c.species)},\n` +
        `    costTier: '${c.costTier}'\n` +
        `  }`
      ).join(',\n') +
      '\n};';

    const blob = new Blob([tsCode], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'corrected-products.ts';
    a.click();
  };

  const stats = {
    total: products.length,
    verified: products.filter(p => p.verified).length,
    autoVerified: products.filter(p => p.autoVerified).length,
    manuallyVerified: products.filter(p => p.verified && !p.autoVerified).length,
    needsReview: products.filter(p => p.needsReview).length
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100 p-6">
      <div className="max-w-7xl mx-auto">
        {/* Header */}
        <div className="bg-white rounded-xl shadow-lg p-6 mb-6">
          <h1 className="text-3xl font-bold text-slate-800 mb-2">
            ASIN Verification Tool
          </h1>
          <p className="text-slate-600">
            Review and correct product ASINs for your vetted products list
          </p>

          {/* Stats */}
          <div className="grid grid-cols-2 md:grid-cols-5 gap-4 mt-6">
            <div className="bg-blue-50 rounded-lg p-4">
              <div className="text-2xl font-bold text-blue-600">{stats.total}</div>
              <div className="text-sm text-blue-600">Total Products</div>
            </div>
            <div className="bg-green-50 rounded-lg p-4">
              <div className="text-2xl font-bold text-green-600">{stats.verified}</div>
              <div className="text-sm text-green-600">Total Verified</div>
            </div>
            <div className="bg-emerald-50 rounded-lg p-4">
              <div className="text-2xl font-bold text-emerald-600">{stats.autoVerified}</div>
              <div className="text-sm text-emerald-600">Auto-Verified</div>
            </div>
            <div className="bg-teal-50 rounded-lg p-4">
              <div className="text-2xl font-bold text-teal-600">{stats.manuallyVerified}</div>
              <div className="text-sm text-teal-600">Manually Verified</div>
            </div>
            <div className="bg-orange-50 rounded-lg p-4">
              <div className="text-2xl font-bold text-orange-600">{stats.needsReview}</div>
              <div className="text-sm text-orange-600">Needs Review</div>
            </div>
          </div>

          {/* Progress Bar */}
          <div className="mt-4">
            <div className="flex justify-between text-sm text-slate-600 mb-1">
              <span>Verification Progress</span>
              <span>{stats.total > 0 ? Math.round((stats.verified / stats.total) * 100) : 0}% Complete</span>
            </div>
            <div className="w-full bg-slate-200 rounded-full h-2">
              <div
                className="bg-gradient-to-r from-green-500 to-blue-500 h-2 rounded-full transition-all duration-300"
                style={{ width: `${stats.total > 0 ? (stats.verified / stats.total) * 100 : 0}%` }}
              ></div>
            </div>
          </div>
        </div>

        {/* Controls */}
        <div className="bg-white rounded-xl shadow-lg p-4 mb-6">
          <div className="flex gap-4 flex-wrap">
            <div className="flex-1 min-w-64">
              <div className="relative">
                <Search className="absolute left-3 top-3 text-slate-400 w-5 h-5" />
                <input
                  type="text"
                  placeholder="Search ingredients, products, or categories..."
                  value={searchQuery}
                  onChange={(e) => setSearchQuery(e.target.value)}
                  className="w-full pl-10 pr-4 py-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                />
              </div>
            </div>

            <select
              value={filter}
              onChange={(e) => setFilter(e.target.value)}
              className="px-4 py-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-blue-500"
            >
              <option value="all">All Products ({stats.total})</option>
              <option value="needs-review">Needs Review ({stats.needsReview})</option>
              <option value="verified">Verified ({stats.verified})</option>
              <option value="auto-verified">Auto-Verified ({products.filter(p => p.autoVerified).length})</option>
            </select>

            <button
              onClick={exportCorrections}
              className="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 flex items-center gap-2"
              disabled={stats.verified === 0}
            >
              <Download className="w-4 h-4" />
              Export Corrections ({stats.verified})
            </button>
          </div>
        </div>

        {/* Products List */}
        <div className="space-y-4">
          {filteredProducts.map(product => (
            <div key={product.id} className={`bg-white rounded-xl shadow-lg p-6 ${product.needsReview ? 'border-l-4 border-orange-400' : 'border-l-4 border-green-400'}`}>
              {editingId === product.id ? (
                // Edit Mode
                <div className="space-y-4">
                  <div className="flex items-center gap-2 mb-4">
                    <h3 className="text-lg font-bold text-slate-800">
                      Editing: {product.ingredient}
                    </h3>
                    <span className="px-2 py-1 bg-slate-100 text-slate-600 rounded text-sm">
                      {product.category}
                    </span>
                  </div>

                  <div>
                    <label className="block text-sm font-medium text-slate-700 mb-1">
                      Product Name
                    </label>
                    <input
                      type="text"
                      value={editData.productName}
                      onChange={(e) => setEditData({...editData, productName: e.target.value})}
                      className="w-full px-3 py-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                    />
                  </div>

                  <div>
                    <label className="block text-sm font-medium text-slate-700 mb-1">
                      ASIN
                    </label>
                    <input
                      type="text"
                      value={editData.asin}
                      onChange={(e) => setEditData({...editData, asin: e.target.value})}
                      className="w-full px-3 py-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                      placeholder="B0XXXXXXXXX"
                    />
                  </div>

                  <div>
                    <label className="block text-sm font-medium text-slate-700 mb-1">
                      Vet Note
                    </label>
                    <textarea
                      value={editData.vetNote}
                      onChange={(e) => setEditData({...editData, vetNote: e.target.value})}
                      className="w-full px-3 py-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                      rows={3}
                    />
                  </div>

                  <div className="flex gap-2">
                    <button
                      onClick={() => saveEdit(product.id)}
                      className="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700"
                    >
                      Save Changes
                    </button>
                    <button
                      onClick={() => setEditingId(null)}
                      className="px-4 py-2 bg-slate-300 text-slate-700 rounded-lg hover:bg-slate-400"
                    >
                      Cancel
                    </button>
                  </div>
                </div>
              ) : (
                // View Mode
                <div>
                  <div className="flex items-start justify-between mb-4">
                    <div className="flex-1">
                      <div className="flex items-center gap-3 mb-2">
                        <h3 className="text-xl font-bold text-slate-800">
                          {product.ingredient}
                        </h3>
                        {product.verified ? (
                          <span className="flex items-center gap-1 px-3 py-1 bg-green-100 text-green-700 rounded-full text-sm">
                            <CheckCircle className="w-4 h-4" />
                            {product.autoVerified ? 'Auto-Verified' : 'Verified'}
                          </span>
                        ) : (
                          <span className="flex items-center gap-1 px-3 py-1 bg-orange-100 text-orange-700 rounded-full text-sm">
                            <AlertCircle className="w-4 h-4" />
                            Needs Review
                          </span>
                        )}
                        <span className="px-2 py-1 bg-slate-100 text-slate-600 rounded text-sm">
                          {product.category}
                        </span>
                      </div>
                      <div className="text-slate-600 mb-2">
                        <strong>Product:</strong> {product.productName}
                      </div>
                      <div className="text-slate-600 mb-2">
                        <strong>ASIN:</strong> <code className="bg-slate-100 px-2 py-1 rounded">{product.asin}</code>
                      </div>
                      <div className="text-sm text-slate-500 mt-2">
                        {product.vetNote}
                      </div>
                    </div>

                    <div className="flex gap-2">
                      <a
                        href={product.amazonLink}
                        target="_blank"
                        rel="noopener noreferrer"
                        className="p-2 text-blue-600 hover:bg-blue-50 rounded-lg"
                        title="View on Amazon"
                      >
                        <ExternalLink className="w-5 h-5" />
                      </a>
                      <button
                        onClick={() => startEdit(product)}
                        className="p-2 text-slate-600 hover:bg-slate-100 rounded-lg"
                        title="Edit"
                      >
                        <Edit2 className="w-5 h-5" />
                      </button>
                      {!product.verified && (
                        <button
                          onClick={() => markVerified(product.id)}
                          className="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 text-sm"
                        >
                          Mark Verified
                        </button>
                      )}
                    </div>
                  </div>

                  {/* Quick Actions */}
                  <div className="mt-4 pt-4 border-t border-slate-200">
                    <div className="text-sm text-slate-600 space-y-2">
                      <div>
                        <strong>Quick Search:</strong>{' '}
                        <a
                          href={`https://www.amazon.com/s?k=${encodeURIComponent(product.ingredient + ' for dogs')}&i=pet-supplies`}
                          target="_blank"
                          rel="noopener noreferrer"
                          className="text-blue-600 hover:underline"
                        >
                          Search "{product.ingredient}" on Amazon ‚Üí
                        </a>
                      </div>
                      <div>
                        <strong>ASIN Check:</strong>{' '}
                        <a
                          href={`https://www.amazon.com/dp/${product.asin}`}
                          target="_blank"
                          rel="noopener noreferrer"
                          className="text-blue-600 hover:underline"
                        >
                          Verify current ASIN ‚Üí
                        </a>
                      </div>
                    </div>
                  </div>
                </div>
              )}
            </div>
          ))}
        </div>

        {filteredProducts.length === 0 && (
          <div className="bg-white rounded-xl shadow-lg p-12 text-center">
            <p className="text-slate-500 text-lg">No products match your filters</p>
            <p className="text-slate-400 text-sm mt-2">
              Try adjusting your search query or filter settings
            </p>
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="app/category/[category]/page.tsx">
'use client';

import { useState, useEffect } from 'react';
import { useParams } from 'next/navigation';
import Link from 'next/link';
import { ChevronRight, Filter } from 'lucide-react';
import { breeds, ageGroups, healthConcerns } from '@/lib/data/pets';
import { nutritionalGuidelines } from '@/lib/data/nutritional-guidelines';
import RecipeCard from '@/components/RecipeCard';
import { PetCategory, Breed, AgeGroup, HealthConcern } from '@/lib/types';

export default function CategoryPage() {
  const params = useParams();
  const category = params.category as PetCategory;
  
  const [selectedBreed, setSelectedBreed] = useState<string>('');
  const [selectedAge, setSelectedAge] = useState<string>('');
  const [selectedHealth, setSelectedHealth] = useState<string>('');
  const [showFilters, setShowFilters] = useState(true);

  const categoryBreeds = breeds[category] || [];
  // Recipes are now generated dynamically
  const filteredRecipes: any[] = [];

  const categoryNames: Record<PetCategory, string> = {
    dogs: 'Dogs',
    cats: 'Cats',
    birds: 'Birds',
    reptiles: 'Reptiles',
    'pocket-pets': 'Pocket Pets',
  };

  const getNutritionalInfo = () => {
    const guidelines = nutritionalGuidelines[category];
    if (!guidelines) return null;
    
    let ageKey: 'puppy' | 'adult' | 'senior' = 'adult';
    if (selectedAge === 'baby' || selectedAge === 'young') {
      ageKey = 'puppy';
    } else if (selectedAge === 'senior') {
      ageKey = 'senior';
    }
    
    return guidelines[ageKey] || guidelines.adult;
  };

  const nutritionalInfo = getNutritionalInfo();

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Header */}
      <div className="bg-gradient-to-r from-primary-600 to-primary-800 text-white py-12 px-4">
        <div className="max-w-7xl mx-auto">
          <nav className="flex items-center gap-2 text-sm mb-4 text-primary-200">
            <Link href="/" className="hover:text-white">Home</Link>
            <ChevronRight size={16} />
            <span className="text-white">{categoryNames[category]}</span>
          </nav>
          <h1 className="text-4xl md:text-5xl font-bold mb-4">
            {categoryNames[category]} Meal Plans
          </h1>
          <p className="text-xl text-primary-100 max-w-3xl">
            Personalized nutrition based on breed, age, and health needs
          </p>
        </div>
      </div>

      <div className="max-w-7xl mx-auto px-4 py-8">
        <div className="grid grid-cols-1 lg:grid-cols-4 gap-8">
          {/* Filters Sidebar */}
          <div className="lg:col-span-1">
            <div className="bg-white rounded-lg shadow-md p-6 sticky top-20">
              <div className="flex items-center justify-between mb-6">
                <h2 className="text-xl font-bold text-gray-900 flex items-center gap-2">
                  <Filter size={20} />
                  Filters
                </h2>
                <button
                  onClick={() => setShowFilters(!showFilters)}
                  className="lg:hidden text-primary-600"
                >
                  {showFilters ? 'Hide' : 'Show'}
                </button>
              </div>

              {showFilters && (
                <div className="space-y-6">
                  {/* Breed Selection */}
                  <div>
                    <label className="block text-sm font-semibold text-gray-700 mb-2">
                      1. Select Breed/Type
                    </label>
                    <select
                      value={selectedBreed}
                      onChange={(e) => setSelectedBreed(e.target.value)}
                      className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary-500"
                    >
                      <option value="">All Breeds</option>
                      {categoryBreeds.map((breed) => (
                        <option key={breed.id} value={breed.id}>
                          {breed.name}
                        </option>
                      ))}
                    </select>
                  </div>

                  {/* Age Selection */}
                  <div>
                    <label className="block text-sm font-semibold text-gray-700 mb-2">
                      2. Select Age Group
                    </label>
                    <select
                      value={selectedAge}
                      onChange={(e) => setSelectedAge(e.target.value)}
                      className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary-500"
                    >
                      <option value="">All Ages</option>
                      {ageGroups.map((age) => (
                        <option key={age.value} value={age.value}>
                          {age.label}
                        </option>
                      ))}
                    </select>
                    {selectedAge && (
                      <p className="text-xs text-gray-500 mt-1">
                        {ageGroups.find(a => a.value === selectedAge)?.label}
                      </p>
                    )}
                  </div>

                  {/* Health Concerns */}
                  <div>
                    <label className="block text-sm font-semibold text-gray-700 mb-2">
                      3. Health Concerns
                    </label>
                    <select
                      value={selectedHealth}
                      onChange={(e) => setSelectedHealth(e.target.value)}
                      className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary-500"
                    >
                      <option value="">Select Concern</option>
                      {healthConcerns.map((concern) => (
                        <option key={concern.id} value={concern.id}>
                          {concern.name}
                        </option>
                      ))}
                    </select>
                    {selectedHealth && (
                      <div className="mt-2 text-xs text-gray-600">
                        <p className="font-medium">
                          {healthConcerns.find(h => h.id === selectedHealth)?.description}
                        </p>
                        <p className="mt-1 text-gray-500">
                          Focus: {healthConcerns.find(h => h.id === selectedHealth)?.dietaryAdjustments.join(', ')}
                        </p>
                      </div>
                    )}
                  </div>

                  {/* Clear Filters */}
                  {(selectedBreed || selectedAge || selectedHealth) && (
                    <button
                      onClick={() => {
                        setSelectedBreed('');
                        setSelectedAge('');
                        setSelectedHealth('');
                      }}
                      className="w-full px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition-colors text-sm font-medium"
                    >
                      Clear All Filters
                    </button>
                  )}
                </div>
              )}
            </div>

            {/* Nutritional Guidelines */}
            {nutritionalInfo && (
              <div className="bg-primary-50 rounded-lg p-6 mt-6">
                <h3 className="text-lg font-bold text-gray-900 mb-4">
                  Nutritional Guidelines
                </h3>
                <div className="space-y-3 text-sm">
                  {nutritionalInfo.protein && (
                    <div>
                      <span className="font-semibold text-gray-700">Protein:</span>
                      <span className="text-gray-600 ml-2">
                        {nutritionalInfo.protein.min}-{nutritionalInfo.protein.max}{nutritionalInfo.protein.unit}
                      </span>
                    </div>
                  )}
                  {nutritionalInfo.fat && (
                    <div>
                      <span className="font-semibold text-gray-700">Fat:</span>
                      <span className="text-gray-600 ml-2">
                        {nutritionalInfo.fat.min}-{nutritionalInfo.fat.max}{nutritionalInfo.fat.unit}
                      </span>
                    </div>
                  )}
                  {nutritionalInfo.fiber && (
                    <div>
                      <span className="font-semibold text-gray-700">Fiber:</span>
                      <span className="text-gray-600 ml-2">
                        {nutritionalInfo.fiber.min}-{nutritionalInfo.fiber.max}{nutritionalInfo.fiber.unit}
                      </span>
                    </div>
                  )}
                  {nutritionalInfo.calcium && (
                    <div>
                      <span className="font-semibold text-gray-700">Calcium:</span>
                      <span className="text-gray-600 ml-2">
                        {nutritionalInfo.calcium.min}-{nutritionalInfo.calcium.max}{nutritionalInfo.calcium.unit}
                      </span>
                    </div>
                  )}
                  {(nutritionalInfo as any).calories && (
                    <div>
                      <span className="font-semibold text-gray-700">Calories:</span>
                      <span className="text-gray-600 ml-2">
                        {(nutritionalInfo as any).calories.min}-{(nutritionalInfo as any).calories.max} {(nutritionalInfo as any).calories.unit}
                      </span>
                    </div>
                  )}
                  {nutritionalInfo.vitamins && (
                    <div>
                      <span className="font-semibold text-gray-700">Key Vitamins:</span>
                      <span className="text-gray-600 ml-2">
                        {nutritionalInfo.vitamins.join(', ')}
                      </span>
                    </div>
                  )}
                </div>
                <p className="text-xs text-gray-500 mt-4">
                  Based on AAFCO and WSAVA guidelines
                </p>
              </div>
            )}
          </div>

          {/* Results */}
          <div className="lg:col-span-3">
            <div className="mb-6">
              <h2 className="text-2xl font-bold text-gray-900 mb-2">
                Recommended Meals
              </h2>
              <p className="text-gray-600">
                Found {filteredRecipes.length} recipe{filteredRecipes.length !== 1 ? 's' : ''} matching your criteria
              </p>
            </div>

            {filteredRecipes.length > 0 ? (
              <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                {filteredRecipes.map((recipe) => (
                  <RecipeCard key={recipe.id} recipe={recipe} />
                ))}
              </div>
            ) : (
              <div className="bg-white rounded-lg shadow-md p-12 text-center">
                <p className="text-gray-600 text-lg mb-4">
                  No recipes found matching your filters
                </p>
                <p className="text-gray-500 mb-6">
                  Try adjusting your filters or browse all meals
                </p>
                <Link
                  href="/profile"
                  className="inline-block px-6 py-3 bg-primary-600 text-white font-semibold rounded-lg hover:bg-primary-700 transition-colors"
                >
                  Go to My Pets
                </Link>
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/dashboard/page.tsx">
'use client';

import React, { useState, useEffect } from 'react';
import Link from 'next/link';
import { useUser } from '@clerk/nextjs';
import { Settings, Plus, Utensils, Heart, ArrowRight } from 'lucide-react';

// Firebase Imports
import { initializeApp } from 'firebase/app';
import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from 'firebase/auth';
import { getFirestore, doc, getDoc, collection, getDocs, query, onSnapshot, where } from 'firebase/firestore';

// --- Data Structures (Based on your other files) ---
interface SavedRecipe {
    id: string; // This MUST be the actual recipe ID (e.g., dog-immune-01)
    name: string;
    dateAdded: string;
}

interface Pet {
    petId: string; // The Firestore document ID for the pet (e.g., pet_176...)
    name: string;
    type: string;
    breed: string;
    age: string;
    healthConcerns: string[];
    savedRecipes: SavedRecipe[]; // Array of recipes saved to this pet
    names?: string[];
    weight?: string | number;
    weightKg?: number;
    dietaryRestrictions?: string[];
    allergies?: string[];
    dislikes?: string[];
}

// Firestore Globals (MUST be used)
const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

// Utility to safely retrieve Firebase services
let app: any;
let db: any;
let auth: any;

if (firebaseConfig) {
  try {
    app = initializeApp(firebaseConfig);
    db = getFirestore(app);
    auth = getAuth(app);
    // setLogLevel('debug'); // Uncomment for debugging
  } catch (error) {
    console.error("Firebase initialization failed:", error);
  }
}

// --- Pet Dashboard Component ---
export default function DashboardPage() {
    const { user, isLoaded: isClerkLoaded } = useUser();
    const [pets, setPets] = useState<Pet[]>([]);
    const [userId, setUserId] = useState<string | null>(null);
    const [isAuthReady, setIsAuthReady] = useState(false);
    const [isLoading, setIsLoading] = useState(true);

    // 1. Firebase Auth and Initialization
    useEffect(() => {
        if (!auth) return;

        const setupAuth = async () => {
            try {
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Firebase Auth failed:", error);
            }
        };

        const unsubscribe = onAuthStateChanged(auth, (firebaseUser) => {
            if (firebaseUser) {
                setUserId(firebaseUser.uid);
            } else {
                setUserId(crypto.randomUUID()); // Anonymous fallback
            }
            setIsAuthReady(true);
        });

        setupAuth();
        return () => unsubscribe();
    }, []);

    // 2. Real-time Pet Data Fetch (Using onSnapshot)
    useEffect(() => {
        if (!isAuthReady || !userId || !db) return;

        // Reference the 'pets' subcollection under the user's private path
        const petCollectionRef = collection(db, `artifacts/${appId}/users/${userId}/pets`);
        
        // Use onSnapshot to listen for real-time changes
        const unsubscribe = onSnapshot(
            petCollectionRef,
            (snapshot) => {
                const fetchedPets: Pet[] = [];
                snapshot.forEach((doc) => {
                    const data = doc.data();
                    // Ensure savedRecipes is treated as an array, even if empty/missing
                    const savedRecipes = Array.isArray(data.savedRecipes) ? data.savedRecipes : [];

                    fetchedPets.push({
                        petId: doc.id, // Firestore document ID (e.g., pet_176...)
                        name: data.name || 'Unnamed Pet',
                        type: data.type || 'Unknown',
                        breed: data.breed || 'Mixed',
                        age: data.age || 'Adult',
                        healthConcerns: data.healthConcerns || [],
                        savedRecipes: savedRecipes as SavedRecipe[], 
                    });
                });
                setPets(fetchedPets);
                setIsLoading(false);
            },
            (error) => {
                console.error("Error fetching real-time pet data:", error);
                setIsLoading(false);
            }
        );

        return () => unsubscribe();
    }, [isAuthReady, userId]);


    if (!isClerkLoaded || isLoading) {
        return <div className="min-h-screen flex items-center justify-center text-xl text-primary-600">Loading Dashboard...</div>;
    }

    // --- JSX Render ---
    return (
        <div className="min-h-screen bg-gray-50 py-12">
            <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
                
                <header className="flex justify-between items-center mb-10 border-b pb-4">
                    <h1 className="text-4xl font-extrabold text-gray-900">Your Paw & Plate Dashboard</h1>
                    <button 
                        // Assuming you have an AddPetModal component (not included here)
                        className="flex items-center px-4 py-2 bg-primary-600 text-white font-medium rounded-lg hover:bg-primary-700 transition-colors shadow-lg"
                    >
                        <Plus className="w-5 h-5 mr-2" />
                        Add New Pet
                    </button>
                </header>

                <div className="space-y-10">
                    {pets.length === 0 ? (
                        <div className="p-12 text-center bg-white rounded-xl shadow-lg border border-gray-200">
                            <h2 className="text-2xl font-semibold mb-3 text-gray-700">No Pets Found</h2>
                            <p className="text-gray-500 mb-6">Start by adding your first furry (or scaled!) friend.</p>
                            <button 
                                // Placeholder for opening modal
                                className="px-6 py-2 bg-secondary-600 text-white font-medium rounded-lg hover:bg-secondary-700 transition-colors"
                            >
                                Add a Pet Now
                            </button>
                        </div>
                    ) : (
                        // --- Pet List ---
                        pets.map((pet) => (
                            <div key={pet.petId} className="bg-white rounded-xl shadow-xl overflow-hidden border border-gray-100">
                                <div className="p-6 bg-primary-50 border-b border-primary-100 flex justify-between items-center">
                                    <h2 className="text-2xl font-bold text-primary-800">{pet.name}</h2>
                                    <div className="text-sm text-primary-600 font-medium">
                                        {pet.breed} ‚Ä¢ {pet.age}
                                    </div>
                                </div>

                                <div className="p-6">
                                    <div className="flex flex-wrap gap-2 mb-6">
                                        <span className="flex items-center text-sm font-medium text-gray-700 bg-green-100 px-3 py-1 rounded-full">
                                            <Heart className="w-4 h-4 mr-1 text-green-600" />
                                            Health: {pet.healthConcerns.join(', ') || 'General'}
                                        </span>
                                        <span className="text-sm font-medium text-gray-700 bg-gray-100 px-3 py-1 rounded-full">
                                            Pet ID: {pet.petId}
                                        </span>
                                    </div>
                                    
                                    <h3 className="text-xl font-semibold text-gray-800 mb-4 flex items-center">
                                        <Utensils className="w-5 h-5 mr-2 text-secondary-500" />
                                        Saved Recipes ({pet.savedRecipes.length})
                                    </h3>

                                    {pet.savedRecipes.length === 0 ? (
                                        <p className="text-gray-500 italic">No recipes saved yet. Time to go shopping!</p>
                                    ) : (
                                        <div className="space-y-3">
                                            {pet.savedRecipes.map((recipe) => (
                                                <div key={recipe.id} className="p-4 bg-gray-50 rounded-lg border border-gray-200 flex justify-between items-center">
                                                    <div className="flex flex-col">
                                                        <span className="font-medium text-gray-900">{recipe.name}</span>
                                                        <span className="text-xs text-gray-500">Added: {new Date(recipe.dateAdded).toLocaleDateString()}</span>
                                                    </div>
                                                    
                                                    <Link
                                                        // === CRITICAL FIX APPLIED HERE ===
                                                        // The link MUST use the recipe.id, NOT the pet.petId.
                                                        href={`/profile/pet/${pet.petId}`}
                                                        className="flex items-center text-sm font-semibold text-secondary-600 hover:text-secondary-800 transition-colors"
                                                    >
                                                        View recommended Meals
                                                        <ArrowRight className="w-4 h-4 ml-1" />
                                                    </Link>
                                                </div>
                                            ))}
                                        </div>
                                    )}
                                </div>
                            </div>
                        ))
                    )}
                </div>
                
                <p className="text-center text-sm text-gray-400 mt-10">
                    User ID: {userId}
                </p>

            </div>
        </div>
    );
}
</file>

<file path="app/diagnostics/image-inversion/page.tsx">
'use client';

export default function ImageInversionDetector() {
  return (
    <div style={{
      margin: 0,
      padding: '20px',
      background: '#0a0a0a',
      fontFamily: 'monospace',
      color: 'white',
      minHeight: '100vh'
    }}>
      <div style={{ maxWidth: '1200px', margin: '0 auto' }}>
        <h1 style={{ color: '#60a5fa' }}>üîç Image Color Inversion Detector</h1>
        <p style={{ color: '#9ca3af', marginBottom: '20px' }}>
          This tool scans your page for CSS that inverts image colors (common in dark mode implementations)
        </p>

        <div style={{ marginBottom: '20px' }}>
          <button
            onClick={() => {
              if (typeof window !== 'undefined' && (window as any).scanPage) {
                (window as any).scanPage();
              }
            }}
            style={{
              background: '#3b82f6',
              color: 'white',
              border: 'none',
              padding: '12px 24px',
              borderRadius: '8px',
              cursor: 'pointer',
              fontSize: '16px',
              fontWeight: 'bold',
              marginRight: '10px'
            }}
            onMouseOver={(e) => e.currentTarget.style.background = '#2563eb'}
            onMouseOut={(e) => e.currentTarget.style.background = '#3b82f6'}
          >
            üîé Scan Page
          </button>
          <button
            onClick={() => {
              if (typeof window !== 'undefined' && (window as any).highlightIssues) {
                (window as any).highlightIssues();
              }
            }}
            style={{
              background: '#ef4444',
              color: 'white',
              border: 'none',
              padding: '12px 24px',
              borderRadius: '8px',
              cursor: 'pointer',
              fontSize: '16px',
              fontWeight: 'bold',
              marginRight: '10px'
            }}
            onMouseOver={(e) => e.currentTarget.style.background = '#dc2626'}
            onMouseOut={(e) => e.currentTarget.style.background = '#ef4444'}
          >
            üéØ Highlight Affected Images
          </button>
          <button
            onClick={() => {
              if (typeof window !== 'undefined' && (window as any).fixIssues) {
                (window as any).fixIssues();
              }
            }}
            style={{
              background: '#10b981',
              color: 'white',
              border: 'none',
              padding: '12px 24px',
              borderRadius: '8px',
              cursor: 'pointer',
              fontSize: '16px',
              fontWeight: 'bold'
            }}
            onMouseOver={(e) => e.currentTarget.style.background = '#059669'}
            onMouseOut={(e) => e.currentTarget.style.background = '#10b981'}
          >
            üîß Auto-Fix (Temporary)
          </button>
        </div>

        <div id="stats" style={{
          display: 'grid',
          gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))',
          gap: '16px',
          marginBottom: '20px'
        }}></div>
        <div id="results" style={{
          background: '#1a1a1a',
          border: '2px solid #333',
          borderRadius: '8px',
          padding: '20px',
          marginBottom: '20px'
        }}></div>
      </div>

      <script
        dangerouslySetInnerHTML={{
          __html: `
            function scanPage() {
              const results = document.getElementById('results');
              const stats = document.getElementById('stats');
              results.innerHTML = '<h2>Scanning...</h2>';
              
              const issues = [];
              const affectedImages = [];
              
              // Check all images
              const allImages = document.querySelectorAll('img');
              console.log(\`Found \${allImages.length} images\`);
              
              allImages.forEach((img, index) => {
                const computedStyle = window.getComputedStyle(img);
                const filter = computedStyle.filter;
                
                // Check for invert filter
                if (filter && filter !== 'none' && filter.includes('invert')) {
                  issues.push({
                    type: 'Image has invert filter',
                    element: img,
                    selector: getSelector(img),
                    filter: filter,
                    src: img.src,
                    alt: img.alt || 'no alt',
                    severity: 'high'
                  });
                  affectedImages.push(img);
                }
                
                // Check parent elements for dark mode classes
                let parent = img.parentElement;
                let depth = 0;
                while (parent && depth < 10) {
                  const parentStyle = window.getComputedStyle(parent);
                  const parentFilter = parentStyle.filter;
                  
                  if (parentFilter && parentFilter !== 'none' && parentFilter.includes('invert')) {
                    issues.push({
                      type: 'Parent element has invert filter',
                      element: parent,
                      imageElement: img,
                      selector: getSelector(parent),
                      filter: parentFilter,
                      src: img.src,
                      alt: img.alt || 'no alt',
                      severity: 'high'
                    });
                    affectedImages.push(img);
                    break;
                  }
                  
                  parent = parent.parentElement;
                  depth++;
                }
              });
              
              // Check global CSS rules
              const stylesheets = Array.from(document.styleSheets);
              let cssRulesWithInvert = [];
              
              stylesheets.forEach(sheet => {
                try {
                  const rules = Array.from(sheet.cssRules || []);
                  rules.forEach(rule => {
                    if (rule.style && rule.style.filter && rule.style.filter !== 'none' && rule.style.filter.includes('invert')) {
                      cssRulesWithInvert.push({
                        selector: rule.selectorText,
                        filter: rule.style.filter,
                        sheet: sheet.href || 'inline'
                      });
                    }
                  });
                } catch (e) {
                  // Cross-origin stylesheets might throw errors
                  console.warn('Could not access stylesheet:', e);
                }
              });
              
              // Display stats
              stats.innerHTML = \`
                <div style="background: #1a1a1a; border: 2px solid #333; border-radius: 8px; padding: 16px; text-align: center;">
                  <div style="font-size: 32px; font-weight: bold; color: #60a5fa;">\${allImages.length}</div>
                  <div style="color: #9ca3af; margin-top: 8px;">Total Images</div>
                </div>
                <div style="background: #1a1a1a; border: 2px solid #333; border-radius: 8px; padding: 16px; text-align: center;">
                  <div style="font-size: 32px; font-weight: bold; color: \${affectedImages.length > 0 ? '#ef4444' : '#10b981'}">\${affectedImages.length}</div>
                  <div style="color: #9ca3af; margin-top: 8px;">Affected Images</div>
                </div>
                <div style="background: #1a1a1a; border: 2px solid #333; border-radius: 8px; padding: 16px; text-align: center;">
                  <div style="font-size: 32px; font-weight: bold; color: #60a5fa">\${cssRulesWithInvert.length}</div>
                  <div style="color: #9ca3af; margin-top: 8px;">CSS Rules with Invert</div>
                </div>
              \`;
              
              // Display results
              let html = '<h2 style="color: #34d399; font-size: 18px; margin-top: 20px;">Scan Results</h2>';
              
              if (issues.length === 0 && cssRulesWithInvert.length === 0) {
                html += '<div style="background: #152d15; border-left: 4px solid #10b981; padding: 12px; margin: 8px 0; border-radius: 4px;">‚úÖ No color inversion issues found!</div>';
              } else {
                // Show affected images
                if (issues.length > 0) {
                  html += '<h2 style="color: #34d399; font-size: 18px; margin-top: 20px;">üö® Affected Images</h2>';
                  issues.forEach((issue, i) => {
                    html += \`
                      <div style="background: #2d1515; border-left: 4px solid #ef4444; padding: 12px; margin: 8px 0; border-radius: 4px;">
                        <strong>\${issue.type}</strong><br>
                        Selector: <code style="background: #000; padding: 4px; border-radius: 4px; color: #60a5fa;">\${issue.selector}</code><br>
                        Filter: <code style="background: #000; padding: 4px; border-radius: 4px; color: #60a5fa;">\${issue.filter}</code><br>
                        Image: <code style="background: #000; padding: 4px; border-radius: 4px; color: #60a5fa;">\${issue.src.split('/').pop()}</code><br>
                        Alt: <code style="background: #000; padding: 4px; border-radius: 4px; color: #60a5fa;">\${issue.alt}</code>
                        <div style="background: #000; padding: 8px; border-radius: 4px; margin-top: 8px; overflow-x: auto; font-size: 12px; color: #60a5fa;">
                          // To fix, add this CSS:<br>
                          \${issue.selector} {<br>
                          &nbsp;&nbsp;filter: none !important;<br>
                          &nbsp;&nbsp;-webkit-filter: none !important;<br>
                          }
                        </div>
                      </div>
                    \`;
                  });
                }
                
                // Show CSS rules
                if (cssRulesWithInvert.length > 0) {
                  html += '<h2 style="color: #34d399; font-size: 18px; margin-top: 20px;">üìã CSS Rules Using Invert Filter</h2>';
                  cssRulesWithInvert.forEach(rule => {
                    html += \`
                      <div style="background: #2d1515; border-left: 4px solid #ef4444; padding: 12px; margin: 8px 0; border-radius: 4px;">
                        <strong>Rule found in: \${rule.sheet}</strong><br>
                        Selector: <code style="background: #000; padding: 4px; border-radius: 4px; color: #60a5fa;">\${rule.selector}</code><br>
                        Filter: <code style="background: #000; padding: 4px; border-radius: 4px; color: #60a5fa;">\${rule.filter}</code>
                        <div style="background: #000; padding: 8px; border-radius: 4px; margin-top: 8px; overflow-x: auto; font-size: 12px; color: #60a5fa;">
                          // This rule might be affecting images.<br>
                          // Consider excluding images from this rule or adding filter: none !important to images.
                        </div>
                      </div>
                    \`;
                  });
                }
                
                // Common fixes
                html += \`
                  <h2 style="color: #34d399; font-size: 18px; margin-top: 20px;">üîß Common Fixes</h2>
                  <div style="background: #152d15; border-left: 4px solid #10b981; padding: 12px; margin: 8px 0; border-radius: 4px;">
                    <strong>Method 1: Exclude images from dark mode inversion</strong>
                    <div style="background: #000; padding: 8px; border-radius: 4px; margin-top: 8px; overflow-x: auto; font-size: 12px; color: #60a5fa;">
/* In your global CSS */<br>
img, picture, video {<br>
&nbsp;&nbsp;filter: none !important;<br>
}<br>
<br>
/* Or for specific dark mode implementations */<br>
.dark img, [data-theme="dark"] img {<br>
&nbsp;&nbsp;filter: none !important;<br>
}
                    </div>
                  </div>
                  <div style="background: #152d15; border-left: 4px solid #10b981; padding: 12px; margin: 8px 0; border-radius: 4px; margin-top: 12px;">
                    <strong>Method 2: Add a class to images that should NOT be inverted</strong>
                    <div style="background: #000; padding: 8px; border-radius: 4px; margin-top: 8px; overflow-x: auto; font-size: 12px; color: #60a5fa;">
.no-invert {<br>
&nbsp;&nbsp;filter: none !important;<br>
}<br>
<br>
// Then add to your images:<br>
&lt;img className="no-invert" src="..." /&gt;
                    </div>
                  </div>
                \`;
              }
              
              results.innerHTML = html;
              
              // Store for other functions
              window.affectedImages = affectedImages;
              window.cssRulesWithInvert = cssRulesWithInvert;
            }
            
            function getSelector(element) {
              if (element.id) return \`#\${element.id}\`;
              if (element.className) {
                const classes = element.className.split(' ').filter(c => c).join('.');
                if (classes) return \`\${element.tagName.toLowerCase()}.\${classes}\`;
              }
              return element.tagName.toLowerCase();
            }
            
            function highlightIssues() {
              if (!window.affectedImages) {
                alert('Please run scan first!');
                return;
              }
              
              window.affectedImages.forEach(img => {
                img.style.outline = '4px solid red';
                img.style.outlineOffset = '2px';
              });
              
              setTimeout(() => {
                window.affectedImages.forEach(img => {
                  img.style.outline = '';
                });
              }, 3000);
            }
            
            function fixIssues() {
              if (!window.affectedImages) {
                alert('Please run scan first!');
                return;
              }
              
              let fixed = 0;
              window.affectedImages.forEach(img => {
                img.style.filter = 'none';
                img.style.webkitFilter = 'none';
                fixed++;
              });
              
              alert(\`Temporarily fixed \${fixed} images. Add permanent CSS fix to your stylesheet!\`);
            }
            
            // Auto-run on load
            if (typeof window !== 'undefined') {
              window.addEventListener('load', () => {
                setTimeout(scanPage, 500);
              });
            }
          `
        }}
      />
    </div>
  );
}

// Client-side functions
if (typeof window !== 'undefined') {
  (window as any).scanPage = function() {
    const results = document.getElementById('results');
    const stats = document.getElementById('stats');
    if (!results || !stats) return;
    
    results.innerHTML = '<h2>Scanning...</h2>';
    
    const issues: any[] = [];
    const affectedImages: HTMLImageElement[] = [];
    
    // Check all images
    const allImages = document.querySelectorAll('img');
    console.log(`Found ${allImages.length} images`);
    
    allImages.forEach((img) => {
      const computedStyle = window.getComputedStyle(img);
      const filter = computedStyle.filter;
      
      // Check for invert filter
      if (filter && filter !== 'none' && filter.includes('invert')) {
        issues.push({
          type: 'Image has invert filter',
          element: img,
          selector: getSelector(img),
          filter: filter,
          src: img.src,
          alt: img.alt || 'no alt',
          severity: 'high'
        });
        affectedImages.push(img);
      }
      
      // Check parent elements
      let parent = img.parentElement;
      let depth = 0;
      while (parent && depth < 10) {
        const parentStyle = window.getComputedStyle(parent);
        const parentFilter = parentStyle.filter;
        
        if (parentFilter && parentFilter !== 'none' && parentFilter.includes('invert')) {
          issues.push({
            type: 'Parent element has invert filter',
            element: parent,
            imageElement: img,
            selector: getSelector(parent),
            filter: parentFilter,
            src: img.src,
            alt: img.alt || 'no alt',
            severity: 'high'
          });
          affectedImages.push(img);
          break;
        }
        
        parent = parent.parentElement;
        depth++;
      }
    });
    
    // Check global CSS rules
    const stylesheets = Array.from(document.styleSheets);
    const cssRulesWithInvert: any[] = [];
    
    stylesheets.forEach(sheet => {
      try {
        const rules = Array.from(sheet.cssRules || []);
        rules.forEach(rule => {
          const cssRule = rule as CSSStyleRule;
          if (cssRule.style && cssRule.style.filter && cssRule.style.filter !== 'none' && cssRule.style.filter.includes('invert')) {
            cssRulesWithInvert.push({
              selector: cssRule.selectorText,
              filter: cssRule.style.filter,
              sheet: sheet.href || 'inline'
            });
          }
        });
      } catch (e) {
        console.warn('Could not access stylesheet:', e);
      }
    });
    
    // Display stats
    stats.innerHTML = `
      <div style="background: #1a1a1a; border: 2px solid #333; border-radius: 8px; padding: 16px; text-align: center;">
        <div style="font-size: 32px; font-weight: bold; color: #60a5fa;">${allImages.length}</div>
        <div style="color: #9ca3af; margin-top: 8px;">Total Images</div>
      </div>
      <div style="background: #1a1a1a; border: 2px solid #333; border-radius: 8px; padding: 16px; text-align: center;">
        <div style="font-size: 32px; font-weight: bold; color: ${affectedImages.length > 0 ? '#ef4444' : '#10b981'}">${affectedImages.length}</div>
        <div style="color: #9ca3af; margin-top: 8px;">Affected Images</div>
      </div>
      <div style="background: #1a1a1a; border: 2px solid #333; border-radius: 8px; padding: 16px; text-align: center;">
        <div style="font-size: 32px; font-weight: bold; color: #60a5fa">${cssRulesWithInvert.length}</div>
        <div style="color: #9ca3af; margin-top: 8px;">CSS Rules with Invert</div>
      </div>
    `;
    
    // Display results
    let html = '<h2 style="color: #34d399; font-size: 18px; margin-top: 20px;">Scan Results</h2>';
    
    if (issues.length === 0 && cssRulesWithInvert.length === 0) {
      html += '<div style="background: #152d15; border-left: 4px solid #10b981; padding: 12px; margin: 8px 0; border-radius: 4px;">‚úÖ No color inversion issues found!</div>';
    } else {
      if (issues.length > 0) {
        html += '<h2 style="color: #34d399; font-size: 18px; margin-top: 20px;">üö® Affected Images</h2>';
        issues.forEach((issue) => {
          html += `
            <div style="background: #2d1515; border-left: 4px solid #ef4444; padding: 12px; margin: 8px 0; border-radius: 4px;">
              <strong>${issue.type}</strong><br>
              Selector: <code style="background: #000; padding: 4px; border-radius: 4px; color: #60a5fa;">${issue.selector}</code><br>
              Filter: <code style="background: #000; padding: 4px; border-radius: 4px; color: #60a5fa;">${issue.filter}</code><br>
              Image: <code style="background: #000; padding: 4px; border-radius: 4px; color: #60a5fa;">${issue.src.split('/').pop()}</code><br>
              Alt: <code style="background: #000; padding: 4px; border-radius: 4px; color: #60a5fa;">${issue.alt}</code>
              <div style="background: #000; padding: 8px; border-radius: 4px; margin-top: 8px; overflow-x: auto; font-size: 12px; color: #60a5fa;">
                // To fix, add this CSS:<br>
                ${issue.selector} {<br>
                &nbsp;&nbsp;filter: none !important;<br>
                &nbsp;&nbsp;-webkit-filter: none !important;<br>
                }
              </div>
            </div>
          `;
        });
      }
      
      if (cssRulesWithInvert.length > 0) {
        html += '<h2 style="color: #34d399; font-size: 18px; margin-top: 20px;">üìã CSS Rules Using Invert Filter</h2>';
        cssRulesWithInvert.forEach(rule => {
          html += `
            <div style="background: #2d1515; border-left: 4px solid #ef4444; padding: 12px; margin: 8px 0; border-radius: 4px;">
              <strong>Rule found in: ${rule.sheet}</strong><br>
              Selector: <code style="background: #000; padding: 4px; border-radius: 4px; color: #60a5fa;">${rule.selector}</code><br>
              Filter: <code style="background: #000; padding: 4px; border-radius: 4px; color: #60a5fa;">${rule.filter}</code>
              <div style="background: #000; padding: 8px; border-radius: 4px; margin-top: 8px; overflow-x: auto; font-size: 12px; color: #60a5fa;">
                // This rule might be affecting images.<br>
                // Consider excluding images from this rule or adding filter: none !important to images.
              </div>
            </div>
          `;
        });
      }
    }
    
    results.innerHTML = html;
    (window as any).affectedImages = affectedImages;
    (window as any).cssRulesWithInvert = cssRulesWithInvert;
  };
  
  (window as any).highlightIssues = function() {
    const affectedImages = (window as any).affectedImages;
    if (!affectedImages || affectedImages.length === 0) {
      alert('Please run scan first!');
      return;
    }
    
    affectedImages.forEach((img: HTMLImageElement) => {
      img.style.outline = '4px solid red';
      img.style.outlineOffset = '2px';
    });
    
    setTimeout(() => {
      affectedImages.forEach((img: HTMLImageElement) => {
        img.style.outline = '';
      });
    }, 3000);
  };
  
  (window as any).fixIssues = function() {
    const affectedImages = (window as any).affectedImages;
    if (!affectedImages || affectedImages.length === 0) {
      alert('Please run scan first!');
      return;
    }
    
    let fixed = 0;
    affectedImages.forEach((img: HTMLImageElement) => {
      img.style.filter = 'none';
      img.style.webkitFilter = 'none';
      fixed++;
    });
    
    alert(`Temporarily fixed ${fixed} images. Add permanent CSS fix to your stylesheet!`);
  };
}

function getSelector(element: Element): string {
  if (element.id) return `#${element.id}`;
  if (element.className) {
    const classes = element.className.toString().split(' ').filter(c => c).join('.');
    if (classes) return `${element.tagName.toLowerCase()}.${classes}`;
  }
  return element.tagName.toLowerCase();
}
</file>

<file path="app/forum/gallery/page.tsx">
'use client';

import Link from 'next/link';
import { useState, useEffect } from 'react';
import { Star, Users, Heart, ChefHat, Clock, ThumbsUp } from 'lucide-react';
import Image from '@/components/Image';
import { getEmojiGroup } from '@/lib/utils/imageMapping';

export default function CommunityGalleryPage() {
  const [communityRecipes, setCommunityRecipes] = useState<any[]>([]);
  const [filter, setFilter] = useState('all');

  useEffect(() => {
    // Load all community modifications from localStorage
    const allRecipes = [];
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && key.startsWith('recipe_modifications_')) {
        const recipeId = key.replace('recipe_modifications_', '');
        const modifications = JSON.parse(localStorage.getItem(key) || '[]');

        if (modifications.length > 0) {
          // Get original recipe data
          const originalRecipe = JSON.parse(localStorage.getItem('recipes') || '[]').find((r: any) => r.id === recipeId);

          allRecipes.push({
            recipeId,
            originalRecipe,
            modifications,
            totalModifications: modifications.length,
            averageRating: modifications.reduce((sum: number, mod: any) => sum + (mod.rating || 0), 0) / modifications.length,
            lastModified: modifications[0]?.timestamp
          });
        }
      }
    }

    setCommunityRecipes(allRecipes);
  }, []);

  const filteredRecipes = communityRecipes.filter(recipe => {
    if (filter === 'all') return true;
    if (filter === 'highly-rated') return recipe.averageRating >= 4;
    if (filter === 'recent') return new Date(recipe.lastModified) > new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
    if (filter === 'popular') return recipe.totalModifications >= 3;
    return true;
  });

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Header */}
      <div className="bg-gradient-to-r from-green-800 to-green-900 text-white py-16 px-4">
        <div className="max-w-6xl mx-auto text-center">
          <h1 className="text-4xl md:text-5xl font-bold mb-4">
            Community Recipe Gallery
          </h1>
          <p className="text-xl text-primary-100 max-w-3xl mx-auto">
            Discover creative recipe modifications and improvements shared by our community of pet parents.
            See how others adapted recipes for their pets' unique needs.
          </p>
        </div>
      </div>

      <div className="max-w-6xl mx-auto px-4 py-8">
        {/* Stats */}
        <div className="grid grid-cols-2 md:grid-cols-4 gap-6 mb-8">
          <div className="bg-white rounded-lg shadow-md p-6 text-center">
            <ChefHat className="w-8 h-8 mx-auto mb-3 text-primary-600" />
            <div className="text-2xl font-bold text-gray-900 mb-1">{communityRecipes.length}</div>
            <div className="text-sm text-gray-600">Modified Recipes</div>
          </div>
          <div className="bg-white rounded-lg shadow-md p-6 text-center">
            <Users className="w-8 h-8 mx-auto mb-3 text-green-600" />
            <div className="text-2xl font-bold text-gray-900 mb-1">
              {communityRecipes.reduce((sum, recipe) => sum + recipe.totalModifications, 0)}
            </div>
            <div className="text-sm text-gray-600">Community Contributions</div>
          </div>
          <div className="bg-white rounded-lg shadow-md p-6 text-center">
            <Star className="w-8 h-8 mx-auto mb-3 text-yellow-600" />
            <div className="text-2xl font-bold text-gray-900 mb-1">
              {communityRecipes.length > 0
                ? (communityRecipes.reduce((sum, recipe) => sum + recipe.averageRating, 0) / communityRecipes.length).toFixed(1)
                : '0.0'
              }
            </div>
            <div className="text-sm text-gray-600">Average Rating</div>
          </div>
          <div className="bg-white rounded-lg shadow-md p-6 text-center">
            <Heart className="w-8 h-8 mx-auto mb-3 text-red-600" />
            <div className="text-2xl font-bold text-gray-900 mb-1">
              {communityRecipes.reduce((sum, recipe) => sum + recipe.modifications.reduce((mSum: number, mod: any) => mSum + (mod.helpful || 0), 0), 0)}
            </div>
            <div className="text-sm text-gray-600">Helpful Votes</div>
          </div>
        </div>

        {/* Filters */}
        <div className="bg-white rounded-lg shadow-md p-6 mb-8">
          <div className="flex flex-wrap gap-2">
            <button
              onClick={() => setFilter('all')}
              className={`px-4 py-2 rounded-full text-sm font-medium transition-colors ${
                filter === 'all' ? 'bg-primary-600 text-white' : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
              }`}
            >
              All Meals
            </button>
            <button
              onClick={() => setFilter('highly-rated')}
              className={`px-4 py-2 rounded-full text-sm font-medium transition-colors ${
                filter === 'highly-rated' ? 'bg-primary-600 text-white' : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
              }`}
            >
              Highly Rated (4+ stars)
            </button>
            <button
              onClick={() => setFilter('recent')}
              className={`px-4 py-2 rounded-full text-sm font-medium transition-colors ${
                filter === 'recent' ? 'bg-primary-600 text-white' : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
              }`}
            >
              Recently Modified
            </button>
            <button
              onClick={() => setFilter('popular')}
              className={`px-4 py-2 rounded-full text-sm font-medium transition-colors ${
                filter === 'popular' ? 'bg-primary-600 text-white' : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
              }`}
            >
              Most Modified (3+ variations)
            </button>
          </div>
        </div>

        {/* Recipe Gallery */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
          {filteredRecipes.map((recipe) => (
            <div key={recipe.recipeId} className="bg-white rounded-lg shadow-md overflow-hidden hover:shadow-lg transition-shadow">
              <div className="p-6">
                {/* Original Recipe Info */}
                <div className="mb-4">
                  <h3 className="text-lg font-bold text-gray-900 mb-2">
                    Modified: {recipe.originalRecipe?.name || 'Unknown Recipe'}
                  </h3>
                  <div className="flex items-center gap-2 text-sm text-gray-600 mb-2">
                    <span className={`px-2 py-1 rounded text-xs font-medium ${
                      recipe.originalRecipe?.category === 'dogs' ? 'bg-blue-100 text-blue-800' :
                      recipe.originalRecipe?.category === 'cats' ? 'bg-orange-100 text-orange-800' :
                      'bg-gray-100 text-gray-800'
                    }`}>
                      {recipe.originalRecipe?.category || 'Unknown'}
                    </span>
                    <div className="flex items-center gap-1">
                      <Star className="w-4 h-4 text-yellow-500 fill-yellow-500" />
                      <span>{recipe.averageRating.toFixed(1)}</span>
                    </div>
                  </div>
                </div>

                {/* Community Stats */}
                <div className="grid grid-cols-2 gap-4 mb-4 text-sm">
                  <div className="text-center">
                    <div className="font-semibold text-gray-900">{recipe.totalModifications}</div>
                    <div className="text-gray-600">Variations</div>
                  </div>
                  <div className="text-center">
                    <div className="font-semibold text-gray-900">
                      {recipe.modifications.reduce((sum: number, mod: any) => sum + (mod.helpful || 0), 0)}
                    </div>
                    <div className="text-gray-600">Helpful</div>
                  </div>
                </div>

                {/* Latest Modification Preview */}
                <div className="mb-4">
                  <h4 className="font-semibold text-gray-900 mb-2">Latest Variation:</h4>
                  <p className="text-gray-700 text-sm line-clamp-3">
                    {recipe.modifications[0]?.modifications || 'No description available'}
                  </p>
                  <div className="flex items-center gap-2 mt-2 text-xs text-gray-500">
                    <span>by {recipe.modifications[0]?.userName || 'Anonymous'}</span>
                    <span>‚Ä¢</span>
                    <span>{new Date(recipe.modifications[0]?.timestamp).toLocaleDateString()}</span>
                  </div>
                </div>

                {/* Action Buttons */}
                <div className="flex gap-2">
                  <Link
                    href={`/recipe/${recipe.recipeId}`}
                    className="flex-1 text-center px-4 py-2 bg-primary-600 text-white text-sm font-medium rounded-lg hover:bg-primary-700 transition-colors"
                  >
                    View Recipe
                  </Link>
                  <button className="px-3 py-2 border border-gray-300 text-gray-700 text-sm font-medium rounded-lg hover:bg-gray-50 transition-colors">
                    <ThumbsUp className="w-4 h-4" />
                  </button>
                </div>
              </div>
            </div>
          ))}
        </div>

        {filteredRecipes.length === 0 && (
          <div className="text-center py-12">
            <ChefHat className="w-16 h-16 mx-auto mb-4 text-gray-300" />
            <h3 className="text-xl font-semibold text-gray-900 mb-2">No recipes found</h3>
            <p className="text-gray-600 mb-6">
              {filter === 'all'
                ? "No community modifications have been shared yet. Be the first to modify a recipe and share your improvements!"
                : `No recipes match the "${filter}" filter. Try a different filter.`
              }
            </p>
            <Link
              href="/forum"
              className="inline-flex items-center gap-2 px-6 py-3 bg-primary-600 text-white font-semibold rounded-lg hover:bg-primary-700 transition-colors"
            >
              <ChefHat className="w-5 h-5" />
              Start Modifying Recipes
            </Link>
          </div>
        )}

        {/* Call to Action */}
        <div className="bg-primary-600 text-white rounded-lg p-8 mt-12 text-center">
          <h3 className="text-2xl font-bold mb-4">Share Your Recipe Creations</h3>
          <p className="text-primary-100 mb-6 max-w-2xl mx-auto">
            Have you modified a recipe to better suit your pet's needs? Share your innovations with the community
            and help other pet parents discover new ways to make meals their pets will love.
          </p>
          <Link
            href="/forum"
            className="inline-flex items-center gap-2 px-6 py-3 bg-white text-primary-600 font-semibold rounded-lg hover:bg-gray-100 transition-colors"
          >
            Share Your Modifications
          </Link>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/forum/page.tsx">
'use client';

import { useState } from 'react';
import Link from 'next/link';
import { MessageSquare, Users, TrendingUp, Plus, Search, Filter, ThumbsUp, MessageCircle, Eye, ChefHat } from 'lucide-react';

export default function ForumPage() {
  const [activeCategory, setActiveCategory] = useState('all');
  const [searchQuery, setSearchQuery] = useState('');

  const categories = [
    { id: 'all', name: 'All Topics', count: 1247, color: 'bg-gray-100 text-gray-800' },
    { id: 'recipes', name: 'Recipe Discussions', count: 456, color: 'bg-blue-100 text-blue-800' },
    { id: 'nutrition', name: 'Nutrition Questions', count: 234, color: 'bg-green-100 text-green-800' },
    { id: 'health', name: 'Health & Conditions', count: 189, color: 'bg-red-100 text-red-800' },
    { id: 'training', name: 'Training & Behavior', count: 156, color: 'bg-purple-100 text-purple-800' },
    { id: 'products', name: 'Product Reviews', count: 98, color: 'bg-orange-100 text-orange-800' },
    { id: 'general', name: 'General Discussion', count: 114, color: 'bg-indigo-100 text-indigo-800' }
  ];

  const forumThreads = [
    {
      id: 1,
      title: "Homemade chicken and rice recipe - my dog won't eat it!",
      author: "SarahPetMom",
      avatar: "/images/avatars/sarah.jpg",
      category: "recipes",
      replies: 23,
      views: 1456,
      lastReply: "2 hours ago",
      lastReplyBy: "ChefMike",
      isSticky: false,
      tags: ["chicken", "rice", "picky-eater"],
      excerpt: "I've been trying this recipe for 3 days now but my golden retriever just sniffs it and walks away. Any suggestions for making it more appealing?"
    },
    {
      id: 2,
      title: "STICKY: Community Recipe Contest - Winter Warmers!",
      author: "Paw & Plate",
      avatar: "/images/avatars/admin.jpg",
      category: "recipes",
      replies: 67,
      views: 3241,
      lastReply: "1 hour ago",
      lastReplyBy: "RecipeQueen",
      isSticky: true,
      tags: ["contest", "winter", "featured"],
      excerpt: "Share your best warming recipes for cold weather! Winner gets featured on our blog and a $50 Amazon gift card. Contest ends December 15th."
    },
    {
      id: 3,
      title: "Kidney disease diet modifications - success stories?",
      author: "HopefulOwner",
      avatar: "/images/avatars/hope.jpg",
      category: "health",
      replies: 34,
      views: 892,
      lastReply: "4 hours ago",
      lastReplyBy: "KidneyWarrior",
      isSticky: false,
      tags: ["kidney-disease", "success-story", "chronic-illness"],
      excerpt: "My 12-year-old lab was diagnosed with early kidney disease. We've been on a homemade diet for 6 months. Anyone else have positive experiences to share?"
    },
    {
      id: 4,
      title: "Best supplements for senior dogs (8+ years)",
      author: "SeniorDogDad",
      avatar: "/images/avatars/senior.jpg",
      category: "nutrition",
      replies: 28,
      views: 756,
      lastReply: "6 hours ago",
      lastReplyBy: "VetAssistant",
      isSticky: false,
      tags: ["senior-dogs", "supplements", "joint-health"],
      excerpt: "My 10-year-old shepherd has arthritis. What supplements have you found most helpful for mobility and joint health?"
    },
    {
      id: 5,
      title: "Cat food recipes that actually work",
      author: "CatLady2024",
      avatar: "/images/avatars/cat.jpg",
      category: "recipes",
      replies: 45,
      views: 1234,
      lastReply: "3 hours ago",
      lastReplyBy: "FelineExpert",
      isSticky: false,
      tags: ["cats", "recipes", "picky-eaters"],
      excerpt: "My Maine Coon is so picky! She turns her nose up at most commercial foods. What homemade recipes have worked for your finicky felines?"
    },
    {
      id: 6,
      title: "Allergy testing vs elimination diet - which is better?",
      author: "AllergyMom",
      avatar: "/images/avatars/allergy.jpg",
      category: "health",
      replies: 19,
      views: 543,
      lastReply: "8 hours ago",
      lastReplyBy: "Dermatologist",
      isSticky: false,
      tags: ["allergies", "testing", "elimination-diet"],
      excerpt: "My vet recommended allergy testing ($300) but I'm considering trying an elimination diet first. What has your experience been?"
    }
  ];

  const stats = [
    { label: 'Active Members', value: '12,847', icon: Users, color: 'text-blue-600' },
    { label: 'Discussions', value: '3,421', icon: MessageSquare, color: 'text-green-600' },
    { label: 'Recipes Shared', value: '1,892', icon: TrendingUp, color: 'text-purple-600' },
    { label: 'Success Stories', value: '756', icon: ThumbsUp, color: 'text-orange-600' }
  ];

  const filteredThreads = forumThreads.filter(thread => {
    const matchesCategory = activeCategory === 'all' || thread.category === activeCategory;
    const matchesSearch = searchQuery === '' ||
      thread.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
      thread.excerpt.toLowerCase().includes(searchQuery.toLowerCase()) ||
      thread.tags.some(tag => tag.toLowerCase().includes(searchQuery.toLowerCase()));
    return matchesCategory && matchesSearch;
  });

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Header */}
      <div className="bg-gradient-to-r from-green-800 to-green-900 text-white py-16 px-4">
        <div className="max-w-6xl mx-auto text-center">
          <h1 className="text-4xl md:text-5xl font-bold mb-4">
            Pet Nutrition Community
          </h1>
          <p className="text-xl text-primary-100 max-w-3xl mx-auto">
            Connect with fellow pet parents, share recipes, get advice from experts,
            and learn from real experiences in our supportive community.
          </p>
        </div>
      </div>

      <div className="max-w-6xl mx-auto px-4 py-8">
        {/* Community Stats */}
        <div className="grid grid-cols-2 md:grid-cols-4 gap-6 mb-8">
          {stats.map((stat, index) => (
            <div key={index} className="bg-white rounded-lg shadow-md p-6 text-center">
              <stat.icon className={`w-8 h-8 mx-auto mb-3 ${stat.color}`} />
              <div className="text-2xl font-bold text-gray-900 mb-1">{stat.value}</div>
              <div className="text-sm text-gray-600">{stat.label}</div>
            </div>
          ))}
        </div>

        {/* Quick Links */}
        <div className="bg-white rounded-lg shadow-md p-6 mb-8">
          <h3 className="text-lg font-semibold text-gray-900 mb-4">Explore Community</h3>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
            <Link
              href="/forum/gallery"
              className="flex items-center gap-3 p-4 border border-gray-200 rounded-lg hover:bg-gray-50 transition-colors"
            >
              <ChefHat className="w-8 h-8 text-primary-600" />
              <div>
                <div className="font-semibold text-gray-900">Recipe Gallery</div>
                <div className="text-sm text-gray-600">Browse community modifications</div>
              </div>
            </Link>
            <Link
              href="/forum?category=recipes"
              className="flex items-center gap-3 p-4 border border-gray-200 rounded-lg hover:bg-gray-50 transition-colors"
            >
              <MessageSquare className="w-8 h-8 text-green-600" />
              <div>
                <div className="font-semibold text-gray-900">Recipe Discussions</div>
                <div className="text-sm text-gray-600">Ask questions, share tips</div>
              </div>
            </Link>
            <Link
              href="/forum?category=health"
              className="flex items-center gap-3 p-4 border border-gray-200 rounded-lg hover:bg-gray-50 transition-colors"
            >
              <Users className="w-8 h-8 text-blue-600" />
              <div>
                <div className="font-semibold text-gray-900">Health Support</div>
                <div className="text-sm text-gray-600">Connect with other pet parents</div>
              </div>
            </Link>
          </div>
        </div>

        {/* Search and Filters */}
        <div className="bg-white rounded-lg shadow-md p-6 mb-8">
          <div className="flex flex-col md:flex-row gap-4">
            <div className="flex-1 relative">
              <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-5 h-5" />
              <input
                type="text"
                placeholder="Search discussions, recipes, or topics..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                className="w-full pl-10 pr-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent"
              />
            </div>
            <button className="px-6 py-3 bg-primary-600 text-white rounded-lg hover:bg-primary-700 transition-colors flex items-center gap-2">
              <Plus className="w-5 h-5" />
              Start Discussion
            </button>
          </div>

          {/* Category Filters */}
          <div className="flex flex-wrap gap-2 mt-4">
            {categories.map((category) => (
              <button
                key={category.id}
                onClick={() => setActiveCategory(category.id)}
                className={`px-4 py-2 rounded-full text-sm font-medium transition-colors ${
                  activeCategory === category.id
                    ? 'bg-primary-600 text-white'
                    : category.color + ' hover:opacity-80'
                }`}
              >
                {category.name} ({category.count})
              </button>
            ))}
          </div>
        </div>

        {/* Forum Threads */}
        <div className="space-y-4">
          {filteredThreads.map((thread) => (
            <div key={thread.id} className="bg-white rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <div className="p-6">
                <div className="flex items-start gap-4">
                  {/* Avatar */}
                  <div className="w-12 h-12 bg-gray-200 rounded-full flex items-center justify-center flex-shrink-0">
                    <span className="text-gray-600 font-semibold text-lg">
                      {thread.author.charAt(0).toUpperCase()}
                    </span>
                  </div>

                  {/* Thread Content */}
                  <div className="flex-1 min-w-0">
                    <div className="flex items-start justify-between gap-4">
                      <div className="flex-1">
                        <div className="flex items-center gap-2 mb-2">
                          {thread.isSticky && (
                            <span className="bg-yellow-100 text-yellow-800 px-2 py-1 rounded text-xs font-medium">
                              STICKY
                            </span>
                          )}
                          <span className={`px-2 py-1 rounded text-xs font-medium ${
                            thread.category === 'recipes' ? 'bg-blue-100 text-blue-800' :
                            thread.category === 'health' ? 'bg-red-100 text-red-800' :
                            thread.category === 'nutrition' ? 'bg-green-100 text-green-800' :
                            'bg-gray-100 text-gray-800'
                          }`}>
                            {categories.find(c => c.id === thread.category)?.name}
                          </span>
                        </div>

                        <Link href="/forum">
                          <h3 className="text-lg font-semibold text-gray-900 hover:text-primary-600 transition-colors mb-2">
                            {thread.title}
                          </h3>
                        </Link>

                        <p className="text-gray-600 text-sm mb-3 line-clamp-2">
                          {thread.excerpt}
                        </p>

                        {/* Tags */}
                        <div className="flex flex-wrap gap-1 mb-3">
                          {thread.tags.map((tag) => (
                            <span
                              key={tag}
                              className="bg-gray-100 text-gray-600 px-2 py-1 rounded text-xs"
                            >
                              #{tag}
                            </span>
                          ))}
                        </div>

                        {/* Thread Meta */}
                        <div className="flex items-center gap-4 text-sm text-gray-500">
                          <span>by <strong className="text-gray-700">{thread.author}</strong></span>
                          <span>Last reply {thread.lastReply} by {thread.lastReplyBy}</span>
                        </div>
                      </div>

                      {/* Thread Stats */}
                      <div className="flex flex-col items-end gap-2 text-sm text-gray-500">
                        <div className="flex items-center gap-1">
                          <MessageCircle className="w-4 h-4" />
                          <span>{thread.replies} replies</span>
                        </div>
                        <div className="flex items-center gap-1">
                          <Eye className="w-4 h-4" />
                          <span>{thread.views.toLocaleString()} views</span>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          ))}
        </div>

        {/* Load More */}
        <div className="text-center mt-8">
          <button className="px-6 py-3 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 transition-colors">
            Load More Discussions
          </button>
        </div>

        {/* Community Guidelines */}
        <div className="bg-blue-50 border border-blue-200 rounded-lg p-6 mt-8">
          <h3 className="text-lg font-semibold text-blue-900 mb-3">Community Guidelines</h3>
          <ul className="text-blue-800 text-sm space-y-2">
            <li>‚Ä¢ Be respectful and supportive of fellow pet parents</li>
            <li>‚Ä¢ Always consult your veterinarian for health-related advice</li>
            <li>‚Ä¢ Share your experiences and learn from others</li>
            <li>‚Ä¢ No spam, self-promotion, or inappropriate content</li>
            <li>‚Ä¢ Report any concerns to our moderation team</li>
          </ul>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/globals.css">
/* ============================================
   IMAGE FILTER NEUTRALIZATION
   Prevent unwanted filters from being applied to images
   BUT allow explicit inline filter styles to work
   ============================================ */

/* Override Tailwind CSS filter variables for images and all parent containers */
img,
img *,
* img {
  --tw-blur: var(--tw-empty, /*!*/ /*!*/) !important;
  --tw-brightness: var(--tw-empty, /*!*/ /*!*/) !important;
  --tw-contrast: var(--tw-empty, /*!*/ /*!*/) !important;
  --tw-grayscale: var(--tw-empty, /*!*/ /*!*/) !important;
  --tw-hue-rotate: var(--tw-empty, /*!*/ /*!*/) !important;
  --tw-invert: var(--tw-empty, /*!*/ /*!*/) !important;
  --tw-saturate: var(--tw-empty, /*!*/ /*!*/) !important;
  --tw-sepia: var(--tw-empty, /*!*/ /*!*/) !important;
  --tw-drop-shadow: var(--tw-empty, /*!*/ /*!*/) !important;
}

/* Only prevent filters on images that don't have explicit inline filter styles */
img:not([style*="filter"]) {
  filter: none !important;
  -webkit-filter: none !important;
  isolation: isolate !important;
}

/* Prevent Tailwind filter utility classes from affecting images */
img.blur,
img.invert,
img.brightness,
img.contrast,
img.grayscale,
img.hue-rotate,
img.saturate,
img.sepia {
  filter: none !important;
  -webkit-filter: none !important;
}

/* Prevent parent containers with Tailwind filter classes from affecting images */
.blur img,
.invert img,
.brightness img,
.contrast img,
.grayscale img,
.hue-rotate img,
.saturate img,
.sepia img {
  filter: none !important;
  -webkit-filter: none !important;
  isolation: isolate !important;
}

/* Prevent any filter inheritance from parent containers */
img {
  isolation: isolate !important;
  mix-blend-mode: normal !important;
}

/* Specific fix for mascot images - ensure they can use filters if needed */
img[src*="Sherlock"],
img[src*="Harvest"],
img[src*="Mascots"] {
  mix-blend-mode: normal !important;
  isolation: isolate !important;
  forced-color-adjust: none !important;
  -webkit-forced-color-adjust: none !important;
}

/* Specific fix for badge images - prevent color inversion */
img[src*="ElvenBadges"],
img[src*="/images/ElvenBadges/"] {
  filter: none !important;
  -webkit-filter: none !important;
  isolation: isolate !important;
  mix-blend-mode: normal !important;
  forced-color-adjust: none !important;
  -webkit-forced-color-adjust: none !important;
}

/* Also target Next.js Image components that render badge images */
.next-image img[src*="ElvenBadges"],
img[src*="ElvenBadges"][class*="object-contain"] {
  filter: none !important;
  -webkit-filter: none !important;
}

/* Utility class for badge images */
.no-invert-badge {
  filter: none !important;
  -webkit-filter: none !important;
  isolation: isolate !important;
}

@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --foreground-rgb: 240, 240, 240;
  --background-start-rgb: 10, 30, 20;
  --background-end-rgb: 15, 35, 25;
}

body {
  color: rgb(var(--foreground-rgb));
  background: linear-gradient(
      to bottom,
      transparent,
      rgb(var(--background-end-rgb))
    )
    rgb(var(--background-start-rgb));
}

@layer utilities {
  .text-balance {
    text-wrap: balance;
  }
}

/* Modern Button Design System */
@layer components {
  /* Base Button Styles */
  .btn {
    @apply relative inline-flex items-center justify-center font-semibold transition-colors duration-200 ease-out;
    @apply border-0 outline-none cursor-pointer;
    @apply select-none active:scale-95;
    border-radius: 12px;
    font-weight: 600;
    letter-spacing: 0.025em;
    text-decoration: none;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15), 0 2px 4px rgba(0, 0, 0, 0.1);
  }

  .btn:focus-visible {
    @apply ring-2 ring-blue-500 ring-offset-2;
  }

  /* Button Sizes */
  .btn-sm {
    @apply px-4 py-2 text-sm;
    min-height: 36px;
  }

  .btn-md {
    @apply px-6 py-3 text-base;
    min-height: 44px;
  }

  .btn-lg {
    @apply px-8 py-4 text-lg;
    min-height: 52px;
  }

  .btn-xl {
    @apply px-10 py-5 text-xl;
    min-height: 60px;
  }

  /* Primary Button - Green with Orange Border */
  .btn-primary {
    background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
    color: white;
    border: 3px solid #f97316;
    box-shadow: 0 6px 20px rgba(72, 187, 120, 0.4), 0 4px 12px rgba(0, 0, 0, 0.15);
  }

  .btn-primary:hover {
    background: linear-gradient(135deg, #38a169 0%, #2f855a 100%);
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(72, 187, 120, 0.5), 0 6px 15px rgba(0, 0, 0, 0.2);
  }

  .btn-primary:active {
    transform: translateY(0);
    box-shadow: 0 4px 12px rgba(72, 187, 120, 0.3), 0 2px 6px rgba(0, 0, 0, 0.1);
  }

  /* Secondary Button - Adjusted for Dark Mode */
  .btn-secondary {
    @apply bg-surface text-gray-200;
    border: 3px solid #f97316;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
  }

  .btn-secondary:hover {
    @apply bg-surface-highlight text-white;
    border-color: #f97316;
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  }

  /* Success Button */
  .btn-success {
    background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
    color: #0f2c0f;
    border: 3px solid #f97316;
    box-shadow: 0 6px 20px rgba(72, 187, 120, 0.4), 0 4px 12px rgba(0, 0, 0, 0.15);
  }

  .btn-success:hover {
    background: linear-gradient(135deg, #38a169 0%, #2f855a 100%);
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(72, 187, 120, 0.5), 0 6px 15px rgba(0, 0, 0, 0.2);
  }

  /* Danger Button */
  .btn-danger {
    background: transparent;
    color: #ef4444;
    border: 3px solid #ef4444;
    outline: 3px solid #ef4444;
    outline-offset: 2px;
    box-shadow: none;
  }

  .btn-danger:hover {
    background: rgba(239, 68, 68, 0.08);
    color: #ef4444;
    border-color: #ef4444;
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(239, 68, 68, 0.25), 0 2px 6px rgba(0, 0, 0, 0.1);
  }

  /* Warning Button -> Dark Green with Orange text/outline */
  .btn-warning {
    background: #0f2c0f;
    color: #f97316;
    border: 3px solid #f97316;
    outline: 3px solid #0f2c0f;
    outline-offset: 2px;
    box-shadow: 0 6px 20px rgba(15, 44, 15, 0.4), 0 4px 12px rgba(0, 0, 0, 0.15);
  }

  .btn-warning:hover {
    background: #0c240c;
    color: #f97316;
    border-color: #f97316;
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(15, 44, 15, 0.5), 0 6px 15px rgba(0, 0, 0, 0.2);
  }

  /* Info Button */
  .btn-info {
    background: linear-gradient(135deg, #4299e1 0%, #3182ce 100%);
    color: #0f2c0f;
    border: 3px solid #f97316;
    box-shadow: 0 6px 20px rgba(66, 153, 225, 0.4), 0 4px 12px rgba(0, 0, 0, 0.15);
  }

  .btn-info:hover {
    background: linear-gradient(135deg, #3182ce 0%, #2c5282 100%);
    border-color: #f97316;
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(66, 153, 225, 0.5), 0 6px 15px rgba(0, 0, 0, 0.2);
  }

  /* Dark Green / Orange Button */
  .btn-darkgreen {
    background: #0f2c0f;
    color: #f97316;
    border: 3px solid #f97316;
    outline: 3px solid #0f2c0f;
    outline-offset: 2px;
    box-shadow: 0 6px 20px rgba(15, 44, 15, 0.4), 0 4px 12px rgba(0, 0, 0, 0.15);
  }

  .btn-darkgreen:hover {
    background: #0c240c;
    color: #f97316;
    border-color: #f97316;
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(15, 44, 15, 0.5), 0 6px 15px rgba(0, 0, 0, 0.2);
  }

  .btn-darkgreen:active {
    transform: translateY(0);
    box-shadow: 0 4px 12px rgba(15, 44, 15, 0.3), 0 2px 6px rgba(0, 0, 0, 0.1);
  }

  /* Ghost Button - Adjusted for Dark Mode */
  .btn-ghost {
    @apply bg-transparent text-gray-300;
    border: 3px solid #f97316;
    box-shadow: none;
  }

  .btn-ghost:hover {
    @apply bg-surface-highlight text-white;
    border-color: #f97316;
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
  }

  /* Icon Buttons */
  .btn-icon {
    @apply p-3 rounded-full;
    min-width: 44px;
    min-height: 44px;
  }

  .btn-icon-sm {
    @apply p-2;
    min-width: 36px;
    min-height: 36px;
  }

  /* Loading State */
  .btn-loading {
    @apply cursor-not-allowed;
    position: relative;
  }

  .btn-loading::after {
    content: '';
    position: absolute;
    width: 16px;
    height: 16px;
    margin: auto;
    border: 2px solid transparent;
    border-top-color: currentColor;
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }

  .btn-loading > * {
    opacity: 0;
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  /* Disabled State */
  .btn:disabled,
  .btn[disabled] {
    @apply cursor-not-allowed opacity-50;
    transform: none !important;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1) !important;
  }

  .btn:disabled:hover,
  .btn[disabled]:hover {
    transform: none !important;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1) !important;
  }

  /* Ripple Effect */
  .btn-ripple {
    position: relative;
    overflow: hidden;
  }

  .btn-ripple::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0;
    height: 0;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.3);
    transform: translate(-50%, -50%);
    transition: width 0.6s, height 0.6s;
  }

  .btn-ripple:active::before {
    width: 300px;
    height: 300px;
  }

  /* Full Width */
  .btn-full {
    @apply w-full;
  }

  /* Rounded Variants */
  .btn-pill {
    border-radius: 9999px;
  }

  .btn-square {
    border-radius: 8px;
  }
}

/* Base styles for inputs to ensure visibility in dark mode */
@layer base {
  input, textarea, select {
    @apply bg-surface border border-surface-highlight text-foreground rounded-lg px-4 py-2 focus:ring-2 focus:ring-primary-500 outline-none;
  }
  
  /* Placeholder color */
  input::placeholder, textarea::placeholder {
    @apply text-gray-500;
  }
}

/* Mascot Animations */
@keyframes breathe {
  0%, 100% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.02);
  }
}

@keyframes stern-active {
  0%, 100% {
    transform: translateY(0px) rotate(0deg);
  }
  25% {
    transform: translateY(-2px) rotate(-1deg);
  }
  50% {
    transform: translateY(0px) rotate(0deg);
  }
  75% {
    transform: translateY(-2px) rotate(1deg);
  }
}

@keyframes anxious-active {
  0%, 100% {
    transform: translateX(0px) translateY(0px);
  }
  25% {
    transform: translateX(-1px) translateY(-1px);
  }
  50% {
    transform: translateX(1px) translateY(0px);
  }
  75% {
    transform: translateX(-1px) translateY(-1px);
  }
}

@keyframes excitable-active {
  0%, 100% {
    transform: translateY(0px) scale(1);
  }
  25% {
    transform: translateY(-4px) scale(1.05);
  }
  50% {
    transform: translateY(0px) scale(1);
  }
  75% {
    transform: translateY(-4px) scale(1.05);
  }
}

@keyframes thoughtful-active {
  0%, 100% {
    transform: translateY(0px) rotate(0deg);
  }
  25% {
    transform: translateY(-1px) rotate(-0.5deg);
  }
  50% {
    transform: translateY(0px) rotate(0deg);
  }
  75% {
    transform: translateY(-1px) rotate(0.5deg);
  }
}

@keyframes hyperactive-active {
  0%, 100% {
    transform: translateY(0px) rotate(0deg) scale(1);
  }
  25% {
    transform: translateY(-3px) rotate(-2deg) scale(1.03);
  }
  50% {
    transform: translateY(0px) rotate(2deg) scale(1);
  }
  75% {
    transform: translateY(-3px) rotate(-2deg) scale(1.03);
  }
}

.animate-breathe {
  animation: breathe 2s ease-in-out infinite;
}

.animate-stern-active {
  animation: stern-active 1s ease-in-out infinite;
}

.animate-anxious-active {
  animation: anxious-active 0.6s ease-in-out infinite;
}

.animate-excitable-active {
  animation: excitable-active 0.8s ease-in-out infinite;
}

.animate-thoughtful-active {
  animation: thoughtful-active 2s ease-in-out infinite;
}

.animate-hyperactive-active {
  animation: hyperactive-active 0.5s ease-in-out infinite;
}

@keyframes float {
  0%, 100% {
    background-position: 0% 50%;
  }
  50% {
    background-position: 100% 50%;
  }
}
</file>

<file path="app/layout.tsx">
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import Navigation from "@/components/Navigation";
import Footer from "@/components/Footer";
import { ClerkProvider } from '@clerk/nextjs';
import ErrorBoundaryWrapper from "@/components/ErrorBoundaryWrapper";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  metadataBase: new URL('https://petplatesmealplatform-ldvstwjsy-plateandpaw.vercel.app'),
  title: {
    default: "Paws & Plates - Fresh Meal Prep for Dogs, Cats, Birds, Reptiles & Small Pets",
    template: "%s | Paws & Plates"
  },
  description: "Free vet-approved meal plans for ALL your pets. Custom recipes for dogs, cats, birds, reptiles, and pocket pets with one-click Amazon ingredient ordering. AAFCO & WSAVA compliant.",
  keywords: [
    "homemade dog food",
    "homemade cat food", 
    "DIY pet meals",
    "pet meal prep",
    "fresh pet food recipes",
    "vet approved pet food",
    "custom pet nutrition",
    "AAFCO pet food",
    "bird food recipes",
    "reptile diet plans",
    "small pet nutrition",
    "homemade pet food delivery",
    "pet meal planner",
    "healthy pet recipes",
    "balanced dog nutrition",
    "cat diet recipes"
  ],
  authors: [{ name: "Paws & Plates Team" }],
  creator: "Paws & Plates",
  publisher: "Paws & Plates",
  robots: {
    index: true,
    follow: true,
    googleBot: {
      index: true,
      follow: true,
      'max-video-preview': -1,
      'max-image-preview': 'large',
      'max-snippet': -1,
    },
  },
  openGraph: {
    type: 'website',
    locale: 'en_US',
    url: 'https://petplatesmealplatform-ldvstwjsy-plateandpaw.vercel.app',
    siteName: 'Paws & Plates',
    title: 'Paws & Plates - Fresh Meal Prep for Dogs, Cats, Birds, Reptiles & Small Pets',
    description: 'Free vet-approved meal plans for ALL your pets. Custom recipes with one-click Amazon ordering. AAFCO & WSAVA compliant nutrition.',
    images: [
      {
        url: '/images/emojis/Mascots/HeroPics/HeroBanner-v3.png',
        width: 1200,
        height: 630,
        alt: 'Paws & Plates - Meal prep for all pets',
      }
    ],
  },
  twitter: {
    card: 'summary_large_image',
    title: 'Paws & Plates - Fresh Meal Prep for Dogs, Cats, Birds, Reptiles & Small Pets',
    description: 'Free vet-approved meal plans for ALL your pets. Custom recipes with one-click Amazon ordering.',
    images: ['/images/emojis/Mascots/HeroPics/HeroBanner-v3.png'],
  },
  alternates: {
    canonical: 'https://petplatesmealplatform-ldvstwjsy-plateandpaw.vercel.app',
  },
  verification: {
    // Add these later when you have accounts:
    // google: 'your-google-verification-code',
    // yandex: 'your-yandex-verification-code',
    // bing: 'your-bing-verification-code',
  },
  category: 'Pet Care',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <ClerkProvider
      publishableKey={process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY}
    >
      <html lang="en" suppressHydrationWarning>
        <head>
          {/* Additional SEO tags */}
          <link rel="icon" href="/favicon.ico" />
          <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
          <meta name="theme-color" content="#043136" />
          <meta name="apple-mobile-web-app-capable" content="yes" />
          <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
          
          {/* Schema.org markup for Google */}
          <script
            type="application/ld+json"
            dangerouslySetInnerHTML={{
              __html: JSON.stringify({
                "@context": "https://schema.org",
                "@type": "WebSite",
                "name": "Paws & Plates",
                "description": "Free vet-approved meal plans for dogs, cats, birds, reptiles, and pocket pets",
                "url": "https://petplatesmealplatform-ldvstwjsy-plateandpaw.vercel.app",
                "potentialAction": {
                  "@type": "SearchAction",
                  "target": "https://petplatesmealplatform-ldvstwjsy-plateandpaw.vercel.app/search?q={search_term_string}",
                  "query-input": "required name=search_term_string"
                }
              })
            }}
          />
        </head>
        <body className={`${inter.className} bg-background text-foreground min-h-screen`}>
          <ErrorBoundaryWrapper>
            <Navigation />
            <main className="min-h-screen">
              {children}
            </main>
            <Footer />
          </ErrorBoundaryWrapper>
        </body>
      </html>
    </ClerkProvider>
  );
}
</file>

<file path="app/meal-plans/page.tsx">
'use client';

import { useState } from 'react';
import Link from 'next/link';
import { Check, Calendar, ShoppingCart } from 'lucide-react';
import { PetCategory } from '@/lib/types';

export default function MealPlansPage() {
  const [selectedCategory, setSelectedCategory] = useState<PetCategory>('dogs');
  const [planType, setPlanType] = useState<'one-time' | 'weekly'>('weekly');

  // Recipes are now generated dynamically
  const categoryRecipes: any[] = [];

  const planOptions = [
    {
      id: 'one-time',
      name: 'One-Time Meal',
      description: 'Single fresh meal for your pet',
      price: 12.99,
      features: [
        'Choose any recipe',
        'Complete ingredient list',
        'Detailed instructions',
        'Nutritional breakdown',
      ],
    },
    {
      id: 'weekly',
      name: 'Weekly Plan',
      description: '14 meals (2 per day for 7 days)',
      price: 89.99,
      savings: 'Save $92',
      features: [
        'Variety of meals',
        'All ingredients included',
        'Portion controlled',
        'Delivery schedule',
        'Flexible menu changes',
        'Cancel anytime',
      ],
    },
  ];
  const whyCards = [
    {
      id: 'standards',
      title: 'AAFCO Approved',
      subtitle: 'All meals meet or exceed AAFCO + WSAVA nutritional standards',
      hover:
        'AAFCO = Association of American Feed Control Officials. WSAVA = World Small Animal Veterinary Association. We follow both so every bowl stays complete and balanced.',
    },
    {
      id: 'ordering',
      title: 'Easy Ordering',
      subtitle: 'Get every ingredient delivered or buy them with one click online',
      hover:
        'Order from Major Pet Retailers, Chewy, Petco, Walmart, plus fresh options like Ollie, The Farmer‚Äôs Dog, Butternut Box, HolistaPet, and affiliate networks (Skimlinks, Rakuten, CJ, ShareASale).',
    },
    {
      id: 'mealprep',
      title: 'Why Meal Prep?',
      subtitle: 'Fresh prep beats whatever comes in a bag‚Äîevery single time.',
      hover:
        'Meal prepping keeps pets healthier with fresh ingredients tailored to their needs‚Äînot generic kibble. Paw & Plate knows species, age, size, and health concerns, then auto-adjusts portions and links the exact products you can buy today.',
    },
  ];

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Header */}
      <div className="bg-gradient-to-r from-primary-600 to-primary-800 text-white py-12 px-4">
        <div className="max-w-7xl mx-auto">
          <h1 className="text-4xl md:text-5xl font-bold mb-4">
            Meal Plans
          </h1>
          <p className="text-xl text-primary-100">
            Choose the perfect meal plan for your pet
          </p>
        </div>
      </div>

      <div className="max-w-7xl mx-auto px-4 py-12">
        {/* Category Selection */}
        <div className="mb-12">
          <h2 className="text-2xl font-bold text-gray-900 mb-6 text-center">
            Select Your Pet Category
          </h2>
          <div className="grid grid-cols-2 md:grid-cols-5 gap-4">
            {[
              { id: 'dogs' as PetCategory, name: 'Dogs', emoji: 'üêï' },
              { id: 'cats' as PetCategory, name: 'Cats', emoji: 'üêà' },
              { id: 'birds' as PetCategory, name: 'Birds', emoji: 'ü¶ú' },
              { id: 'reptiles' as PetCategory, name: 'Reptiles', emoji: 'ü¶é' },
              { id: 'pocket-pets' as PetCategory, name: 'Pocket Pets', emoji: 'üê∞' },
            ].map((category) => (
              <button
                key={category.id}
                onClick={() => setSelectedCategory(category.id)}
                className={`p-6 rounded-lg border-2 transition-all ${
                  selectedCategory === category.id
                    ? 'border-primary-600 bg-primary-50'
                    : 'border-gray-200 bg-white hover:border-primary-300'
                }`}
              >
                <div className="text-4xl mb-2">{category.emoji}</div>
                <div className="font-semibold text-gray-900">{category.name}</div>
              </button>
            ))}
          </div>
        </div>

        {/* Plan Type Selection */}
        <div className="mb-12">
          <h2 className="text-2xl font-bold text-gray-900 mb-6 text-center">
            Choose Your Plan
          </h2>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-8 max-w-5xl mx-auto">
            {planOptions.map((plan) => (
              <div
                key={plan.id}
                className={`bg-white rounded-lg shadow-lg overflow-hidden transition-all ${
                  planType === plan.id
                    ? 'ring-4 ring-primary-600'
                    : 'hover:shadow-xl'
                }`}
              >
                <div className="p-8">
                  {plan.savings && (
                    <div className="inline-block px-3 py-1 bg-green-100 text-green-700 rounded-full text-sm font-semibold mb-4">
                      {plan.savings}
                    </div>
                  )}
                  <h3 className="text-2xl font-bold text-gray-900 mb-2">
                    {plan.name}
                  </h3>
                  <p className="text-gray-600 mb-4">{plan.description}</p>
                  <div className="mb-6">
                    <span className="text-4xl font-bold text-gray-900">${plan.price}</span>
                    <span className="text-gray-600 ml-2">
                      {plan.id === 'weekly' ? '/week' : '/meal'}
                    </span>
                  </div>
                  <button
                    onClick={() => setPlanType(plan.id as 'one-time' | 'weekly')}
                    className={`w-full py-3 rounded-lg font-semibold transition-colors ${
                      planType === plan.id
                        ? 'bg-primary-600 text-white'
                        : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                    }`}
                  >
                    {planType === plan.id ? 'Selected' : 'Select Plan'}
                  </button>
                </div>
                <div className="bg-gray-50 p-8 border-t">
                  <h4 className="font-semibold text-gray-900 mb-4">What's included:</h4>
                  <ul className="space-y-3">
                    {plan.features.map((feature, index) => (
                      <li key={index} className="flex items-start gap-3">
                        <Check size={20} className="text-green-600 flex-shrink-0 mt-0.5" />
                        <span className="text-gray-700">{feature}</span>
                      </li>
                    ))}
                  </ul>
                </div>
              </div>
            ))}
          </div>
        </div>

        {/* Sample Weekly Menu */}
        {planType === 'weekly' && (
          <div className="mb-12">
            <h2 className="text-2xl font-bold text-gray-900 mb-6 text-center">
              Sample Weekly Menu for {selectedCategory.charAt(0).toUpperCase() + selectedCategory.slice(1)}
            </h2>
            <div className="bg-white rounded-lg shadow-md p-8">
              <div className="grid grid-cols-1 md:grid-cols-7 gap-4">
                {['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'].map((day, dayIndex) => (
                  <div key={day} className="border rounded-lg p-4">
                    <h3 className="font-bold text-gray-900 mb-3 text-center">{day}</h3>
                    <div className="space-y-3">
                      {[0, 1].map((mealIndex) => {
                        const recipeIndex = (dayIndex * 2 + mealIndex) % categoryRecipes.length;
                        const recipe = categoryRecipes[recipeIndex];
                        return recipe ? (
                          <div key={mealIndex} className="bg-gray-50 rounded p-2">
                            <div className="text-xs font-semibold text-gray-600 mb-1">
                              {mealIndex === 0 ? 'Breakfast' : 'Dinner'}
                            </div>
                            <div className="text-sm font-medium text-gray-900 line-clamp-2">
                              {recipe.name}
                            </div>
                          </div>
                        ) : null;
                      })}
                    </div>
                  </div>
                ))}
              </div>
              <p className="text-center text-gray-600 mt-6">
                Menus are customized based on your pet's breed, age, and health needs
              </p>
            </div>
          </div>
        )}

        {/* CTA Section */}
        <div className="bg-gradient-to-r from-primary-600 to-primary-800 rounded-lg p-12 text-center text-white">
          <h2 className="text-3xl font-bold mb-4">
            Ready to Get Started?
          </h2>
          <p className="text-xl text-primary-100 mb-8 max-w-2xl mx-auto">
            Complete your pet's profile to receive a personalized meal plan with meals tailored to their needs
          </p>
          <div className="flex flex-col sm:flex-row gap-4 justify-center">
            <Link
              href={`/category/${selectedCategory}`}
              className="inline-flex items-center justify-center gap-2 px-8 py-4 bg-white text-primary-700 font-semibold rounded-lg hover:bg-primary-50 transition-colors"
            >
              <Calendar size={20} />
              Customize My Plan
            </Link>
            <Link
              href="/profile"
              className="inline-flex items-center justify-center gap-2 px-8 py-4 bg-primary-700 text-white font-semibold rounded-lg hover:bg-primary-600 transition-colors border-2 border-white"
            >
              My Pets
            </Link>
          </div>
        </div>

        {/* Why Pet Plates */}
        <div className="mt-16 grid grid-cols-1 md:grid-cols-3 gap-8">
          {whyCards.map((card) => {
            const Icon =
              card.id === 'standards' ? Check : card.id === 'ordering' ? ShoppingCart : Calendar;
            return (
              <div
                key={card.id}
                className="relative group text-center bg-white rounded-xl shadow p-8 overflow-hidden"
              >
                <div className="w-16 h-16 bg-primary-100 rounded-full flex items-center justify-center mx-auto mb-4">
                  <Icon size={32} className="text-primary-600" />
                </div>
                <h3 className="text-xl font-bold text-gray-900 mb-2">{card.title}</h3>
                <p className="text-gray-600">{card.subtitle}</p>
                <div className="absolute inset-0 bg-white/95 px-4 py-6 text-sm text-gray-700 flex items-center justify-center opacity-0 pointer-events-none group-hover:opacity-100 group-hover:pointer-events-auto transition-opacity duration-200">
                  <p className="leading-relaxed">{card.hover}</p>
                </div>
              </div>
            );
          })}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/nutrition-guide/page.tsx">
'use client';

import Link from 'next/link';

const foundations = [
  'AAFCO nutrient profiles for growth, maintenance, and senior diets (dogs/cats)',
  'NRC (National Research Council) data for exotic species',
  'Pet health specialist guidance for balancing protein, fats, essential amino acids, minerals, vitamins, and calories',
  'Evidence-backed functional ingredients (joint care, skin, digestion, urinary health, metabolic support)',
];

const adjustments = [
  'Species-specific needs',
  'Breed tendencies',
  'Age and activity level',
  'Weight goals',
  'Medical considerations (allergies, joint support, etc.)',
];

export default function NutritionGuidePage() {
  return (
    <div className="min-h-screen bg-gray-50 py-16 px-4">
      <div className="max-w-5xl mx-auto space-y-8">
        <div>
          <Link href="/" className="text-orange-600 font-semibold hover:underline">
            ‚Üê Back to home
          </Link>
        </div>
        <header>
          <h1 className="text-4xl font-extrabold text-gray-900 mb-3">Nutrition Guide</h1>
          <p className="text-lg text-gray-600 max-w-3xl">
            Paw & Plate uses peer-reviewed science, pet health specialist standards, and functional ingredients to
            keep every fresh meal nutritionally complete.
          </p>
        </header>

        <section className="bg-white rounded-2xl shadow p-6 border border-gray-100">
          <h2 className="text-2xl font-semibold text-gray-900 mb-4">Our foundation</h2>
          <p className="text-gray-600 mb-4">
            We build meal templates using the following evidence-based references:
          </p>
          <ul className="space-y-2 list-disc list-inside text-gray-700">
            {foundations.map((item) => (
              <li key={item}>{item}</li>
            ))}
          </ul>
        </section>

        <section className="bg-white rounded-2xl shadow p-6 border border-gray-100">
          <h2 className="text-2xl font-semibold text-gray-900 mb-4">Key philosophy</h2>
          <p className="text-gray-600 mb-4">
            Nutrition isn‚Äôt one-size-fits-all. Every Paw & Plate meal starts balanced, then adapts to
            your pet‚Äôs unique context.
          </p>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div>
              <h3 className="text-lg font-semibold text-gray-900 mb-2">We adjust for:</h3>
              <ul className="space-y-2 list-disc list-inside text-gray-700">
                {adjustments.map((item) => (
                  <li key={item}>{item}</li>
                ))}
              </ul>
            </div>
            <div>
              <h3 className="text-lg font-semibold text-gray-900 mb-2">Non-negotiables</h3>
              <p className="text-gray-600">
                Every meal starts nutritionally complete. Functional modifications only add benefits ‚Äî
                they never reduce baseline requirements.
              </p>
            </div>
          </div>
        </section>
      </div>
    </div>
  );
}
</file>

<file path="app/page.tsx">
'use client';

import { useState } from 'react';
import Link from 'next/link';
import Image from 'next/image';
import { Check, Calendar, ShoppingCart, ArrowRight, Sparkles } from 'lucide-react';
import { useUser, SignOutButton } from '@clerk/nextjs'; 
import { PetCategory } from '@/lib/types';
import QuickPreviewModal from '@/components/QuickPreviewModal';
import SocialProof, { TestimonialSection } from '@/components/SocialProof';
import EmailCaptureModal, { useExitIntent } from '@/components/EmailCaptureModal';
import ABTestDashboard from '@/components/ABTestDashboard';
import TrustBadges from '@/components/TrustBadges';

const getPetData = (userId: string) => {
  if (typeof window === 'undefined') return [];
  const stored = localStorage.getItem(`pets_${userId}`);
  return stored ? JSON.parse(stored) : [];
};

const whyCards = [
  {
    id: 'standards',
    title: 'AAFCO Approved',
    subtitle: 'All meals meet or exceed AAFCO + WSAVA nutritional standards',
    hover:
      '**AAFCO** (Association of American Feed Control Officials) and **WSAVA** (World Small Animal Veterinary Association) set the gold standard for pet nutrition. We build every meal to those benchmarks with guidance from pet health specialists so your pet stays balanced.',
    icon: Check,
  },
  {
    id: 'ordering',
    title: 'Easy Ordering',
    subtitle: 'Get every ingredient delivered or buy them with one click on Amazon',
    hover:
      'Source ingredients from **Major Pet Retailers** like **Amazon**, Chewy, Petco, Walmart, Ollie, The Farmer\'s Dog, Butternut Box, HolistaPet, plus affiliate networks like Skimlinks, Rakuten, CJ, and ShareASale.',
    icon: ShoppingCart,
  },
  {
    id: 'plans',
    title: 'Why Meal Prep?',
    subtitle: 'Fresh prep beats whatever comes in a bag‚Äîevery single time.',
    hover:
      'Meal prepping keeps pets healthier with fresh ingredients tailored to their needs. Paws & Plates knows species, age, size, and health concerns, then auto-adjusts portions and links trusted products you can buy today.',
    icon: Calendar,
  },
];

const WhyUsSection = () => (
  <div className="grid grid-cols-1 md:grid-cols-3 gap-8 max-w-5xl mx-auto">
    {whyCards.map((card) => {
      const Icon = card.icon;
      return (
        <div
          key={card.id}
          className="relative group text-center bg-surface rounded-xl shadow-lg border border-surface-highlight p-8 overflow-hidden hover:shadow-xl transition-shadow duration-300"
        >
          <div className="w-16 h-16 bg-surface-highlight rounded-full flex items-center justify-center mx-auto mb-4 border border-white/10">
            <Icon size={32} className="text-orange-400" />
          </div>
          <h3 className="text-xl font-bold text-foreground mb-2">{card.title}</h3>
          <p className="text-gray-400">{card.subtitle}</p>
          <div className="absolute inset-0 bg-surface/95 px-4 py-6 text-sm text-gray-200 flex items-center justify-center opacity-0 pointer-events-none group-hover:opacity-100 group-hover:pointer-events-auto transition-opacity duration-200 backdrop-blur-sm">
            <p className="leading-relaxed"><strong>{card.hover}</strong></p>
          </div>
        </div>
      );
    })}
  </div>
);

export default function HomePage() { 
  const { user, isLoaded } = useUser();
  const [selectedCategory, setSelectedCategory] = useState<PetCategory>('dogs');
  const [showPreviewModal, setShowPreviewModal] = useState(false);
  const [showEmailCapture, setShowEmailCapture] = useState(false);
  
  // Exit intent - show email capture when user tries to leave
  useExitIntent(() => {
    if (!user && !showEmailCapture) {
      setShowEmailCapture(true);
    }
  });
  
  // Get userId for purchase tracking
  const userId = user?.id || (typeof window !== 'undefined' ? localStorage.getItem('last_user_id') || '' : '');
  
  if (isLoaded && user?.id) {
    const pets = getPetData(user.id);
    const hasPets = pets.length > 0;
    
    return (
      <div className="min-h-screen bg-background text-foreground">
        <header className="relative w-full border-b border-surface-highlight py-8" style={{ backgroundColor: '#043136' }}>
          <div className="max-w-4xl mx-auto relative w-full aspect-[16/9] h-[500px] md:h-[600px]">
            <Image
              src="/images/emojis/Mascots/HeroPics/LOGO.png"
              alt="Paws & Plates - Meal prep for All your pets"
              fill
              className="object-contain"
              priority
            />
          </div>
        </header>

        <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-12">
          <section className="text-center mb-12">
            <h1 className="text-4xl md:text-5xl font-extrabold tracking-tight text-white mb-4">
              Welcome Back, {user.firstName || 'Pet Owner'}!
            </h1>
            <p className="text-xl md:text-2xl text-gray-300 max-w-2xl mx-auto mb-8">
              Fresh, vet-approved, and personalized nutrition for your beloved pets.
            </p>
          </section>
          
          <section className="py-12">
            <h2 className="text-2xl font-bold text-white mb-8 text-center">Why Paws & Plates?</h2>
            <WhyUsSection />
          </section>
        </main>

        <footer className="py-6 text-center text-sm text-gray-500 border-t border-surface-highlight">
          <SignOutButton>
            <button className="text-orange-400 hover:text-orange-300 font-medium">
              Log Out
            </button>
          </SignOutButton>
        </footer>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-background text-foreground">
      <header className="relative w-full border-b border-surface-highlight py-8" style={{ backgroundColor: '#043136' }}>
        <div className="max-w-4xl mx-auto relative w-full aspect-[16/9] h-[250px] md:h-[300px]">
          <Image
            src="/images/emojis/Mascots/HeroPics/HeroBanner-v3.png"
            alt="Paws & Plates - Meal prep made easy, for ALL your pets!"
            fill
            className="object-contain"
            priority
          />
        </div>
      </header>

      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-12">
        <section className="text-center mb-12">
          <div className="flex flex-col sm:flex-row items-center justify-center gap-4">
            {/* PRIMARY CTA - See Examples (Drives Affiliate Clicks!) */}
            <button
              onClick={() => setShowPreviewModal(true)}
              className="btn btn-lg bg-gradient-to-r from-orange-500 to-orange-600 hover:from-orange-600 hover:to-orange-700 text-white border-3 border-orange-400 shadow-xl hover:shadow-2xl transform hover:scale-105 transition-all flex items-center gap-2"
            >
              <Sparkles size={24} />
              See Example Meals
              <ArrowRight size={20} />
            </button>
            
            {/* Secondary CTA */}
            <Link
              href="/sign-up"
              className="btn btn-lg btn-success"
            >
              Create Free Account
            </Link>
          </div>
          
          {/* Value Prop Subheading */}
          <p className="text-gray-400 text-sm mt-4">
            üéØ View meals instantly ‚Ä¢ No signup required ‚Ä¢ Start shopping now
          </p>
        </section>

        {/* Trust Badges */}
        <section className="py-8">
          <TrustBadges />
        </section>

        {/* Social Proof Section */}
        <section className="py-12">
          <SocialProof />
        </section>

        <section className="py-12 border-t border-surface-highlight">
          <WhyUsSection />
        </section>

        {/* Testimonials Section */}
        <section className="py-12 border-t border-surface-highlight">
          <TestimonialSection />
        </section>
      </main>

      {/* Quick Preview Modal */}
      <QuickPreviewModal 
        isOpen={showPreviewModal}
        onClose={() => setShowPreviewModal(false)}
      />

      {/* Email Capture Modal (Exit Intent) */}
      <EmailCaptureModal
        isOpen={showEmailCapture}
        onClose={() => setShowEmailCapture(false)}
        petType="your pet"
        mealCount={5}
        trigger="exit-intent"
      />

      {/* A/B Test Dashboard (Admin) */}
      <ABTestDashboard />
    </div>
  );
}
</file>

<file path="app/pets/[id]/page.tsx">
'use client';

import { useEffect, useState, useMemo } from 'react';
import { useParams, useRouter } from 'next/navigation';
import Link from 'next/link';
import { ArrowLeft } from 'lucide-react';
import { NutritionDashboard } from '@/components/NutritionDashboard';
import { calculateDailyNutrition, getNutritionTargets } from '@/lib/nutrition/nutritionHistory';
import { getCustomMeals } from '@/lib/utils/customMealStorage';
import type { Recipe, CustomMeal } from '@/lib/types';

const DAYS = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
const SIMULATED_USER_ID = 'clerk_simulated_user_id_123';

const getCurrentUserId = () => {
  if (typeof window === 'undefined') return SIMULATED_USER_ID;
  return localStorage.getItem('last_user_id') || SIMULATED_USER_ID;
};

const getPetsFromLocalStorage = (userId: string) => {
  if (typeof window === 'undefined') return [];
  const stored = localStorage.getItem(`pets_${userId}`);
  if (!stored) return [];
  try {
    const parsed = JSON.parse(stored);
    return Array.isArray(parsed) ? parsed : [];
  } catch {
    return [];
  }
};

const convertCustomMealToRecipe = (customMeal: CustomMeal): Recipe => {
  return {
    id: customMeal.id,
    name: customMeal.name,
    category: 'custom',
    ageGroup: ['adult'],
    healthConcerns: [],
    description: `Custom meal created on ${new Date(customMeal.createdAt).toLocaleDateString()}`,
    ingredients: customMeal.ingredients.map((ing, idx) => ({
      id: `${idx + 1}`,
      name: ing.key.replace(/_/g, ' '),
      amount: `${ing.grams}g`,
    })),
    instructions: ['Mix all ingredients according to saved recipe', 'Serve at recommended portion size'],
    nutritionalInfo: {
      protein: {
        min: (customMeal.analysis.nutrients.protein_g || 0) / (customMeal.analysis.totalRecipeGrams / 100),
        max: (customMeal.analysis.nutrients.protein_g || 0) / (customMeal.analysis.totalRecipeGrams / 100),
        unit: '%',
      },
      fat: {
        min: (customMeal.analysis.nutrients.fat_g || 0) / (customMeal.analysis.totalRecipeGrams / 100),
        max: (customMeal.analysis.nutrients.fat_g || 0) / (customMeal.analysis.totalRecipeGrams / 100),
        unit: '%',
      },
      calories: {
        min: customMeal.analysis.nutrients.kcal || customMeal.analysis.nutrients.calories_kcal || 0,
        max: customMeal.analysis.nutrients.kcal || customMeal.analysis.nutrients.calories_kcal || 0,
        unit: 'kcal',
      },
    },
    rating: 0,
    reviews: 0,
    tags: ['custom', 'user-created'],
  };
};

const buildEvenPlan = (meals: Recipe[]) => {
  const totalSlots = DAYS.length * 2;
  const rotation: Recipe[] = [];
  while (rotation.length < totalSlots) {
    rotation.push(...meals);
  }
  return rotation.slice(0, totalSlots);
};

export default function NutritionPage() {
  const params = useParams();
  const router = useRouter();
  const petId = params.id as string;
  const [pet, setPet] = useState<any>(null);
  const [savedMeals, setSavedMeals] = useState<Recipe[]>([]);
  const [customMeals, setCustomMeals] = useState<CustomMeal[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    async function loadPetData() {
      const userId = getCurrentUserId();
      const pets = getPetsFromLocalStorage(userId);
      const foundPet = pets.find((p: any) => p.id === petId) || null;
      setPet(foundPet);
      if (foundPet) {
        // Saved recipes are no longer stored statically
        setSavedMeals([]);
        const customMealsList = await getCustomMeals(userId, petId);
        setCustomMeals(customMealsList);
      }
      setLoading(false);
    }
    loadPetData();
  }, [petId]);

  const weeklyPlan = useMemo(() => {
    const allMeals = [...savedMeals, ...customMeals.map(convertCustomMealToRecipe)];
    if (allMeals.length === 0) return [];
    const rotation = buildEvenPlan(allMeals);
    const plan: { day: string; meals: Recipe[] }[] = [];
    for (let i = 0; i < DAYS.length; i += 1) {
      const breakfastIndex = i * 2;
      const dinnerIndex = breakfastIndex + 1;
      const breakfast = rotation[breakfastIndex];
      let dinner = rotation[dinnerIndex];
      if (dinner.id === breakfast.id) {
        const swapIndex = rotation.findIndex((entry, idx) => idx > dinnerIndex && entry.id !== breakfast.id);
        if (swapIndex !== -1) {
          [rotation[dinnerIndex], rotation[swapIndex]] = [rotation[swapIndex], rotation[dinnerIndex]];
          dinner = rotation[dinnerIndex];
        } else {
          dinner = allMeals.find((meal) => meal.id !== breakfast.id) || dinner;
        }
      }
      plan.push({ day: DAYS[i], meals: [breakfast, dinner] });
    }
    return plan;
  }, [savedMeals, customMeals]);

  const dailyNutrition = useMemo(() => calculateDailyNutrition(weeklyPlan), [weeklyPlan]);
  const targets = useMemo(() => getNutritionTargets(pet?.type), [pet?.type]);

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <p className="text-gray-600">Loading nutrition data...</p>
      </div>
    );
  }

  if (!pet) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <div className="bg-white p-8 rounded-xl shadow text-center space-y-4">
          <p className="text-xl font-semibold text-gray-800">Pet not found.</p>
          <Link href="/profile" className="text-green-800 font-semibold">
            Back to Profiles
          </Link>
        </div>
      </div>
    );
  }

  if (dailyNutrition.length === 0) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center px-4">
        <div className="max-w-lg bg-white rounded-xl shadow p-8 text-center space-y-4">
          <div className="text-5xl">üìä</div>
          <h1 className="text-2xl font-bold text-gray-900">No meal plan data</h1>
          <p className="text-gray-600">
            Save at least one meal for {pet.name || 'your pet'} to view nutrition data.
          </p>
          <Link
            href={`/profile/pet/${petId}/meal-plan`}
            className="inline-block px-6 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700"
          >
            Go to Meal Plan
          </Link>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50 py-8">
      <div className="max-w-7xl mx-auto px-4">
        <Link
          href={`/profile/pet/${petId}/meal-plan`}
          className="inline-flex items-center gap-2 text-gray-600 hover:text-gray-900 mb-6"
        >
          <ArrowLeft size={20} />
          Back to Meal Plan
        </Link>
        <NutritionDashboard daily={dailyNutrition} targets={targets} petName={pet.name || pet.names?.[0] || 'Your Pet'} />
      </div>
    </div>
  );
}
</file>

<file path="app/profile/page.tsx">
'use client';

import React, { useState, useEffect, useCallback, useMemo, startTransition } from 'react';
import Link from 'next/link';
import { Plus, Edit, Trash2, ShoppingCart } from 'lucide-react';
import { getPrimaryName } from '@/lib/utils/petUtils';
import type { Pet } from '@/lib/types';
import { v4 as uuidv4 } from 'uuid';
import HealthConcernsDropdown from '@/components/HealthConcernsDropdown';
import { useVillageStore } from '@/lib/state/villageStore';
import { getMascotFaceForPetType, getProfilePictureForPetType } from '@/lib/utils/emojiMapping';
import AddPetModal from '@/components/CreatePetModal';
import { getCustomMeals } from '@/lib/utils/customMealStorage';
import { getPets, savePet, deletePet } from '@/lib/utils/petStorage'; // Import from storage util
import type { CustomMeal } from '@/lib/types';
import { getVettedProduct, VETTED_PRODUCTS } from '@/lib/data/vetted-products';
import Image from 'next/image';
import EmojiIcon from '@/components/EmojiIcon';
import { ensureCartUrlSellerId } from '@/lib/utils/affiliateLinks';
import ConfirmModal from '@/components/ConfirmModal';
import { nutritionalGuidelines } from '@/lib/data/nutritional-guidelines';
import { calculateEnhancedCompatibility, calculateRecipeNutrition, type Pet as EnhancedPet } from '@/lib/utils/enhancedCompatibilityScoring';
import type { Recipe } from '@/lib/types';
import { checkAllBadges } from '@/lib/utils/badgeChecker';
import PetBadges from '@/components/PetBadges';
import BadgeToggle from '@/components/BadgeToggle';
import Tooltip from '@/components/Tooltip';

const DAYS = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];

const convertCustomMealToRecipe = (customMeal: CustomMeal): any => {
  return {
    id: customMeal.id,
    name: customMeal.name,
    category: 'custom',
    ageGroup: ['adult'],
    healthConcerns: [],
    description: `Custom meal created on ${customMeal.createdAt ? new Date(customMeal.createdAt).toLocaleDateString() : ''}`,
    ingredients: customMeal.ingredients.map((ing, idx) => ({
      id: `${idx + 1}`,
      name: ing.key.replace(/_/g, ' '),
      amount: `${ing.grams}g`,
    })),
    instructions: [
      'Mix all ingredients according to saved recipe',
      'Serve at recommended portion size',
      `Recommended serving: ${customMeal.analysis.recommendedServingGrams}g`,
    ],
    nutritionalInfo: {
      protein: {
        min: (customMeal.analysis.nutrients.protein_g || 0) / (customMeal.analysis.totalRecipeGrams / 100),
        max: (customMeal.analysis.nutrients.protein_g || 0) / (customMeal.analysis.totalRecipeGrams / 100),
        unit: '%',
      },
      fat: {
        min: (customMeal.analysis.nutrients.fat_g || 0) / (customMeal.analysis.totalRecipeGrams / 100),
        max: (customMeal.analysis.nutrients.fat_g || 0) / (customMeal.analysis.totalRecipeGrams / 100),
        unit: '%',
      },
      calories: {
        min: customMeal.analysis.nutrients.kcal || customMeal.analysis.nutrients.calories_kcal || 0,
        max: customMeal.analysis.nutrients.kcal || customMeal.analysis.nutrients.calories_kcal || 0,
        unit: 'kcal',
      },
    },
    rating: 0,
    reviews: 0,
    tags: ['custom', 'user-created'],
  };
};

const buildEvenPlan = (meals: any[]) => {
  const totalSlots = DAYS.length * 2;
  const rotation: any[] = [];
  if (meals.length === 0) return [];
  while (rotation.length < totalSlots) {
    rotation.push(...meals);
  }
  return rotation.slice(0, totalSlots);
};

// =================================================================
// 1. TYPES & LOCAL STORAGE FUNCTIONS
// =================================================================

type PetCategory = 'dogs' | 'cats' | 'birds' | 'reptiles' | 'pocket-pets';
type AgeGroup = 'baby' | 'young' | 'adult' | 'senior';

type ProfilePet = Pet;

// Simulated user id (replace with Clerk user.id in real auth)
const SIMULATED_USER_ID = 'clerk_simulated_user_id_123';

// =================================================================
// 2. DATA CONSTANTS
// =================================================================

import { getBreedNamesForSpecies } from '@/lib/data/speciesBreeds';

// Get breeds from centralized source
const PET_BREEDS: Record<PetCategory, string[]> = {
  dogs: [...getBreedNamesForSpecies('dogs'), 'Other'],
  cats: [...getBreedNamesForSpecies('cats'), 'Other'],
  birds: [...getBreedNamesForSpecies('birds'), 'Other'],
  reptiles: [...getBreedNamesForSpecies('reptiles'), 'Other'],
  'pocket-pets': [...getBreedNamesForSpecies('pocket-pets'), 'Other'],
};

// Health concerns are now handled by HealthConcernsDropdown component
// This old array is no longer used - kept for reference only
// const PET_HEALTH_CONCERNS: string[] = [
//   'Allergy Support',
//   'Weight Management',
//   'Digestive Health',
//   'Joint & Mobility',
//   'Skin & Coat',
//   'Dental Health',
//   'Kidney/Urinary Support',
//   'Other',
// ];

// =================================================================
// 3. ICON UTILITY
// =================================================================

const formatRecipeName = (id: string) => {
  if (!id) return 'Unnamed Meal';
  // Replace dashes/underscores with spaces and title-case segments
  return id
    .replace(/[-_]+/g, ' ')
    .split(' ')
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join(' ')
    .trim();
};

type WeeklyPlanEntry = {
  day: string;
  meals: (string | null)[];
};

const PET_ICON_MAP: Record<PetCategory, string> = {
  dogs: 'üêï',
  cats: 'üêà',
  birds: 'ü¶ú',
  reptiles: 'ü¶é',
  'pocket-pets': 'üê∞',
};

const getPetIcon = (type: PetCategory, breed: string = '', size: number = 24, className = '') => {
  // Ensure type is valid
  if (!type || !PET_ICON_MAP[type]) {
    return <EmojiIcon emoji="üêæ" size={size} className={className} />;
  }
  
  let emoji = PET_ICON_MAP[type];
  
  // Handle pocket-pets breed-specific emojis
  if (type === 'pocket-pets' && breed) {
    const breedLower = breed.toLowerCase();
    if (breedLower.includes('hamster')) emoji = 'üêπ';
    else if (breedLower.includes('gerbil')) emoji = 'üêπ'; // No gerbil emoji, use hamster
    else if (breedLower.includes('guinea pig') || breedLower.includes('guinea-pig')) emoji = 'üêπ';
    else if (breedLower.includes('rat')) emoji = 'üê≠';
    else if (breedLower.includes('mouse')) emoji = 'üê≠';
    else if (breedLower.includes('chinchilla')) emoji = 'üêπ';
    else if (breedLower.includes('hedgehog')) emoji = 'ü¶î';
    else if (breedLower.includes('ferret')) emoji = 'ü¶¶'; // Closest
    // Default to rabbit (üê∞) for pocket-pets
  }
  
  return <EmojiIcon emoji={emoji} size={size} className={className} />;
};

// =================================================================
// 4. PET MODAL COMPONENT
// =================================================================

interface PetModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSave: (pet: any) => void;
  editingPet: Pet | null;
}

const PetModal: React.FC<PetModalProps> = ({ isOpen, onClose, onSave, editingPet }) => {
  // Initialize with empty defaults - will be set by useEffect when modal opens
  const [formData, setFormData] = useState<{
    id: string;
    names: string[];
    type: string;
    breed: string;
    age: string;
    weight: string;
    healthConcerns: string[];
    image: string;
  }>({
    id: uuidv4(),
    names: [],
    type: 'dogs',
    breed: '',
    age: 'adult',
    weight: '',
    healthConcerns: [],
    image: '',
  });

  const [newName, setNewName] = useState('');

  // Reset formData when modal opens or editingPet changes to prevent name bleeding between pets
  useEffect(() => {
    // Only update when modal is open
    if (!isOpen) {
      return;
    }
    
    // When modal opens, load the correct data
    if (editingPet) {
      // Load existing names, filter out empty ones
      const existingNames = editingPet.names && Array.isArray(editingPet.names)
        ? editingPet.names.filter(n => n && n.trim() !== '')
        : [];
      
      setFormData({
        id: editingPet.id,
        names: existingNames.length > 0 ? existingNames : [],
        type: editingPet.type || 'dogs',
        breed: editingPet.breed || '',
        age: editingPet.age || 'adult',
        weight: editingPet.weight || '',
        healthConcerns: Array.isArray(editingPet.healthConcerns) ? editingPet.healthConcerns : [],
        image: editingPet.image || '',
      });
      setNewName('');
    } else {
      // Reset to defaults when adding new pet
      setFormData({
        id: uuidv4(),
        names: [],
        type: 'dogs',
        breed: '',
        age: 'adult',
        weight: '',
        healthConcerns: [],
        image: '',
      });
      setNewName('');
    }
  }, [isOpen, editingPet]);

  if (!isOpen) return null;

  const handleAddName = () => {
    if (newName.trim()) {
      setFormData({
        ...formData,
        names: [...formData.names, newName.trim()]
      });
      setNewName('');
    }
  };

  const handleRemoveName = (index: number) => {
    setFormData({
      ...formData,
      names: formData.names.filter((_, i) => i !== index)
    });
  };

  const handleHealthConcernToggle = (concern: string) => {
    setFormData(prev => ({
      ...prev,
      healthConcerns: prev.healthConcerns.includes(concern)
        ? prev.healthConcerns.filter(c => c !== concern)
        : [...prev.healthConcerns, concern]
    }));
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    // IMPORTANT: If user typed a name but didn't click "Add", include it now
    let allNames = [...formData.names];
    if (newName.trim() && !allNames.includes(newName.trim())) {
      allNames.push(newName.trim());
    }
    
    // Filter out empty names before saving
    const cleanedNames = allNames.filter(name => name && name.trim() !== '');
    
    // Ensure at least one name exists
    if (cleanedNames.length === 0) {
      cleanedNames.push('Unnamed Pet');
    }
    
    const cleanedData = {
      ...formData,
      names: cleanedNames,
    };
    
    // Saving pet with names
    
    onSave(cleanedData);
    setNewName(''); // Clear the input
    onClose();
  };

  // Get the first name for display at top
  const firstName = formData.names.length > 0 ? formData.names[0] : null;
  const additionalNames = formData.names.slice(1);

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4">
      <div className="bg-white rounded-2xl shadow-2xl w-full max-w-6xl max-h-[95vh] overflow-y-auto">
        <div className="sticky top-0 bg-white border-b border-gray-200 px-6 py-3 z-10">
          <div className="flex justify-between items-center">
            <h2 className="text-xl font-bold text-gray-900">
              {editingPet ? 'Edit Pet' : 'Add New Pet'}
            </h2>
            <button
              onClick={onClose}
              className="text-gray-400 hover:text-gray-600 text-2xl"
            >
              ‚úï
            </button>
          </div>
        </div>

        <form onSubmit={handleSubmit} className="p-4">
          {/* Primary Pet Name - Top Row */}
          {firstName && (
            <div className="mb-3 pb-3 border-b border-gray-200">
              <label className="block text-xs font-medium text-gray-700 mb-1">
                Primary Name
              </label>
              <div className="flex items-center gap-2">
                <div className="bg-green-900/20 text-green-800 px-3 py-1.5 rounded-lg text-base font-semibold shadow-sm flex-1">
                  {firstName}
                </div>
                <button
                  type="button"
                  onClick={() => handleRemoveName(0)}
                  className="text-gray-400 hover:text-red-600 text-lg px-2"
                  title="Remove primary name"
                >
                  ‚úï
                </button>
              </div>
            </div>
          )}

          {/* Main Form - Horizontal Layout */}
          <div className="space-y-3">
            {/* Row 1: Name Input */}
            <div>
              <label className="block text-xs font-medium text-gray-700 mb-1">
                {firstName ? 'Add Another Name' : (
                  <>
                    Pet Name(s) <span className="text-gray-500 font-normal">(required)</span>
                  </>
                )}
              </label>
              <div className="flex gap-2">
                <input
                  type="text"
                  value={newName}
                  onChange={(e) => setNewName(e.target.value)}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter') {
                      e.preventDefault();
                      handleAddName();
                    }
                  }}
                  placeholder={firstName ? "Add another name..." : "Type a name and press Enter"}
                  className="flex-1 px-2 py-1.5 text-sm border border-gray-300 rounded-lg focus:ring-1 focus:ring-green-800 focus:border-green-800"
                />
                <button
                  type="button"
                  onClick={handleAddName}
                  disabled={!newName.trim()}
                  className="px-3 py-1.5 text-sm bg-gray-100 hover:bg-gray-200 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  Add
                </button>
              </div>
              {firstName && additionalNames.length > 0 && (
                <div className="flex flex-wrap gap-1.5 mt-1.5">
                  {additionalNames.map((name, index) => (
                    name.trim() !== '' && (
                      <div key={index + 1} className="bg-primary-100 text-primary-800 px-2 py-1 rounded-full flex items-center gap-1 text-xs font-medium">
                        <span>{name}</span>
                        <button
                          type="button"
                          onClick={() => handleRemoveName(index + 1)}
                          className="text-green-800 hover:text-green-900"
                          title="Remove name"
                        >
                          ‚úï
                        </button>
                      </div>
                    )
                  ))}
                </div>
              )}
            </div>

            {/* Row 2: Pet Type, Breed, Age, Weight - Horizontal */}
            <div className="grid grid-cols-4 gap-3">
              {/* Pet Type */}
              <div>
                <label className="block text-xs font-medium text-gray-700 mb-1">
                  Pet Type
                </label>
                <div className="grid grid-cols-5 gap-1">
                  {Object.entries(PET_ICON_MAP).map(([type, emoji]) => (
                    <button
                      key={type}
                      type="button"
                      onClick={() => setFormData({...formData, type})}
                      className={`flex flex-col items-center p-1 rounded border transition-colors ${formData.type === type ? 'border-primary-500 bg-primary-50' : 'border-gray-200 hover:border-gray-300'}`}
                      title={type.replace('-', ' ')}
                    >
                      <EmojiIcon emoji={emoji} size={24} />
                    </button>
                  ))}
                </div>
              </div>

              {/* Breed */}
              <div className="col-span-2">
                <label className="block text-xs font-medium text-gray-700 mb-1">
                  Breed
                </label>
                <select
                  value={formData.breed}
                  onChange={(e) => setFormData({...formData, breed: e.target.value})}
                  className="w-full min-w-[220px] px-2 py-1.5 text-sm border border-gray-300 rounded-lg"
                >
                  <option value="">Select breed</option>
                  {PET_BREEDS[formData.type as PetCategory]?.map(breed => (
                    <option key={breed} value={breed}>{breed}</option>
                  ))}
                </select>
              </div>

              {/* Age */}
              <div>
                <label className="block text-xs font-medium text-gray-700 mb-1">
                  Age
                </label>
                <div className="grid grid-cols-4 gap-1">
                  {['baby', 'young', 'adult', 'senior'].map(age => (
                    <button
                      key={age}
                      type="button"
                      onClick={() => setFormData({...formData, age})}
                      className={`px-2 py-1.5 text-xs rounded border capitalize ${formData.age === age ? 'border-green-800 bg-green-900/10' : 'border-gray-200 hover:border-gray-300'}`}
                    >
                      {age}
                    </button>
                  ))}
                </div>
              </div>

              {/* Weight */}
              <div>
                <label className="block text-xs font-medium text-gray-700 mb-1">
                  Weight
                </label>
                <input
                  type="text"
                  value={formData.weight}
                  onChange={(e) => setFormData({...formData, weight: e.target.value})}
                  placeholder="e.g., 10 lbs"
                  className="w-full px-2 py-1.5 text-sm border border-gray-300 rounded-lg"
                />
              </div>
            </div>

            {/* Row 3: Health Concerns - Full Width */}
            <div>
              <HealthConcernsDropdown
                species={formData.type || ''}
                selectedConcerns={formData.healthConcerns || []}
                onConcernsChange={(concerns) => setFormData({...formData, healthConcerns: concerns})}
                className="mt-0"
              />
            </div>
          </div>

          <div className="flex justify-end gap-2 mt-4 pt-3 border-t border-gray-200">
            <button
              type="button"
              onClick={onClose}
              className="px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 rounded-lg"
            >
              Cancel
            </button>
            <button
              type="submit"
              className="px-4 py-2 text-sm bg-primary-600 text-white hover:bg-primary-700 rounded-lg"
            >
              {editingPet ? 'Save Changes' : 'Add Pet'}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

// =================================================================
// 5. MAIN PAGE COMPONENT
// =================================================================

export default function MyPetsPage() {
  const userId = SIMULATED_USER_ID;
  const { setUserId } = useVillageStore();

  const [pets, setPets] = useState<ProfilePet[]>([]);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingPet, setEditingPet] = useState<Pet | null>(null);
  const [customMeals, setCustomMeals] = useState<CustomMeal[]>([]);
  const [isClient, setIsClient] = useState(false);
  const [activePetId, setActivePetId] = useState<string | null>(null);
  const [activeTab, setActiveTab] = useState<'bio' | 'saved' | 'plan'>('bio');
  const [planOffset, setPlanOffset] = useState(0);
const [planWeekly, setPlanWeekly] = useState<{ day: string; meals: any[] }[]>([]);
const [swapTarget, setSwapTarget] = useState<{ dayIdx: number; mealIdx: number } | null>(null);
  const [badgeRefreshKey, setBadgeRefreshKey] = useState(0);
const activePet = useMemo(() => (activePetId ? pets.find((p) => p.id === activePetId) : null), [activePetId, pets]);
  const [confirmModal, setConfirmModal] = useState<{
    isOpen: boolean;
    title: string;
    message: string;
    onConfirm: () => void;
  }>({
    isOpen: false,
    title: '',
    message: '',
    onConfirm: () => {},
  });
  // Recipe name lookup - uses formatted name since recipes are now generated dynamically
  const getRecipeName = useCallback((id: string) => {
    if (!id) return 'Unnamed Meal';
    return formatRecipeName(id);
  }, []);
const buildWeeklyPlan = useCallback(
    (saved: string[], offset: number): WeeklyPlanEntry[] => {
      const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];
      if (!Array.isArray(saved) || saved.length < 2) {
        return days.map((day) => ({ day, meals: [null, null] }));
      }
      const unique = saved.filter(Boolean);
      const len = unique.length;
      return days.map((day, idx) => {
        const base = (idx + offset) % len;
        const first = unique[base] || null;
        let second = unique[(base + 1) % len] || null;
        if (second === first) {
          second = unique[(base + 2) % len] || null;
          if (second === first) second = null;
        }
        return { day, meals: [first, second] };
      });
    },
    []
  );

  const shuffleMealsNoRepeats = (meals: any[], totalSlots: number) => {
    if (meals.length === 0) return [];
    const base = [...meals];
    const rotation: any[] = [];
    const shuffle = (arr: any[]) => {
      for (let i = arr.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    };
    let pool = shuffle([...base]);
    while (rotation.length < totalSlots) {
      if (pool.length === 0) {
        pool = shuffle([...base]);
      }
      const next = pool.pop();
      if (rotation.length % 2 === 1 && rotation[rotation.length - 1]?.id === next?.id) {
        pool.unshift(next);
        continue;
      }
      rotation.push(next);
    }
    return rotation;
  };

  useEffect(() => {
    setIsClient(true);
  }, []);

  // Load pets function - reusable
  const loadPets = useCallback(async () => {
    const loadedPets = await getPets(userId);
    // Normalize names: convert name field to names array if needed
    const normalizedPets = loadedPets.map((p: Pet) => ({
      ...p,
      names: p.names && Array.isArray(p.names) && p.names.length > 0
        ? p.names.filter((n: string) => n && n.trim() !== '')
        : (p.name && typeof p.name === 'string' && p.name.trim() !== ''
            ? [p.name.trim()]
            : ['Unnamed Pet']),
    }));
    setPets(normalizedPets);
  }, [userId]);

  // Load custom meals when active pet changes - deferred until pet is actually selected
  const loadCustomMeals = useCallback(async () => {
    if (activePetId && userId) {
      const meals = await getCustomMeals(userId, activePetId);
      // Use startTransition for non-critical state updates to avoid blocking UI
      startTransition(() => {
        setCustomMeals(meals);
      });
      // Note: loadPets() is called by the petsUpdated event handler, so we don't need to call it here
      // This avoids race conditions and redundant calls
    } else {
      startTransition(() => {
        setCustomMeals([]);
      });
    }
  }, [activePetId, userId]);

  // Load saved active pet ID from localStorage on mount (before pets load)
  useEffect(() => {
    if (typeof window !== 'undefined') {
      localStorage.setItem('last_user_id', userId);
      
      // Load saved active pet ID - this will be validated once pets are loaded
      const savedActivePetId = localStorage.getItem(`active_pet_id_${userId}`);
      if (savedActivePetId) {
        setActivePetId(savedActivePetId);
      }
    }
  }, [userId]);

  // Load pets and expose user id for other pages (recipe detail, etc.)
  useEffect(() => {
    if (typeof window !== 'undefined') {
      localStorage.setItem('last_user_id', userId);
    }
    
    // Initial load - only critical data (pets list)
    loadPets();

    // Initialize village store with userId
    setUserId(userId);
  }, [userId, setUserId, loadPets]);

  // Refresh pets when page becomes visible (user returns to tab)
  useEffect(() => {
    if (typeof window === 'undefined') return;

    const handleVisibilityChange = () => {
      if (!document.hidden) {
        // Page became visible, refresh pets
        loadPets();
      }
    };

    const handleFocus = () => {
      // Window regained focus, refresh pets
      loadPets();
    };

    const handleStorageChange = (e: StorageEvent) => {
      // Refresh if pets storage was modified (cross-tab/window)
      if (e.key === `pets_${userId}`) {
        loadPets();
      }
    };

    const handlePetsUpdated = (e: CustomEvent) => {
      // Refresh if pets were updated (same-tab)
      if (e.detail?.userId === userId) {
        loadPets();
        // If the updated pet is the active pet, also refresh custom meals
        // Use the current activePetId from closure, don't include loadCustomMeals in deps
        if (e.detail?.petId === activePetId && activePetId) {
          // Call getCustomMeals directly - use startTransition for non-critical updates
          getCustomMeals(userId, activePetId).then(meals => {
            startTransition(() => {
              setCustomMeals(meals);
            });
          });
        }
      }
    };

    document.addEventListener('visibilitychange', handleVisibilityChange);
    window.addEventListener('focus', handleFocus);
    window.addEventListener('storage', handleStorageChange);
    window.addEventListener('petsUpdated', handlePetsUpdated as EventListener);

    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange);
      window.removeEventListener('focus', handleFocus);
      window.removeEventListener('storage', handleStorageChange);
      window.removeEventListener('petsUpdated', handlePetsUpdated as EventListener);
    };
  }, [userId, loadPets, activePetId]);

  useEffect(() => {
    if (pets.length === 0) {
      setActivePetId(null);
      setActiveTab('bio');
      if (typeof window !== 'undefined') {
        localStorage.removeItem(`active_pet_id_${userId}`);
      }
      return;
    }
    
    // Check if current activePetId still exists in pets list
    const stillExists = pets.some((p) => p.id === activePetId);
    if (activePetId && !stillExists) {
      // Current selection no longer exists, clear it
      setActivePetId(null);
      setActiveTab('bio');
      if (typeof window !== 'undefined') {
        localStorage.removeItem(`active_pet_id_${userId}`);
      }
    }
    
    // If no pet is selected and we have pets, check localStorage first
    if (!activePetId && pets.length > 0) {
      if (typeof window !== 'undefined') {
        const savedActivePetId = localStorage.getItem(`active_pet_id_${userId}`);
        const savedPetExists = savedActivePetId && pets.some((p) => p.id === savedActivePetId);
        if (savedPetExists) {
          // Restore saved selection
          setActivePetId(savedActivePetId);
        } else {
          // Only auto-select first pet if no valid saved selection exists
          // Don't save this auto-selection to localStorage (only user selections are saved)
          setActivePetId(pets[0].id);
        }
      } else {
        setActivePetId(pets[0].id);
      }
    }
  }, [pets, activePetId, userId]);

  // Defer custom meals loading - only load when a pet is actually selected and viewed
  // Don't load on initial mount if no pet is active (saves initial load time)
  useEffect(() => {
    // Only load if we have an active pet ID (pet is selected)
    if (activePetId) {
      loadCustomMeals();
    } else {
      // Clear custom meals if no pet is selected
      setCustomMeals([]);
    }
  }, [activePetId, loadCustomMeals]);

  // Listen for custom meal updates
  useEffect(() => {
    if (typeof window === 'undefined') return;

    const handleCustomMealsUpdated = (e: CustomEvent) => {
      // Refresh if custom meals were updated for the active pet
      if (e.detail?.userId === userId && e.detail?.petId === activePetId && activePetId) {
        // Call getCustomMeals directly to avoid dependency on loadCustomMeals callback
        // Use startTransition for non-critical updates
        getCustomMeals(userId, activePetId).then(meals => {
          startTransition(() => {
            setCustomMeals(meals);
          });
        });
      }
    };

    const handleStorageChange = (e: StorageEvent) => {
      // Refresh if custom meals storage was modified (cross-tab/window)
      if (activePetId && e.key === `custom_meals_${userId}_${activePetId}`) {
        // Call getCustomMeals directly to avoid dependency on loadCustomMeals callback
        // Use startTransition for non-critical updates
        getCustomMeals(userId, activePetId).then(meals => {
          startTransition(() => {
            setCustomMeals(meals);
          });
        });
      }
    };

    window.addEventListener('customMealsUpdated', handleCustomMealsUpdated as EventListener);
    window.addEventListener('storage', handleStorageChange);

    return () => {
      window.removeEventListener('customMealsUpdated', handleCustomMealsUpdated as EventListener);
      window.removeEventListener('storage', handleStorageChange);
    };
  }, [userId, activePetId]);

  // Build weekly plan for Plan tab (merge saved recipes + custom meals)
  const allMealsForPlan = useMemo(() => {
    if (!activePet) return [];
    const saved = Array.isArray(activePet.savedRecipes)
      ? activePet.savedRecipes.filter(Boolean) as any[]
      : [];
    const customs = customMeals.map(convertCustomMealToRecipe);
    return [...saved, ...customs];
  }, [activePet, customMeals]);

  useEffect(() => {
    if (allMealsForPlan.length === 0) {
      setPlanWeekly([]);
      return;
    }
    const rotation = buildEvenPlan(allMealsForPlan);
    const nextPlan: { day: string; meals: any[] }[] = [];
    for (let i = 0; i < DAYS.length; i += 1) {
      const breakfastIndex = i * 2;
      const dinnerIndex = breakfastIndex + 1;
      const breakfast = rotation[breakfastIndex];
      let dinner = rotation[dinnerIndex];
      if (dinner.id === breakfast.id) {
        const swapIndex = rotation.findIndex(
          (entry, idx) => idx > dinnerIndex && entry.id !== breakfast.id
        );
        if (swapIndex !== -1) {
          [rotation[dinnerIndex], rotation[swapIndex]] = [
            rotation[swapIndex],
            rotation[dinnerIndex],
          ];
          dinner = rotation[dinnerIndex];
        } else {
          dinner = allMealsForPlan.find((meal) => meal.id !== breakfast.id) || dinner;
        }
      }
      nextPlan.push({ day: DAYS[i], meals: [breakfast, dinner] });
    }
    setPlanWeekly(nextPlan);
  }, [allMealsForPlan]);

  const handleRandomizePlan = () => {
    if (allMealsForPlan.length === 0) return;
    const totalSlots = DAYS.length * 2;
    const rotation = shuffleMealsNoRepeats(allMealsForPlan, totalSlots);
    const nextPlan: { day: string; meals: any[] }[] = [];
    for (let i = 0; i < DAYS.length; i += 1) {
      const breakfastIndex = i * 2;
      const dinnerIndex = breakfastIndex + 1;
      nextPlan.push({ day: DAYS[i], meals: [rotation[breakfastIndex], rotation[dinnerIndex]] });
    }
    setPlanWeekly(nextPlan);
  };

  const handleAddPet = useCallback(
    (newPet: any) => {
      // Ensure names array is properly formatted and has at least one name
      // First, try to get names from names array
      let cleanedNames = Array.isArray(newPet.names)
        ? newPet.names.filter((n: string) => n && n.trim() !== '')
        : [];
      
      // If no names array, check for singular name field (from CreatePetModal)
      if (cleanedNames.length === 0 && newPet.name && typeof newPet.name === 'string' && newPet.name.trim() !== '') {
        cleanedNames = [newPet.name.trim()];
      }
      
      // If still no names after cleaning, set a default
      if (cleanedNames.length === 0) {
        cleanedNames.push('Unnamed Pet');
      }
      
      const petWithSavedRecipes = { 
        ...newPet,
        names: cleanedNames, // Use cleaned names
        // Remove singular name field if it exists (we're using names array now)
        name: undefined,
        savedRecipes: newPet.savedRecipes || [] 
      };
      
      // Saving pet with saved recipes
      
      setPets((prevPets) => {
        const isEditing = prevPets.some((p) => p.id === petWithSavedRecipes.id);
        let updatedPets: Pet[];

        if (isEditing) {
          updatedPets = prevPets.map((p) =>
            p.id === petWithSavedRecipes.id ? petWithSavedRecipes : p
          );
        } else {
          updatedPets = [...prevPets, petWithSavedRecipes];
        }

        // Save each pet async
        updatedPets.forEach(pet => {
          savePet(userId, pet).catch(err => console.error('Failed to save pet:', err));
        });
        
        return updatedPets;
      });
    },
    [userId]
  );

  const handleEditPet = useCallback((pet: Pet) => {
    setEditingPet(pet);
    setIsModalOpen(true);
  }, []);

  // Memoize modal handlers to prevent re-renders
  const handleCloseModal = useCallback(() => {
    setIsModalOpen(false);
  }, []);

  const handleSubmitPet = useCallback((pet: Pet) => {
    handleAddPet(pet);
    setEditingPet(null);
  }, [handleAddPet]);

  const handleDeletePet = useCallback((petId: string) => {
    const pet = pets.find(p => p.id === petId);
    const petName = pet ? getPrimaryName(pet.names || []) : 'this pet';
    
    setConfirmModal({
      isOpen: true,
      title: 'Delete Pet',
      message: `Are you sure you want to delete ${petName}? This action cannot be undone.`,
      onConfirm: async () => {
        await deletePet(userId, petId);
        
        setPets(prevPets => {
          const updatedPets = prevPets.filter(p => p.id !== petId);
          if (activePetId === petId) {
            setActivePetId(null);
            setActiveTab('bio');
          }
          return updatedPets;
        });
      },
    });
  }, [userId, activePetId, pets]);

  const handleRemoveSavedMeal = useCallback(async (recipeId: string) => {
    if (!activePetId) return;
    
    // If it's a custom meal, also delete it from custom meals storage
    if (recipeId.startsWith('custom_')) {
      const { deleteCustomMeal } = await import('@/lib/utils/customMealStorage');
      await deleteCustomMeal(userId, activePetId, recipeId);
      // Update local custom meals state
      setCustomMeals(prev => prev.filter(m => m.id !== recipeId));
    }
    
    const petToUpdate = pets.find(p => p.id === activePetId);
    if (petToUpdate) {
      const updatedPet = {
        ...petToUpdate,
        savedRecipes: (petToUpdate.savedRecipes || []).filter(id => id !== recipeId)
      };
      
      await savePet(userId, updatedPet);
      
      setPets(prevPets => prevPets.map(p => 
        p.id === activePetId ? updatedPet : p
      ));
      
      // Check badges after recipe is removed
      if (activePet) {
        const uniqueMealIds = new Set<string>();
        planWeekly.forEach(day => {
          day.meals.forEach(meal => {
            if (meal && meal.id) uniqueMealIds.add(meal.id);
          });
        });
        const mealPlanCount = uniqueMealIds.size;
        const savedRecipesCount = updatedPet.savedRecipes?.length || 0;
        const weeklyPlanCompleted = false;
        
        checkAllBadges(userId, activePet.id, {
          action: 'recipe_removed',
          mealPlanCount,
          savedRecipesCount,
          weeklyPlanCompleted,
        }).catch(err => {
          console.error('Failed to check badges:', err);
        });
      }
    }
  }, [userId, activePetId, pets, planWeekly, activePet]);

  // Component to buy all ingredients from meal plan
  const BuyAllMealPlanIngredientsButton = ({ weeklyPlan, petId }: { weeklyPlan: { day: string; meals: (string | null)[] }[]; petId: string }) => {
    const [isOpening, setIsOpening] = useState(false);
    const [openedCount, setOpenedCount] = useState(0);

    const handleBuyAll = async () => {
      alert('Meal plans are now generated dynamically. Please navigate to individual meals to purchase ingredients.');
    };

    const totalIngredients = 0;

    if (totalIngredients === 0) {
      return null;
    }

    return (
      <button
        onClick={handleBuyAll}
        disabled={isOpening}
        className={`w-full py-3 px-6 rounded-lg font-bold text-base transition-all ${
          isOpening
            ? 'bg-gray-600 cursor-wait text-gray-300'
            : 'bg-gradient-to-r from-[#FF9900] to-[#F08804] hover:from-[#F08804] hover:to-[#E07704] text-black shadow-lg hover:shadow-xl'
        } flex items-center justify-center gap-2`}
      >
        {isOpening ? (
          <>
            <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-white"></div>
            Opening...
          </>
        ) : (
          <>
            <ShoppingCart size={20} />
            Buy All
          </>
        )}
      </button>
    );
  };

  if (!isClient) {
    return (
      <div className="min-h-screen bg-background text-foreground flex items-center justify-center">
        <div className="text-center py-12">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-green-800 mx-auto"></div>
          <p className="text-gray-400 mt-4">Loading your pets...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-background text-foreground py-6">
      <div className="max-w-6xl mx-auto px-4 space-y-6">
        <header className="flex flex-wrap items-center justify-between gap-3">
          <div>
            <h1 className="text-3xl font-extrabold">My Pets</h1>
            {pets.length > 0 && (
              <p className="text-sm text-gray-400 mt-1">
                Choose a pet to view details, saved meals, and meal plans.
              </p>
            )}
          </div>
          <div className="flex gap-2">
            <button
              onClick={() => {
                setEditingPet(null);
                setIsModalOpen(true);
              }}
              className="btn btn-success btn-sm btn-ripple"
            >
              <Plus size={16} className="mr-1" />
              Add Pet
            </button>
          </div>
        </header>

        {pets.length === 0 ? (
          <div className="text-center py-14 px-6 bg-surface rounded-2xl border border-surface-highlight shadow-lg">
            <div className="text-4xl mb-3">üêæ</div>
            <h2 className="text-2xl font-bold mb-2">No Pets Yet</h2>
            <p className="text-gray-400 mb-6">
              Add your first pet to start building personalized meals and plans.
            </p>
            <button
              onClick={() => {
                setEditingPet(null);
                setIsModalOpen(true);
              }}
              className="btn btn-success btn-md btn-ripple"
            >
              <Plus size={18} className="mr-2" />
              Add Your First Pet
            </button>
          </div>
        ) : (
          <div className="grid grid-cols-1 lg:grid-cols-[260px_1fr] gap-4 lg:gap-6 items-start">
            <div className="bg-surface border border-surface-highlight rounded-2xl shadow-lg p-4 space-y-3">
                <div className="flex items-center justify-between">
                  <h3 className="text-lg font-semibold">Pets</h3>
                  <span className="text-xs text-gray-400">{pets.length} total</span>
                </div>
                <div className="space-y-2">
                  {pets.map((pet) => {
                    if (!pet?.id) return null;
                    const name = getPrimaryName(pet.names || []) || 'Unnamed Pet';
                  return (
                    <button
                      key={pet.id}
                      onClick={() => {
                        setActivePetId(pet.id);
                        setActiveTab('bio');
                        // Persist selection to localStorage
                        if (typeof window !== 'undefined') {
                          localStorage.setItem(`active_pet_id_${userId}`, pet.id);
                        }
                      }}
                      className={`w-full flex items-center gap-3 rounded-xl px-3 py-2 text-left transition-all duration-200 ease-out ${
                        activePetId === pet.id
                          ? 'bg-green-900/20 text-white'
                          : 'bg-surface-highlight/60 text-foreground hover:bg-surface-highlight hover:-translate-y-1 hover:scale-[1.02] hover:shadow-lg'
                      }`}
                      style={{
                        border: activePetId === pet.id ? '3px solid #f97316' : '3px solid rgba(249, 115, 22, 0.5)'
                      }}
                    >
                      <div className="w-10 h-10 rounded-full overflow-hidden border border-white/10 bg-surface flex items-center justify-center flex-shrink-0">
                        <Image
                          src={getMascotFaceForPetType(pet.type as PetCategory)}
                          alt={`${name} mascot`}
                          width={40}
                          height={40}
                          className="object-cover"
                          unoptimized
                        />
                      </div>
                      <div className="min-w-0 flex-1">
                        <div className="text-sm font-semibold truncate">{name}</div>
                        <div className="text-xs text-gray-400 capitalize truncate">
                          {pet.type}
                          {pet.age ? ` ‚Ä¢ ${pet.age}` : ''}
                        </div>
                      </div>
                    </button>
                  );
                  })}
                </div>
            </div>

            {activePet ? (
              <div className="bg-surface border border-surface-highlight rounded-2xl shadow-xl p-5">
                      <div className="flex items-start justify-between gap-3 flex-wrap">
                        <div className="flex-1 min-w-0">
                          <div className="relative float-left mr-4 mb-2" style={{ shapeOutside: 'circle(50%)', width: '168px', height: '168px' }}>
                            <svg className="absolute -top-8 left-0 pointer-events-none" width="168" height="40" style={{ overflow: 'visible' }}>
                              <defs>
                                <path id={`textPath-${activePet.id}`} d="M 10,35 Q 84,15 158,35" fill="none" />
                              </defs>
                              <text className="text-xs" fill="#9ca3af" fontSize="12">
                                <textPath href={`#textPath-${activePet.id}`} startOffset="50%">
                                  <tspan textAnchor="middle">Click to upload photo</tspan>
                                </textPath>
                              </text>
                            </svg>
                            <label className="w-42 h-42 rounded-full overflow-hidden border border-white/10 bg-surface-highlight flex items-center justify-center cursor-pointer hover:opacity-80 transition-opacity group" style={{ width: '168px', height: '168px' }}>
                              <input
                                type="file"
                                accept="image/*"
                                className="hidden"
                                onChange={(e) => {
                                  const file = e.target.files?.[0];
                                  if (file) {
                                    const reader = new FileReader();
                                    reader.onloadend = () => {
                                      const imageDataUrl = reader.result as string;
                                      const updatedPet = { ...activePet, image: imageDataUrl };
                                      savePet(userId, updatedPet);
                                      setPets(prevPets => prevPets.map(p => p.id === activePet.id ? updatedPet : p));
                                    };
                                    reader.readAsDataURL(file);
                                  }
                                }}
                              />
                              {activePet.image ? (
                                <img
                                  src={activePet.image}
                                  alt={getPrimaryName(activePet.names || []) || 'Pet'}
                                  className="w-full h-full object-cover"
                                />
                              ) : (
                                <Image
                                  src={getProfilePictureForPetType(activePet.type as PetCategory)}
                                  alt={`${getPrimaryName(activePet.names || []) || 'Pet'} mascot`}
                                  width={168}
                                  height={168}
                                  className="object-cover"
                                  unoptimized
                                  style={activePet.type === 'cats' || activePet.type === 'cat' ? { transform: 'scale(1.5)', transformOrigin: 'center', objectPosition: 'center' } : undefined}
                                />
                              )}
                            </label>
                          </div>
                        </div>
                        <div className="flex flex-col gap-3">
                          {/* Pet name and Edit/Delete buttons row */}
                          <div className="flex items-center justify-between gap-3 w-[600px]">
                            <h2 className="text-3xl font-bold">
                              {getPrimaryName(activePet.names || []) || 'Unnamed Pet'}
                            </h2>
                            {activeTab === 'bio' && (
                              <div className="flex flex-wrap gap-2">
                                <button
                                  onClick={() => handleEditPet(activePet)}
                                  className="btn btn-success btn-sm"
                                >
                                  Edit
                                </button>
                                <button
                                  onClick={() => handleDeletePet(activePet.id)}
                                  className="btn btn-darkgreen btn-sm"
                                >
                                  Delete
                                </button>
                              </div>
                            )}
                          </div>
                          {/* Badges Section - moved to far right, maintaining current height */}
                          <div className="p-4 border border-surface-highlight rounded-lg bg-surface-highlight/30 min-h-[140px] w-[600px]">
                            <div className="flex items-center justify-between mb-3">
                              <Tooltip 
                                content={`Available Badges:\n\n1. Perfect Match\n   Awarded when you hit a 100% compatibility score.\n\n2. Feast Architect\n   Unlocked by building a layered or multi‚Äëstep meal plan.\n\n3. Week Whisker (Progressive)\n   Bronze: Complete 1 weekly plan\n   Silver: Complete 10 weekly plans\n   Gold: Complete 50 weekly plans\n\n4. Purchase Champion (Progressive)\n   Bronze: 1 purchase\n   Silver: 10 purchases\n   Gold: 20 purchases\n   Platinum: 30 purchases\n   Diamond: 40 purchases\n   Sultan: 50+ purchases`}
                                wide={true}
                              >
                                <div className="text-sm font-semibold text-gray-400 cursor-help hover:text-gray-300 transition-colors">Badges</div>
                              </Tooltip>
                            </div>
                            <PetBadges key={badgeRefreshKey} petId={activePet.id} userId={userId} />
                            <BadgeToggle 
                              petId={activePet.id} 
                              userId={userId} 
                              onBadgeChange={() => setBadgeRefreshKey((prev: number) => prev + 1)}
                            />
                          </div>
                        </div>
                      </div>

                    <div className="mt-4">
                      <div className="flex gap-0 border-b-2 border-surface-highlight">
                        {['bio', 'saved', 'plan'].map((tab) => {
                          const label = tab === 'bio' ? 'Bio' : tab === 'saved' ? 'Saved Meals' : 'Meal Plan';
                          const isActive = activeTab === tab;
                          return (
                            <button
                              key={tab}
                              onClick={() => {
                                setActiveTab(tab as any);
                                // Refresh pets when switching to saved tab to ensure latest data
                                if (tab === 'saved') {
                                  loadPets();
                                }
                              }}
                              className={`relative px-6 py-3 text-sm font-semibold transition-all duration-200 ${
                                isActive
                                  ? 'text-orange-400 border-b-3 border-orange-400 bg-transparent'
                                  : 'text-gray-400 hover:text-gray-300 bg-transparent border-b-3 border-transparent'
                              }`}
                              style={isActive ? { borderBottomWidth: '3px' } : { borderBottomWidth: '3px' }}
                              aria-selected={isActive}
                              role="tab"
                            >
                              {label}
                            </button>
                          );
                        })}
                      </div>

                      <div className="mt-3">
                        {activeTab === 'bio' && (
                          <div className="flex gap-6">
                            {/* Bio Column */}
                            <div className="flex-1 min-w-0">
                              <div className="grid grid-cols-1 gap-y-1 text-sm text-gray-300">
                                {activePet.breed && (
                                  <div className="flex items-start gap-1.5">
                                    <span className="text-orange-400 mt-0.5">‚Ä¢</span>
                                    <span><strong className="text-gray-200">Breed:</strong> {activePet.breed}</span>
                                  </div>
                                )}
                                {activePet.age && (
                                  <div className="flex items-start gap-1.5">
                                    <span className="text-orange-400 mt-0.5">‚Ä¢</span>
                                    <span><strong className="text-gray-200">Age:</strong> {activePet.age}</span>
                                  </div>
                                )}
                                {(activePet.weight || activePet.weightKg) && (
                                  <div className="flex items-start gap-1.5">
                                    <span className="text-orange-400 mt-0.5">‚Ä¢</span>
                                    <span><strong className="text-gray-200">Weight:</strong> {activePet.weightKg ? `${activePet.weightKg}kg` : activePet.weight}</span>
                                  </div>
                                )}
                                {(activePet.dietaryRestrictions || []).length > 0 && (
                                  <div className="flex items-start gap-1.5">
                                    <span className="text-orange-400 mt-0.5">‚Ä¢</span>
                                    <span><strong className="text-gray-200">Dietary Restrictions:</strong> {(activePet.dietaryRestrictions || []).join(', ')}</span>
                                  </div>
                                )}
                                {(activePet.dislikes || []).length > 0 && (
                                  <div className="flex items-start gap-1.5">
                                    <span className="text-orange-400 mt-0.5">‚Ä¢</span>
                                    <span><strong className="text-gray-200">Dislikes:</strong> {(activePet.dislikes || []).join(', ')}</span>
                                  </div>
                                )}
                              </div>
                            </div>

                            {/* Health Concerns Column - Always rendered for consistent layout */}
                            <div className="flex-shrink-0 min-w-[180px]">
                              <h3 className="text-sm font-semibold text-gray-300 mb-2">Health Concerns</h3>
                              <div className="flex flex-col gap-1.5">
                                {(activePet.healthConcerns || []).length > 0 ? (
                                  (activePet.healthConcerns || []).map((concern) => (
                                    <div
                                      key={concern}
                                      className="px-2 py-1 bg-orange-900/40 text-orange-200 border border-orange-700/50 text-xs rounded"
                                    >
                                      {concern.replace(/-/g, ' ')}
                                    </div>
                                  ))
                                ) : (
                                  <div className="px-2 py-1 text-gray-500 text-xs italic">
                                    None
                                  </div>
                                )}
                              </div>
                            </div>

                            {/* Allergies Column - Always rendered for consistent layout */}
                            <div className="flex-shrink-0 min-w-[180px]">
                              <h3 className="text-sm font-semibold text-gray-300 mb-2">Allergies</h3>
                              <div className="flex flex-col gap-1.5">
                                {(activePet.allergies || []).length > 0 ? (
                                  (activePet.allergies || []).map((allergy) => (
                                    <div
                                      key={allergy}
                                      className="px-2 py-1 bg-orange-900/40 text-orange-200 border border-orange-700/50 text-xs rounded"
                                    >
                                      {allergy.replace(/-/g, ' ')}
                                    </div>
                                  ))
                                ) : (
                                  <div className="px-2 py-1 text-gray-500 text-xs italic">
                                    None
                                  </div>
                                )}
                              </div>
                            </div>
                          </div>
                        )}

                        {activeTab === 'bio' && (
                          <div className="mt-3 flex flex-wrap gap-2">
                            <a href={`/profile/pet/${activePet.id}`} className="btn btn-success btn-sm">Find Meals</a>
                            <a href={`/profile/pet/${activePet.id}/recipe-builder`} className="btn btn-success btn-sm">Create Meal</a>
                          </div>
                        )}

                        {activeTab === 'saved' && (
                          <div className="space-y-2">
                            {(() => {
                              const savedIds = Array.isArray(activePet.savedRecipes) ? activePet.savedRecipes : [];
                              const customIds = customMeals.map((m) => m.id);
                              const combinedIds = Array.from(new Set([...savedIds, ...customIds]));

                              if (combinedIds.length === 0) {
                                return (
                                  <div className="text-gray-400 text-sm">
                                    No saved meals yet. Use "Find Meals" to add some.
                                  </div>
                                );
                              }

                              return (
                                <div className="max-h-[480px] overflow-y-auto pr-2 space-y-2">
                                  {combinedIds.map((rid) => {
                                    const isCustomMeal = rid.startsWith('custom_');
                                    const customMeal = isCustomMeal ? customMeals.find((m) => m.id === rid) : null;
                                    const mealName = isCustomMeal ? customMeal?.name || 'Custom Meal' : getRecipeName(rid);
                                    const mealData = isCustomMeal ? customMeal : null;

                                    // Calculate compatibility score
                                    let compatibilityScore: number | null = null;
                                    if (activePet && mealData) {
                                      try {
                                        const enhancedPet: EnhancedPet = {
                                          id: activePet.id,
                                          name: getPrimaryName(activePet.names || []) || 'Pet',
                                          type: activePet.type === 'dogs' ? 'dog' : activePet.type === 'cats' ? 'cat' : activePet.type === 'birds' ? 'bird' : activePet.type === 'reptiles' ? 'reptile' : 'pocket-pet',
                                          breed: activePet.breed || '',
                                          age: activePet.age === 'baby' ? 0.5 : activePet.age === 'young' ? 2 : activePet.age === 'adult' ? 5 : 10,
                                          weight: activePet.weightKg || 10,
                                          activityLevel: 'moderate',
                                          healthConcerns: activePet.healthConcerns || [],
                                          dietaryRestrictions: activePet.allergies || [],
                                          allergies: activePet.allergies || [],
                                        };
                                        const result = calculateEnhancedCompatibility(mealData as Recipe, enhancedPet);
                                        compatibilityScore = result.overallScore;
                                      } catch (error) {
                                        console.error('Error calculating compatibility:', error);
                                        compatibilityScore = null;
                                      }
                                    }

                                    return (
                                      <div key={rid} className="p-2 rounded border border-white/5 grid grid-cols-[1fr_auto_auto] items-center gap-4">
                                        <div className="min-w-0">
                                          <button
                                            onClick={() => {
                                              window.location.href = `/recipe/${rid}?petId=${activePet.id}`;
                                            }}
                                            className="text-primary-300 hover:text-primary-100 text-sm font-semibold break-words text-left px-3 py-2 rounded transition-colors bg-surface border border-orange-500/50 hover:border-orange-500 hover:bg-surface-highlight/50"
                                          >
                                            {mealName}
                                          </button>
                                        </div>
                                        <div className="flex items-center justify-center min-w-[60px]">
                                          {compatibilityScore !== null && (
                                            <div className={`text-sm font-bold rounded-full w-10 h-10 flex items-center justify-center border-2 ${
                                              compatibilityScore >= 80 
                                                ? 'text-green-400 border-green-400' 
                                                : compatibilityScore >= 60 
                                                ? 'text-yellow-400 border-yellow-400' 
                                                : 'text-red-400 border-red-400'
                                            }`}>
                                              {compatibilityScore}%
                                            </div>
                                          )}
                                        </div>
                                        <div className="flex items-center gap-2 flex-shrink-0">
                                          {mealData && (mealData as any).ingredients && (
                                            <button
                                              onClick={(e) => {
                                                e.preventDefault();
                                                const cartItems = ((mealData as any).ingredients || [])
                                                  .map((ing: any, idx: number) => {
                                                    const genericName = (ing.name || '').toLowerCase().trim();
                                                    const vettedProduct = VETTED_PRODUCTS[genericName];
                                                    const link = vettedProduct ? vettedProduct.purchaseLink : ing.asinLink;
                                                    if (link) {
                                                      const asinMatch = link.match(/\/dp\/([A-Z0-9]{10})/);
                                                      if (asinMatch) {
                                                        return `ASIN.${idx + 1}=${asinMatch[1]}&Quantity.${idx + 1}=1`;
                                                      }
                                                    }
                                                    return null;
                                                  })
                                                  .filter(Boolean);
                                                if (cartItems.length > 0) {
                                                  const cartUrl = ensureCartUrlSellerId(`https://www.amazon.com/gp/aws/cart/add.html?${cartItems.join('&')}`);
                                                  window.open(cartUrl, '_blank');
                                                } else {
                                                  alert('No ingredient links available for this recipe.');
                                                }
                                              }}
                                              className="inline-flex items-center gap-1 text-sm px-4 py-2 rounded font-semibold transition-all shadow-md hover:shadow-lg bg-gradient-to-r from-[#FF9900] to-[#F08804] hover:from-[#F08804] hover:to-[#E07704] text-black flex-shrink-0"
                                              title="Buy ingredients"
                                            >
                                              <ShoppingCart size={14} />
                                              Buy
                                            </button>
                                          )}
                                          <button
                                            onClick={(e) => {
                                              e.preventDefault();
                                              setConfirmModal({
                                                isOpen: true,
                                                title: 'Remove Meal',
                                                message: `Remove "${mealName}" from saved meals?`,
                                                onConfirm: () => {
                                                  handleRemoveSavedMeal(rid);
                                                },
                                              });
                                            }}
                                            className="btn btn-success btn-sm"
                                            title="Remove meal"
                                          >
                                            Remove
                                          </button>
                                        </div>
                                      </div>
                                    );
                                  })}
                                </div>
                              );
                            })()}
                            <div className="flex flex-wrap gap-2">
                              <a
                                href={`/profile/pet/${activePet.id}`}
                                className="btn btn-success btn-sm"
                              >
                                Find Meals
                              </a>
                              <a
                                href={`/profile/pet/${activePet.id}/recipe-builder`}
                                className="btn btn-success btn-sm"
                              >
                                Create Meal
                              </a>
                            </div>
                          </div>
                        )}

                        {activeTab === 'plan' && (
                          <div className="space-y-4 text-sm">
                            {planWeekly.length > 0 ? (
                              <>
                                {/* Weekly Nutritional Coverage Summary */}
                                {(() => {
                                  if (!activePet) return null;
                                  
                                  // Calculate weekly nutrition totals
                                  const calculateMealNutrition = (meal: any): { protein: number; fat: number; fiber: number; calcium: number; phosphorus: number; calories: number } => {
                                    // Use calculateRecipeNutrition directly to get actual nutrition values
                                    try {
                                      const nutrition = calculateRecipeNutrition(meal as Recipe);
                                      return {
                                        protein: nutrition.protein || 0,
                                        fat: nutrition.fat || 0,
                                        fiber: nutrition.fiber || 0,
                                        calcium: nutrition.calcium || 0,
                                        phosphorus: nutrition.phosphorus || 0,
                                        calories: nutrition.calories || 0,
                                      };
                                    } catch {
                                      return { protein: 0, fat: 0, fiber: 0, calcium: 0, phosphorus: 0, calories: 0 };
                                    }
                                  };
                                  
                                  const weeklyTotals = planWeekly.reduce((acc, day) => {
                                    day.meals.forEach(meal => {
                                      const nutrition = calculateMealNutrition(meal);
                                      acc.protein += nutrition.protein;
                                      acc.fat += nutrition.fat;
                                      acc.fiber += nutrition.fiber;
                                      acc.calcium += nutrition.calcium;
                                      acc.phosphorus += nutrition.phosphorus;
                                      acc.calories += nutrition.calories;
                                    });
                                    return acc;
                                  }, { protein: 0, fat: 0, fiber: 0, calcium: 0, phosphorus: 0, calories: 0 });
                                  
                                  // Average per day (divide by 7)
                                  const dailyAvg = {
                                    protein: weeklyTotals.protein / 7,
                                    fat: weeklyTotals.fat / 7,
                                    fiber: weeklyTotals.fiber / 7,
                                    calcium: weeklyTotals.calcium / 7,
                                    phosphorus: weeklyTotals.phosphorus / 7,
                                    calories: weeklyTotals.calories / 7,
                                  };
                                  
                                  // Get pet requirements
                                  const petType = activePet.type as keyof typeof nutritionalGuidelines;
                                  const ageGroup = activePet.age === 'baby' ? 'puppy' : activePet.age === 'senior' ? 'senior' : 'adult';
                                  const requirements = nutritionalGuidelines[petType]?.[ageGroup] || nutritionalGuidelines[petType]?.adult;
                                  
                                  if (!requirements) return null;
                                  
                                  // Calculate coverage scores (0-100)
                                  const calculateCoverage = (value: number, min: number, max: number): number => {
                                    if (value < min) return (value / min) * 50; // Below min: 0-50
                                    if (value > max) return 100 - Math.min((value - max) / max * 50, 50); // Above max: 50-100
                                    return 50 + ((value - min) / (max - min)) * 50; // In range: 50-100
                                  };
                                  
                                  const proteinScore = calculateCoverage(dailyAvg.protein, requirements.protein.min, requirements.protein.max);
                                  const fatScore = calculateCoverage(dailyAvg.fat, requirements.fat.min, requirements.fat.max);
                                  const fiberScore = requirements.fiber ? calculateCoverage(dailyAvg.fiber, requirements.fiber.min, requirements.fiber.max) : 100;
                                  const calciumScore = requirements.calcium ? calculateCoverage(dailyAvg.calcium, requirements.calcium.min, requirements.calcium.max) : 100;
                                  const phosphorusScore = requirements.phosphorus ? calculateCoverage(dailyAvg.phosphorus, requirements.phosphorus.min, requirements.phosphorus.max) : 100;
                                  
                                  const overallScore = Math.round((proteinScore + fatScore + fiberScore + calciumScore + phosphorusScore) / 5);
                                  
                                  return (
                                    <div className="mb-4 p-3 bg-surface-highlight rounded-lg border border-surface-highlight flex items-center gap-3">
                                      <h3 className="text-base font-semibold text-foreground">Compatibility score for the week:</h3>
                                      <div className={`text-xl font-bold ${overallScore >= 80 ? 'text-green-400' : overallScore >= 60 ? 'text-yellow-400' : 'text-red-400'}`}>
                                        {overallScore}%
                                      </div>
                                    </div>
                                  );
                                })()}
                                <div className="max-h-[480px] overflow-y-auto pr-2 space-y-3">
                                  {planWeekly.map((dayPlan, index) => {
                                    // Calculate day score for this day's meals
                                    const calculateDayScore = (meals: any[]): number => {
                                      if (!activePet || meals.length === 0) return 0;
                                      
                                      const calculateMealNutrition = (meal: any): { protein: number; fat: number; fiber: number; calcium: number; phosphorus: number } => {
                                        // Use calculateRecipeNutrition directly to get actual nutrition values
                                        try {
                                          const nutrition = calculateRecipeNutrition(meal as Recipe);
                                          return {
                                            protein: nutrition.protein || 0,
                                            fat: nutrition.fat || 0,
                                            fiber: nutrition.fiber || 0,
                                            calcium: nutrition.calcium || 0,
                                            phosphorus: nutrition.phosphorus || 0,
                                          };
                                        } catch {
                                          return { protein: 0, fat: 0, fiber: 0, calcium: 0, phosphorus: 0 };
                                        }
                                      };
                                      
                                      const dayTotals = meals.reduce((acc, meal) => {
                                        const nutrition = calculateMealNutrition(meal);
                                        acc.protein += nutrition.protein;
                                        acc.fat += nutrition.fat;
                                        acc.fiber += nutrition.fiber;
                                        acc.calcium += nutrition.calcium;
                                        acc.phosphorus += nutrition.phosphorus;
                                        return acc;
                                      }, { protein: 0, fat: 0, fiber: 0, calcium: 0, phosphorus: 0 });
                                      
                                      // Average per meal (divide by number of meals)
                                      const mealAvg = {
                                        protein: dayTotals.protein / meals.length,
                                        fat: dayTotals.fat / meals.length,
                                        fiber: dayTotals.fiber / meals.length,
                                        calcium: dayTotals.calcium / meals.length,
                                        phosphorus: dayTotals.phosphorus / meals.length,
                                      };
                                      
                                      const petType = activePet.type as keyof typeof nutritionalGuidelines;
                                      const ageGroup = activePet.age === 'baby' ? 'puppy' : activePet.age === 'senior' ? 'senior' : 'adult';
                                      const requirements = nutritionalGuidelines[petType]?.[ageGroup] || nutritionalGuidelines[petType]?.adult;
                                      
                                      if (!requirements) return 0;
                                      
                                      const calculateCoverage = (value: number, min: number, max: number): number => {
                                        if (value < min) return (value / min) * 50;
                                        if (value > max) return 100 - Math.min((value - max) / max * 50, 50);
                                        return 50 + ((value - min) / (max - min)) * 50;
                                      };
                                      
                                      const proteinScore = calculateCoverage(mealAvg.protein, requirements.protein.min, requirements.protein.max);
                                      const fatScore = calculateCoverage(mealAvg.fat, requirements.fat.min, requirements.fat.max);
                                      const fiberScore = requirements.fiber ? calculateCoverage(mealAvg.fiber, requirements.fiber.min, requirements.fiber.max) : 100;
                                      const calciumScore = requirements.calcium ? calculateCoverage(mealAvg.calcium, requirements.calcium.min, requirements.calcium.max) : 100;
                                      const phosphorusScore = requirements.phosphorus ? calculateCoverage(mealAvg.phosphorus, requirements.phosphorus.min, requirements.phosphorus.max) : 100;
                                      
                                      return Math.round((proteinScore + fatScore + fiberScore + calciumScore + phosphorusScore) / 5);
                                    };
                                    
                                    const dayScore = calculateDayScore(dayPlan.meals);
                                    
                                    return (
                                      <div key={dayPlan.day} className="rounded-lg border border-surface-highlight px-3 py-2">
                                        <div className="text-white font-semibold mb-2 flex items-center gap-2">
                                          {dayPlan.day}
                                          <div className={`text-xs font-bold rounded-full w-6 h-6 flex items-center justify-center border ${
                                            dayScore >= 80 
                                              ? 'text-green-400 border-green-400' 
                                              : dayScore >= 60 
                                              ? 'text-yellow-400 border-yellow-400' 
                                              : 'text-red-400 border-red-400'
                                          }`}>
                                            {dayScore}%
                                          </div>
                                        </div>
                                        <div className="space-y-2">
                                          {dayPlan.meals.map((meal, mealIndex) => (
                                            <div key={meal.id + mealIndex} className="p-2 rounded border border-white/5 grid grid-cols-[1fr_auto] items-center gap-4">
                                              <button
                                                onClick={() => {
                                                  window.location.href = `/recipe/${meal.id}?petId=${activePet.id}`;
                                                }}
                                                className="text-primary-300 hover:text-primary-100 text-sm font-semibold break-words text-left px-3 py-2 rounded transition-colors bg-surface border border-orange-500/50 hover:border-orange-500 hover:bg-surface-highlight/50"
                                              >
                                                {meal.name}
                                              </button>
                                              <div className="flex items-center gap-2 flex-shrink-0">
                                            <button
                                              onClick={(e) => {
                                                e.preventDefault();
                                                const cartItems = (meal.ingredients || [])
                                                  .map((ing: any, idx: number) => {
                                                    const genericName = (ing.name || '').toLowerCase().trim();
                                                    const vettedProduct = VETTED_PRODUCTS[genericName];
                                                    const link = vettedProduct ? vettedProduct.purchaseLink : ing.asinLink;
                                                    if (link) {
                                                      const asinMatch = link.match(/\/dp\/([A-Z0-9]{10})/);
                                                      if (asinMatch) {
                                                        return `ASIN.${idx + 1}=${asinMatch[1]}&Quantity.${idx + 1}=1`;
                                                      }
                                                    }
                                                    return null;
                                                  })
                                                  .filter(Boolean);
                                                if (cartItems.length > 0) {
                                                  const cartUrl = ensureCartUrlSellerId(`https://www.amazon.com/gp/aws/cart/add.html?${cartItems.join('&')}`);
                                                  window.open(cartUrl, '_blank');
                                                } else {
                                                  alert('No ingredient links available for this recipe.');
                                                }
                                              }}
                                              className="inline-flex items-center gap-1 text-sm px-4 py-2 rounded font-semibold transition-all shadow-md hover:shadow-lg bg-gradient-to-r from-[#FF9900] to-[#F08804] hover:from-[#F08804] hover:to-[#E07704] text-black flex-shrink-0"
                                              title="Buy ingredients"
                                            >
                                              <ShoppingCart size={14} />
                                              Buy
                                            </button>
                                            <button
                                              onClick={(e) => {
                                                e.preventDefault();
                                                setSwapTarget({ dayIdx: index, mealIdx: mealIndex });
                                              }}
                                              className="btn btn-success btn-sm"
                                              title="Edit this slot"
                                            >
                                              Edit
                                            </button>
                                            </div>
                                          </div>
                                        ))}
                                        </div>
                                      </div>
                                    );
                                  })}
                                </div>
                                {swapTarget && (
                                  <div className="fixed inset-0 z-50 bg-black/60 flex items-center justify-center px-4">
                                    <div className="bg-surface rounded-xl border border-surface-highlight shadow-2xl max-w-lg w-full p-5">
                                      <div className="flex items-center justify-between mb-3">
                                        <h3 className="text-lg font-bold text-foreground">Edit Meal Slot</h3>
                                        <button
                                          onClick={() => setSwapTarget(null)}
                                          className="text-gray-400 hover:text-white"
                                          aria-label="Close swap dialog"
                                        >
                                          ‚úï
                                        </button>
                                      </div>
                                      <p className="text-sm text-gray-300 mb-3">Choose a saved or custom meal to place into this slot.</p>
                                      <div className="max-h-72 overflow-y-auto space-y-2">
                                        {allMealsForPlan.map((meal) => (
                                          <button
                                            key={meal.id}
                                            onClick={() => {
                                              if (!swapTarget) return;
                                              setPlanWeekly(prev => {
                                                const copy = prev.map(d => ({ ...d, meals: [...d.meals] }));
                                                copy[swapTarget.dayIdx].meals[swapTarget.mealIdx] = meal;
                                                return copy;
                                              });
                                              setSwapTarget(null);
                                            }}
                                            className="w-full text-left p-3 rounded-lg border border-surface-highlight hover:border-primary-500 hover:bg-surface-highlight transition-colors"
                                          >
                                            <div className="flex justify-between items-center">
                                              <span className="font-semibold text-foreground truncate">{meal.name}</span>
                                              {meal.category === 'custom' && (
                                                <span className="text-xxs text-green-300 bg-green-900/40 px-2 py-0.5 rounded-full">Custom</span>
                                              )}
                                            </div>
                                          </button>
                                        ))}
                                        {allMealsForPlan.length === 0 && (
                                          <p className="text-sm text-gray-400">No meals available to swap.</p>
                                        )}
                                      </div>
                                      <div className="mt-4 flex justify-end">
                                        <button
                                          onClick={() => setSwapTarget(null)}
                                          className="px-4 py-2 text-sm text-gray-200 border border-surface-highlight rounded-lg hover:bg-surface-highlight"
                                        >
                                          Cancel
                                        </button>
                                      </div>
                                    </div>
                                  </div>
                                )}
                              </>
                            ) : (
                              <div className="text-gray-400">Add at least one saved or custom meal to generate a weekly plan.</div>
                            )}
                            {planWeekly.length > 0 && (
                              <div className="pt-2 flex gap-2 items-center">
                                <BuyAllMealPlanIngredientsButton weeklyPlan={planWeekly as any} petId={activePet?.id || ''} />
                                <button
                                  onClick={async () => {
                                    if (!activePet) return;
                                    
                                    // Mark plan as completed
                                    const updatedPet = {
                                      ...activePet,
                                      completedMealPlans: (activePet.completedMealPlans || 0) + 1,
                                    };
                                    await savePet(userId, updatedPet);
                                    setPets(prevPets => prevPets.map(p => p.id === activePet.id ? updatedPet : p));
                                    
                                    // Check badges
                                    const uniqueMealIds = new Set<string>();
                                    planWeekly.forEach(day => {
                                      day.meals.forEach(meal => {
                                        if (meal && meal.id) uniqueMealIds.add(meal.id);
                                      });
                                    });
                                    
                                    await checkAllBadges(userId, activePet.id, {
                                      action: 'meal_plan_completed',
                                      mealPlanCount: uniqueMealIds.size,
                                      savedRecipesCount: activePet.savedRecipes?.length || 0,
                                      weeklyPlanCompleted: true,
                                      completionCount: updatedPet.completedMealPlans || 1,
                                    });
                                  }}
                                  className="btn btn-success btn-sm"
                                  title="Mark this weekly plan as completed (saved and locked)"
                                >
                                  ‚úì Lock Plan
                                </button>
                              </div>
                            )}
                            {planWeekly.length > 0 && (
                              <div className="flex flex-wrap gap-2 mt-4">
                                <button
                                  onClick={handleRandomizePlan}
                                  className="btn btn-success btn-sm"
                                >
                                  Randomize Week
                                </button>
                                <Link
                                  href={`/pets/${activePet?.id}/nutrition`}
                                  className="btn btn-success btn-sm"
                                >
                                  View Nutrition Dashboard
                                </Link>
                              </div>
                            )}
                          </div>
                        )}
                      </div>
                    </div>
              </div>
            ) : (
              <div className="bg-surface border border-surface-highlight rounded-2xl shadow-lg p-6 flex items-center justify-center text-center min-h-[280px]">
                <div>
                  <div className="text-3xl mb-2">üêæ</div>
                  <p className="text-lg font-semibold">Select a pet to view details</p>
                  <p className="text-sm text-gray-400 mt-1">Choose a pet from the list on the left.</p>
                </div>
              </div>
            )}
          </div>
        )}

        <AddPetModal
          isOpen={isModalOpen}
          onClose={handleCloseModal}
          onSubmit={handleSubmitPet}
          editingPet={editingPet}
        />

        <ConfirmModal
          isOpen={confirmModal.isOpen}
          onClose={() => setConfirmModal({ ...confirmModal, isOpen: false })}
          onConfirm={confirmModal.onConfirm}
          title={confirmModal.title}
          message={confirmModal.message}
          confirmText="Delete"
          cancelText="Cancel"
          isDeleteModal={true}
        />
      </div>
    </div>
  );
}
</file>

<file path="app/profile/pet/[id]/custom-meals/[mealId]/page.tsx">
'use client';

import { useEffect } from 'react';
import { useParams, useRouter } from 'next/navigation';

export default function CustomMealDetailPage() {
  const params = useParams();
  const router = useRouter();
  const petId = params.id as string;
  const mealId = params.mealId as string;

  useEffect(() => {
    // Redirect to recipe detail page with petId query parameter
    if (mealId && petId) {
      router.replace(`/recipe/${mealId}?petId=${petId}`);
    }
  }, [mealId, petId, router]);

  return (
    <div className="min-h-screen bg-background flex items-center justify-center">
      <p className="text-gray-400">Redirecting...</p>
    </div>
  );
}
</file>

<file path="app/profile/pet/[id]/custom-meals/page.tsx">
'use client';

import { useState, useEffect } from 'react';
import { useParams, useRouter } from 'next/navigation';
import Link from 'next/link';
import { ArrowLeft, Trash2, Edit, Calendar, ChefHat } from 'lucide-react';
import { getCustomMeals, deleteCustomMeal } from '@/lib/utils/customMealStorage';
import { getPets } from '@/lib/utils/petStorage'; // Import async storage
import type { CustomMeal, Pet } from '@/lib/types';

const getCurrentUserId = () => {
  if (typeof window === 'undefined') return 'clerk_simulated_user_id_123';
  return localStorage.getItem('last_user_id') || 'clerk_simulated_user_id_123';
};

const getPetsFromLocalStorage = (userId: string): Pet[] => {
  if (typeof window === 'undefined') return [];
  const stored = localStorage.getItem(`pets_${userId}`);
  if (!stored) return [];
  try {
    return JSON.parse(stored);
  } catch {
    return [];
  }
};

export default function CustomMealsHistoryPage() {
  const params = useParams();
  const router = useRouter();
  const petId = params.id as string;
  
  const [pet, setPet] = useState<Pet | null>(null);
  const [customMeals, setCustomMeals] = useState<CustomMeal[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const loadData = async () => {
      const userId = getCurrentUserId();
      try {
        const pets = await getPets(userId);
        const foundPet = pets.find(p => p.id === petId) || null;
        setPet(foundPet);
        
        if (foundPet) {
          const meals = await getCustomMeals(userId, petId);
          // Sort by most recent first
          meals.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
          setCustomMeals(meals);
        }
      } catch (error) {
        console.error('Error loading custom meals:', error);
      }
      setLoading(false);
    };
    loadData();
  }, [petId]);

  const handleDelete = async (mealId: string) => {
    if (!confirm('Are you sure you want to delete this custom meal?')) return;
    
    const userId = getCurrentUserId();
    await deleteCustomMeal(userId, petId, mealId);
    
    // Refresh the list
    const meals = await getCustomMeals(userId, petId);
    meals.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
    setCustomMeals(meals);
  };

  const formatDate = (dateString: string) => {
    const date = new Date(dateString);
    return date.toLocaleDateString('en-US', { 
      year: 'numeric', 
      month: 'short', 
      day: 'numeric' 
    });
  };

  const getScoreColor = (score: number) => {
    if (score >= 80) return 'text-green-600 bg-green-50 border-green-200';
    if (score >= 60) return 'text-yellow-600 bg-yellow-50 border-yellow-200';
    return 'text-red-600 bg-red-50 border-red-200';
  };

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <p className="text-gray-600">Loading custom meals...</p>
      </div>
    );
  }

  if (!pet) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <div className="bg-white p-8 rounded-xl shadow text-center space-y-4">
          <p className="text-xl font-semibold text-gray-800">Pet not found.</p>
          <Link href="/profile" className="text-green-800 font-semibold">
            Back to Profiles
          </Link>
        </div>
      </div>
    );
  }

  // Get random name from pet's names array
  const petNames = Array.isArray(pet.names) ? pet.names.filter(n => n && n.trim() !== '') : [];
  const petDisplayName = petNames.length > 0 
    ? petNames[Math.floor(Math.random() * petNames.length)]
    : 'Pet';

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Header */}
      <div className="bg-white border-b border-gray-200 sticky top-0 z-10">
        <div className="max-w-7xl mx-auto px-4 py-2">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-3">
              <Link
                href={`/profile/pet/${petId}`}
                className="p-1.5 hover:bg-gray-100 rounded-md transition-colors"
              >
                <ArrowLeft size={18} className="text-gray-600" />
              </Link>
              <div>
                <h1 className="text-lg font-bold text-gray-900">
                  Custom Meals for {petDisplayName}
                </h1>
                <p className="text-xs text-gray-600 mt-0.5">
                  {pet.breed} ‚Ä¢ {pet.age} ‚Ä¢ {pet.weight}
                </p>
              </div>
            </div>
            <Link
              href={`/profile/pet/${petId}/recipe-builder`}
              className="flex items-center gap-2 px-4 py-2 text-sm font-medium text-white bg-green-800 rounded-md hover:bg-green-900 transition-colors"
            >
              <ChefHat size={16} />
              Create New Meal
            </Link>
          </div>
        </div>
      </div>

      <div className="max-w-7xl mx-auto px-4 py-3">
        {customMeals.length === 0 ? (
          <div className="bg-white rounded-lg border border-gray-200 p-12 text-center">
            <ChefHat size={48} className="mx-auto text-gray-400 mb-4" />
            <h2 className="text-xl font-semibold text-gray-900 mb-2">No custom meals yet</h2>
            <p className="text-gray-600 mb-6">
              Create your first custom meal to get started!
            </p>
            <Link
              href={`/profile/pet/${petId}/recipe-builder`}
              className="inline-flex items-center gap-2 px-4 py-2 text-sm font-medium text-white bg-primary-600 rounded-md hover:bg-primary-700 transition-colors"
            >
              <ChefHat size={16} />
              Create Your First Meal
            </Link>
          </div>
        ) : (
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            {customMeals.map((meal) => (
              <div
                key={meal.id}
                className="bg-white rounded-lg border border-gray-200 p-6 hover:shadow-lg transition-shadow"
              >
                {/* Meal Header */}
                <div className="flex items-start justify-between mb-4">
                  <div className="flex-1">
                    <h3 className="text-lg font-semibold text-gray-900 mb-1">
                      {meal.name}
                    </h3>
                    <div className="flex items-center gap-2 text-sm text-gray-500">
                      <Calendar size={14} />
                      {formatDate(meal.createdAt)}
                    </div>
                  </div>
                  <button
                    onClick={() => handleDelete(meal.id)}
                    className="p-2 text-red-600 hover:bg-red-50 rounded-md transition-colors"
                    title="Delete meal"
                  >
                    <Trash2 size={16} />
                  </button>
                </div>

                {/* Compatibility Score */}
                <div className={`mb-4 p-3 rounded-lg border ${getScoreColor(meal.analysis.score)}`}>
                  <div className="flex items-center justify-between">
                    <span className="text-sm font-medium">Compatibility Score</span>
                    <span className="text-2xl font-bold">{meal.analysis.score}</span>
                  </div>
                  <div className="w-full bg-white/50 rounded-full h-2 mt-2">
                    <div
                      className={`h-2 rounded-full ${
                        meal.analysis.score >= 80 ? 'bg-green-600' :
                        meal.analysis.score >= 60 ? 'bg-yellow-600' :
                        'bg-red-600'
                      }`}
                      style={{ width: `${meal.analysis.score}%` }}
                    />
                  </div>
                </div>

                {/* Ingredients Summary */}
                <div className="mb-4">
                  <h4 className="text-sm font-medium text-gray-700 mb-2">Ingredients</h4>
                  <div className="space-y-1">
                    {meal.ingredients.slice(0, 3).map((ing, idx) => (
                      <div key={idx} className="text-sm text-gray-600">
                        ‚Ä¢ {ing.key.replace(/_/g, ' ')} ({ing.grams}g)
                      </div>
                    ))}
                    {meal.ingredients.length > 3 && (
                      <div className="text-sm text-gray-500">
                        + {meal.ingredients.length - 3} more
                      </div>
                    )}
                  </div>
                </div>

                {/* Nutritional Summary */}
                <div className="mb-4 text-sm">
                  <div className="flex justify-between mb-1">
                    <span className="text-gray-600">Total Weight:</span>
                    <span className="font-medium">{meal.analysis.totalRecipeGrams}g</span>
                  </div>
                  <div className="flex justify-between mb-1">
                    <span className="text-gray-600">Recommended Serving:</span>
                    <span className="font-medium text-green-800">
                      {meal.analysis.recommendedServingGrams}g
                    </span>
                  </div>
                </div>

                {/* Warnings Summary */}
                {meal.analysis.toxicityWarnings.length > 0 && (
                  <div className="mb-4 p-2 bg-red-50 border border-red-200 rounded text-xs text-red-800">
                    ‚ö†Ô∏è {meal.analysis.toxicityWarnings.length} safety warning(s)
                  </div>
                )}

                {/* Actions */}
                <div className="flex gap-2 pt-4 border-t border-gray-200">
                  <button
                    onClick={() => {
                      // TODO: Implement edit functionality (load meal into builder)
                      router.push(`/profile/pet/${petId}/recipe-builder?mealId=${meal.id}`);
                    }}
                    className="flex-1 flex items-center justify-center gap-2 px-3 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50 transition-colors"
                  >
                    <Edit size={14} />
                    Edit
                  </button>
                  <button
                    onClick={() => {
                      router.push(`/recipe/${meal.id}?petId=${petId}`);
                    }}
                    className="flex-1 px-3 py-2 text-sm font-medium text-green-800 bg-green-900/10 border border-green-800/30 rounded-md hover:bg-green-900/20 transition-colors"
                  >
                    View Details
                  </button>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="app/profile/pet/[id]/meal-plan/page.tsx">
'use client';

import { useEffect, useMemo, useState } from 'react';
import { useParams, useRouter } from 'next/navigation';
import Link from 'next/link';
import { ArrowLeft, ShoppingCart } from 'lucide-react';
import type { Recipe, CustomMeal } from '@/lib/types';
import { getProductPrice } from '@/lib/data/product-prices';
import { VETTED_PRODUCTS, getVettedProduct, getVettedProductByAnyIdentifier } from '@/lib/data/vetted-products';
import { getCustomMeals } from '@/lib/utils/customMealStorage';
import { getPets } from '@/lib/utils/petStorage'; // Import async storage
import { ensureCartUrlSellerId } from '@/lib/utils/affiliateLinks';

// Format price for display
const formatPrice = (price: number) => {
  return `$${price.toFixed(2)}`;
};

const DAYS = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
const SIMULATED_USER_ID = 'clerk_simulated_user_id_123';

interface PetProfile {
  id: string;
  name: string;
  savedRecipes: string[];
}

const getCurrentUserId = () => {
  if (typeof window === 'undefined') return SIMULATED_USER_ID;
  return localStorage.getItem('last_user_id') || SIMULATED_USER_ID;
};

const getPetsFromLocalStorage = (userId: string): PetProfile[] => {
  if (typeof window === 'undefined') return [];
  const stored = localStorage.getItem(`pets_${userId}`);
  if (!stored) return [];
  try {
    const parsed = JSON.parse(stored);
    return Array.isArray(parsed)
      ? parsed.map((pet: any) => ({
          id: pet.id,
          name: pet.name,
          savedRecipes: pet.savedRecipes || [],
        }))
      : [];
  } catch {
    return [];
  }
};

const buildEvenPlan = (meals: Recipe[]) => {
  const totalSlots = DAYS.length * 2;
  const rotation: Recipe[] = [];
  while (rotation.length < totalSlots) {
    rotation.push(...meals);
  }
  return rotation.slice(0, totalSlots);
};

const shuffleMealsNoRepeats = (meals: Recipe[], totalSlots: number) => {
  if (meals.length === 0) return [];
  const poolBase = [...meals];
  const rotation: Recipe[] = [];

  const shuffle = (arr: Recipe[]) => {
    for (let i = arr.length - 1; i > 0; i -= 1) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  };

  let pool = shuffle([...poolBase]);

  while (rotation.length < totalSlots) {
    if (pool.length === 0) {
      pool = shuffle([...poolBase]);
    }
    const next = pool.pop() as Recipe;
    // Avoid duplicate within the same day (pair of two)
    if (rotation.length % 2 === 1 && rotation[rotation.length - 1].id === next.id) {
      // Put it back to the front and try another
      pool.unshift(next);
      continue;
    }
    rotation.push(next);
  }

  return rotation;
};

export default function MealPlanPage() {
  const params = useParams();
  const router = useRouter();
  const petId = params.id as string;

  const [pet, setPet] = useState<PetProfile | null>(null);
  const [savedMeals, setSavedMeals] = useState<Recipe[]>([]);
  const [customMeals, setCustomMeals] = useState<CustomMeal[]>([]);
  const [weeklyPlan, setWeeklyPlan] = useState<{ day: string; meals: Recipe[] }[]>([]);
  const [loading, setLoading] = useState(true);
  const [swapTarget, setSwapTarget] = useState<{ dayIdx: number; mealIdx: number } | null>(null);

  // Convert custom meal to Recipe format for meal plan
  const convertCustomMealToRecipe = (customMeal: CustomMeal): Recipe => {
    return {
      id: customMeal.id,
      name: customMeal.name,
      category: 'custom', // Mark as custom meal
      ageGroup: ['adult'], // Default, could be enhanced
      healthConcerns: [],
      description: `Custom meal created on ${new Date(customMeal.createdAt).toLocaleDateString()}`,
      ingredients: customMeal.ingredients.map((ing, idx) => ({
        id: `${idx + 1}`,
        name: ing.key.replace(/_/g, ' '),
        amount: `${ing.grams}g`,
      })),
      instructions: [
        'Mix all ingredients according to saved recipe',
        'Serve at recommended portion size',
        `Recommended serving: ${customMeal.analysis.recommendedServingGrams}g`,
      ],
      nutritionalInfo: {
        protein: {
          min: (customMeal.analysis.nutrients.protein_g || 0) / (customMeal.analysis.totalRecipeGrams / 100),
          max: (customMeal.analysis.nutrients.protein_g || 0) / (customMeal.analysis.totalRecipeGrams / 100),
          unit: '%',
        },
        fat: {
          min: (customMeal.analysis.nutrients.fat_g || 0) / (customMeal.analysis.totalRecipeGrams / 100),
          max: (customMeal.analysis.nutrients.fat_g || 0) / (customMeal.analysis.totalRecipeGrams / 100),
          unit: '%',
        },
        calories: {
          min: customMeal.analysis.nutrients.kcal || customMeal.analysis.nutrients.calories_kcal || 0,
          max: customMeal.analysis.nutrients.kcal || customMeal.analysis.nutrients.calories_kcal || 0,
          unit: 'kcal',
        },
      },
      rating: 0,
      reviews: 0,
      tags: ['custom', 'user-created'],
    };
  };

  useEffect(() => {
    const loadData = async () => {
      const userId = getCurrentUserId();
      try {
        const pets = await getPets(userId);
        const foundPet = pets.find((p: any) => p.id === petId) || null;
        
        if (foundPet) {
          // Normalize pet profile
          setPet({
            id: foundPet.id,
            name: foundPet.name || foundPet.names?.[0] || 'Pet',
            savedRecipes: foundPet.savedRecipes || [],
          });

          // Saved recipes are no longer stored statically
          setSavedMeals([]);
          
          // Load custom meals
          const customMealsList = await getCustomMeals(userId, petId);
          setCustomMeals(customMealsList);
        } else {
          setPet(null);
        }
      } catch (error) {
        console.error('Error loading meal plan data:', error);
      }
      setLoading(false);
    };
    loadData();
  }, [petId]);

  const generatePlan = (meals: Recipe[]) => {
    const rotation = buildEvenPlan(meals);
    const plan: { day: string; meals: Recipe[] }[] = [];
    for (let i = 0; i < DAYS.length; i += 1) {
      const breakfastIndex = i * 2;
      const dinnerIndex = breakfastIndex + 1;
      const breakfast = rotation[breakfastIndex];
      let dinner = rotation[dinnerIndex];
      if (dinner.id === breakfast.id) {
        const swapIndex = rotation.findIndex(
          (entry, idx) => idx > dinnerIndex && entry.id !== breakfast.id
        );
        if (swapIndex !== -1) {
          [rotation[dinnerIndex], rotation[swapIndex]] = [
            rotation[swapIndex],
            rotation[dinnerIndex],
          ];
          dinner = rotation[dinnerIndex];
        } else {
          dinner = meals.find((meal) => meal.id !== breakfast.id) || dinner;
        }
      }
      plan.push({ day: DAYS[i], meals: [breakfast, dinner] });
    }
    return plan;
  };

  const allMeals = useMemo<Recipe[]>(() => {
    return [
      ...savedMeals,
      ...customMeals.map(convertCustomMealToRecipe),
    ];
  }, [savedMeals, customMeals]);

  useEffect(() => {
    if (allMeals.length > 0) {
      setWeeklyPlan(generatePlan(allMeals));
    }
  }, [allMeals]);

  const handleRegenerate = () => {
    setWeeklyPlan(generatePlan(allMeals));
  };

  const handleRandomize = () => {
    const totalSlots = DAYS.length * 2;
    const rotation = shuffleMealsNoRepeats(allMeals, totalSlots);
    const plan: { day: string; meals: Recipe[] }[] = [];
    for (let i = 0; i < DAYS.length; i += 1) {
      const breakfastIndex = i * 2;
      const dinnerIndex = breakfastIndex + 1;
      const breakfast = rotation[breakfastIndex];
      const dinner = rotation[dinnerIndex];
      plan.push({ day: DAYS[i], meals: [breakfast, dinner] });
    }
    setWeeklyPlan(plan);
  };

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <p className="text-gray-600">Loading meal plan...</p>
      </div>
    );
  }

  if (!pet) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <div className="bg-white p-8 rounded-xl shadow text-center space-y-4">
          <p className="text-xl font-semibold text-gray-800">Pet not found.</p>
          <Link href="/profile" className="text-green-800 font-semibold">
            Back to Profiles
          </Link>
        </div>
      </div>
    );
  }

  const allMealsCount = savedMeals.length + customMeals.length;
  
  if (allMealsCount < 1) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center px-4">
        <div className="max-w-lg bg-white rounded-xl shadow p-8 text-center space-y-4">
          <div className="text-5xl">üçΩÔ∏è</div>
          <h1 className="text-2xl font-bold text-gray-900">Add more meals first</h1>
          <p className="text-gray-600">
            Save at least two meals (recipes or custom meals) for {pet.name} to build a balanced weekly rotation.
          </p>
          <div className="flex flex-col gap-2">
            <button
              onClick={() => router.push(`/recipes/recommended/${pet.id}`)}
              className="bg-green-800 text-white font-semibold px-6 py-3 rounded-lg hover:bg-green-900 transition-colors"
            >
              See Recommended Meals
            </button>
            <button
              onClick={() => router.push(`/profile/pet/${pet.id}/recipe-builder`)}
              className="bg-green-800 text-white font-semibold px-6 py-3 rounded-lg hover:bg-green-900 transition-colors"
            >
              Create Custom Meal
            </button>
            <button
              onClick={() => router.push(`/profile/pet/${pet.id}`)}
              className="text-green-800 font-semibold"
            >
              Find More Meals for {pet.name}
            </button>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50 py-10 px-4">
      <div className="max-w-6xl mx-auto space-y-8">
        <div className="bg-white rounded-xl shadow p-6 flex flex-col gap-4">
          <div className="flex items-center gap-3 text-green-800">
            <button
              onClick={() => router.push('/profile')}
              className="inline-flex items-center gap-2 font-semibold"
            >
              <ArrowLeft size={20} />
              Back to pets
            </button>
          </div>
            <div>
              <p className="text-sm uppercase tracking-wide text-gray-500 font-semibold">
                Weekly Meal Prep
              </p>
              <h1 className="text-3xl font-bold text-gray-900">
                7-Day Meal Plan for {pet.name}
              </h1>
              <p className="text-gray-600 mt-1">
                Two meals per day. No repeats on the same day. Each saved meal gets equal play.
              </p>
            </div>
          </div>
        

        <div className="grid grid-cols-7 gap-2">
          {weeklyPlan.map((dayPlan, index) => (
            <div key={dayPlan.day} className="bg-white rounded-lg shadow p-2">
              <div className="text-center mb-2">
                <p className="text-xs uppercase tracking-wide text-gray-500 font-semibold">
                  {dayPlan.day.slice(0, 3)}
                </p>
              </div>
              <div className="space-y-2">
                {dayPlan.meals.map((meal, mealIndex) => (
                  <div key={meal.id + mealIndex} className="text-center">
                    <Link
                      href={`/recipe/${meal.id}?petId=${petId}`}
                      className="block hover:text-primary-600 transition-colors mb-1"
                    >
                      <p className="font-medium text-gray-900 text-xs leading-tight">
                        {meal.name}
                        {meal.category === 'custom' && (
                          <span className="ml-1 text-xs text-green-800">(Custom)</span>
                        )}
                      </p>
                    </Link>
                    <div className="flex flex-col items-center gap-1">
                      <button
                        onClick={(e) => {
                          e.preventDefault();
                          const cartItems = meal.ingredients
                            .map((ing, index) => {
                              const genericName = ing.name.toLowerCase().trim();
                              const vettedProduct = VETTED_PRODUCTS[genericName];
                              const link = vettedProduct ? vettedProduct.purchaseLink : ing.asinLink;
                              if (link) {
                                // Extract ASIN from /dp/ASIN format
                                const asinMatch = link.match(/\/dp\/([A-Z0-9]{10})/);
                                if (asinMatch) {
                                  return `ASIN.${index + 1}=${asinMatch[1]}&Quantity.${index + 1}=1`;
                                }
                              }
                              return null;
                            })
                            .filter(Boolean);

                          if (cartItems.length > 0) {
                            const cartUrl = ensureCartUrlSellerId(`https://www.amazon.com/gp/aws/cart/add.html?${cartItems.join('&')}`);
                            window.open(cartUrl, '_blank');
                          } else {
                            alert('No ingredient links available for this recipe.');
                          }
                        }}
                        className="inline-flex items-center gap-1 text-xs bg-green-600 text-black px-1 py-0.5 rounded hover:bg-green-700 transition-colors"
                        title="Add all vetted ingredients to your Amazon cart"
                      >
                        <ShoppingCart size={8} />
                        Buy
                      </button>
                      {/* Price Display */}
                      {(() => {
                        const mealTotalPrice = meal.ingredients?.reduce((sum, ing) => {
                          const price = getProductPrice(ing.name);
                          if (typeof price === 'number') return sum + price;
                          return sum;
                        }, 0) || 0;
                        return mealTotalPrice > 0 ? (
                          <span className="text-[10px] text-green-700 font-semibold">
                            {formatPrice(mealTotalPrice)}
                          </span>
                        ) : null;
                      })()}
                    </div>
                    <button
                      onClick={(e) => {
                        e.preventDefault();
                        setSwapTarget({ dayIdx: index, mealIdx: mealIndex });
                      }}
                    className="mt-2 w-full inline-flex items-center justify-center gap-1 text-xs px-2 py-1 rounded border border-primary-500 text-primary-700 bg-white hover:bg-primary-50 transition-colors"
                      title="Edit this slot"
                    >
                    Edit
                    </button>
                  </div>
                ))}
              </div>
            </div>
          ))}
        </div>

        {swapTarget && (
          <div className="fixed inset-0 z-50 bg-black/60 flex items-center justify-center px-4">
            <div className="bg-white rounded-xl shadow-2xl max-w-lg w-full p-5 border border-gray-200">
              <div className="flex items-center justify-between mb-3">
                <h3 className="text-lg font-bold text-gray-900">Swap Meal</h3>
                <button
                  onClick={() => setSwapTarget(null)}
                  className="text-gray-500 hover:text-gray-700"
                  aria-label="Close swap dialog"
                >
                  ‚úï
                </button>
              </div>
              <p className="text-sm text-gray-600 mb-3">Choose a saved meal to place into this slot.</p>
              <div className="max-h-72 overflow-y-auto space-y-2">
                {allMeals.map((meal) => (
                  <button
                    key={meal.id}
                    onClick={() => {
                      if (!swapTarget) return;
                      const planCopy = weeklyPlan.map((d) => ({ ...d, meals: [...d.meals] }));
                      planCopy[swapTarget.dayIdx].meals[swapTarget.mealIdx] = meal;
                      setWeeklyPlan(planCopy);
                      setSwapTarget(null);
                    }}
                    className="w-full text-left p-3 rounded-lg border border-gray-200 hover:border-green-600 hover:bg-green-50 transition-colors"
                  >
                    <div className="flex justify-between items-center">
                      <span className="font-semibold text-gray-900">{meal.name}</span>
                      {meal.category === 'custom' && (
                        <span className="text-xs text-green-700 bg-green-100 px-2 py-0.5 rounded-full">Custom</span>
                      )}
                    </div>
                  </button>
                ))}
                {allMeals.length === 0 && (
                  <p className="text-sm text-gray-500">No saved meals available.</p>
                )}
              </div>
              <div className="mt-4 flex justify-end gap-2">
                <button
                  onClick={() => setSwapTarget(null)}
                  className="px-4 py-2 text-sm text-gray-700 border border-gray-300 rounded-lg hover:bg-gray-50"
                >
                  Cancel
                </button>
              </div>
            </div>
          </div>
        )}

        <div className="bg-white rounded-xl shadow p-6">
          <h3 className="text-lg font-bold text-gray-900 mb-2">How rotation works</h3>
          <p className="text-gray-600 text-sm mb-2">
            We loop through every saved meal (recipes and custom meals) equally, then shuffle lightly to keep variety.
            Each day uses two different meals so {pet.name} never sees a repeat on the same day.
          </p>
          <div className="mt-3 pt-3 border-t border-gray-200">
            <p className="text-xs text-gray-500">
              <strong>Meals included:</strong> {savedMeals.length} saved recipe{savedMeals.length !== 1 ? 's' : ''} 
              {customMeals.length > 0 && ` + ${customMeals.length} custom meal${customMeals.length !== 1 ? 's' : ''}`}
            </p>
          </div>
        </div>

        <div className="flex flex-wrap gap-2 mt-4">
          <button
            onClick={handleRandomize}
            className="btn btn-success btn-sm"
          >
            Randomize Week
          </button>
          <Link
            href={`/pets/${petId}/nutrition`}
            className="btn btn-success btn-sm"
          >
            View Nutrition Dashboard
          </Link>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/profile/pet/[id]/page.tsx">
'use client';

import { useState, useEffect, useMemo, useRef } from 'react';
import { useParams } from 'next/navigation';
import Link from 'next/link';
import Image from 'next/image';
import { ArrowLeft, Plus } from 'lucide-react';
import type { ModifiedRecipeResult, Recipe } from '@/lib/types';
import { calculateEnhancedCompatibility, type Pet as EnhancedPet, getGrade } from '@/lib/utils/enhancedCompatibilityScoring';
import { CompatibilityBadge } from '@/components/CompatibilityBadge';
import { getRandomName } from '@/lib/utils/petUtils';
import EmojiIcon from '@/components/EmojiIcon';
import { getPets, savePet } from '@/lib/utils/petStorage'; // Import from storage util
import { useChunkedRecipeScoring } from '@/lib/hooks/useChunkedRecipeScoring';
import ScoringProgress from '@/components/ScoringProgress';
import { calculateMealCountVariation } from '@/lib/utils/mealCountCalculator';
import { makeCountOrganic, getCountMessage, getSubtext } from '@/lib/utils/organicCount';
import { useProgressiveMealCount } from '@/hooks/useProgressiveMealCount';


type PetCategory = 'dogs' | 'cats' | 'birds' | 'reptiles' | 'pocket-pets';
type AgeGroup = 'baby' | 'young' | 'adult' | 'senior';

interface Pet {
  id: string;
  name?: string; // Legacy field, prefer names array
  names?: string[]; // Array of names
  type: PetCategory;
  breed: string;
  age: AgeGroup;
  healthConcerns?: string[];
  dietaryRestrictions?: string[];
  savedRecipes?: string[];
  allergies?: string[];
  weightKg?: number;
  weight?: string;
  dislikes?: string[];
}

// Same simulated user ID setup as profile and saved-recipes pages
const SIMULATED_USER_ID = 'clerk_simulated_user_id_123';

const getCurrentUserId = () => {
  if (typeof window === 'undefined') return SIMULATED_USER_ID;
  return localStorage.getItem('last_user_id') || SIMULATED_USER_ID;
};

// Get custom recipes from localStorage
const getCombinedRecipes = (): Recipe[] => {
  if (typeof window !== 'undefined') {
    try {
      const customRecipes = JSON.parse(localStorage.getItem('custom_recipes') || '[]');
      return customRecipes;
    } catch (error) {
      console.error('Error loading custom recipes:', error);
    }
  }

  return [];
};

export default function RecommendedRecipesPage() {
  const params = useParams();
  const [pet, setPet] = useState<Pet | null>(null);
  const [hoveredRecipe, setHoveredRecipe] = useState<string | null>(null);
  const [engineMeals, setEngineMeals] = useState<ModifiedRecipeResult[] | null>(null);
  const [engineError, setEngineError] = useState<string | null>(null);
  const [loadingMeals, setLoadingMeals] = useState(true);
  const [cardMessage, setCardMessage] = useState<{ id: string; text: string } | null>(null);
  const petId = params.id as string;

  // Get pet display name (use names array if available, fallback to name field) - memoized for stability
  const petDisplayName = useMemo(() => {
    if (!pet) return 'Pet';
    return getRandomName(pet.names || (pet.name ? [pet.name] : ['Unnamed Pet']));
  }, [pet?.id, pet?.names, pet?.name]);

  // Convert pet data to rating system format - memoized to prevent recalculation when only savedRecipes changes
  // Use JSON.stringify for arrays to ensure stable comparison
  const healthConcernsKey = pet ? JSON.stringify(pet.healthConcerns || []) : '';
  const allergiesKey = pet ? JSON.stringify(pet.allergies || []) : '';
  const dislikesKey = pet ? JSON.stringify(pet.dislikes || []) : '';
  
  // Convert pet data to enhanced compatibility format
  const enhancedPet: EnhancedPet | null = useMemo(() => {
    if (!pet) return null;
    const petAge = pet.age === 'baby' ? 0.5 : pet.age === 'young' ? 2 : pet.age === 'adult' ? 5 : 10;
    return {
      id: pet.id,
      name: petDisplayName,
      type: (pet.type === 'dogs' ? 'dog' : pet.type === 'cats' ? 'cat' : pet.type === 'birds' ? 'bird' : pet.type === 'reptiles' ? 'reptile' : 'pocket-pet') as 'dog' | 'cat' | 'bird' | 'reptile' | 'pocket-pet',
      breed: pet.breed,
      age: petAge,
      weight: pet.weightKg || (pet.type === 'dogs' ? 25 : pet.type === 'cats' ? 10 : 5),
      activityLevel: 'moderate' as const,
      healthConcerns: pet.healthConcerns || [],
      dietaryRestrictions: pet.dietaryRestrictions || [],
      allergies: pet.allergies || [],
    };
  }, [pet?.id, pet?.type, pet?.breed, pet?.age, pet?.weightKg, healthConcernsKey, allergiesKey, petDisplayName, pet?.dietaryRestrictions]);


  useEffect(() => {
    const userId = getCurrentUserId();
    if (!userId || !petId) return;

    const loadPet = async () => {
      try {
        // Add 5 second timeout to prevent hanging
        const timeoutPromise = new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Timeout loading pets')), 5000)
        );
        
        const pets = await Promise.race([
          getPets(userId),
          timeoutPromise
        ]) as any[];
        
        // Normalize names when loading
        const normalizedPets = pets.map((p: any) => ({
          ...p,
          names: p.names || (p.name ? [p.name] : []),
          savedRecipes: p.savedRecipes || [],
          healthConcerns: p.healthConcerns || [],
        }));
        
        const foundPet = normalizedPets.find((p: any) => p.id === petId) || null;
        setPet(foundPet);
        
        if (!foundPet) {
          console.warn('Pet not found with id:', petId);
          setLoadingMeals(false); // Stop loading if pet not found
        }
      } catch (error) {
        console.error('Failed to load pet data:', error);
        setPet(null);
        setLoadingMeals(false); // CRITICAL: Stop loading on error
      }
    };
    loadPet();
  }, [petId]); // petId is the only dependency needed

useEffect(() => {
  if (!pet) return;
  let isMounted = true;
  setLoadingMeals(true);
  setEngineError(null);

  (async () => {
    try {
      // First try the new cost-optimized recipe generation API
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
      
      const response = await fetch('/api/recipes/generate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        signal: controller.signal,
        body: JSON.stringify({
          species: pet.type,
          count: 50,
          petProfile: {
            name: petDisplayName,
            weight: pet.weight,
            weightKg: pet.weightKg,
            age: pet.age,
            allergies: pet.allergies || [],
            healthConcerns: pet.healthConcerns || [],
          },
        }),
      });
      
      clearTimeout(timeoutId);

      if (!response.ok) {
        throw new Error(`Recipe generation failed (${response.status})`);
      }

      const data = await response.json();
      if (!isMounted) return;
      
      if (data?.recipes && data.recipes.length > 0) {
        // Convert generated recipes to ModifiedRecipeResult format
        const generatedMeals = data.recipes.map((recipe: any) => ({
          recipe,
          explanation: `Cost-optimized meal: $${recipe.estimatedCostPerMeal?.toFixed(2) || 'N/A'} per meal`,
        }));
        setEngineMeals(generatedMeals as ModifiedRecipeResult[]);
      } else {
        throw new Error('No recipes generated');
      }
    } catch (error) {
      if (!isMounted) return;
      console.error('Recipe generation error:', error);
      // Fall back to recommendations API if generation fails
      try {
        const concerns = (pet.healthConcerns || []).filter((concern) => concern !== 'none');
        const allergies = pet.allergies?.filter((allergy) => allergy !== 'none') || [];
        
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000);
        
        const response = await fetch('/api/recommendations', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          signal: controller.signal,
          body: JSON.stringify({
            profile: {
              species: pet.type,
              ageGroup: pet.age,
              breed: pet.breed,
              weightKg: pet.weightKg || 10,
              healthConcerns: concerns,
              allergies,
              petName: petDisplayName,
            },
            limit: 50,
          }),
        });
        
        clearTimeout(timeoutId);

        if (!response.ok) {
          throw new Error(`Recommendations failed (${response.status})`);
        }

        const data = await response.json();
        if (!isMounted) return;
        
        setEngineMeals((data?.results as ModifiedRecipeResult[]) || []);
      } catch (fallbackError) {
        if (!isMounted) return;
        setEngineMeals(null);
        setEngineError('Unable to load meals‚Äîshowing standard matches.');
      }
    } finally {
      if (isMounted) {
        setLoadingMeals(false);
      }
    }
  })();

  return () => {
    isMounted = false;
  };
}, [pet]);

  // Debug logging (as suggested by DeepSeek) - MUST be after all useState hooks, before early returns
  useEffect(() => {
    // Only log state variables, not computed values
    if (pet) {
      const { getRecommendedRecipes } = require('@/lib/utils/recipeRecommendations');
      const tieredRecommendations = getRecommendedRecipes(pet, 20, true);
      const fallbackCount = tieredRecommendations.length;
      
      // Using engine meals or fallback
    }
  }, [engineMeals, pet]);

  // Import subtype matching
  const { normalizeToSubtype } = require('@/lib/utils/ingredientWhitelists');
  
  // Helper to check species/subtype match
  const matchesSpecies = (recipe: Recipe, currentPet: Pet): boolean => {
    if (recipe.category === currentPet.type) return true;
    
    // Subtype matching for exotics
    const subtype = normalizeToSubtype(currentPet.type as any, currentPet.breed);
    
    if (currentPet.type === 'birds') {
      if (recipe.category === 'birds' || recipe.category === 'bird') return true;
      if (recipe.category === subtype) return true;
    }
    
    if (currentPet.type === 'reptiles') {
      if (recipe.category === 'reptiles' || recipe.category === 'reptile') return true;
      if (recipe.category === subtype) return true;
    }
    
    if (currentPet.type === 'pocket-pets') {
      if (recipe.category === 'pocket-pets' || recipe.category === 'pocket-pet') return true;
      if (recipe.category === subtype) return true;
    }
    
    return false;
  };

  // Use tiered recommendation system to ensure we always have results
  // Only depend on properties that affect recommendations, NOT savedRecipes
  // Use JSON.stringify for arrays to ensure stable comparison
  const tieredHealthConcernsKey = pet ? JSON.stringify(pet.healthConcerns || []) : '';
  const tieredAllergiesKey = pet ? JSON.stringify(pet.allergies || []) : '';

  const tieredRecommendations = useMemo(() => {
    if (!pet) return [];
    const { getRecommendedRecipes } = require('@/lib/utils/recipeRecommendations');
    // Pass combined recipes (base + custom) to the recommendation system
    const combinedRecipes = getCombinedRecipes();
    return getRecommendedRecipes(pet, 20, true, combinedRecipes);
  }, [pet?.id, pet?.type, pet?.breed, pet?.age, tieredHealthConcernsKey, pet?.weightKg, tieredAllergiesKey]);
  
  const buildFallbackExplanation = (recipe: Recipe, currentPet: Pet, tierLabel?: string, warning?: string) => {
    if (warning) {
      return warning;
    }
    if (tierLabel && tierLabel !== 'Best Match') {
      return `${recipe.name} - ${tierLabel}`;
    }
    const concern = (currentPet.healthConcerns || [])[0]?.replace(/-/g, ' ') || 'overall wellness';
    const highlight = recipe.tags?.[0] || (recipe.description || '').split('. ')[0] || recipe.name;
    return `${recipe.name} keeps ${currentPet.name || 'pet'}'s ${concern} on track with ${highlight?.toLowerCase()}.`;
  };

  // Convert tiered recommendations to format expected by UI
  // Only depend on properties that affect meal recommendations, NOT savedRecipes
  const fallbackHealthConcernsKey = pet ? JSON.stringify(pet.healthConcerns || []) : '';
  const fallbackPetName = pet?.name || '';
  
  const fallbackMeals = useMemo(() => {
    if (!pet) return [];
    return tieredRecommendations.map((rec: any) => ({
      recipe: rec.recipe,
      explanation: buildFallbackExplanation(rec.recipe, pet, rec.tierLabel, rec.warning),
      _tierLabel: rec.tierLabel,
      _warning: rec.warning,
      _healthMatch: rec.healthConcernMatch,
      _tier: rec.tier
    }));
  }, [pet?.id, pet?.type, pet?.breed, pet?.age, fallbackHealthConcernsKey, fallbackPetName, tieredRecommendations]);

  // Fix: Properly check for empty array - use fallback if engineMeals is null, undefined, empty, or has too few results
  // Use fallback if API returns fewer than 15 meals (threshold to ensure we get a good selection)
  const MIN_MEALS_THRESHOLD = 15;
  // Memoize mealsToRender to prevent recalculation when only savedRecipes changes
  const mealsToRender: (ModifiedRecipeResult | { recipe: Recipe; explanation: string })[] = useMemo(() => {
    const hasEnoughFromAPI = engineMeals && Array.isArray(engineMeals) && engineMeals.length >= MIN_MEALS_THRESHOLD;
    return hasEnoughFromAPI ? engineMeals : fallbackMeals;
  }, [engineMeals, fallbackMeals]);

  // Use chunked scoring hook for non-blocking performance
  const { scoredMeals, isLoading: isScoring, progress, totalMeals: totalMealsToScore, scoredCount } = useChunkedRecipeScoring(
    mealsToRender,
    null, // ratingPet deprecated - using enhancedPet only
    enhancedPet
  );

  // Store sorted meals (already sorted by the hook, but ensure final sort)
  const sortedMealsToRender = useMemo(() => {
    return [...scoredMeals].sort((a: any, b: any) => {
      const aScore = ('score' in a && typeof a.score === 'number') ? a.score : 0;
      const bScore = ('score' in b && typeof b.score === 'number') ? b.score : 0;
      const scoreDiff = bScore - aScore;
      // If scores differ, sort by score (descending)
      if (Math.abs(scoreDiff) > 0.001) {
        return scoreDiff;
      }
      // If scores are equal, use recipe ID as tiebreaker
      const aId = a.recipe?.id || '';
      const bId = b.recipe?.id || '';
      return aId.localeCompare(bId);
    });
  }, [scoredMeals]);

  // Calculate base meal count (before early returns to ensure hooks are always called)
  const baseTotalMeals = sortedMealsToRender.length;
  
  // Memoize the count calculation - use actual count with minimal organic tweaking
  // Only recalculate when pet profile or base count changes
  const { countMessage, countSubtext, targetDisplayCount } = useMemo(() => {
    // Use the actual count as the base
    const message = getCountMessage(baseTotalMeals, pet?.type);
    const subtext = getSubtext(baseTotalMeals, pet?.type);
    // Use actual count
    const target = baseTotalMeals;
    
    return {
      countMessage: message,
      countSubtext: subtext,
      targetDisplayCount: target,
    };
  }, [baseTotalMeals, pet?.type]);
  
  // Progressive count animation - MUST be called before any early returns
  const { displayCount, isCounting } = useProgressiveMealCount({
    target: targetDisplayCount,
    duration: 1000,
    steps: 20,
  });

  // Track saved recipes separately to avoid triggering meal recalculation
  const [savedRecipeIds, setSavedRecipeIds] = useState<Set<string>>(new Set());

  // Initialize savedRecipeIds from pet when pet loads
  useEffect(() => {
    if (pet?.savedRecipes) {
      setSavedRecipeIds(new Set(pet.savedRecipes));
    }
  }, [pet?.id]); // Only update when pet ID changes, not when savedRecipes changes

  const handleSaveRecipe = async (recipeId: string, recipeName: string) => {
    const userId = getCurrentUserId();
    if (!userId || !pet) return;

    // Check if already saved (using local state)
    if (savedRecipeIds.has(recipeId)) {
      setCardMessage({ id: recipeId, text: 'Already saved for this pet.' });
      setTimeout(() => setCardMessage(null), 2500);
      return;
    }

    // Update via storage util
    const updatedPet = {
      ...pet,
      savedRecipes: [...(pet.savedRecipes || []), recipeId]
    };
    
    await savePet(userId, updatedPet);

    // Update local state to reflect the change immediately
    setPet(updatedPet);
    setSavedRecipeIds(new Set([...savedRecipeIds, recipeId]));
    setCardMessage({ id: recipeId, text: `${recipeName} added to ${petDisplayName}'s meals.` });
    setTimeout(() => setCardMessage(null), 2500);
  };

  if (!pet) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-background text-foreground">
        <p>Loading...</p>
      </div>
    );
  }

  const usingEngine = Boolean(engineMeals && engineMeals.length > 0);

  const getPetEmoji = (type: PetCategory) => {
    const emojis = {
      dogs: 'üêï',
      cats: 'üêà',
      birds: 'ü¶ú',
      reptiles: 'ü¶é',
      'pocket-pets': 'üê∞',
    };
    return emojis[type];
  };
  
  // Component to render pet emoji as image
  const PetEmojiIcon = ({ type, size = 24 }: { type: PetCategory; size?: number }) => {
    const emoji = getPetEmoji(type);
    return <EmojiIcon emoji={emoji} size={size} />;
  };

  const getHealthCompatibilityScore = (recipe: any, pet: Pet): number => {
    const concerns = pet.healthConcerns || [];
    if (!concerns.length) return 0;
    const overlaps = concerns.filter((c) => (recipe.healthConcerns || []).includes(c));
    if (!overlaps.length) return 0;
    return overlaps.length / concerns.length; // 0..1
  };

  const getHealthMatchBadge = (score: number) => {
    if (score >= 0.67)
      return {
        label: 'Great health match',
        className: 'bg-green-900/50 text-green-200 border border-green-700/50',
      };
    if (score >= 0.34)
      return {
        label: 'Good health match',
        className: 'bg-yellow-900/50 text-yellow-200 border border-yellow-700/50',
      };
    if (score > 0)
      return {
        label: 'Some health benefit',
        className: 'bg-blue-900/50 text-blue-200 border border-blue-700/50',
      };
    return null;
  };

  const getStarStates = (rating: number): boolean[] => {
    const fullStars = Math.round(rating); // 0..5
    return Array.from({ length: 5 }, (_, i) => i < fullStars);
  };

  return (
    <div className="min-h-screen bg-background text-foreground py-4">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <Link
          href="/profile"
          className="inline-flex items-center gap-2 text-gray-400 hover:text-primary-400 mb-6"
        >
          <ArrowLeft className="h-5 w-5" />
          Back to Profile
        </Link>

        <div 
          className="bg-surface rounded-lg shadow-md border border-surface-highlight p-4 mb-3"
        >
          <div className="flex items-start gap-4">
            {/* Left: Turtle Image (twice as large) */}
            <div className="flex-shrink-0">
              <Image
                src="/images/emojis/Mascots/Sherlock Shells/Shell4.jpg"
                alt="Sherlock Shells Detective"
                width={288}
                height={288}
                className="w-72 h-72 object-contain mascot-icon mascot-sherlock-shells"
                unoptimized
              />
            </div>

            {/* Left-Middle: Title and Bio Info in Grid */}
            <div className="flex-1 min-w-0">
              <h1 className="text-2xl font-bold text-foreground mb-6 mt-8">
                Sherlock Shells is detecting meals...
              </h1>
              
              {/* Three Column Layout: Bio, Health Concerns, Allergies */}
              <div className="flex gap-6 mt-8">
                {/* Bio Column */}
                <div className="flex-1 min-w-0">
                  <h3 className="text-sm font-semibold text-gray-300 mb-2">Bio</h3>
                  <div className="grid grid-cols-1 gap-y-1 text-sm text-gray-300">
                    {pet.breed && (
                      <div className="flex items-start gap-1.5">
                        <span className="text-orange-400 mt-0.5">‚Ä¢</span>
                        <span><strong className="text-gray-200">Breed:</strong> {pet.breed}</span>
                      </div>
                    )}
                    {pet.age && (
                      <div className="flex items-start gap-1.5">
                        <span className="text-orange-400 mt-0.5">‚Ä¢</span>
                        <span><strong className="text-gray-200">Age:</strong> {pet.age}</span>
                      </div>
                    )}
                    {(pet.weightKg || pet.weight) && (
                      <div className="flex items-start gap-1.5">
                        <span className="text-orange-400 mt-0.5">‚Ä¢</span>
                        <span><strong className="text-gray-200">Weight:</strong> {pet.weightKg ? `${pet.weightKg}kg` : pet.weight}</span>
                      </div>
                    )}
                    {pet.type && (
                      <div className="flex items-start gap-1.5">
                        <span className="text-orange-400 mt-0.5">‚Ä¢</span>
                        <span><strong className="text-gray-200">Type:</strong> {pet.type}</span>
                      </div>
                    )}
                    {pet.savedRecipes && pet.savedRecipes.length > 0 && (
                      <div className="flex items-start gap-1.5">
                        <span className="text-orange-400 mt-0.5">‚Ä¢</span>
                        <span><strong className="text-gray-200">Total Meals:</strong> {pet.savedRecipes.length}</span>
                      </div>
                    )}
                    {(pet.dietaryRestrictions || []).length > 0 && (
                      <div className="flex items-start gap-1.5">
                        <span className="text-orange-400 mt-0.5">‚Ä¢</span>
                        <span><strong className="text-gray-200">Dietary Restrictions:</strong> {(pet.dietaryRestrictions || []).join(', ')}</span>
                      </div>
                    )}
                    {(pet.dislikes || []).length > 0 && (
                      <div className="flex items-start gap-1.5">
                        <span className="text-orange-400 mt-0.5">‚Ä¢</span>
                        <span><strong className="text-gray-200">Dislikes:</strong> {(pet.dislikes || []).join(', ')}</span>
                      </div>
                    )}
                  </div>
                </div>

                {/* Health Concerns Column - Always rendered for consistent layout */}
                <div className="flex-shrink-0 min-w-[180px]">
                  <h3 className="text-sm font-semibold text-gray-300 mb-2">Health Concerns</h3>
                  <div className="flex flex-col gap-1.5">
                    {(pet.healthConcerns || []).length > 0 ? (
                      (pet.healthConcerns || []).map((concern) => (
                        <div
                          key={concern}
                          className="px-2 py-1 bg-orange-900/40 text-orange-200 border border-orange-700/50 text-xs rounded"
                        >
                          {concern.replace(/-/g, ' ')}
                        </div>
                      ))
                    ) : (
                      <div className="px-2 py-1 text-gray-500 text-xs italic">
                        None
                      </div>
                    )}
                  </div>
                </div>

                {/* Allergies Column - Always rendered for consistent layout */}
                <div className="flex-shrink-0 min-w-[180px]">
                  <h3 className="text-sm font-semibold text-gray-300 mb-2">Allergies</h3>
                  <div className="flex flex-col gap-1.5">
                    {(pet.allergies || []).length > 0 ? (
                      (pet.allergies || []).map((allergy) => (
                        <div
                          key={allergy}
                          className="px-2 py-1 bg-orange-900/40 text-orange-200 border border-orange-700/50 text-xs rounded"
                        >
                          {allergy.replace(/-/g, ' ')}
                        </div>
                      ))
                    ) : (
                      <div className="px-2 py-1 text-gray-500 text-xs italic">
                        None
                      </div>
                    )}
                  </div>
                </div>
              </div>

              {engineError && (
                <p className="mt-4 text-sm text-amber-200 bg-amber-900/30 border border-amber-700/50 px-3 py-2 rounded-lg">
                  {engineError}
                </p>
              )}
            </div>

            {/* Far Right: Number of Meals Found (Larger) */}
            <div className="flex-shrink-0 text-right">
              <div className="text-5xl font-bold text-orange-500">
                {displayCount}{isCounting && <span className="text-3xl">+</span>}
              </div>
              <div className="text-sm text-gray-400 mt-1">
                meals found
                {isCounting && (
                  <span className="text-xs ml-2 text-gray-500">(still searching...)</span>
                )}
              </div>
              {countSubtext && !isCounting && (
                <div className="text-xs text-gray-500 mt-1 max-w-[120px]">
                  {countSubtext}
                </div>
              )}
            </div>
          </div>
        </div>

        {/* Show progress indicator while scoring */}
        {isScoring && (
          <ScoringProgress
            progress={progress}
            totalMeals={totalMealsToScore}
            scoredCount={scoredCount}
          />
        )}

        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {(() => {
            // FINAL SAFETY CHECK: Sort one more time right before rendering to ensure highest to lowest
            const finalRendered = [...sortedMealsToRender].sort((a: any, b: any) => {
              const aScore = ('score' in a && typeof a.score === 'number') ? a.score : 0;
              const bScore = ('score' in b && typeof b.score === 'number') ? b.score : 0;
              return bScore - aScore; // Descending order (highest first)
            });
            return finalRendered;
          })().map((meal) => {
            const recipe = meal.recipe;
            const explanation = meal.explanation;
            const recipeId = recipe.id;
            return (
            <div
              key={recipeId}
              className="relative group"
              onMouseEnter={() => setHoveredRecipe(recipeId)}
              onMouseLeave={() => setHoveredRecipe(null)}
            >
              <Link 
                href={`/recipe/${recipeId}?petId=${petId}`}
                onClick={() => {
                  // Store recipe in session storage for dynamically generated recipes
                  if (typeof window !== 'undefined') {
                    sessionStorage.setItem(`recipe_${recipeId}`, JSON.stringify(recipe));
                  }
                }}
              >
                <div className="bg-surface rounded-lg shadow-md border border-surface-highlight overflow-hidden cursor-pointer hover:shadow-xl hover:border-orange-500/30 hover:-translate-y-1 hover:scale-[1.02] transition-all duration-200 ease-out h-full flex flex-col">
                  <div className="p-6 flex-1 flex flex-col">
                    <div className="mb-3">
                      <h3 className="text-xl font-bold text-foreground text-center">
                        {recipe.name}
                      </h3>
                      {/* Compatibility Rating - Centered under meal name */}
                      {enhancedPet && (
                        <div className="mt-2 flex justify-center">
                          <CompatibilityBadge
                            score={
                              'score' in meal && typeof meal.score === 'number'
                                ? meal.score
                                : (() => {
                                    if (!enhancedPet) return 0;
                                    const enhanced = calculateEnhancedCompatibility(recipe, enhancedPet);
                                    return enhanced.overallScore;
                                  })()
                            }
                          />
                        </div>
                      )}
                    </div>
                    <p className="text-gray-300 text-sm mb-4 flex-1 text-center">
                      {recipe.description}
                    </p>
                    {explanation && (
                      <p className="text-sm text-gray-300 bg-surface-highlight rounded-lg p-3 mb-3 border border-white/5">
                        {explanation}
                      </p>
                    )}
                  </div>
                  <div className="px-6 pb-4 pt-2 border-t border-surface-highlight">
                    {(() => {
                      const isSaved = savedRecipeIds.has(recipeId);
                      return (
                        <button
                          onClick={(e) => {
                            e.preventDefault();
                            handleSaveRecipe(recipeId, recipe.name);
                          }}
                          disabled={isSaved}
                          className={`w-full px-4 py-2 rounded-md shadow-md transition-colors flex items-center justify-center gap-2 text-sm font-semibold ${
                            isSaved
                              ? 'bg-green-600 text-white cursor-not-allowed'
                              : 'bg-green-800 text-white hover:bg-green-900'
                          }`}
                        >
                          {isSaved ? '‚úì Added to Saved Meals' : (
                            <>
                              <Plus className="h-4 w-4" /> Add Meal
                            </>
                          )}
                        </button>
                      );
                    })()}
                  </div>
                </div>
              </Link>
            </div>
          )})}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/profile/pet/[id]/recipe-builder/page.tsx">
'use client';

import { useState, useEffect } from 'react';
import { useParams, useRouter } from 'next/navigation';
import Link from 'next/link';
import {
  ChevronLeft,
  X
} from 'lucide-react';
import { generateCustomMealAnalysis } from '@/lib/analyzeCustomMeal';
import { INGREDIENT_COMPOSITIONS } from '@/lib/data/ingredientCompositions';
import { type IngredientSelection, type MealAnalysis } from '@/lib/analyzeCustomMeal';
import { getIngredientsForSpecies, mapIngredientToCompositionKey, ALL_INGREDIENTS, getIngredientDisplayName } from '@/lib/utils/allIngredients';
import { generateIngredientSuggestions } from '@/lib/utils/ingredientSuggestions';
import { getWhitelistForSpecies, isWhitelisted, getSpeciesCoverageLevel, getBlacklistForSpecies } from '@/lib/utils/ingredientWhitelists';
import IngredientPicker from '@/components/IngredientPicker';
import MealCompositionList from '@/components/MealCompositionList';
import CompatibilityPanel from '@/components/CompatibilityPanel';
import SuggestedIngredients from '@/components/SuggestedIngredients';
import MealBuilderWizard from '@/components/MealBuilderWizard';
import MealCompleteView from '@/components/MealCompleteView';
import { getPets } from '@/lib/utils/petStorage'; // Import async storage

// Style mapping for severity levels
const severityStyles = {
  critical: 'bg-red-50 border-red-200 text-red-800',
  major: 'bg-red-50 border-red-200 text-red-700',
  moderate: 'bg-orange-50 border-orange-200 text-orange-700',
};

const getSeverityIcon = (severity: string) => {
  switch (severity) {
    case 'critical':
      return <span className="text-red-600">‚ö†Ô∏è</span>;
    case 'major':
      return <span className="text-red-600">‚ö†Ô∏è</span>;
    default:
      return <span className="text-orange-600">‚ÑπÔ∏è</span>;
  }
};

const getProgressGradientColor = (score: number) => {
  if (score === 0) return '#dc2626'; // red-600
  if (score <= 10) return '#dc2626'; // red-600
  if (score <= 20) return '#ea580c'; // orange-600
  if (score <= 30) return '#d97706'; // amber-600
  if (score <= 40) return '#ca8a04'; // yellow-600
  if (score <= 50) return '#a3a3a3'; // gray-400 (neutral)
  if (score <= 60) return '#84cc16'; // lime-500
  if (score <= 70) return '#65a30d'; // lime-700
  if (score <= 80) return '#16a34a'; // green-600
  if (score <= 90) return '#15803d'; // green-700
  return '#166534'; // green-800
};

interface Pet {
  id: string;
  names: string[];
  type: string;
  breed: string;
  age: string;
  weight: string;
  healthConcerns?: string[];
  dietaryRestrictions?: string[];
  allergies?: string[];
  dislikes?: string[];
  image?: string;
  savedRecipes?: string[];
  weightKg?: number;
}

// Species-appropriate ingredient categories
const SPECIES_INGREDIENT_FILTERS = {
  dogs: {
    allowed: ['chicken_breast', 'ground_turkey', 'chicken_thighs', 'turkey_breast', 'chicken_liver', 'chicken_hearts',
              'salmon_atlantic', 'sardines_water', 'tuna_water',
              'ground_beef_lean', 'beef_liver',
              'eggs_whole',
              'kale_raw', 'spinach_raw', 'carrots_raw', 'sweet_potato', 'broccoli_raw',
              'blueberries_raw', 'bananas_raw',
              'brown_rice_cooked', 'oats', 'quinoa_cooked',
              'fish_oil'], // Meat-focused with some veggies
    disallowed: ['taurine_powder'], // Dogs can synthesize taurine
  },
  cats: {
    allowed: ['chicken_breast', 'ground_turkey', 'turkey_breast', 'chicken_liver', 'chicken_hearts',
              'salmon_atlantic', 'sardines_water', 'tuna_water',
              'eggs_whole',
              'brown_rice_cooked', 'quinoa_cooked',
              'taurine_powder', 'fish_oil'], // Taurine essential for cats, very meat-focused
    disallowed: ['ground_beef_lean', 'beef_liver'], // Many cats allergic/intolerant to beef
  },
  reptiles: {
    allowed: ['kale_raw', 'spinach_raw', 'carrots_raw', 'sweet_potato', 'broccoli_raw', 'celery_raw',
              'blueberries_raw', 'bananas_raw', 'eggs_whole',
              'calcium_carbonate'], // Vegetables and calcium (reptiles are often herbivores/omnivores)
    // Reptiles should use insects like crickets, dubia, etc. but those aren't in our current DB
    disallowed: ['chicken_breast', 'ground_turkey', 'ground_beef_lean', 'beef_liver', 'chicken_liver'],
  },
  birds: {
    allowed: [
      // Protein sources
      'eggs_whole', 'egg (hard-boiled)',
      // Seeds (protein sources for birds)
      'millet (white/red)', 'canary seed', 'niger seed', 'hemp seeds', 'flaxseeds',
      'sesame seeds', 'chia seeds', 'sunflower seeds (small amounts)', 'pumpkin seeds',
      'safflower seeds', 'nyjer seeds', 'amaranth seeds', 'wild bird mix',
      // Insects (for some bird species)
      'crickets', 'mealworms', 'superworms', 'black soldier fly larvae', 'hornworms',
      'dubia roaches', 'pinhead crickets',
      // Cooked lean meats (small amounts for some birds)
      'turkey_breast', 'chicken_breast',
      // Fruits, grains, vegetables, calcium
      'blueberries_raw', 'bananas_raw',
      'brown_rice_cooked', 'oats', 'quinoa_cooked',
      'kale_raw', 'spinach_raw', 'carrots_raw', 'broccoli_raw',
      'calcium_carbonate'
    ],
    disallowed: ['ground_beef_lean', 'beef_liver', 'chicken_liver'], // Raw meat not ideal for birds
  },
  'pocket-pets': {
    allowed: ['oats', 'quinoa_cooked', 'brown_rice_cooked',
              'kale_raw', 'spinach_raw', 'carrots_raw', 'broccoli_raw', 'celery_raw',
              'blueberries_raw', 'bananas_raw',
              'calcium_carbonate'], // Hay/pellet substitutes, veggies, fruits, calcium
    disallowed: ['chicken_breast', 'ground_turkey', 'ground_beef_lean', 'beef_liver', 'salmon_atlantic'],
  },
};

// Normalize pet type to match ALL_INGREDIENTS keys
const normalizeSpecies = (species: string): string => {
  const mapping: Record<string, string> = {
    'dog': 'dogs',
    'cat': 'cats',
    'bird': 'birds',
    'reptile': 'reptiles',
    'pocket-pet': 'pocket-pets',
    'dogs': 'dogs',
    'cats': 'cats',
    'birds': 'birds',
    'reptiles': 'reptiles',
    'pocket-pets': 'pocket-pets'
  };
  return mapping[species.toLowerCase()] || species;
};

// Get filtered ingredients based on pet species - ONLY show species-specific ingredients
const getAvailableIngredients = (species: string, bannedIngredients?: string[]): string[] => {
  const normalizedSpecies = normalizeSpecies(species);
  const filters = SPECIES_INGREDIENT_FILTERS[normalizedSpecies as keyof typeof SPECIES_INGREDIENT_FILTERS];

  // Get species-specific ingredients from scraped data (generate-recipes.js INGREDIENTS object)
  // This contains all the AAFCO and research-based ingredients for this species
  const scrapedIngredients = getIngredientsForSpecies(normalizedSpecies);
  
  // Return ALL scraped ingredient names - don't filter by composition key mapping
  // The composition keys will be looked up when needed for nutritional analysis
  const allIngredientNames = new Set<string>(scrapedIngredients);
  
  // Also include composition keys that are commonly used across species (universal ingredients)
  // but only if they're not explicitly disallowed
  const universalIngredients = [
    'eggs_whole', 'carrots_raw', 'broccoli_raw', 'spinach_raw', 
    'kale_raw', 'celery_raw', 'blueberries_raw', 'bananas_raw',
    'brown_rice_cooked', 'quinoa_cooked', 'sweet_potato', 'oats',
    'fish_oil', 'calcium_carbonate'
  ];
  
  universalIngredients.forEach(key => {
    if (!filters?.disallowed?.includes(key)) {
      // Convert composition key to readable name and add
      const displayName = key.split('_').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
      allIngredientNames.add(displayName);
    }
  });
  
  // Return all ingredient names (scraped names + universal ingredients)
  const mappedKeys = Array.from(allIngredientNames);

  let filtered = mappedKeys;
  
  if (filters) {
    // Filter out disallowed items
    filtered = filtered.filter(ing => !filters.disallowed?.includes(ing));
  }
  
  // Filter out banned ingredients (case-insensitive partial match)
  if (bannedIngredients && bannedIngredients.length > 0) {
    const bannedLower = bannedIngredients.map(b => b.toLowerCase());
    filtered = filtered.filter(ing => {
      const ingLower = ing.toLowerCase();
      return !bannedLower.some(banned => ingLower.includes(banned) || banned.includes(ingLower));
    });
  }

  return Array.from(filtered).sort();
};

// Categorize ingredients
const getCategorizedIngredients = (availableIngredients: string[], species: string) => {
  const normalizedSpecies = normalizeSpecies(species);
  const categories = {
    proteins: {
      name: 'Proteins',
      description: 'Main protein source',
      maxSelections: 999, // No limit - let users experiment
      icon: 'ü•©',
      ingredients: [] as string[]
    },
    greens: {
      name: 'Greens & Veggies',
      description: 'Vitamins and fiber',
      maxSelections: 999,
      icon: 'ü•¨',
      ingredients: [] as string[]
    },
    fruits: {
      name: 'Fruits',
      description: 'Natural sweetness and nutrients',
      maxSelections: 999,
      icon: 'üçé',
      ingredients: [] as string[]
    },
    grains: {
      name: 'Grains & Carbs',
      description: 'Energy source',
      maxSelections: 999,
      icon: 'üåæ',
      ingredients: [] as string[]
    },
    supplements: {
      name: 'Supplements',
      description: 'Essential nutrients',
      maxSelections: 999,
      icon: 'üíä',
      ingredients: [] as string[]
    }
  };

  // Special handling for cats (taurine is specifically marked as essential but can be added to supplements)
  if (normalizedSpecies === 'cats') {
    categories.supplements.description = 'Essential nutrients (taurine recommended)';
  }

  // Special handling for reptiles/herbivores (calcium is essential)
  if (['reptiles', 'pocket-pets'].includes(normalizedSpecies)) {
    categories.supplements.description = 'Essential minerals (calcium recommended)';
  }

  // Get species-specific ingredient categories from scraped data
  const speciesData = ALL_INGREDIENTS[normalizedSpecies as keyof typeof ALL_INGREDIENTS];
  
  if (speciesData) {
    // Map scraped ingredients to composition keys and categorize by species-specific categories
    Object.entries(speciesData).forEach(([categoryName, ingredientList]) => {
      if (Array.isArray(ingredientList)) {
        ingredientList.forEach(ingName => {
          // Use the ingredient name directly (not the composition key) for display
          // Only add if it's in availableIngredients (species-filtered)
          if (availableIngredients.includes(ingName)) {
            // Map category names to our 5 categories based on species
            // Use ingredient name directly (not composition key) for display
            if (categoryName === 'proteins' || categoryName === 'insects' || 
                (normalizedSpecies === 'birds' && categoryName === 'seeds')) {
              // For birds, seeds are protein sources
              if (!categories.proteins.ingredients.includes(ingName)) {
                categories.proteins.ingredients.push(ingName);
              }
            } else if (categoryName === 'vegetables' || categoryName === 'hay') {
              if (!categories.greens.ingredients.includes(ingName)) {
                categories.greens.ingredients.push(ingName);
              }
            } else if (categoryName === 'fruits') {
              if (!categories.fruits.ingredients.includes(ingName)) {
                categories.fruits.ingredients.push(ingName);
              }
            } else if (categoryName === 'carbs' || categoryName === 'seeds' || categoryName === 'pellets' || categoryName === 'hamster_additions') {
              // Seeds go to grains for non-bird species
              if (!categories.grains.ingredients.includes(ingName)) {
                categories.grains.ingredients.push(ingName);
              }
            } else if (categoryName === 'fats' || categoryName === 'fiber_supplements' || categoryName === 'supplements') {
              if (!categories.supplements.ingredients.includes(ingName)) {
                categories.supplements.ingredients.push(ingName);
              }
            }
          }
        });
      }
    });
  }
  
  // Also categorize any remaining ingredients that weren't in scraped data
  availableIngredients.forEach(ingName => {
    // Skip if already categorized
    const allCategorized = [
      ...categories.proteins.ingredients,
      ...categories.greens.ingredients,
      ...categories.fruits.ingredients,
      ...categories.grains.ingredients,
      ...categories.supplements.ingredients
    ];
    if (allCategorized.includes(ingName)) return;
    
    const keyLower = ingName.toLowerCase();
    
    // Proteins: meat, fish, eggs, insects
    if (keyLower.includes('chicken') || keyLower.includes('turkey') || 
        keyLower.includes('beef') || keyLower.includes('liver') || 
        keyLower.includes('hearts') || keyLower.includes('salmon') || 
        keyLower.includes('tuna') || keyLower.includes('sardines') ||
        keyLower.includes('duck') || keyLower.includes('venison') ||
        keyLower.includes('rabbit') || keyLower.includes('quail') ||
        keyLower.includes('pork') || keyLower.includes('giblets') ||
        keyLower.includes('eggs') || keyLower.includes('egg') ||
        keyLower.includes('cricket') || keyLower.includes('roach') ||
        keyLower.includes('worm') || keyLower.includes('insect')) {
      categories.proteins.ingredients.push(ingName);
    } 
    // Greens & Vegetables
    else if (keyLower.includes('kale') || keyLower.includes('spinach') || 
             keyLower.includes('carrot') || keyLower.includes('broccoli') || 
             keyLower.includes('celery') || keyLower.includes('bok') ||
             keyLower.includes('choy') || keyLower.includes('green bean') ||
             keyLower.includes('peas') || keyLower.includes('zucchini') ||
             keyLower.includes('brussels') || keyLower.includes('asparagus') ||
             keyLower.includes('cucumber') || keyLower.includes('lettuce') ||
             keyLower.includes('cabbage') || keyLower.includes('cauliflower') ||
             keyLower.includes('hay')) {
      categories.greens.ingredients.push(ingName);
    } 
    // Fruits
    else if (keyLower.includes('blueberr') || keyLower.includes('banana') ||
             keyLower.includes('apple') || keyLower.includes('berry') ||
             keyLower.includes('mango') || keyLower.includes('papaya') ||
             keyLower.includes('strawberr') || keyLower.includes('grape')) {
      categories.fruits.ingredients.push(ingName);
    } 
    // Grains & Carbs
    else if (keyLower.includes('rice') || keyLower.includes('quinoa') || 
             keyLower.includes('oats') || keyLower.includes('barley') ||
             keyLower.includes('sweet potato') || keyLower.includes('potato') ||
             keyLower.includes('pumpkin') || keyLower.includes('squash') ||
             keyLower.includes('lentil') || keyLower.includes('bean') ||
             keyLower.includes('chickpea') || keyLower.includes('grain') ||
             keyLower.includes('amaranth') || keyLower.includes('buckwheat') ||
             keyLower.includes('millet') || keyLower.includes('sorghum') ||
             keyLower.includes('farro') || keyLower.includes('bulgur') ||
             keyLower.includes('seed') || keyLower.includes('pellet')) {
      categories.grains.ingredients.push(ingName);
    } 
    // Supplements
    else if (keyLower.includes('oil') || keyLower.includes('calcium') || 
             keyLower.includes('taurine') || keyLower.includes('supplement') ||
             keyLower.includes('vitamin') || keyLower.includes('probiotic') ||
             keyLower.includes('psyllium') || keyLower.includes('joint')) {
      categories.supplements.ingredients.push(ingName);
    }
    // Default: add to greens if not categorized
    else {
      categories.greens.ingredients.push(ingName);
    }
  });

  return categories;
};

export default function RecipeBuilderPage() {
  const params = useParams();
  const router = useRouter();
  const petId = params.id as string;

  const [pet, setPet] = useState<Pet | null>(null);
  const [selectedIngredients, setSelectedIngredients] = useState<IngredientSelection[]>([]);
  const [analysis, setAnalysis] = useState<MealAnalysis | null>(null);
  const [isAnalyzing, setIsAnalyzing] = useState(false);
  const [showWizard, setShowWizard] = useState(false);
  const [wizardCompleted, setWizardCompleted] = useState(false);
  const [showAddMore, setShowAddMore] = useState(false);
  const [hasAppliedRecommended, setHasAppliedRecommended] = useState(false);
  const [isFirstCreation, setIsFirstCreation] = useState(false); // Track if this is the first creation
  const [recommendedMeals, setRecommendedMeals] = useState<any[]>([]); // Store recommended meals

  // Get species-appropriate ingredients and categories
  const normalizedSpeciesType = pet ? normalizeSpecies(pet.type) : null;
  const speciesCoverageLevel = normalizedSpeciesType ? getSpeciesCoverageLevel(normalizedSpeciesType as any) : 'limited';
  const blacklist = normalizedSpeciesType ? getBlacklistForSpecies(normalizedSpeciesType as any) : [];
  
  // Filter available ingredients through whitelist
  const allAvailableIngredients = pet ? getAvailableIngredients(pet.type, (pet as any).bannedIngredients) : [];
  const whitelist = normalizedSpeciesType ? getWhitelistForSpecies(normalizedSpeciesType as any) : [];
  const availableIngredients = whitelist.length > 0 
    ? allAvailableIngredients.filter(ing => isWhitelisted(ing, normalizedSpeciesType as any))
    : allAvailableIngredients; // Fallback to all if no whitelist data
  
  const categorizedIngredients = pet ? getCategorizedIngredients(availableIngredients, pet.type) : null;
  
  // Generate base suggestions from static rules
  const baseSuggestedIngredients = pet ? generateIngredientSuggestions({
    type: pet.type,
    age: pet.age,
    healthConcerns: pet.healthConcerns || [],
    breed: pet.breed
  }) : [];
  
  // Extract ingredients from recommended meals and merge with base suggestions
  const suggestedIngredients = (() => {
    if (!pet || recommendedMeals.length === 0) {
      return baseSuggestedIngredients;
    }
    
    // Extract unique ingredients from top 5 recommended meals
    const ingredientsFromMeals = new Map<string, { name: string; reason: string; category: string; fromMeal: boolean }>();
    
    recommendedMeals.slice(0, 5).forEach((meal: any) => {
      const mealIngredients = meal.recipe?.ingredients || meal.adjustedIngredients || [];
      mealIngredients.forEach((ing: any) => {
        const ingName = ing.name || ing.productName || '';
        if (ingName && !ingredientsFromMeals.has(ingName)) {
          // Try to categorize the ingredient
          const nameLower = ingName.toLowerCase();
          let category = 'Other';
          if (nameLower.includes('liver') || nameLower.includes('heart') || nameLower.includes('chicken') || 
              nameLower.includes('turkey') || nameLower.includes('duck') || nameLower.includes('salmon') ||
              nameLower.includes('beef') || nameLower.includes('fish') || nameLower.includes('meat')) {
            category = 'Proteins';
          } else if (nameLower.includes('squash') || nameLower.includes('greens') || nameLower.includes('kale') ||
                     nameLower.includes('spinach') || nameLower.includes('carrot') || nameLower.includes('broccoli') ||
                     nameLower.includes('dandelion') || nameLower.includes('vegetable')) {
            category = 'Greens & Veggies';
          } else if (nameLower.includes('rice') || nameLower.includes('quinoa') || nameLower.includes('oats') ||
                     nameLower.includes('grain') || nameLower.includes('carb')) {
            category = 'Grains & Carbs';
          } else if (nameLower.includes('oil') || nameLower.includes('supplement') || nameLower.includes('powder') ||
                     nameLower.includes('currant') || nameLower.includes('vitamin')) {
            category = 'Supplements';
          } else if (nameLower.includes('berry') || nameLower.includes('apple') || nameLower.includes('banana') ||
                     nameLower.includes('fruit')) {
            category = 'Fruits';
          }
          
          ingredientsFromMeals.set(ingName, {
            name: ingName,
            reason: `Found in your top recommended meals - ${meal.recipe?.name || 'recommended meal'}`,
            category,
            fromMeal: true
          });
        }
      });
    });
    
    // Merge with base suggestions, prioritizing ingredients from meals
    const merged = new Map<string, { name: string; reason: string; category: string }>();
    
    // First add ingredients from recommended meals (higher priority)
    ingredientsFromMeals.forEach((ing) => {
      merged.set(ing.name, { name: ing.name, reason: ing.reason, category: ing.category });
    });
    
    // Then add base suggestions (if not already present)
    baseSuggestedIngredients.forEach((ing) => {
      if (!merged.has(ing.name)) {
        merged.set(ing.name, ing);
      }
    });
    
    return Array.from(merged.values()).slice(0, 12); // Limit to 12 total suggestions
  })();
  
  // Extract recommended ingredient names for wizard
  const recommendedIngredientNames = suggestedIngredients.map(s => s.name);
  
  // Debug logging (remove in production)
  useEffect(() => {
    if (pet && availableIngredients.length > 0) {
      // Debug logging removed for production
    }
  }, [pet, availableIngredients.length, categorizedIngredients]);

  // Load pet data and fetch recommended meals
  useEffect(() => {
    const loadPetData = async () => {
      if (typeof window !== 'undefined') {
        const userId = localStorage.getItem('last_user_id') || 'clerk_simulated_user_id_123';
        
        try {
          const pets = await getPets(userId);
          const foundPet = pets.find((p: any) => p.id === petId);
          
          if (foundPet) {
            setPet(foundPet as unknown as Pet);
            // Show wizard on initial load if no ingredients selected
            if (selectedIngredients.length === 0 && !wizardCompleted) {
              setShowWizard(true);
            }
            
            // Fetch recommended meals... (rest of logic)
            const concerns = (foundPet.healthConcerns || []).filter((concern: string) => concern !== 'none');
            const allergies = (foundPet as any).allergies?.filter((allergy: string) => allergy !== 'none') || [];
            // Use random name from pet's names array
            const petNames = Array.isArray(foundPet.names) ? foundPet.names.filter((n: string) => n && n.trim() !== '') : [];
            const petDisplayName = petNames.length > 0 
              ? petNames[Math.floor(Math.random() * petNames.length)]
              : 'Your Pet';
            
            try {
              const response = await fetch('/api/recommendations', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  profile: {
                    species: foundPet.type,
                    ageGroup: foundPet.age,
                    breed: foundPet.breed,
                    weightKg: parseFloat(foundPet.weight?.replace(/[^0-9.]/g, '') || '10'),
                    healthConcerns: concerns,
                    allergies,
                    petName: petDisplayName,
                  },
                  limit: 5, // Only need top 5 for ingredient extraction
                }),
              });

              if (response.ok) {
                const data = await response.json();
                if (data?.results && Array.isArray(data.results)) {
                  setRecommendedMeals(data.results);
                }
              }
            } catch (error) {
              // Failed to fetch recommended meals
            }
          }
        } catch (error) {
          console.error("Error loading pet:", error);
        }
      }
    };

    loadPetData();
  }, [petId]);

  // Handle wizard completion
  const handleWizardComplete = (selections: { [category: string]: string[] }) => {
    // Convert wizard selections to IngredientSelection format
    const ingredients: IngredientSelection[] = [];
    
    Object.entries(selections).forEach(([category, ingredientNames]) => {
      if (ingredientNames && ingredientNames.length > 0) {
        // Start with a reasonable default based on category
        let defaultGrams = 50;
        if (category === 'proteins') defaultGrams = 100; // More protein
        else if (category === 'grains') defaultGrams = 60;
        else if (category === 'greens') defaultGrams = 40;
        else if (category === 'fruits') defaultGrams = 20;
        else if (category === 'supplements') defaultGrams = 5;
        
        // Add all selected ingredients from this category
        ingredientNames.forEach(ingredientName => {
          ingredients.push({
            key: ingredientName,
            grams: defaultGrams
          });
        });
      }
    });

    setSelectedIngredients(ingredients);
    setWizardCompleted(true);
    setShowWizard(false);
    setIsFirstCreation(true); // Mark as first creation to show popup
    
    // Analysis will be triggered automatically by the useEffect when ingredients change
    // After analysis completes, we can update to recommended amounts
  };

  // Handle start over
  const handleStartOver = () => {
    setSelectedIngredients([]);
    setAnalysis(null);
    setWizardCompleted(false);
    setShowWizard(true);
    setShowAddMore(false);
    setHasAppliedRecommended(false);
    setIsFirstCreation(false); // Reset first creation flag
  };

  // Handle add more ingredients
  const handleAddMore = () => {
    setShowAddMore(true);
  };

  // Auto-analyze recipe when ingredients change
  useEffect(() => {
    const analyzeRecipe = async () => {
      if (selectedIngredients.length > 0 && pet) {
        setIsAnalyzing(true);
        try {
          const petProfile = {
            id: pet.id,
            name: pet.names[0] || 'Pet',
            species: pet.type as any,
            lifeStage: pet.age as any, // Maps to 'adult', 'juvenile', etc.
            weightKg: parseFloat(pet.weight?.replace(/[^0-9.]/g, '')) || 5,
            allergies: [],
            activity: 'moderate' as const, // Default activity level
          };

          // Map ingredient display names to composition keys for analysis
          const mappedIngredients = selectedIngredients.map(sel => {
            const compositionKey = mapIngredientToCompositionKey(sel.key) || sel.key.toLowerCase().replace(/\s+/g, '_').replace(/[^a-z0-9_]/g, '');
            return {
              key: compositionKey,
              grams: sel.grams
            };
          });
          
          const result = generateCustomMealAnalysis(petProfile, mappedIngredients);
          setAnalysis(result);
          
          // After first analysis from wizard, auto-apply recommended amounts once
          if (result.recommendedServingGrams > 0 && selectedIngredients.length > 0 && wizardCompleted && !hasAppliedRecommended) {
            const currentTotal = selectedIngredients.reduce((sum, s) => sum + s.grams, 0);
            if (currentTotal > 0) {
              const recommendedTotal = result.recommendedServingGrams;
              const updatedIngredients = selectedIngredients.map(ing => {
                const ratio = ing.grams / currentTotal;
                return {
                  ...ing,
                  grams: Math.round(recommendedTotal * ratio)
                };
              });
              setSelectedIngredients(updatedIngredients);
              setHasAppliedRecommended(true);
            }
          }
        } catch (error) {
          // Analysis error - handled by error state
        } finally {
          setIsAnalyzing(false);
        }
      } else {
        setAnalysis(null);
      }
    };

    const debounceTimer = setTimeout(analyzeRecipe, 500);
    return () => clearTimeout(debounceTimer);
  }, [selectedIngredients, pet]);

  const addIngredient = (ingredientKey: string) => {
    // Check if ingredient is whitelisted for this species
    if (normalizedSpeciesType && whitelist.length > 0) {
      // ingredientKey might be a display name already, try both
      const displayName = ingredientKey; // Assume it's already a display name from the picker
      if (!isWhitelisted(displayName, normalizedSpeciesType as any)) {
        // Show warning but allow (user can override with vet approval)
        const confirmed = window.confirm(
          `${displayName} is not in the recommended whitelist for ${pet?.type}.\n\n` +
          `This ingredient may not be safe for this species. Please check with your vet before using.\n\n` +
          `Do you want to add it anyway?`
        );
        if (!confirmed) return;
      }
    }
    
    const existing = selectedIngredients.find(s => s.key === ingredientKey);
    if (existing) {
      setSelectedIngredients(prev =>
        prev.map(s =>
          s.key === ingredientKey
            ? { ...s, grams: s.grams + 50 }
            : s
        )
      );
    } else {
      setSelectedIngredients(prev => [...prev, { key: ingredientKey, grams: 50 }]);
    }
  };

  const removeIngredient = (ingredientKey: string) => {
    setSelectedIngredients(prev => prev.filter(s => s.key !== ingredientKey));
  };

  const updateIngredientGrams = (ingredientKey: string, grams: number) => {
    if (grams <= 0) {
      removeIngredient(ingredientKey);
      return;
    }

    setSelectedIngredients(prev =>
      prev.map(s =>
        s.key === ingredientKey
          ? { ...s, grams: Math.round(grams) }
          : s
      )
    );
  };

  const totalGrams = selectedIngredients.reduce((sum, s) => sum + s.grams, 0);

  if (!pet) {
    return (
      <div className="min-h-screen flex items-center justify-center" style={{ backgroundColor: '#0f2c0f' }}>
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-green-400"></div>
        <span className="ml-3 text-gray-300">Loading pet data...</span>
      </div>
    );
  }

  // Prepare categories for wizard
  const proteinRequired = !['pocket-pets', 'reptiles'].includes((normalizedSpeciesType || '').toLowerCase());

  const wizardCategories = categorizedIngredients ? {
    proteins: {
      ...categorizedIngredients.proteins,
      required: proteinRequired && categorizedIngredients.proteins.ingredients.length > 0
    },
    grains: {
      ...categorizedIngredients.grains,
      required: false
    },
    greens: {
      ...categorizedIngredients.greens,
      required: false
    },
    fruits: {
      ...categorizedIngredients.fruits,
      required: false
    },
    supplements: {
      ...categorizedIngredients.supplements,
      required: false
    }
  } : null;

  // Show wizard if not completed and no ingredients
  if (showWizard && wizardCategories) {
    return (
      <>
        {/* Species Coverage Badge */}
        {normalizedSpeciesType && (
          <div className="border-b px-4 py-2" style={{ backgroundColor: '#1a3d2e', borderColor: '#2d5a47' }}>
            <div className="max-w-7xl mx-auto flex items-center justify-between">
              <div className="flex items-center gap-2">
                <span className="text-sm text-gray-300">Ingredient Coverage:</span>
                <span className={`px-2 py-1 rounded text-xs font-semibold ${
                  speciesCoverageLevel === 'full' ? 'bg-green-100 text-green-800' :
                  speciesCoverageLevel === 'beta' ? 'bg-yellow-100 text-yellow-800' :
                  'bg-gray-100 text-gray-800'
                }`}>
                  {speciesCoverageLevel === 'full' ? '‚úì Full Coverage' :
                   speciesCoverageLevel === 'beta' ? 'Œ≤ Beta (Expanding)' :
                   '‚ö† Limited Data'}
                </span>
                {blacklist.length > 0 && (
                  <span className="text-xs text-gray-500">
                    ({blacklist.length} ingredients to avoid)
                  </span>
                )}
              </div>
            </div>
          </div>
        )}
        <MealBuilderWizard
          isOpen={showWizard}
          onClose={() => setShowWizard(false)}
          onComplete={handleWizardComplete}
          categories={wizardCategories}
          petName={pet.names[0] || 'Pet'}
          petType={normalizedSpeciesType || pet.type}
          recommendedIngredients={recommendedIngredientNames}
        />
        <div className="min-h-screen" style={{ backgroundColor: '#0f2c0f' }} />
      </>
    );
  }

  // Show meal complete view after wizard or if ingredients exist
  if (wizardCompleted || selectedIngredients.length > 0) {
    return (
      <>
        <MealCompleteView
          petName={pet.names[0] || 'Pet'}
          petBreed={pet.breed}
          petAge={pet.age}
          petWeight={pet.weight}
          petId={petId}
          userId={localStorage.getItem('last_user_id') || 'clerk_simulated_user_id_123'}
          selectedIngredients={selectedIngredients}
          analysis={analysis}
          isAnalyzing={isAnalyzing}
          onUpdateAmount={updateIngredientGrams}
          onRemove={removeIngredient}
          onAddMore={handleAddMore}
          onStartOver={handleStartOver}
          petType={pet.type}
          getIngredientDisplayName={(key) => {
            // Normalize key to match vetted products
            const normalized = key
              .toLowerCase()
              .replace(/_/g, ' ')      // chicken_breast ‚Üí chicken breast
              .replace(/-/g, ' ')      // chicken-breast ‚Üí chicken breast
              .trim();
            
            // Try to find display name in vetted products
            const product = require('@/lib/data/vetted-products').getVettedProduct(normalized);
            return product?.productName || normalized;
          }}
          isFirstCreation={isFirstCreation}
          getCompatibilityIndicator={(key) => {
            if (!analysis) return null;
            const hasToxicityWarning = analysis.toxicityWarnings.some(w => 
              w.ingredientKey === key || (w.ingredientName && w.ingredientName.toLowerCase().includes(key.toLowerCase()))
            );
            if (hasToxicityWarning) return 'blocked';
            const hasAllergyWarning = analysis.allergyWarnings.some(w => 
              (typeof w === 'string' ? w : w.message).toLowerCase().includes(key.toLowerCase())
            );
            if (hasAllergyWarning) return 'warning';
            return 'safe';
          }}
        />

        {/* Add More Ingredients Modal/View */}
        {showAddMore && categorizedIngredients && (
          <div className="fixed inset-0 z-50 bg-black bg-opacity-50 flex items-center justify-center p-4">
            <div className="bg-white rounded-lg shadow-xl max-w-6xl w-full max-h-[95vh] overflow-y-auto">
              <div className="p-6 border-b border-gray-200 flex items-center justify-between sticky top-0 bg-white z-10">
                <h2 className="text-xl font-bold text-gray-100">Add More Ingredients</h2>
                <button
                  onClick={() => setShowAddMore(false)}
                  className="p-2 hover:opacity-80 rounded-full transition-colors"
                  style={{ backgroundColor: '#2d5a47' }}
                >
                  <X size={20} className="text-gray-200" />
                </button>
              </div>
              <div className="p-6">
                {/* Recommended Ingredients Quick Add */}
                {suggestedIngredients.length > 0 && (
                  <div className="mb-6">
                    <div className="flex items-center gap-2 mb-3">
                      <span className="text-sm font-semibold text-gray-200">Recommended Additions:</span>
                      <span className="text-xs text-gray-400">Click to add quickly</span>
                    </div>
                    <div className="flex flex-wrap gap-2">
                      {suggestedIngredients
                        .filter(sug => !selectedIngredients.some(sel => sel.key === sug.name))
                        .slice(0, 12)
                        .map((suggestion, idx) => {
                          // Check if this ingredient comes from recommended meals
                          const fromMeal = recommendedMeals.some((meal: any) => {
                            const mealIngredients = meal.recipe?.ingredients || meal.adjustedIngredients || [];
                            return mealIngredients.some((ing: any) => 
                              (ing.name || ing.productName || '').toLowerCase() === suggestion.name.toLowerCase()
                            );
                          });
                          
                          return (
                            <button
                              key={idx}
                              onClick={() => {
                                addIngredient(suggestion.name);
                              }}
                              className={`flex items-center gap-1.5 px-2.5 py-1 rounded-md text-xs font-medium transition-opacity ${
                                fromMeal
                                  ? 'bg-green-50 border border-green-300 text-green-900 hover:opacity-80'
                                  : 'bg-blue-50 border border-blue-200 text-blue-900 hover:opacity-80'
                              }`}
                              title={suggestion.reason}
                            >
                              <span>{fromMeal ? '‚ú®' : '‚≠ê'}</span>
                              <span>{suggestion.name}</span>
                              {fromMeal && (
                                <span className="text-xs opacity-75">(from meals)</span>
                              )}
                            </button>
                          );
                        })}
                    </div>
                    {suggestedIngredients.filter(sug => !selectedIngredients.some(sel => sel.key === sug.name)).length === 0 && (
                      <p className="text-xs text-gray-500 italic">All recommended ingredients have been added</p>
                    )}
                  </div>
                )}

                {/* Search Bar */}
                <div className="mb-4">
                  <IngredientPicker
                    ingredients={availableIngredients.map(name => {
                      let category = 'Other';
                      for (const [catKey, cat] of Object.entries(categorizedIngredients)) {
                        if (cat.ingredients.includes(name)) {
                          category = cat.name;
                          break;
                        }
                      }
                      return { name, category };
                    })}
                    categories={categorizedIngredients}
                    onSelect={(ingredientName) => {
                      addIngredient(ingredientName);
                    }}
                    disabled={isAnalyzing}
                  />
                </div>
              </div>
            </div>
          </div>
        )}
      </>
    );
  }

  // Fallback: show original builder (shouldn't reach here normally)
  return (
    <div className="min-h-screen flex items-center justify-center" style={{ backgroundColor: '#0f2c0f' }}>
      <div className="text-center">
        <p className="text-gray-300 mb-4">Starting meal builder...</p>
        <button
          onClick={() => setShowWizard(true)}
          className="px-4 py-2 text-white rounded-md hover:opacity-90"
          style={{ backgroundColor: '#16a34a' }}
        >
          Start Wizard
        </button>
      </div>
    </div>
  );
}
</file>

<file path="app/profile/pet/[id]/saved-recipes/page.tsx">
'use client';

import React, { useState, useEffect, useMemo } from 'react';
import { useParams, useRouter } from 'next/navigation';
import Link from 'next/link';
import { HeartOff, ArrowLeft, Utensils, Clock, Trash2 } from 'lucide-react';
import { getCustomMeals, deleteCustomMeal } from '@/lib/utils/customMealStorage';
import { getPets, savePet } from '@/lib/utils/petStorage'; // Import async storage
import type { CustomMeal, Pet } from '@/lib/types';

// Same simulated user ID setup as profile/page.tsx
const SIMULATED_USER_ID = 'clerk_simulated_user_id_123';

const getCurrentUserId = () => {
  if (typeof window === 'undefined') return SIMULATED_USER_ID;
  return localStorage.getItem('last_user_id') || SIMULATED_USER_ID;
};

export default function SavedRecipesPage() {
  const { id: petId } = useParams();
  const router = useRouter();
  const [pet, setPet] = useState<Pet | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [userId, setUserId] = useState<string | null>(null);
  const [customMeals, setCustomMeals] = useState<CustomMeal[]>([]);

  // Load pet and custom meals - async function
  const loadData = async () => {
    const uid = getCurrentUserId();
    setUserId(uid);

    if (!petId) {
      setIsLoading(false);
      return;
    }

    const resolvedPetId = Array.isArray(petId) ? petId[0] : petId;
    
    try {
      // Load pets and find the current pet
      const pets = await getPets(uid);
      const foundPet = pets.find((p) => p.id === resolvedPetId);
      setPet(foundPet || null);
      
      // Load custom meals for this pet
      const meals = await getCustomMeals(uid, resolvedPetId);
      setCustomMeals(meals);
    } catch (error) {
      console.error('Error loading pet data:', error);
    } finally {
      setIsLoading(false);
    }
  };

  // Load pet and custom meals from storage
  useEffect(() => {
    loadData();
  }, [petId]);

  // Listen for updates to pets and custom meals
  useEffect(() => {
    if (typeof window === 'undefined') return;

    const handlePetsUpdated = (e: CustomEvent) => {
      // Refresh if pets were updated
      if (e.detail?.userId === getCurrentUserId()) {
        loadData();
      }
    };

    const handleStorageChange = (e: StorageEvent) => {
      // Refresh if pets or custom meals storage was modified (cross-tab/window)
      const uid = getCurrentUserId();
      if (e.key === `pets_${uid}` || e.key?.startsWith(`custom_meals_${uid}_`)) {
        loadData();
      }
    };

    window.addEventListener('petsUpdated', handlePetsUpdated as EventListener);
    window.addEventListener('storage', handleStorageChange);

    return () => {
      window.removeEventListener('petsUpdated', handlePetsUpdated as EventListener);
      window.removeEventListener('storage', handleStorageChange);
    };
  }, [petId]);

  // Map saved recipe IDs and custom meals to display format
  const savedRecipeDetails = useMemo(() => {
    const allMeals: {
      id: string;
      name: string;
      dateAdded?: number;
      isCustom?: boolean;
      compatibilityScore?: number;
    }[] = [];
    
    // Add custom meals (with compatibility score)
    customMeals.forEach((meal) => {
      allMeals.push({
        id: meal.id,
        name: meal.name,
        dateAdded: meal.createdAt ? new Date(meal.createdAt).getTime() : undefined,
        isCustom: true,
        compatibilityScore: meal.analysis?.score,
      });
    });
    
    return allMeals;
  }, [pet, customMeals]);

  const handleRemoveRecipe = async (recipeIdToRemove: string, isCustom: boolean = false) => {
    if (!userId || !pet) return;

    if (isCustom) {
      // Remove custom meal
      await deleteCustomMeal(userId, pet.id, recipeIdToRemove);
      setCustomMeals(prev => prev.filter(m => m.id !== recipeIdToRemove));
    } else {
      // Update the pet's savedRecipes array
      const updatedPet: Pet = {
        ...pet,
        savedRecipes: (pet.savedRecipes || []).filter(id => id !== recipeIdToRemove),
      };

      await savePet(userId, updatedPet);
      setPet(updatedPet);
    }
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-screen bg-gray-50">
        <p className="text-xl text-green-800 font-medium">Loading pet profile...</p>
      </div>
    );
  }

  if (!pet) {
    return (
      <div className="max-w-4xl mx-auto py-12 px-4 text-center">
        <HeartOff className="w-16 h-16 text-red-500 mx-auto mb-4" />
        <h1 className="text-3xl font-bold text-gray-900 mb-2">Pet Not Found</h1>
        <p className="text-gray-600">
          We couldn't find a pet with the ID:{' '}
          <span className="font-mono bg-gray-100 p-1 rounded text-sm">{String(petId)}</span>.
        </p>
        <Link
          href="/profile"
          className="mt-6 inline-flex items-center text-green-800 hover:text-green-900 transition-colors font-medium"
        >
          <ArrowLeft className="w-5 h-5 mr-2" /> Back to Pet Profiles
        </Link>
      </div>
    );
  }

  const hasSaved = savedRecipeDetails.length > 0;

  // Get random name from pet's names array
  const petNames = Array.isArray((pet as any).names) ? (pet as any).names.filter((n: string) => n && n.trim() !== '') : [];
  const petDisplayName = petNames.length > 0 
    ? petNames[Math.floor(Math.random() * petNames.length)]
    : (pet.name || 'Your Pet');

  return (
    <div className="min-h-screen bg-gray-50 py-4">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <Link
          href="/profile"
          className="inline-flex items-center text-gray-500 hover:text-green-800 transition-colors mb-3 text-sm"
        >
          <ArrowLeft className="w-4 h-4 mr-1" /> Back to Pet Profiles
        </Link>

        <header className="mb-4 p-3 bg-white rounded-lg shadow border-l-4 border-primary-600">
          <h1 className="text-xl font-bold text-gray-900 flex items-center">
            <Utensils className="w-5 h-5 mr-2 text-primary-600" />
            Saved Meals for {petDisplayName}
          </h1>
          <p className="text-sm text-gray-600 mt-1">
            A curated collection for your <span className="capitalize font-medium">{pet.type}</span>, the {pet.breed}.
          </p>
        </header>

        {hasSaved && (
          <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3 mb-6">
            <p className="text-sm text-gray-600">
              {savedRecipeDetails.length} meals saved for {petDisplayName}.
            </p>
            <button
              onClick={() => router.push(`/profile/pet/${pet.id}/meal-plan`)}
              disabled={savedRecipeDetails.length < 2}
              className={`px-5 py-3 rounded-lg font-semibold transition-colors ${
                savedRecipeDetails.length < 2
                  ? 'bg-gray-200 text-gray-500 cursor-not-allowed'
                  : 'bg-green-800 text-white hover:bg-green-900'
              }`}
            >
              Create Meal Plan
            </button>
          </div>
        )}

        <div className="space-y-4">
          {hasSaved ? (
            savedRecipeDetails.map((recipe) => (
              <div
                key={recipe.id}
                className="flex items-center p-4 bg-white rounded-xl shadow hover:shadow-md transition-shadow justify-between"
              >
                <Link
                  href={`/recipe/${recipe.id}?petId=${pet.id}`}
                  className="flex items-center flex-grow group"
                >
                  <div className="ml-0 flex-1">
                    <div className="flex items-center gap-2 flex-wrap">
                      <p className="text-lg font-semibold text-gray-800 group-hover:text-primary-600 transition-colors">
                        {recipe.name}
                      </p>
                      {recipe.isCustom && (
                        <span className="text-xs bg-blue-100 text-blue-800 px-2 py-0.5 rounded-full font-medium">
                          Custom
                        </span>
                      )}
                      {recipe.isCustom && recipe.compatibilityScore !== undefined && (
                        <div className="flex items-center gap-1.5 px-2 py-0.5 rounded-full bg-gray-100">
                          <span className="text-xs font-medium text-gray-600">Score:</span>
                          <span className={`text-xs font-bold ${
                            recipe.compatibilityScore >= 80 ? 'text-green-600' :
                            recipe.compatibilityScore >= 60 ? 'text-yellow-600' :
                            'text-red-600'
                          }`}>
                            {recipe.compatibilityScore}
                          </span>
                        </div>
                      )}
                    </div>
                    {recipe.dateAdded && (
                      <div className="flex items-center text-sm text-gray-500 mt-1">
                        <Clock className="w-3 h-3 mr-1" />
                        <span>
                          Saved: {new Date(recipe.dateAdded).toLocaleDateString()}
                        </span>
                      </div>
                    )}
                  </div>
                </Link>

                <button
                  onClick={() => handleRemoveRecipe(recipe.id, recipe.isCustom)}
                  className="ml-4 p-2 text-red-500 hover:bg-red-50 rounded-full transition-colors"
                  aria-label={`Remove ${recipe.name}`}
                >
                  <Trash2 className="w-5 h-5" />
                </button>
              </div>
            ))
          ) : (
            <div className="text-center p-10 bg-white rounded-xl shadow-inner border border-gray-200">
              <HeartOff className="w-12 h-12 text-gray-400 mx-auto mb-3" />
              <p className="text-xl font-medium text-gray-700">No Saved Meals Yet!</p>
              <p className="text-gray-500 mt-2">
                Start by browsing our catalog to find the perfect meal for {petDisplayName}.
              </p>
              <Link
                href={`/profile/pet/${pet.id}`}
                className="mt-4 inline-block px-6 py-2 bg-green-800 text-white rounded-lg hover:bg-green-900 transition-colors font-medium shadow-md"
              >
                Find Meals
              </Link>
            </div>
          )}
        </div>
      </div>

      <p className="fixed bottom-4 right-4 text-xs text-gray-400">
        Current User ID: {userId || 'Unknown'} (Pet ID: {String(petId)})
      </p>
    </div>
  );
}
</file>

<file path="app/recipe/[id]/page.tsx">
'use client';

import { useState, useEffect, useCallback, useMemo } from 'react';
import { useParams, useSearchParams } from 'next/navigation';
import Link from 'next/link';
import Image from 'next/image';
import {
  Clock,
  User,
  Star,
  ChevronLeft,
  X,
  ShoppingCart,
} from 'lucide-react';

import { loadRecipeById, loadAllRecipes } from '@/lib/data/recipes-index';
import type { Recipe, ModifiedRecipeResult } from '@/lib/types';
import { applyModifiers } from '@/lib/applyModifiers';
import { getVettedProduct, getVettedProductByAnyIdentifier, VETTED_PRODUCTS, getGenericIngredientName } from '@/lib/data/vetted-products';
import { petSupplements } from '@/lib/data/supplements';
import Tooltip from '@/components/Tooltip';
import { RecipeRatingSection } from '@/components/RecipeRatingSection';
import { calculateEnhancedCompatibility, type Pet as EnhancedPet } from '@/lib/utils/enhancedCompatibilityScoring';
import RecipeScoreModal from '@/components/RecipeScoreModal';
import { getRandomName, type Pet } from '@/lib/utils/petUtils';
import OneClickCheckoutModal from '@/components/OneClickCheckoutModal';
import { ShoppingList } from '@/components/ShoppingList';
import { CostComparison } from '@/components/CostComparison';
import { calculateMealsFromGroceryList } from '@/lib/utils/mealEstimation';
import { getCustomMeal } from '@/lib/utils/customMealStorage';
import { convertCustomMealToRecipe } from '@/lib/utils/convertCustomMealToRecipe';
import { getRecommendationsForRecipe, type RecommendedSupplement } from '@/lib/utils/nutritionalRecommendations';
import { checkAllBadges } from '@/lib/utils/badgeChecker';
import { ensureSellerId } from '@/lib/utils/affiliateLinks';
import { getProductPrice } from '@/lib/data/product-prices';

// =================================================================
// 1. CONSTANTS
// =================================================================

type CategoryType = 'dogs' | 'cats' | 'birds' | 'reptiles' | 'pocket-pets';

const NUTRITION_GUIDELINES: Record<
  CategoryType,
  { protein: string; fat: string; fiber: string }
> = {
  dogs: { protein: '25-35%', fat: '10-20%', fiber: '2-5%' },
  cats: { protein: '40-50%', fat: '25-35%', fiber: '1-3%' },
  birds: { protein: '15-20%', fat: '5-10%', fiber: '3-8%' },
  reptiles: { protein: '20-40%', fat: '5-15%', fiber: '5-10%' },
  'pocket-pets': { protein: '12-18%', fat: '3-6%', fiber: '15-25%' },
};

const HEALTH_CONCERN_MAP: Record<string, string> = {
  'allergy-support': 'allergies',
  allergies: 'allergies',
  'weight-management': 'weight-management',
  obesity: 'weight-management',
  'joint-&-mobility': 'joint-health',
  'joint-health': 'joint-health',
  arthritis: 'joint-health',
  'digestive-health': 'digestive',
  digestive: 'digestive',
  'sensitive-stomach': 'digestive',
  'kidney/urinary-support': 'kidney',
  kidney: 'kidney',
  'urinary-health': 'urinary-health',
  'skin-&-coat': 'skin-coat',
  diabetes: 'diabetes',
  hyperthyroidism: 'hyperthyroidism',
  pancreatitis: 'pancreatitis',
  'hairball-issues': 'hairball',
  hairball: 'hairball',
};

const normalizeConcern = (concern: string) => {
  const key = (concern || '').trim().toLowerCase().replace(/[^a-z0-9]/g, '-');
  return HEALTH_CONCERN_MAP[key] || key;
};

const formatIngredientNameForDisplay = (value: string): string => {
  return String(value)
    .trim()
    .replace(/[-_]+/g, ' ')
    .split(' ')
    .filter(Boolean)
    .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
    .join(' ');
};

// =================================================================
// 2. TYPES & LOCAL STORAGE HELPERS
// =================================================================

interface RecipeDetailPet {
  id: string;
  names: string[];
  type: string;
  breed: string;
  age: string;
  healthConcerns: string[];
  allergies?: string[];
  weight: string;
  mealPlan: string[];
  savedRecipes: string[];
}

const getPetsFromLocalStorage = (userId: string): RecipeDetailPet[] => {
  if (typeof window === 'undefined') return [];
  const stored = localStorage.getItem(`pets_${userId}`);
  if (!stored) return [];

  try {
    const parsed = JSON.parse(stored);
    return Array.isArray(parsed)
      ? parsed.map((p: any) => ({
          ...p,
          names: p.names || (p.name ? [p.name] : []),
          savedRecipes: p.savedRecipes || [],
          mealPlan: p.mealPlan || [],
          healthConcerns: p.healthConcerns || [],
        }))
      : [];
  } catch {
    return [];
  }
};

const savePetsToLocalStorage = (userId: string, pets: RecipeDetailPet[]) => {
  if (typeof window !== 'undefined') {
    localStorage.setItem(`pets_${userId}`, JSON.stringify(pets));
  }
};

const getSavedRecipes = (userId: string): string[] => {
  const pets = getPetsFromLocalStorage(userId);
  return [...new Set(pets.flatMap((p) => p.savedRecipes || []))];
};

const getStarStates = (rating: number): boolean[] => {
  const fullStars = Math.round(rating);
  return Array.from({ length: 5 }, (_, i) => i < fullStars);
};

const setRecipeSavedState = (
  userId: string,
  recipeId: string,
  isSaving: boolean
): RecipeDetailPet[] => {
  const pets = getPetsFromLocalStorage(userId);
  const updatedPets = pets.map((pet) => {
    if (!pet.savedRecipes) pet.savedRecipes = [];
    if (isSaving && !pet.savedRecipes.includes(recipeId)) {
      pet.savedRecipes.push(recipeId);
    } else if (!isSaving && pet.savedRecipes.includes(recipeId)) {
      pet.savedRecipes = pet.savedRecipes.filter((id) => id !== recipeId);
    }
    return pet;
  });

  savePetsToLocalStorage(userId, updatedPets);
  
  // Check badges after saving/removing recipe
  if (isSaving) {
    updatedPets.forEach(async (pet) => {
      if (pet.savedRecipes.includes(recipeId)) {
        // Get meal plan count and weekly plan completion status
        // Note: We'll need to check this from the profile page context
        // For now, just check saved recipes count
        const savedRecipesCount = pet.savedRecipes.length;
        
        checkAllBadges(userId, pet.id, {
          action: 'recipe_saved',
          savedRecipesCount,
          mealPlanCount: 0, // Will be updated from profile page
          weeklyPlanCompleted: false,
        }).catch(err => {
          console.error('Failed to check badges:', err);
        });
      }
    });
  }
  
  return updatedPets;
};

// For now we use last_user_id the same way as profile page
const getCurrentUserId = () => {
  if (typeof window === 'undefined') return '';
  return localStorage.getItem('last_user_id') || '';
};


// Helper function to extract ASIN from Amazon URL
const extractASIN = (url: string): string | undefined => {
  if (!url) return undefined;
  // Try /dp/ASIN pattern
  const dpMatch = url.match(/\/dp\/([A-Z0-9]{10})/);
  if (dpMatch) return dpMatch[1];
  
  // Try /gp/product/ASIN pattern
  const gpMatch = url.match(/\/gp\/product\/([A-Z0-9]{10})/);
  if (gpMatch) return gpMatch[1];
  
  // Try ASIN parameter
  try {
    const urlObj = new URL(url);
    const asinParam = urlObj.searchParams.get('ASIN');
    if (asinParam) return asinParam;
  } catch (e) {
    // Invalid URL, try regex
  }
  
  return undefined;
};

// Helper function to derive species from recipe category
const getSpeciesFromRecipeCategory = (category?: string): string | undefined => {
  if (!category) return undefined;
  // recipe.category is like 'dogs', 'cats', 'birds', 'reptiles', 'pocket-pets'
  // This matches the species parameter format
  return category;
};

// Helper function to vet recipe ingredients even without a pet selected
const vetRecipeIngredients = (recipe: Recipe): Recipe => {
  if (!recipe) return recipe;
  
  // Derive species from recipe category
  const species = getSpeciesFromRecipeCategory(recipe.category);
  
  return {
    ...recipe,
    ingredients: recipe.ingredients.map((ing) => {
      // Remove old amazonLink property
      const { amazonLink, ...ingWithoutOldLink } = ing as any;

      const existingLink = ing.asinLink || amazonLink;
      
      const genericKey = getGenericIngredientName((ing as any).productName || ing.name);
      const displayName = genericKey ? formatIngredientNameForDisplay(genericKey) : ing.name;
      
      // Try to find vetted product using the ingredient name
      // If the name is a product name (from applyModifiers), try to reverse-lookup
      // by checking if there's an id that might be the original name
      const lookupName = genericKey || ing.name;
      
      // Pass species for species-aware product matching
      let vettedProduct = getVettedProduct(lookupName, species);
      
      // If lookup by name/id failed and we have a productName, the ingredient was already vetted
      // Try to find the original generic name by searching VETTED_PRODUCTS for matching productName
      if (!vettedProduct && (ing as any).productName) {
        // Search VETTED_PRODUCTS for an entry with matching productName
        const matchingKey = Object.keys(VETTED_PRODUCTS).find(key => 
          VETTED_PRODUCTS[key].productName === (ing as any).productName
        );
        if (matchingKey) {
          vettedProduct = VETTED_PRODUCTS[matchingKey];
        }
      }
      
      if (vettedProduct) {
        const vettedLink = (vettedProduct.asinLink || vettedProduct.purchaseLink);
        return {
          ...ingWithoutOldLink,
          productName: vettedProduct.productName,
          name: displayName,
          asinLink: ensureSellerId(vettedLink), // Prefer vetted product link over existing link
        };
      }
      // If no vetted product found, keep ingredient but no ASIN link
      return {
        ...ingWithoutOldLink,
        name: displayName,
        asinLink: existingLink ? ensureSellerId(existingLink) : undefined,
      };
    }),
    // Also vet supplements if they exist
    supplements: (recipe as any).supplements?.map((supplement: any) => {
      // Remove old amazonLink property
      const { amazonLink, ...supplementWithoutOldLink } = supplement;

      const existingLink = supplement.asinLink || amazonLink;

      const genericKey = getGenericIngredientName(supplement.productName || supplement.name);
      const displayName = genericKey ? formatIngredientNameForDisplay(genericKey) : supplement.name;
      
      // Derive species from recipe category (re-derive here since we're in map scope)
      const species = getSpeciesFromRecipeCategory(recipe.category);
      // Pass species for species-aware product matching
      const lookupName = genericKey || supplement.name;
      const vettedProduct = getVettedProduct(lookupName, species);
      if (vettedProduct) {
        const vettedLink = (vettedProduct.asinLink || vettedProduct.purchaseLink);
        return {
          ...supplementWithoutOldLink,
          productName: vettedProduct.productName,
          name: displayName,
          asinLink: ensureSellerId(vettedLink), // Prefer vetted product link over existing link
        };
      }
      // Keep supplement but no ASIN link if no vetted product found
      return {
        ...supplementWithoutOldLink,
        name: displayName,
        asinLink: existingLink ? ensureSellerId(existingLink) : undefined,
      };
    }),
  };
};

// =================================================================
// 3. MAIN COMPONENT
// =================================================================

export default function RecipeDetailPage() {
  const params = useParams();
  const id = params?.id as string | undefined;

  const [recipe, setRecipe] = useState<Recipe | null>(null);
  const [pets, setPets] = useState<RecipeDetailPet[]>([]);
  const [selectedPetId, setSelectedPetId] = useState('');
  const [message, setMessage] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [petWeight, setPetWeight] = useState('');
  const [petAllergies, setPetAllergies] = useState('');
  const [isPersonalizing, setIsPersonalizing] = useState(false);
  const [modifierError, setModifierError] = useState<string | null>(null);
  const [modifierResult, setModifierResult] = useState<ModifiedRecipeResult | null>(null);
  const [activeTab, setActiveTab] = useState<'ingredients' | 'supplements'>('ingredients');
  const [isMealAdded, setIsMealAdded] = useState(false);
  const [isAddingMeal, setIsAddingMeal] = useState(false);
  const [isScoreModalOpen, setIsScoreModalOpen] = useState(false);
  const [vettedRecipe, setVettedRecipe] = useState<Recipe | null>(null);
  const [isCheckoutOpen, setIsCheckoutOpen] = useState(false);
  const [modifiedRecipe, setModifiedRecipe] = useState<Recipe | null>(null);
  const [recommendedSupplements, setRecommendedSupplements] = useState<RecommendedSupplement[]>([]);
  const [modifiedScore, setModifiedScore] = useState<number | null>(null);
  const [animatedScore, setAnimatedScore] = useState<number | null>(null);

  const userId = getCurrentUserId();

  const searchParams = useSearchParams();
  const queryPetId = searchParams?.get('petId') || '';

  const scoreForQueryPet = useMemo(() => {
    if (!recipe || !queryPetId) return null;
    const pet = getPetsFromLocalStorage(userId).find((p) => p.id === queryPetId);
    if (!pet) return null;

    // Use enhanced scoring
    try {
      const petAge = pet.age === 'baby' ? 0.5 : pet.age === 'young' ? 2 : pet.age === 'adult' ? 5 : 10;
      const enhancedPet: EnhancedPet = {
        id: pet.id,
        name: getRandomName(pet.names),
        type: pet.type as 'dog' | 'cat' | 'bird' | 'reptile' | 'pocket-pet',
        breed: pet.breed,
        age: petAge,
        weight: parseFloat(pet.weight) || (pet.type === 'dogs' ? 25 : pet.type === 'cats' ? 10 : 5),
        activityLevel: 'moderate' as const,
        healthConcerns: pet.healthConcerns || [],
        dietaryRestrictions: pet.allergies || [],
        allergies: pet.allergies || [],
      };
      const enhanced = calculateEnhancedCompatibility(recipe, enhancedPet);
      // Convert to compatible format
      // Generate reason text that includes issues for better keyword matching
      const getReasonWithIssues = (factor: typeof enhanced.factors.ingredientSafety) => {
        if (factor.issues.length > 0) {
          return factor.issues.join('; ') + (factor.reasoning ? ` (${factor.reasoning})` : '');
        }
        return factor.reasoning || '';
      };

      // Get recommendations for nutritional gaps
      const supplementRecommendations = getRecommendationsForRecipe(
        enhanced.detailedBreakdown.nutritionalGaps,
        pet.type as 'dog' | 'cat' | 'bird' | 'reptile' | 'pocket-pet',
        pet.healthConcerns || []
      );

      // Check badges if score is 100% (Nutrient Navigator)
      if (enhanced.overallScore === 100 && queryPetId && userId) {
        checkAllBadges(userId, queryPetId, {
          action: 'recipe_viewed',
          compatibilityScore: enhanced.overallScore,
        }).catch(err => {
          console.error('Failed to check badges:', err);
        });
      }

      // Generate summary reasoning from enhanced breakdown
      const summaryReasoning = enhanced.detailedBreakdown.recommendations.length > 0
        ? enhanced.detailedBreakdown.recommendations.join('. ')
        : enhanced.detailedBreakdown.healthBenefits.length > 0
        ? enhanced.detailedBreakdown.healthBenefits.join('. ')
        : 'Recipe evaluated for compatibility with your pet.';

      return {
        overallScore: enhanced.overallScore,
        compatibility: enhanced.grade === 'A+' || enhanced.grade === 'A' ? 'excellent' :
                       enhanced.grade === 'B+' || enhanced.grade === 'B' ? 'good' :
                       enhanced.grade === 'C+' || enhanced.grade === 'C' ? 'fair' : 'poor',
        summaryReasoning: summaryReasoning,
        explainRecommendations: enhanced.detailedBreakdown.recommendations || [],
        nutritionalGaps: enhanced.detailedBreakdown.nutritionalGaps,
        supplementRecommendations: supplementRecommendations,
        breakdown: {
          petTypeMatch: { 
            score: enhanced.factors.ingredientSafety.score,
            weightedContribution: Math.round(enhanced.factors.ingredientSafety.score * enhanced.factors.ingredientSafety.weight),
            weight: enhanced.factors.ingredientSafety.weight,
            reason: getReasonWithIssues(enhanced.factors.ingredientSafety)
          },
          ageAppropriate: { 
            score: enhanced.factors.lifeStageFit.score,
            weightedContribution: Math.round(enhanced.factors.lifeStageFit.score * enhanced.factors.lifeStageFit.weight),
            weight: enhanced.factors.lifeStageFit.weight,
            reason: getReasonWithIssues(enhanced.factors.lifeStageFit)
          },
          nutritionalFit: { 
            score: enhanced.factors.nutritionalAdequacy.score,
            weightedContribution: Math.round(enhanced.factors.nutritionalAdequacy.score * enhanced.factors.nutritionalAdequacy.weight),
            weight: enhanced.factors.nutritionalAdequacy.weight,
            reason: getReasonWithIssues(enhanced.factors.nutritionalAdequacy),
            recommendations: supplementRecommendations // Add recommendations to nutritional fit
          } as any, // Type assertion needed because recommendations is added dynamically
          healthCompatibility: { 
            score: enhanced.factors.healthAlignment.score,
            weightedContribution: Math.round(enhanced.factors.healthAlignment.score * enhanced.factors.healthAlignment.weight),
            weight: enhanced.factors.healthAlignment.weight,
            reason: getReasonWithIssues(enhanced.factors.healthAlignment)
          },
          activityFit: {
            score: enhanced.factors.activityFit.score,
            weightedContribution: Math.round(enhanced.factors.activityFit.score * enhanced.factors.activityFit.weight),
            weight: enhanced.factors.activityFit.weight,
            reason: getReasonWithIssues(enhanced.factors.activityFit)
          },
          allergenSafety: { 
            score: enhanced.factors.allergenSafety.score,
            weightedContribution: Math.round(enhanced.factors.allergenSafety.score * enhanced.factors.allergenSafety.weight),
            weight: enhanced.factors.allergenSafety.weight,
            reason: getReasonWithIssues(enhanced.factors.allergenSafety)
          },
        },
        warnings: enhanced.detailedBreakdown.warnings,
        strengths: enhanced.detailedBreakdown.healthBenefits,
        recommendations: enhanced.detailedBreakdown.recommendations,
      };
    } catch (error) {
      // Fallback to original scoring
    console.error('Error calculating compatibility:', error);
    return null;
    }
  }, [recipe, queryPetId, userId]);

  const modifierResultForQueryPet = (() => {
    if (!recipe || !queryPetId) return null;
    const pet = getPetsFromLocalStorage(userId).find((p) => p.id === queryPetId);
    if (!pet) return null;
    return applyModifiers(recipe, pet as any);
  })();

  // Load recipe by dynamic route id (handles custom meals, generated recipes, and regular recipes)
  useEffect(() => {
    if (!id) {
      setIsLoading(false);
      return;
    }

    setIsLoading(true);
    
    // Check if this is a custom meal (starts with "custom_")
    const isCustomMeal = id.startsWith('custom_');
    
    if (isCustomMeal && queryPetId) {
      // Load custom meal
      getCustomMeal(userId, queryPetId, id)
        .then((customMeal) => {
          if (customMeal) {
            const recipe = convertCustomMealToRecipe(customMeal);
            // Always vet the recipe ingredients to ensure all have purchase links
            const vetted = vetRecipeIngredients(recipe);
            setRecipe(vetted);
            setVettedRecipe(vetted);
          } else {
            setRecipe(null);
            setVettedRecipe(null);
          }
          setIsLoading(false);
        })
        .catch((error) => {
          console.error('Error loading custom meal:', error);
          setRecipe(null);
          setVettedRecipe(null);
          setIsLoading(false);
        });
    } else {
      // Try to load from session storage first (for dynamically generated recipes)
      let sessionRecipe = null;
      if (typeof window !== 'undefined') {
        const sessionData = sessionStorage.getItem(`recipe_${id}`);
        if (sessionData) {
          try {
            sessionRecipe = JSON.parse(sessionData);
          } catch (e) {
            console.warn('Failed to parse session recipe:', e);
          }
        }
      }

      if (sessionRecipe) {
        // Use recipe from session storage
        const vetted = vetRecipeIngredients(sessionRecipe);
        setRecipe(vetted);
        setVettedRecipe(vetted);
        setIsLoading(false);
      } else {
        // Try to load from static recipes (fallback)
        loadRecipeById(id)
          .then((foundRecipe) => {
            if (foundRecipe) {
              // Always vet the recipe ingredients to ensure all have purchase links
              const vetted = vetRecipeIngredients(foundRecipe);
              setRecipe(vetted);
              // Always set vettedRecipe so ShoppingList can use vetted products
              setVettedRecipe(vetted);
            } else {
              // Recipe not found
              setRecipe(null);
              setVettedRecipe(null);
            }
            setIsLoading(false);
          })
          .catch((error) => {
            console.error('Error loading recipe:', error);
            setRecipe(null);
            setVettedRecipe(null);
            setIsLoading(false);
          });
      }
    }
  }, [id, queryPetId, userId]); // Reload when ID, petId, or userId changes

  // Update recommendations when score changes
  useEffect(() => {
    if (scoreForQueryPet && 'supplementRecommendations' in scoreForQueryPet) {
      const recs = (scoreForQueryPet as any).supplementRecommendations || [];
      setRecommendedSupplements(recs);
    } else {
      setRecommendedSupplements([]);
    }
  }, [scoreForQueryPet]);

  // Initialize modified recipe
  useEffect(() => {
    if (recipe && !modifiedRecipe) {
      setModifiedRecipe(JSON.parse(JSON.stringify(recipe)));
    }
  }, [recipe, modifiedRecipe]);

  // Load pets & saved state
  useEffect(() => {
    if (!userId || !id) return;

    try {
      const loadedPets = getPetsFromLocalStorage(userId);
      setPets(loadedPets);
    } catch (error) {
      // Handle error gracefully - show empty pets array
      console.error('Failed to load pets:', error);
      setPets([]);
    }
  }, [userId, id]);

  useEffect(() => {
    // Auto-select pet from URL parameter if available
    if (queryPetId && pets.length > 0 && !selectedPetId) {
      setSelectedPetId(queryPetId);
    }
  }, [queryPetId, pets, selectedPetId]);

  useEffect(() => {
    // Check if meal is already added for the current pet (check both mealPlan and savedRecipes)
    const currentPet = selectedPetId ? pets.find(p => p.id === selectedPetId) : (queryPetId ? pets.find(p => p.id === queryPetId) : null);
    if (currentPet && recipe) {
      const inMealPlan = currentPet.mealPlan?.includes(recipe.id) || false;
      const inSavedRecipes = currentPet.savedRecipes?.includes(recipe.id) || false;
      setIsMealAdded(inMealPlan || inSavedRecipes);
    } else {
      setIsMealAdded(false);
    }
  }, [selectedPetId, queryPetId, pets, recipe]);

  useEffect(() => {
    if (!selectedPetId || !recipe) {
      setPetWeight('');
      setPetAllergies('');
      setModifierResult(null);
      setModifierError(null);
      setIsMealAdded(false);
      // DON'T set vettedRecipe to null - keep the vetted recipe so ingredients show properly
      // setVettedRecipe(null); // REMOVED - this was causing ingredients to disappear
      return;
    }

    const pet = pets.find((p) => p.id === selectedPetId);
    if (!pet) return;
    setPetWeight(pet.weight || '');
    setPetAllergies(pet.allergies?.join(', ') || '');
    setModifierResult(null);
    setModifierError(null);
    const inMealPlan = pet.mealPlan?.includes(recipe.id) || false;
    const inSavedRecipes = pet.savedRecipes?.includes(recipe.id) || false;
    setIsMealAdded(inMealPlan || inSavedRecipes);

    // Apply modifiers, then vet all ingredients to ensure purchase links
    const { modifiedRecipe } = applyModifiers(recipe, pet);
    const vetted = vetRecipeIngredients(modifiedRecipe);
    setVettedRecipe(vetted);
  }, [selectedPetId, pets, recipe]);

  // Function to add supplement to recipe
  const handleAddSupplement = useCallback((supplement: RecommendedSupplement) => {
    if (!modifiedRecipe) return;

    const newRecipe = JSON.parse(JSON.stringify(modifiedRecipe));
    
    // Initialize supplements array if it doesn't exist
    if (!newRecipe.supplements) {
      newRecipe.supplements = [];
    }

    // Check if supplement already exists
    const exists = newRecipe.supplements.some((s: any) => 
      s.name === supplement.name || s.productName === supplement.productName
    );

    if (exists) {
      setMessage('This supplement is already in the recipe');
      setTimeout(() => setMessage(null), 3000);
      return;
    }

    // Add supplement
    const supplementToAdd: any = {
      id: `supplement-${Date.now()}`,
      name: supplement.name,
      productName: supplement.productName || supplement.name,
      amount: supplement.defaultAmount,
      notes: supplement.benefits,
      asinLink: supplement.asinLink || supplement.amazonLink,
    };

    newRecipe.supplements.push(supplementToAdd);
    setModifiedRecipe(newRecipe);

    // Recalculate score
    if (queryPetId && scoreForQueryPet) {
      const pet = getPetsFromLocalStorage(userId).find((p) => p.id === queryPetId);
      if (pet) {
        const petAge = pet.age === 'baby' ? 0.5 : pet.age === 'young' ? 2 : pet.age === 'adult' ? 5 : 10;
        const enhancedPet: EnhancedPet = {
          id: pet.id,
          name: getRandomName(pet.names),
          type: pet.type as 'dog' | 'cat' | 'bird' | 'reptile' | 'pocket-pet',
          breed: pet.breed,
          age: petAge,
          weight: parseFloat(pet.weight) || (pet.type === 'dogs' ? 25 : pet.type === 'cats' ? 10 : 5),
          activityLevel: 'moderate' as const,
          healthConcerns: pet.healthConcerns || [],
          dietaryRestrictions: pet.allergies || [],
          allergies: pet.allergies || [],
        };

        try {
          const newScore = calculateEnhancedCompatibility(newRecipe, enhancedPet);
          const oldScore = scoreForQueryPet.overallScore;
          const scoreDiff = newScore.overallScore - oldScore;

          if (scoreDiff > 0) {
            // Animate score change
            animateScoreChange(oldScore, newScore.overallScore);
          }

          setModifiedScore(newScore.overallScore);
          setMessage(`${supplement.name} added! Score improved by ${scoreDiff > 0 ? '+' : ''}${scoreDiff.toFixed(0)} points.`);
          setTimeout(() => setMessage(null), 5000);
        } catch (error) {
          console.error('Error recalculating score:', error);
          setMessage(`${supplement.name} added to recipe.`);
          setTimeout(() => setMessage(null), 3000);
        }
      }
    }
  }, [modifiedRecipe, queryPetId, scoreForQueryPet, userId]);

  // Score animation function
  const animateScoreChange = useCallback((from: number, to: number) => {
    const duration = 1500; // 1.5 seconds
    const steps = 60;
    const increment = (to - from) / steps;
    let current = from;
    let step = 0;

    const animate = () => {
      step++;
      current = from + (increment * step);
      
      if (step < steps) {
        setAnimatedScore(Math.round(current));
        requestAnimationFrame(animate);
      } else {
        setAnimatedScore(to);
      }
    };

    animate();
  }, []);

  const handleAddToMealPlan = useCallback(async () => {
    if (!recipe || !userId) {
      setMessage('Please select a pet.');
      setTimeout(() => setMessage(null), 2500);
      return;
    }

    const currentPetId = selectedPetId || queryPetId;
    if (!currentPetId) {
      setMessage('Please select a pet.');
      setTimeout(() => setMessage(null), 2500);
      return;
    }

    const currentPet = pets.find(p => p.id === currentPetId);
    if (!currentPet) {
      setMessage('Pet not found.');
      setTimeout(() => setMessage(null), 2500);
      return;
    }

    // Check if already added (check both mealPlan and savedRecipes)
    if (currentPet.mealPlan?.includes(recipe.id) || currentPet.savedRecipes?.includes(recipe.id)) {
      setIsMealAdded(true);
      return;
    }

    setIsAddingMeal(true);
    
    // Simulate async operation
    await new Promise(resolve => setTimeout(resolve, 300));

    const updatedPets = pets.map((pet) => {
      if (pet.id === currentPetId) {
        if (!pet.mealPlan) pet.mealPlan = [];
        if (!pet.mealPlan.includes(recipe.id)) {
          pet.mealPlan.push(recipe.id);
          setIsMealAdded(true);
        }
      }
      return pet;
    });

    savePetsToLocalStorage(userId, updatedPets);
    setPets(updatedPets);
    setIsAddingMeal(false);
  }, [recipe, selectedPetId, queryPetId, pets, userId]);

  const selectedPet = selectedPetId
    ? pets.find((pet) => pet.id === selectedPetId)
    : null;

  const handlePersonalizeRecipe = async () => {
    if (!recipe) return;

    const currentPet = selectedPet || (queryPetId ? pets.find(p => p.id === queryPetId) : null);
    if (!currentPet) {
      setModifierError('Select a pet profile first.');
      return;
    }

    const parsedWeight = parseFloat(petWeight);
    if (!parsedWeight || parsedWeight <= 0) {
      setModifierError('Enter a valid weight in kilograms.');
      return;
    }

    setIsPersonalizing(true);
    setModifierError(null);

    const healthConcerns = (currentPet.healthConcerns || [])
      .filter((concern) => concern && concern !== 'none')
      .map(normalizeConcern);

    const allergiesArray = petAllergies
      .split(',')
      .map((item) => item.trim())
      .filter(Boolean);

    try {
      const response = await fetch('/api/recommendations', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          profile: {
            species: currentPet.type,
            ageGroup: currentPet.age,
            breed: currentPet.breed,
            weightKg: parsedWeight,
            healthConcerns,
            allergies: allergiesArray,
          },
          recipeIds: [recipe.id],
          limit: 1,
        }),
      });

      if (!response.ok) {
        throw new Error('Failed to personalize recipe.');
      }

      const data = await response.json();
      const result = data.results?.[0] || null;
      setModifierResult(result);
      if (!result) {
        setModifierError('No modifier rules matched for this profile.');
      }
    } catch (error) {
      // Error handled by error state
      setModifierError('Unable to personalize this meal right now.');
      setModifierResult(null);
    } finally {
      setIsPersonalizing(false);
    }
  };

  // Calculate all shopping items and meal estimate for sidebar (MUST be before early returns)
  const { allShoppingItems, mealEstimate } = useMemo(() => {
    const sourceRecipe = vettedRecipe || recipe;
    if (!sourceRecipe) {
      return { allShoppingItems: [], mealEstimate: null };
    }

    const allIngredients = sourceRecipe.ingredients || [];

    const ingredientsEnrichedWithLinks = allIngredients.map((ing: any) => {
      const existingLink = ing?.asinLink || ing?.amazonLink;
      if (existingLink) return ing;

      const lookupName = getGenericIngredientName(ing?.productName || ing?.name) || ing?.name;
      if (!lookupName) return ing;

      const product = getVettedProduct(lookupName, sourceRecipe.category);
      const productLink = product?.asinLink || product?.purchaseLink;
      if (!productLink) return ing;

      const enrichedLink = ensureSellerId(productLink);
      return {
        ...ing,
        productName: ing?.productName || product.productName,
        amazonLink: enrichedLink,
        asinLink: enrichedLink
      };
    });

    const ingredientsWithASINs = ingredientsEnrichedWithLinks.filter((ing: any) => ing.asinLink || ing.amazonLink);
    const supplementsWithASINs = (modifiedRecipe as any)?.supplements?.filter((s: any) => s.asinLink || s.amazonLink) || [];

    const shoppingItems = [
      ...ingredientsWithASINs.map((ing: any) => ({
        id: ing.id,
        name: ing.name,
        amount: ing.amount || '',
        asinLink: ensureSellerId(ing.asinLink || ing.amazonLink)
      })),
      ...supplementsWithASINs.map((supplement: any) => ({
        id: supplement.id || supplement.name,
        name: supplement.name,
        amount: supplement.amount || supplement.defaultAmount || '',
        asinLink: ensureSellerId(supplement.asinLink || supplement.amazonLink)
      }))
    ];

    const totalCost = shoppingItems.reduce((sum: number, item: any) => {
      const price = getProductPrice(item.name);
      if (typeof price === 'number') return sum + price;
      return sum;
    }, 0);

    let estimate = null;
    if (shoppingItems.length > 0) {
      try {
        const shoppingListItems = shoppingItems.map((item: any) => {
          const genericName = getGenericIngredientName(item.name) || item.name.toLowerCase();
          const vettedProduct = getVettedProduct(genericName, sourceRecipe.category);
          return {
            id: item.id,
            name: item.name,
            amount: item.amount,
            category: vettedProduct?.category || 'other'
          };
        });

        estimate = calculateMealsFromGroceryList(shoppingListItems, undefined, sourceRecipe.category);
      } catch (error) {
        estimate = null;
      }
    }

    return { allShoppingItems: shoppingItems, mealEstimate: estimate };
  }, [vettedRecipe, recipe, modifiedRecipe]);

  const guidelines =
    NUTRITION_GUIDELINES[recipe?.category as CategoryType] ||
    ({ protein: 'N/A', fat: 'N/A', fiber: 'N/A' } as const);

  if (isLoading) {
    return (
      <div className="min-h-screen flex items-center justify-center text-xl font-semibold text-gray-400 bg-background">
        Loading meal...
      </div>
    );
  }

  if (!recipe) {
    return (
      <div className="min-h-screen flex flex-col items-center justify-center space-y-4 bg-background">
        <h1 className="text-3xl font-bold text-red-500">Meal not found</h1>
        <p className="text-gray-400">We couldn't find a meal for this link.</p>
        <Link
          href="/profile"
          className="text-secondary-400 font-semibold hover:text-secondary-300"
        >
          Go to My Pets
        </Link>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-background py-12 font-sans text-foreground">
      {/* Message Toast */}
      {message && (
        <div className="fixed top-4 right-4 bg-green-600 text-white px-4 py-2 rounded-lg shadow-lg z-50">
          {message}
        </div>
      )}

      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        {/* Breadcrumb */}
        <Link
          href="/profile"
          className="inline-flex items-center text-gray-400 hover:text-primary-400 mb-6 font-medium transition-colors"
        >
          <ChevronLeft className="w-5 h-5 mr-1" />
          Back to My Pets
        </Link>

        <div className="grid grid-cols-1 lg:grid-cols-5 gap-10">
          <main className="lg:col-span-3">
            {/* Recipe Info Card */}
            <div className="bg-surface rounded-2xl shadow-xl overflow-hidden mb-8 border border-surface-highlight">
              <div className="p-8">
                <h1 className="text-4xl font-extrabold text-foreground mb-2 tracking-tight">
                  <div className="flex items-center gap-3">
                    <span>{recipe.name}</span>
                    {(recipe.needsReview === true || (scoreForQueryPet && 'usesFallbackNutrition' in scoreForQueryPet && (scoreForQueryPet as any).usesFallbackNutrition)) && (
                      <span className="inline-flex items-center px-3 py-1 rounded-full text-xs font-medium bg-amber-900/40 text-amber-200 border border-amber-700/50">
                        ‚ö†Ô∏è Experimental / Topper Only
                      </span>
                    )}
                  </div>
                </h1>
                {/* Pet Compatibility Rating - Using NEW system */}
                
                {queryPetId && scoreForQueryPet && (
                  <div className="mb-4 flex items-center gap-3">
                    <button
                      onClick={() => setIsScoreModalOpen(true)}
                      className="flex items-center cursor-pointer hover:opacity-80 transition-opacity"
                    >
                      <div className="flex items-center">
                        {Array.from({ length: 5 }).map((_, i) => (
                          <Star
                            key={i}
                            className={`w-5 h-5 ${i < Math.round(scoreForQueryPet.overallScore / 20) ? 'text-yellow-500 fill-yellow-500' : 'text-gray-600'}`}
                          />
                        ))}
                      </div>
                      <div className="text-sm text-gray-300 ml-2">
                        Compatibility Score: <strong>{scoreForQueryPet.overallScore}%</strong>
                        <span className="text-xs text-gray-400 ml-2">(weighted average)</span>
                      </div>
                    </button>
                    <Tooltip
                      content={`Compatibility: ${scoreForQueryPet.compatibility}\n\n${scoreForQueryPet.strengths.length > 0 ? 'Strengths:\n‚Ä¢ ' + scoreForQueryPet.strengths.join('\n‚Ä¢ ') + '\n' : ''}${scoreForQueryPet.warnings.length > 0 ? '\nWarnings:\n‚Ä¢ ' + scoreForQueryPet.warnings.join('\n‚Ä¢ ') : ''}`}
                    >
                      <div className="text-xs text-gray-500 cursor-help hover:text-gray-300">
                        Why
                      </div>
                    </Tooltip>
                  </div>
                )}

                {scoreForQueryPet && 'explainRecommendations' in scoreForQueryPet && (scoreForQueryPet as any).explainRecommendations && (scoreForQueryPet as any).explainRecommendations.length > 0 && (
                  <div className="bg-amber-50 border-l-4 border-amber-500 p-4 rounded-r-lg mb-4">
                    <div className="flex items-start gap-2">
                      <span className="text-lg">üí°</span>
                      <div className="flex-1">
                        <h4 className="font-semibold text-amber-900 mb-2">Suggestions:</h4>
                        <ul className="text-sm text-amber-800 space-y-1">
                          {(scoreForQueryPet as any).explainRecommendations.map((rec: string, i: number) => (
                            <li key={i}>‚Ä¢ {rec}</li>
                          ))}
                        </ul>
                      </div>
                    </div>
                  </div>
                )}

                {/* Pet Reviews - Positioned directly under meal title */}
                <div className="mb-6">
                  <RecipeRatingSection
                    recipeId={id || ''}
                    recipeName={recipe.name}
                    userId={userId}
                  />
                </div>

                <div className="mb-8">
                  <p className="text-gray-300 leading-relaxed text-lg">
                    {recipe.description}
                  </p>
                  {(recipe.needsReview === true || (scoreForQueryPet && 'usesFallbackNutrition' in scoreForQueryPet && (scoreForQueryPet as any).usesFallbackNutrition)) && (
                    <div className="mt-3 p-3 bg-amber-900/20 border border-amber-700/50 rounded-lg">
                      <p className="text-sm text-amber-200">
                        <strong>‚ö†Ô∏è Note:</strong> This recipe uses estimated nutrition data. Consult your veterinarian before feeding as a complete meal.
                      </p>
                    </div>
                  )}
                </div>

                <div className="flex flex-wrap gap-2 mb-8">
                  {recipe.tags?.map((tag) => (
                    <span
                      key={tag}
                      className="bg-surface-highlight text-gray-300 px-3 py-1 rounded-full text-sm font-medium border border-surface-highlight"
                    >
                      {tag}
                    </span>
                  ))}
                </div>

              </div>
            </div>

            {/* Ingredients & Supplements Tabs */}
            <div className="bg-surface rounded-2xl shadow-lg p-8 mb-8 border border-surface-highlight">
              {/* Tab Navigation */}
              <div className="flex border-b border-surface-highlight mb-6">
                <button
                  onClick={() => setActiveTab('ingredients')}
                  className={`px-6 py-3 font-semibold text-sm border-b-2 transition-colors ${
                    activeTab === 'ingredients'
                      ? 'border-orange-500 text-orange-400'
                      : 'border-transparent text-gray-500 hover:text-gray-300'
                  }`}
                >
                  Ingredients
                </button>
                <button
                  onClick={() => setActiveTab('supplements')}
                  className={`px-6 py-3 font-semibold text-sm border-b-2 transition-colors ${
                    activeTab === 'supplements'
                      ? 'border-orange-500 text-orange-400'
                      : 'border-transparent text-gray-500 hover:text-gray-300'
                  }`}
                >
                  Supplements
                </button>
              </div>

              {/* Tab Content */}
              {activeTab === 'ingredients' && (
                <div className="relative">
                  {(() => {
                    const allIngredients = vettedRecipe?.ingredients || recipe.ingredients || [];
                    
                    const ingredientsWithASINs = allIngredients.filter((ing: any) => ing.asinLink);
                    // Filter out ingredients with old amazonLink - only show truly missing ASINs
                    const ingredientsWithoutASINs = allIngredients.filter((ing: any) => !ing.asinLink && !ing.amazonLink);
                    
                    // Get recommended ingredients (from recommendations where isIngredient === true)
                    const recommendedIngredients = recommendedSupplements.filter((rec: any) => rec.isIngredient === true);
                    
                    return (
                      <div className="space-y-6">
                        {/* Recommended Ingredients Section */}
                        {recommendedIngredients.length > 0 && (
                          <div className="bg-orange-900/20 border border-orange-700/50 rounded-lg p-6">
                            <h3 className="text-lg font-semibold text-orange-200 mb-4 flex items-center gap-2">
                              <span>‚ú®</span>
                              Recommended Ingredients
                            </h3>
                            <p className="text-sm text-gray-400 mb-4">
                              These ingredients can help address nutritional deficiencies in this recipe:
                            </p>
                            <div className="space-y-3">
                              {recommendedIngredients.map((ingredient: any, index: number) => (
                                <div key={index} className="bg-surface rounded-lg p-4 border border-orange-700/30">
                                  <div className="flex items-start justify-between gap-4">
                                    <div className="flex-1">
                                      <h5 className="font-semibold text-gray-200">{ingredient.name}</h5>
                                      <p className="text-sm text-gray-400 mt-1">{ingredient.description}</p>
                                      <p className="text-xs text-orange-300 mt-2">
                                        Addresses: {ingredient.addressesDeficiency}
                                      </p>
                                      <p className="text-sm text-gray-300 mt-2">
                                        <strong>Benefits:</strong> {ingredient.benefits}
                                      </p>
                                      <p className="text-sm text-gray-400 mt-1">
                                        <strong>Suggested Amount:</strong> {ingredient.defaultAmount}
                                      </p>
                                    </div>
                                  </div>
                                </div>
                              ))}
                            </div>
                          </div>
                        )}
                        
                        {/* Ingredients with ASIN links - show buy buttons */}
                        {allShoppingItems.length > 0 && (
                          <div className="space-y-6">
                            <h3 className="text-lg font-semibold text-foreground mb-4">
                              Recipe Ingredients & Supplements
                            </h3>
                            <ShoppingList
                              ingredients={allShoppingItems}
                              recipeName={recipe.name}
                              userId={userId}
                            />
                          </div>
                        )}
                        
                        {/* Ingredients without ASIN links - just display them */}
                        {ingredientsWithoutASINs.length > 0 && (
                          <div className="bg-surface-lighter rounded-lg border border-surface-highlight p-6">
                            <h3 className="text-lg font-semibold text-foreground mb-4">
                              Additional Ingredients
                            </h3>
                            <div className="space-y-2">
                              {ingredientsWithoutASINs.map((ing: any, index: number) => (
                                <div
                                  key={ing.id || index}
                                  className="flex items-center justify-between p-3 bg-surface rounded-lg border border-surface-highlight"
                                >
                                  <div className="flex-1">
                                    <div className="font-medium text-gray-200">{ing.name}</div>
                                    {ing.amount && (
                                      <div className="text-sm text-gray-400">{ing.amount}</div>
                                    )}
                                  </div>
                                </div>
                              ))}
                            </div>
                          </div>
                        )}
                      </div>
                    );
                  })()}
                </div>
              )}

              {activeTab === 'supplements' && (
                <div className="relative space-y-6">
                  {/* Recommended Supplements Section */}
                  {(() => {
                    // Filter out ingredients - only show supplements
                    const recommendedSupplementsOnly = recommendedSupplements.filter((rec: any) => !rec.isIngredient);
                    
                    if (recommendedSupplementsOnly.length === 0) return null;
                    
                    return (
                      <div className="bg-orange-900/20 border border-orange-700/50 rounded-lg p-6">
                        <h3 className="text-lg font-semibold text-orange-200 mb-4 flex items-center gap-2">
                          <span>üíä</span>
                          Recommended Supplements
                        </h3>
                        <p className="text-sm text-gray-400 mb-4">
                          These supplements can help address nutritional deficiencies in this recipe:
                        </p>
                        <div className="space-y-3">
                          {recommendedSupplementsOnly.map((supplement, index) => {
                            const isAlreadyAdded = ((modifiedRecipe || recipe) as any)?.supplements?.some((s: any) => 
                              s.name === supplement.name || s.productName === supplement.productName
                            ) || false;
                            
                            return (
                              <div key={index} className="bg-surface rounded-lg p-4 border border-orange-700/30">
                                <div className="flex items-start justify-between gap-4">
                                  <div className="flex-1">
                                    <h5 className="font-semibold text-gray-200">{supplement.name}</h5>
                                    <p className="text-sm text-gray-400 mt-1">{supplement.description}</p>
                                    <p className="text-xs text-orange-300 mt-2">
                                      Addresses: {supplement.addressesDeficiency}
                                    </p>
                                    <p className="text-sm text-gray-300 mt-2">
                                      <strong>Benefits:</strong> {supplement.benefits}
                                    </p>
                                    <p className="text-sm text-gray-400 mt-1">
                                      <strong>Amount:</strong> {supplement.defaultAmount}
                                    </p>
                                  </div>
                                  <button
                                    onClick={() => handleAddSupplement(supplement)}
                                    disabled={isAlreadyAdded}
                                    className={`px-4 py-2 rounded-md text-sm font-semibold transition-colors whitespace-nowrap ${
                                      isAlreadyAdded
                                        ? 'bg-green-600 text-white cursor-not-allowed opacity-50'
                                        : 'bg-orange-600 text-white hover:bg-orange-700'
                                    }`}
                                  >
                                    {isAlreadyAdded ? '‚úì Added' : '+ Add to Recipe'}
                                  </button>
                                </div>
                              </div>
                            );
                          })}
                        </div>
                      </div>
                    );
                  })()}

                  {/* Existing Recipe Supplements */}
                  {(() => {
                    const supplementsWithASINs = ((modifiedRecipe || recipe) as any)?.supplements?.filter((s: any) => s.asinLink) || [];
                    if (supplementsWithASINs.length > 0) {
                      return (
                        <div>
                          <h3 className="text-lg font-semibold text-gray-200 mb-4">
                            Recipe Supplements
                          </h3>
                          <ShoppingList
                            ingredients={supplementsWithASINs.map((supplement: any) => ({
                              id: supplement.id || supplement.name,
                              name: supplement.name,
                              amount: supplement.amount || '',
                              asinLink: ensureSellerId(supplement.asinLink)
                            }))}
                            recipeName={`${recipe.name} supplements`}
                            userId={userId}
                          />
                        </div>
                      );
                    } else {
                      const recipeSupplements = ((modifiedRecipe || recipe) as any)?.supplements || [];
                      if (recipeSupplements.length === 0 && recommendedSupplements.length === 0) {
                        return (
                          <div>
                            <h3 className="text-2xl font-bold text-foreground mb-6">
                              Recipe Supplements
                            </h3>
                            <div className="text-center py-8 text-gray-500">
                              <p>This recipe doesn't include specific supplements.</p>
                              <p className="text-sm mt-2">Check the ingredients tab for all components.</p>
                            </div>
                          </div>
                        );
                      } else if (recipeSupplements.length > 0) {
                        return (
                          <div>
                            <h3 className="text-2xl font-bold text-foreground mb-6">
                              Recipe Supplements
                            </h3>
                            <div className="space-y-4">
                              {recipeSupplements.map((supplement: any, index: number) => (
                                <div key={index} className="bg-surface-lighter rounded-lg p-4 border border-surface-highlight">
                                  <div className="flex justify-between items-start">
                                    <div className="flex-1">
                                      <h5 className="font-semibold text-gray-200">{supplement.name}</h5>
                                      {supplement.productName && supplement.productName !== supplement.name && (
                                        <div className="text-sm text-gray-400 mt-1">
                                          (Generic: {supplement.name})
                                        </div>
                                      )}
                                      <p className="text-sm text-gray-400 mt-1">{supplement.notes || 'Health supplement for optimal nutrition'}</p>
                                    </div>
                                    <div className="flex items-center gap-4 ml-4">
                                      {supplement.amount && (
                                        <span className="text-orange-400 font-bold">
                                          {supplement.amount}
                                        </span>
                                      )}
                                    </div>
                                  </div>
                                </div>
                              ))}
                            </div>
                          </div>
                        );
                      }
                    }
                  })()}
                </div>
              )}
            </div>

            {modifierResultForQueryPet && modifierResultForQueryPet.addedIngredients.length > 0 && (
              <div className="bg-surface rounded-2xl shadow-lg p-8 mb-8 border border-surface-highlight">
                <h3 className="text-2xl font-bold text-foreground mb-6 border-b border-surface-highlight pb-4">
                  Recommended Additions
                </h3>
                <ul className="space-y-4">
                  {modifierResultForQueryPet.addedIngredients.map((add) => (
                    <li
                      key={add.name}
                      className="flex justify-between items-center p-3 bg-green-900/20 rounded-lg transition-colors border border-green-800/30"
                    >
                      <div>
                        <span className="text-gray-200 font-medium text-lg">
                          {add.name}
                        </span>
                        <p className="text-sm text-gray-400">{add.benefit}</p>
                        <p className="text-xs text-green-400">Added for {add.forConcern}</p>
                      </div>
                      <a
                        href={ensureSellerId(add.amazon)}
                        target="_blank"
                        rel="noreferrer"
                        className="inline-flex items-center gap-2 px-4 py-2 bg-[#FF9900] hover:bg-[#E07704] text-black rounded-lg transition-all duration-200 text-sm font-semibold whitespace-nowrap hover:shadow-md"
                      >
                        <ShoppingCart size={16} />
                        Buy
                      </a>
                    </li>
                  ))}
                </ul>
              </div>
            )}

          </main>

          <aside className="lg:col-span-2 space-y-8">
            {/* Health Breakdown Panel - Moved to top */}
            {scoreForQueryPet && (
              <div className="bg-surface rounded-2xl shadow-lg p-6 border-l-4 border-green-500 border border-surface-highlight">
                <h4 className="text-lg font-bold mb-4 flex items-center justify-center text-gray-200">
                  <span className="text-2xl mr-2">üè•</span>
                  Health Analysis
                </h4>
                <div className="mb-4 flex justify-center">
                  <Image
                    src="/images/emojis/Mascots/Proffessor Purfessor/PUrfessorDesk.jpg"
                    alt="Professor Purfessor"
                    width={280}
                    height={210}
                    className="rounded-lg object-contain"
                    unoptimized
                  />
                </div>
                <p className="text-xs text-gray-400 mb-4">
                  Proffessor Purfessor has found these individual factors that contribute to the overall compatibility score
                </p>
                <div className="space-y-3">
                  {Object.entries(scoreForQueryPet.breakdown).map(([key, factor]) => {
                    const f = factor as { score: number; weightedContribution?: number; weight: number; reason?: string };
                    const score = f.score || 0;
                    const weightedContribution = f.weightedContribution ?? Math.round(score * (f.weight || 0));
                    const weight = f.weight || 0;

                    // Always show all health factors with appropriate colors
                    let bgColor = 'bg-green-900/20 border-green-700/50';
                    let icon = '‚úÖ';
                    let textColor = 'text-green-200';

                    if (score < 70) {
                      bgColor = 'bg-yellow-900/20 border-yellow-700/50';
                      icon = '‚ö†Ô∏è';
                      textColor = 'text-yellow-200';
                    }
                    if (score < 40) {
                      bgColor = 'bg-red-900/20 border-red-700/50';
                      icon = '‚ùå';
                      textColor = 'text-red-200';
                    }

                    // Format factor name
                    const factorName = key.replace(/([A-Z])/g, ' $1').toLowerCase();
                    // Format tooltip content with better structure and spacing
                    const formattedFactorName = factorName.charAt(0).toUpperCase() + factorName.slice(1);
                    
                    // Get recommendations for this factor
                    let recommendationText = '';
                    const factorWithRecommendations = f as typeof f & { recommendations?: any[] };
                    if (key === 'nutritionalFit' && factorWithRecommendations.recommendations && factorWithRecommendations.recommendations.length > 0) {
                      recommendationText += '\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\nüíä Recommendations:\n';
                      const supplements = factorWithRecommendations.recommendations.filter((r: any) => !r.isIngredient);
                      const ingredients = factorWithRecommendations.recommendations.filter((r: any) => r.isIngredient);
                      
                      if (supplements.length > 0) {
                        recommendationText += `\nCheck Supplements tab for: ${supplements.map((r: any) => r.productName || r.name).join(', ')}`;
                      }
                      if (ingredients.length > 0) {
                        recommendationText += `\nCheck Ingredients tab for: ${ingredients.map((r: any) => r.name).join(', ')}`;
                      }
                    }
                    
                    const tooltipContent = `üìä ${formattedFactorName}\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\nRaw Score: ${score}%\nWeight: ${(weight * 100).toFixed(0)}%\nContribution: ${weightedContribution} points\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n${f.reason ? `üí° ${f.reason}` : 'No additional details available'}${recommendationText}`;

                    return (
                      <Tooltip key={key} content={tooltipContent} wide={key === 'nutritionalFit'}>
                        <div className={`flex items-center justify-between p-3 ${bgColor} rounded-lg border cursor-help hover:opacity-80 transition-colors`}>
                          <div className="flex items-center gap-2">
                            <span className="text-sm">{icon}</span>
                            <span className={`text-sm font-medium capitalize ${textColor}`}>
                              {factorName}
                            </span>
                          </div>
                          <div className="flex flex-col items-end">
                            <span className={`text-sm font-bold ${textColor}`}>
                              {score}%
                            </span>
                            <span className="text-xs text-gray-400">
                              +{weightedContribution} pts
                            </span>
                          </div>
                        </div>
                      </Tooltip>
                    );
                  })}
                </div>
              </div>
            )}

            {/* Cost Comparison */}
            {allShoppingItems.length > 0 && mealEstimate && mealEstimate.estimatedMeals > 0 && mealEstimate.costPerMeal > 0 && (
              <CostComparison 
                costPerMeal={mealEstimate.costPerMeal}
                totalCost={mealEstimate.totalCost}
                estimatedMeals={mealEstimate.estimatedMeals}
                exceedsBudget={mealEstimate.exceedsBudget || false}
              />
            )}



            {/* Action Buttons */}
            {!isMealAdded && (
              <div className="bg-surface rounded-2xl shadow-lg p-6 space-y-4 border border-surface-highlight">
                <button
                  onClick={handleAddToMealPlan}
                  disabled={isAddingMeal}
                  className={`btn btn-success btn-lg btn-full ${
                    isAddingMeal 
                      ? 'btn-loading' 
                      : 'btn-ripple'
                  }`}
                >
                  {isAddingMeal ? 'Adding...' : '+Add Meal'}
                </button>
              </div>
            )}

            {/* Preparation Instructions */}
            <div className="bg-surface rounded-2xl shadow-lg p-6 border border-surface-highlight">
              <h3 className="text-xl font-bold text-foreground mb-4 border-b border-surface-highlight pb-3">
                üë®‚Äçüç≥ Preparation
              </h3>
              <ol className="space-y-4">
                {recipe.instructions?.map((step, index) => (
                  <li key={index} className="flex items-start">
                    <span className="flex-shrink-0 w-6 h-6 bg-secondary-900/50 border border-secondary-700 text-secondary-200 rounded-full flex items-center justify-center font-bold mr-3 mt-1 text-sm">
                      {index + 1}
                    </span>
                    <span className="text-gray-300 text-base leading-relaxed">
                      {step}
                    </span>
                  </li>
                ))}
              </ol>
            </div>
          </aside>
        </div>
      </div>

      {/* Recipe Score Modal */}
      {isScoreModalOpen && scoreForQueryPet && (
        <RecipeScoreModal
          recipe={recipe}
          pet={(() => {
            const pet = getPetsFromLocalStorage(userId).find((p) => p.id === queryPetId);
            if (!pet) return null;
            return {
              id: pet.id,
              name: getRandomName(pet.names),
              type: pet.type as 'dog' | 'cat' | 'bird' | 'reptile' | 'pocket-pet',
              breed: pet.breed,
              age: pet.age === 'baby' ? 0.5 : pet.age === 'young' ? 2 : pet.age === 'adult' ? 5 : 10,
              weight: parseFloat(pet.weight) || (pet.type === 'dogs' ? 25 : pet.type === 'cats' ? 10 : 5),
              activityLevel: 'moderate' as const,
              healthConcerns: pet.healthConcerns || [],
              dietaryRestrictions: pet.allergies || []
            };
          })()}
          onClose={() => setIsScoreModalOpen(false)}
        />
      )}

      {/* One-Click Checkout Modal */}
      {recipe && (
        <OneClickCheckoutModal
          isOpen={isCheckoutOpen}
          onClose={() => setIsCheckoutOpen(false)}
          items={(vettedRecipe?.ingredients || recipe.ingredients || [])
            .filter((ing: any) => ing.asinLink)
            .map((ing: any) => ({
              id: ing.id,
              name: ing.name,
              asinLink: ensureSellerId(ing.asinLink),
              amount: ing.amount,
              asin: extractASIN(ing.asinLink)
            }))}
          recipeName={recipe.name}
          userId={userId}
        />
      )}
    </div>
  );
}
</file>

<file path="app/recipes/recommended/[id]/page.tsx">
'use client';

import { useState, useEffect, useMemo } from 'react';
import { useParams } from 'next/navigation';
import Link from 'next/link';
import { ArrowLeft } from 'lucide-react';
import type { Recipe, Pet } from '@/lib/types';
import RecipeCard from '@/components/RecipeCard';
import {
  calculateEnhancedCompatibility,
  calibrateScoresForPet,
  type Pet as EnhancedPet,
} from '@/lib/utils/enhancedCompatibilityScoring';

const SIMULATED_USER_ID = 'clerk_simulated_user_id_123';

interface Pet {
  id: string;
  name: string;
  type: string;
  breed: string;
  age: string;
  healthConcerns: string[];
  mealPlan: string[];
  savedRecipes?: string[];
  names?: string[];
  weight?: string | number;
  weightKg?: number;
  dietaryRestrictions?: string[];
  allergies?: string[];
  dislikes?: string[];
}

const getPetsFromLocalStorage = (userId: string): Pet[] => {
  if (typeof window === 'undefined') return [];
  const stored = localStorage.getItem(`pets_${userId}`);
  if (!stored) return [];
  try {
    const parsed = JSON.parse(stored);
    return Array.isArray(parsed) ? parsed : [];
  } catch {
    return [];
  }
};

export default function RecommendedRecipesPage() {
  const params = useParams();
  const petId = params.id as string;

  const [pet, setPet] = useState<Pet | null>(null);
  const [loading, setLoading] = useState(true);

  // Convert pet data to enhanced compatibility format
  const enhancedPet: EnhancedPet | null = pet ? {
    id: pet.id,
    name: pet.name,
    type: pet.type as 'dog' | 'cat' | 'bird' | 'reptile' | 'pocket-pet',
    breed: pet.breed,
    age: pet.age === 'baby' ? 0.5 : pet.age === 'young' ? 2 : pet.age === 'adult' ? 5 : 10, // Convert to years
    weight: 25, // Default to 25 lbs since weight isn't stored in this format
    activityLevel: 'moderate' as const, // Default activity level
    healthConcerns: pet.healthConcerns || [],
    dietaryRestrictions: [] // Not available in current pet format
  } : null;

  useEffect(() => {
    if (petId) {
      const userId = SIMULATED_USER_ID;
      const pets = getPetsFromLocalStorage(userId);
      const foundPet = pets.find((p) => p.id === petId) || null;
      setPet(foundPet);
      setLoading(false);
    }
  }, [petId]);

  const scoredRecipes = useMemo(() => {
    if (!pet) return [];

    // Debug logging removed - use logger if needed

    // Calculate compatibility scores for all recipes against this pet using enhanced scoring
    const scored = recipes.map((recipe) => {
      if (!enhancedPet) return { recipe, score: null };
      
      try {
        const enhanced = calculateEnhancedCompatibility(recipe, enhancedPet);
        return {
          recipe,
          score: {
            compatibilityScore: enhanced.overallScore,
            stars: Math.round(enhanced.overallScore / 20),
            reasoning: {
              goodMatches: enhanced.detailedBreakdown.healthBenefits,
              conflicts: enhanced.detailedBreakdown.warnings,
            },
            enhancedScore: enhanced, // keep for detail view
          }
        };
      } catch (error) {
        console.error('Error calculating compatibility:', error);
        return { recipe, score: null };
      }
    });

    // Apply per-pet calibration to normalize scores
    // This ensures 100% is rare and meaningful, and scores are spread across the range
    const validScored = scored.filter(s => s.score !== null && enhancedPet);
    if (validScored.length > 0 && enhancedPet) {
      
      const recipesToCalibrate = validScored.map(s => s.recipe);
      const calibratedScores = calibrateScoresForPet(recipesToCalibrate, enhancedPet);
      
      // Update scores with calibrated values
      validScored.forEach((item) => {
        const calibratedScore = calibratedScores.get(item.recipe.id);
        if (calibratedScore !== undefined && item.score) {
          item.score.compatibilityScore = calibratedScore;
          item.score.stars = Math.round(calibratedScore / 20);
          // Update enhanced score if it exists
          if (item.score.enhancedScore) {
            item.score.enhancedScore.overallScore = calibratedScore;
          }
        }
      });
    }

    // Debug logging removed - use logger if needed

    // Sort by compatibility score (highest first)
    const sorted = scored.sort((a, b) => {
      if (!a.score || !b.score) return 0;
      return b.score.compatibilityScore - a.score.compatibilityScore;
    });

    // Debug logging removed - use logger if needed

    return sorted;
  }, [pet]);

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <p className="text-gray-600">Loading recommended recipes...</p>
      </div>
    );
  }

  if (!pet) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <div className="bg-white p-8 rounded-xl shadow text-center space-y-4">
          <p className="text-xl font-semibold text-gray-800">Pet not found.</p>
          <Link href="/profile" className="text-primary-600 font-semibold">
            Back to Profiles
          </Link>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50 py-12">
      <div className="max-w-7xl mx-auto px-4">
        <div className="flex items-center gap-4 mb-8">
          <Link
            href={`/profile/pet/${pet.id}/meal-plan`}
            className="inline-flex items-center gap-2 text-gray-600 hover:text-primary-600 font-medium"
          >
            <ArrowLeft size={20} />
            Back to Meal Plan
          </Link>
        </div>

        <div className="mb-8">
          <h1 className="text-4xl font-bold text-gray-900 mb-2">
            Best Matches for {pet.name}
          </h1>
          <p className="text-gray-600 mb-4">
            Recipes ranked by how well they match {pet.name}'s nutritional needs, breed, age, and health concerns.
            Higher compatibility scores indicate better suitability.
          </p>

          {/* Debug Info */}
          <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-4 mb-4">
            <h3 className="font-semibold text-yellow-800 mb-2">Debug Info:</h3>
            <p className="text-sm text-yellow-700">
              Pet Type: <strong>{pet.type}</strong> |
              Total Recipes: <strong>{recipes?.length || 0}</strong> |
              Scored Recipes: <strong>{scoredRecipes.length}</strong> |
              Recipes with Score {'>'} 0: <strong>{scoredRecipes.filter(s => s.score?.compatibilityScore && s.score.compatibilityScore > 0).length}</strong>
            </p>
            {scoredRecipes.length > 0 && (
              <p className="text-sm text-yellow-700 mt-1">
                Top Score: <strong>{scoredRecipes[0]?.score?.compatibilityScore || 0}%</strong> |
                Sample Recipe: <strong>{scoredRecipes[0]?.recipe?.name} ({scoredRecipes[0]?.recipe?.category})</strong>
              </p>
            )}
          </div>
        </div>

        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {scoredRecipes.slice(0, 50).map(({ recipe }) => (
            <RecipeCard
              key={recipe.id}
              recipe={recipe}
              pet={pet}
            />
          ))}
        </div>

        {scoredRecipes.length > 50 && (
          <div className="text-center mt-8">
            <p className="text-gray-600">
              Showing top 50 best compatibility matches. There are {scoredRecipes.length - 50} more recipes available.
            </p>
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="app/robots.ts">
import { MetadataRoute } from 'next';

export default function robots(): MetadataRoute.Robots {
  const baseUrl = 'https://petplatesmealplatform-ldvstwjsy-plateandpaw.vercel.app';
  
  return {
    rules: [
      {
        userAgent: '*',
        allow: '/',
        disallow: [
          '/api/',
          '/profile/',
          '/sign-in/',
          '/sign-up/',
          '/_next/',
          '/admin/',
          '*.json',
          '/dashboard/private',
        ],
      },
      {
        userAgent: 'Googlebot',
        allow: '/',
        disallow: ['/api/', '/profile/', '/sign-in/', '/sign-up/'],
      },
      {
        userAgent: 'Googlebot-Image',
        allow: '/',
      },
    ],
    sitemap: `${baseUrl}/sitemap.xml`,
    host: baseUrl,
  };
}
</file>

<file path="app/sign-in/[[...sign-in]]/page.tsx">
import { SignIn } from "@clerk/nextjs";

export default function Page() {
  return (
    <div className="flex items-center justify-center min-h-screen bg-gray-50">
      <SignIn />
    </div>
  );
}
</file>

<file path="app/sign-up/[[...sign-up]]/page.tsx">
import { SignUp } from "@clerk/nextjs";

export default function Page() {
  return (
    <div className="flex items-center justify-center min-h-screen">
      <SignUp />
    </div>
  );
}
</file>

<file path="app/sitemap.ts">
import { MetadataRoute } from 'next';

// Dynamic sitemap generation for Next.js
export default function sitemap(): MetadataRoute.Sitemap {
  const baseUrl = 'https://petplatesmealplatform-ldvstwjsy-plateandpaw.vercel.app';
  
  // Static pages
  const routes = [
    '',
    '/about',
    '/contact',
    '/faq',
    '/privacy',
    '/subscribe',
    '/nutrition-guide',
    '/meal-plans',
    '/forum',
    '/forum/gallery',
    '/blog',
    '/dashboard',
  ].map((route) => ({
    url: `${baseUrl}${route}`,
    lastModified: new Date(),
    changeFrequency: route === '' ? 'daily' as const : 'weekly' as const,
    priority: route === '' ? 1.0 : 0.8,
  }));

  // Pet category pages
  const categories = ['dogs', 'cats', 'birds', 'reptiles', 'pocket-pets'].map((category) => ({
    url: `${baseUrl}/category/${category}`,
    lastModified: new Date(),
    changeFrequency: 'weekly' as const,
    priority: 0.9,
  }));

  // Blog posts (if you have them)
  const blogPosts = [
    'homemade-dog-food-recipes',
    'cat-nutrition-guide',
    'bird-diet-essentials',
    'reptile-meal-prep',
    'small-pet-feeding-tips',
  ].map((slug) => ({
    url: `${baseUrl}/blog/${slug}`,
    lastModified: new Date(),
    changeFrequency: 'monthly' as const,
    priority: 0.7,
  }));

  return [...routes, ...categories, ...blogPosts];
}
</file>

<file path="app/subscribe/page.tsx">
'use client';

import { useState } from 'react';
import Link from 'next/link';
import { Mail, CheckCircle } from 'lucide-react';

export default function SubscribePage() {
  const [email, setEmail] = useState('');
  const [petType, setPetType] = useState('');
  const [submitted, setSubmitted] = useState(false);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    // Here you would send to your backend/email service
    setSubmitted(true);
  };

  if (submitted) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center px-4">
        <div className="max-w-md w-full bg-white rounded-lg shadow-lg p-8 text-center">
          <CheckCircle className="text-green-600 mx-auto mb-4" size={64} />
          <h2 className="text-3xl font-bold text-gray-900 mb-4">
            You're Subscribed!
          </h2>
          <p className="text-gray-600 mb-6">
            Check your inbox for a welcome email with exclusive recipes and tips.
          </p>
          <Link
            href="/"
            className="inline-block px-6 py-3 bg-primary-600 text-white font-semibold rounded-lg hover:bg-primary-700 transition-colors"
          >
            Back to Home
          </Link>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Header */}
      <div className="bg-gradient-to-r from-primary-600 to-primary-800 text-white py-16 px-4">
        <div className="max-w-4xl mx-auto text-center">
          <h1 className="text-4xl md:text-5xl font-bold mb-4">
            Subscribe to ThePetPantry
          </h1>
          <p className="text-xl text-primary-100">
            Get exclusive recipes, nutrition tips, and special offers
          </p>
        </div>
      </div>

      <div className="max-w-2xl mx-auto px-4 py-12">
        {/* Benefits */}
        <div className="bg-white rounded-lg shadow-md p-8 mb-8">
          <h2 className="text-2xl font-bold text-gray-900 mb-6 text-center">
            What You'll Get
          </h2>
          <ul className="space-y-4">
            <li className="flex items-start gap-3">
              <CheckCircle className="text-primary-600 flex-shrink-0 mt-1" size={24} />
              <div>
                <h3 className="font-bold text-gray-900">Weekly Recipe Updates</h3>
                <p className="text-gray-600">New recipes delivered to your inbox every week</p>
              </div>
            </li>
            <li className="flex items-start gap-3">
              <CheckCircle className="text-primary-600 flex-shrink-0 mt-1" size={24} />
              <div>
                <h3 className="font-bold text-gray-900">Nutrition Tips</h3>
                <p className="text-gray-600">Expert advice on pet nutrition and health</p>
              </div>
            </li>
            <li className="flex items-start gap-3">
              <CheckCircle className="text-primary-600 flex-shrink-0 mt-1" size={24} />
              <div>
                <h3 className="font-bold text-gray-900">Exclusive Discounts</h3>
                <p className="text-gray-600">Subscriber-only deals on meal plans</p>
              </div>
            </li>
            <li className="flex items-start gap-3">
              <CheckCircle className="text-primary-600 flex-shrink-0 mt-1" size={24} />
              <div>
                <h3 className="font-bold text-gray-900">Early Access</h3>
                <p className="text-gray-600">Be first to try new recipes and features</p>
              </div>
            </li>
          </ul>
        </div>

        {/* Subscribe Form */}
        <div className="bg-white rounded-lg shadow-md p-8">
          <form onSubmit={handleSubmit} className="space-y-6">
            <div>
              <label htmlFor="email" className="block text-sm font-semibold text-gray-700 mb-2">
                Email Address
              </label>
              <div className="relative">
                <Mail className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400" size={20} />
                <input
                  type="email"
                  id="email"
                  required
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                  placeholder="your.email@example.com"
                  className="w-full pl-10 pr-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary-500"
                />
              </div>
            </div>

            <div>
              <label htmlFor="petType" className="block text-sm font-semibold text-gray-700 mb-2">
                What type of pet do you have?
              </label>
              <select
                id="petType"
                required
                value={petType}
                onChange={(e) => setPetType(e.target.value)}
                className="w-full px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary-500"
              >
                <option value="">Select your pet type</option>
                <option value="dog">Dog</option>
                <option value="cat">Cat</option>
                <option value="bird">Bird</option>
                <option value="reptile">Reptile</option>
                <option value="pocket-pet">Pocket Pet</option>
                <option value="multiple">Multiple Pets</option>
              </select>
            </div>

            <button
              type="submit"
              className="w-full px-6 py-4 bg-primary-600 text-white font-semibold rounded-lg hover:bg-primary-700 transition-colors text-lg"
            >
              Subscribe Now
            </button>

            <p className="text-sm text-gray-500 text-center">
              We respect your privacy. Unsubscribe anytime. No spam, we promise! üêæ
            </p>
          </form>
        </div>

        {/* Social Proof */}
        <div className="mt-12 text-center">
          <p className="text-gray-600 mb-4">
            Join <strong>10,000+</strong> pet parents who trust ThePetPantry
          </p>
          <div className="flex justify-center gap-2">
            {[1, 2, 3, 4, 5].map((star) => (
              <svg
                key={star}
                className="w-6 h-6 text-yellow-400 fill-current"
                viewBox="0 0 20 20"
              >
                <path d="M10 15l-5.878 3.09 1.123-6.545L.489 6.91l6.572-.955L10 0l2.939 5.955 6.572.955-4.756 4.635 1.123 6.545z" />
              </svg>
            ))}
          </div>
          <p className="text-sm text-gray-600 mt-2">
            4.9/5 average rating from our community
          </p>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="components/ABTestDashboard.tsx">
'use client';

import React, { useState, useEffect } from 'react';
import { BarChart3, RefreshCw, Trophy, TrendingUp } from 'lucide-react';
import { getConversionStats, type ButtonVariant } from '@/lib/utils/abTesting';

// Admin dashboard to view A/B test results in-app
export default function ABTestDashboard() {
  const [stats, setStats] = useState<any>(null);
  const [isVisible, setIsVisible] = useState(false);

  const loadStats = () => {
    setStats(getConversionStats());
  };

  useEffect(() => {
    loadStats();
  }, []);

  if (!isVisible) {
    return (
      <button
        onClick={() => setIsVisible(true)}
        className="fixed bottom-4 right-4 bg-green-700 hover:bg-green-600 text-white p-3 rounded-full shadow-lg z-40 border-2 border-orange-500"
        title="View A/B Test Results"
      >
        <BarChart3 size={24} />
      </button>
    );
  }

  if (!stats) {
    return null;
  }

  // Calculate totals and winner
  const variants = Object.entries(stats) as [ButtonVariant, any][];
  const totalClicks = variants.reduce((sum, [_, data]) => sum + data.total, 0);
  const winner = variants.reduce((best, current) => 
    current[1].total > best[1].total ? current : best
  );

  const getVariantLabel = (id: ButtonVariant) => {
    const labels = {
      'shop-now': 'Shop Now',
      'buy-amazon': 'Buy on Amazon',
      'get-ingredients': 'Get Ingredients'
    };
    return labels[id] || id;
  };

  const getPercentage = (count: number) => {
    if (totalClicks === 0) return 0;
    return ((count / totalClicks) * 100).toFixed(1);
  };

  return (
    <div className="fixed bottom-4 right-4 bg-surface border-2 border-orange-500/50 rounded-2xl shadow-2xl p-6 w-96 z-50 max-h-[80vh] overflow-y-auto">
      {/* Header */}
      <div className="flex items-center justify-between mb-4 pb-3 border-b border-surface-highlight">
        <h3 className="text-xl font-bold text-white flex items-center gap-2">
          <BarChart3 className="text-orange-400" size={24} />
          A/B Test Results
        </h3>
        <div className="flex gap-2">
          <button
            onClick={loadStats}
            className="text-gray-400 hover:text-white p-1"
            title="Refresh"
          >
            <RefreshCw size={20} />
          </button>
          <button
            onClick={() => setIsVisible(false)}
            className="text-gray-400 hover:text-white p-1"
            title="Close"
          >
            √ó
          </button>
        </div>
      </div>

      {/* Summary */}
      <div className="mb-6 p-4 bg-green-900/20 border border-green-700/30 rounded-lg">
        <div className="text-center">
          <div className="text-3xl font-black text-green-400 mb-1">
            {totalClicks}
          </div>
          <div className="text-sm text-gray-400">Total Clicks Tracked</div>
        </div>
      </div>

      {/* Winner Badge */}
      {totalClicks > 10 && (
        <div className="mb-4 p-3 bg-gradient-to-r from-orange-500/20 to-yellow-500/20 border border-orange-500/50 rounded-lg">
          <div className="flex items-center gap-2 text-orange-400 font-bold text-sm">
            <Trophy size={20} />
            <span>Current Leader: {getVariantLabel(winner[0])}</span>
          </div>
          <div className="text-xs text-gray-400 mt-1">
            {winner[1].total} clicks ({getPercentage(winner[1].total)}%)
          </div>
        </div>
      )}

      {/* Variant Breakdown */}
      <div className="space-y-3">
        {variants.map(([variant, data]) => {
          const percentage = getPercentage(data.total);
          const isWinner = variant === winner[0] && totalClicks > 10;
          
          return (
            <div
              key={variant}
              className={`p-4 rounded-lg border-2 transition-all ${
                isWinner
                  ? 'bg-orange-900/20 border-orange-500/50'
                  : 'bg-surface-highlight border-surface-highlight'
              }`}
            >
              <div className="flex items-center justify-between mb-2">
                <div className="font-semibold text-white flex items-center gap-2">
                  {isWinner && <Trophy size={16} className="text-orange-400" />}
                  {getVariantLabel(variant)}
                </div>
                <div className="text-lg font-bold text-orange-400">
                  {data.total}
                </div>
              </div>
              
              {/* Progress Bar */}
              <div className="w-full bg-surface rounded-full h-2 mb-2">
                <div
                  className={`h-2 rounded-full transition-all ${
                    isWinner ? 'bg-orange-500' : 'bg-gray-600'
                  }`}
                  style={{ width: `${percentage}%` }}
                />
              </div>
              
              <div className="flex items-center justify-between text-xs text-gray-400">
                <span>{percentage}% of total clicks</span>
                {isWinner && (
                  <span className="flex items-center gap-1 text-orange-400">
                    <TrendingUp size={12} />
                    Leading
                  </span>
                )}
              </div>
              
              {/* Context Breakdown */}
              {Object.keys(data.byContext).length > 0 && (
                <div className="mt-2 pt-2 border-t border-surface text-xs">
                  <div className="text-gray-500 mb-1">By context:</div>
                  <div className="flex gap-2 flex-wrap">
                    {Object.entries(data.byContext).map(([context, count]: [string, any]) => (
                      <span
                        key={context}
                        className="bg-surface px-2 py-1 rounded text-gray-400"
                      >
                        {context}: {count}
                      </span>
                    ))}
                  </div>
                </div>
              )}
            </div>
          );
        })}
      </div>

      {/* Action Buttons */}
      <div className="mt-6 pt-4 border-t border-surface-highlight space-y-2">
        <button
          onClick={() => {
            if (confirm('Reset all A/B test data?')) {
              localStorage.removeItem('ab_button_clicks');
              loadStats();
            }
          }}
          className="w-full py-2 px-4 bg-red-600/20 hover:bg-red-600/30 border border-red-500/50 text-red-400 rounded-lg text-sm font-semibold transition-colors"
        >
          Reset Test Data
        </button>
        
        <button
          onClick={() => {
            if (confirm('Change your variant? (will refresh page)')) {
              localStorage.removeItem('ab_button_variant');
              window.location.reload();
            }
          }}
          className="w-full py-2 px-4 bg-green-600/20 hover:bg-green-600/30 border border-green-500/50 text-green-400 rounded-lg text-sm font-semibold transition-colors"
        >
          Change My Variant
        </button>
      </div>

      {/* Instructions */}
      <div className="mt-4 p-3 bg-surface-lighter rounded-lg">
        <p className="text-xs text-gray-500 leading-relaxed">
          <strong className="text-gray-400">How it works:</strong> Each visitor is randomly assigned one of 3 button text variants. 
          We track which variant gets more clicks to find the best performing copy.
        </p>
        <p className="text-xs text-gray-500 mt-2">
          <strong className="text-gray-400">Console:</strong> Run <code className="bg-surface px-1 rounded">logABTestResults()</code> for details.
        </p>
      </div>
    </div>
  );
}
</file>

<file path="components/BadgeToggle.tsx">
// components/BadgeToggle.tsx
// Badge toggle component for demonstrating badges in pet profile

'use client';

import { useState, useEffect } from 'react';
import { BadgeType, BadgeTier, type PetBadges } from '@/lib/types/badges';
import { getPetBadges, unlockBadge, removeBadge } from '@/lib/utils/badgeStorage';
import { BADGE_DEFINITIONS } from '@/lib/data/badgeDefinitions';
import Image from 'next/image';

interface BadgeToggleProps {
  petId: string;
  userId: string;
  onBadgeChange?: () => void;
}

export default function BadgeToggle({ petId, userId, onBadgeChange }: BadgeToggleProps) {
  const [badges, setBadges] = useState<PetBadges>({ badges: [] });
  const [isExpanded, setIsExpanded] = useState(false);

  useEffect(() => {
    if (!petId || !userId) return;
    const loadedBadges = getPetBadges(userId, petId);
    setBadges(loadedBadges);
  }, [petId, userId]);

  const handleToggleBadge = (badgeType: BadgeType, tier?: BadgeTier) => {
    const existingBadge = badges.badges.find(b => b.type === badgeType);
    
    if (existingBadge) {
      // Remove badge
      removeBadge(userId, petId, badgeType);
    } else {
      // Add badge
      unlockBadge(userId, petId, badgeType, tier);
    }
    
    // Refresh badges
    const updatedBadges = getPetBadges(userId, petId);
    setBadges(updatedBadges);
    
    // Dispatch event for other components
    window.dispatchEvent(new CustomEvent('badgesUpdated'));
    
    // Trigger refresh in parent
    if (onBadgeChange) {
      onBadgeChange();
    }
  };

  const handleToggleTier = (badgeType: BadgeType, tier: BadgeTier) => {
    const existingBadge = badges.badges.find(b => b.type === badgeType);
    
    if (existingBadge && existingBadge.tier === tier) {
      // Remove badge if clicking the same tier
      removeBadge(userId, petId, badgeType);
    } else {
      // Unlock with specific tier
      unlockBadge(userId, petId, badgeType, tier);
    }
    
    // Refresh badges
    const updatedBadges = getPetBadges(userId, petId);
    setBadges(updatedBadges);
    
    // Dispatch event for other components
    window.dispatchEvent(new CustomEvent('badgesUpdated'));
    
    if (onBadgeChange) {
      onBadgeChange();
    }
  };

  const hasBadge = (badgeType: BadgeType, tier?: BadgeTier): boolean => {
    const badge = badges.badges.find(b => b.type === badgeType);
    if (!badge) return false;
    if (tier) {
      return badge.tier === tier;
    }
    return true;
  };

  return (
    <div className="mt-3">
      <button
        onClick={() => setIsExpanded(!isExpanded)}
        className="text-xs text-orange-400 hover:text-orange-300 underline mb-2"
      >
        {isExpanded ? '‚ñº Hide Badge Demo' : '‚ñ∂ Demo Badges'}
      </button>
      
      {isExpanded && (
        <div className="mt-2 space-y-3 p-3 bg-surface rounded border border-surface-highlight">
          <p className="text-xs text-gray-400 mb-2">Toggle badges on/off to see them displayed:</p>
          
          {Object.values(BADGE_DEFINITIONS).map((def) => {
            const badge = badges.badges.find(b => b.type === def.type);
            const isUnlocked = badge !== undefined;
            
            if (def.isProgressive && def.tiers) {
              // Progressive badge with tiers
              return (
                <div key={def.type} className="pb-2 border-b border-surface-highlight last:border-b-0">
                  <div className="flex items-center gap-2 mb-2">
                    <input
                      type="checkbox"
                      checked={isUnlocked}
                      onChange={() => handleToggleBadge(def.type)}
                      className="w-4 h-4"
                    />
                    <label className="text-xs font-semibold text-gray-300 flex-1">
                      {def.name}
                    </label>
                    {isUnlocked && (
                      <span className="text-xs text-gray-500">
                        ({badge?.tier || 'bronze'})
                      </span>
                    )}
                  </div>
                  
                  {isUnlocked && (
                    <div className="ml-6 space-y-1">
                      <p className="text-xs text-gray-400 mb-1">Tiers:</p>
                      <div className="flex flex-wrap gap-2">
                        {def.tiers.map((tierDef) => (
                          <button
                            key={tierDef.tier}
                            onClick={() => handleToggleTier(def.type, tierDef.tier)}
                            className={`flex items-center gap-1 px-2 py-1 rounded text-xs border transition-colors ${
                              hasBadge(def.type, tierDef.tier)
                                ? 'bg-orange-900/30 border-orange-500/50 text-orange-300'
                                : 'bg-surface-highlight border-surface-highlight text-gray-400 hover:border-gray-500'
                            }`}
                          >
                            <div className="w-4 h-4 rounded bg-surface-highlight border border-white/10 flex items-center justify-center">
                              {hasBadge(def.type, tierDef.tier) && (
                                <span className="text-xs">‚úì</span>
                              )}
                            </div>
                            {tierDef.name}
                          </button>
                        ))}
                      </div>
                    </div>
                  )}
                </div>
              );
            } else {
              // Single-tier badge
              return (
                <div key={def.type} className="flex items-center gap-2">
                  <input
                    type="checkbox"
                    checked={isUnlocked}
                    onChange={() => handleToggleBadge(def.type)}
                    className="w-4 h-4"
                  />
                  <div className="w-6 h-6 rounded bg-surface-highlight border border-white/10 flex items-center justify-center flex-shrink-0">
                    <Image
                      src={def.iconPath}
                      alt={def.name}
                      width={20}
                      height={20}
                      className="object-contain no-invert-badge"
                      unoptimized
                      onError={(e) => {
                        (e.target as HTMLImageElement).style.display = 'none';
                      }}
                    />
                  </div>
                  <label className="text-xs text-gray-300 flex-1 cursor-pointer">
                    {def.name}
                  </label>
                </div>
              );
            }
          })}
        </div>
      )}
    </div>
  );
}
</file>

<file path="components/CompatibilityBadge.tsx">
import React from 'react';

import { getScoreTier, type ScoreTier } from '@/lib/utils/enhancedCompatibilityScoring';

interface CompatibilityBadgeProps {
  compatibility?: 'excellent' | 'good' | 'fair' | 'poor';
  score: number;
  className?: string;
  isGoldStandard?: boolean;
  hasPerfectMatches?: boolean;
}

export const CompatibilityBadge: React.FC<CompatibilityBadgeProps> = ({
  compatibility,
  score,
  className = '',
  isGoldStandard = false,
  hasPerfectMatches = true
}) => {
  // Use scoring tier system for better UX
  const tier = getScoreTier(score);
  
  // Determine compatibility from score if not provided
  const effectiveCompatibility = compatibility || (
    score >= 95 ? 'excellent' :
    score >= 85 ? 'good' :
    score >= 70 ? 'fair' : 'poor'
  );
  
  const getBadgeStyles = () => {
    switch (effectiveCompatibility) {
      case 'excellent':
        return 'bg-green-100 text-green-800 border-green-200';
      case 'good':
        return 'bg-blue-100 text-blue-800 border-blue-200';
      case 'fair':
        return 'bg-yellow-100 text-yellow-800 border-yellow-200';
      case 'poor':
        return 'bg-red-100 text-red-800 border-red-200';
      default:
        return 'bg-gray-100 text-gray-800 border-gray-200';
    }
  };

  const getCompatibilityLabel = (): string => {
    if (score >= 95 && isGoldStandard) {
      return 'Perfect Match';
    } else if (score >= 90) {
      return 'Excellent Match';
    } else if (score >= 85) {
      return 'Great Match';
    } else if (score >= 80) {
      return 'Good Match';
    } else if (score >= 70) {
      return 'Acceptable Match';
    } else {
      return hasPerfectMatches 
        ? 'Below Average Match'
        : 'Best Available Match';
    }
  };

  const getScoreSubtext = (): string => {
    if (!hasPerfectMatches && score < 90) {
      return ' (no perfect matches for this profile yet)';
    }
    if (isGoldStandard) {
      return ' (meets all requirements)';
    }
    return '';
  };

  return (
    <div className={`inline-flex items-center px-3 py-1 rounded-full text-sm font-medium border ${getBadgeStyles()} ${className}`}>
      <span>{score}% {getCompatibilityLabel()}{getScoreSubtext()}</span>
    </div>
  );
};
</file>

<file path="components/CompatibilityPanel.tsx">
'use client';

import { AlertTriangle, CheckCircle, XCircle, Target, Info } from 'lucide-react';
import { MealAnalysis } from '@/lib/analyzeCustomMeal';

interface CompatibilityPanelProps {
  analysis: MealAnalysis | null;
  isAnalyzing: boolean;
  totalGrams: number;
  ingredientCount: number;
}

export default function CompatibilityPanel({
  analysis,
  isAnalyzing,
  totalGrams,
  ingredientCount
}: CompatibilityPanelProps) {
  if (isAnalyzing) {
    return (
      <div className="bg-white rounded-lg border border-gray-200 p-6">
        <div className="flex items-center justify-center gap-3">
          <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-primary-600"></div>
          <span className="text-gray-600 text-sm">Analyzing...</span>
        </div>
      </div>
    );
  }

  if (!analysis) {
    return (
      <div className="bg-white rounded-lg border border-gray-200 p-6">
        <div className="text-center text-gray-400 text-sm">
          <Info size={24} className="mx-auto mb-2 opacity-50" />
          <p>Add ingredients to see compatibility score</p>
        </div>
      </div>
    );
  }

  const getScoreColor = (score: number) => {
    if (score >= 80) return 'text-green-600 bg-green-50 border-green-200';
    if (score >= 60) return 'text-yellow-600 bg-yellow-50 border-yellow-200';
    return 'text-red-600 bg-red-50 border-red-200';
  };

  const getScoreIcon = (score: number) => {
    if (score >= 80) return <CheckCircle size={20} className="text-green-600" />;
    if (score >= 60) return <AlertTriangle size={20} className="text-yellow-600" />;
    return <XCircle size={20} className="text-red-600" />;
  };

  return (
    <div className="space-y-4">
      {/* Compatibility Score */}
      <div className={`bg-white rounded-lg border-2 p-6 ${getScoreColor(analysis.score)}`}>
        <div className="flex items-center justify-between mb-4">
          <div className="flex items-center gap-2">
            {getScoreIcon(analysis.score)}
            <h3 className="font-semibold text-lg">Compatibility Score</h3>
          </div>
          <div className="text-3xl font-bold">{analysis.score}/100</div>
        </div>
        
        {/* Progress Bar */}
        <div className="w-full bg-white/50 rounded-full h-3 mb-2">
          <div
            className={`h-3 rounded-full transition-[width] duration-500 ease-out will-change-[width] ${
              analysis.score >= 80 ? 'bg-green-600' :
              analysis.score >= 60 ? 'bg-yellow-600' :
              'bg-red-600'
            }`}
            style={{ width: `${analysis.score}%` }}
          />
        </div>

        <div className="text-xs opacity-75 mt-2">
          {analysis.score >= 80 && '‚úì Excellent match for your pet'}
          {analysis.score >= 60 && analysis.score < 80 && '‚ö† Good, but could be improved'}
          {analysis.score < 60 && '‚úó Needs adjustments for safety'}
        </div>
      </div>

      {/* Warnings & Safety Alerts */}
      {(analysis.toxicityWarnings.length > 0 || analysis.allergyWarnings.length > 0) && (
        <div className="bg-red-50 rounded-lg border border-red-200 p-4">
          <div className="flex items-center gap-2 mb-2">
            <AlertTriangle size={16} className="text-red-600" />
            <h4 className="font-semibold text-red-900 text-sm">Safety Alerts</h4>
          </div>
          <div className="space-y-1">
            {analysis.toxicityWarnings.slice(0, 3).map((warning, idx) => (
              <div key={idx} className="text-xs text-red-800">
                ‚ö†Ô∏è {warning.message}
              </div>
            ))}
            {analysis.allergyWarnings.slice(0, 2).map((warning, idx) => (
              <div key={idx} className="text-xs text-red-800">
                ‚ö†Ô∏è {typeof warning === 'string' ? warning : warning.message}
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Safe Choices Indicator */}
      {analysis.score >= 60 && (
        <div className="bg-green-50 rounded-lg border border-green-200 p-4">
          <div className="flex items-center gap-2 mb-2">
            <CheckCircle size={16} className="text-green-600" />
            <h4 className="font-semibold text-green-900 text-sm">Safe Choices</h4>
          </div>
          <div className="text-xs text-green-800">
            ‚úì All selected ingredients are safe for your pet
          </div>
        </div>
      )}

      {/* Quick Nutrition Summary */}
      <div className="bg-white rounded-lg border border-gray-200 p-4">
        <h4 className="font-semibold text-gray-900 text-sm mb-3">Quick Summary</h4>
        <div className="space-y-2 text-xs">
          <div className="flex justify-between">
            <span className="text-gray-600">Total:</span>
            <span className="font-medium">{totalGrams}g ‚Ä¢ {ingredientCount} ingredients</span>
          </div>
          <div className="flex justify-between">
            <span className="text-gray-600">Calories:</span>
            <span className="font-medium">
              {((analysis.nutrients as any).kcal ?? (analysis.nutrients as any).calories_kcal ?? (analysis.nutrients as any).energy_kcal ?? 0).toFixed(0)} kcal
            </span>
          </div>
          {analysis.caToPratio && (
            <div className="flex justify-between">
              <span className="text-gray-600">Ca:P Ratio:</span>
              <span className="font-medium">{analysis.caToPratio.toFixed(1)}</span>
            </div>
          )}
        </div>
      </div>

      {/* Suggestions */}
      {analysis.suggestions.length > 0 && (
        <div className="bg-blue-50 rounded-lg border border-blue-200 p-4">
          <h4 className="font-semibold text-blue-900 text-sm mb-2">Suggestions</h4>
          <div className="space-y-1">
            {analysis.suggestions.slice(0, 2).map((suggestion, idx) => (
              <div key={idx} className="text-xs text-blue-800">
                üí° {typeof suggestion === 'string' ? suggestion : suggestion.message}
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="components/ConfirmModal.tsx">
import React from 'react';
import Image from 'next/image';
import { X, AlertTriangle } from 'lucide-react';

interface ConfirmModalProps {
  isOpen: boolean;
  onClose: () => void;
  onConfirm: () => void;
  title?: string;
  message?: string;
  confirmText?: string;
  cancelText?: string;
  isDeleteModal?: boolean;
}

export default function ConfirmModal({
  isOpen,
  onClose,
  onConfirm,
  title = 'Confirm Action',
  message = 'Are you sure you want to proceed?',
  confirmText = 'Confirm',
  cancelText = 'Cancel',
  isDeleteModal = false,
}: ConfirmModalProps) {
  
  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/60">
      <div 
        className={`rounded-xl shadow-2xl border-3 w-full ${isDeleteModal ? 'border-orange-500 max-w-2xl' : 'border-surface-highlight max-w-md'}`}
        style={isDeleteModal ? { backgroundColor: '#143424' } : {}}
      >
        <div className={`${isDeleteModal ? 'p-10' : 'p-6'}`}>
          <div className="flex items-start gap-6">
            {isDeleteModal && (
              <div className="flex-shrink-0">
                <Image
                  src="/images/emojis/Mascots/Harvest Hamster/HHReaper.jpg"
                  alt="Harvest Hamster"
                  width={240}
                  height={240}
                  className="w-[240px] h-[240px] object-contain mascot-icon mascot-farmer-fluff"
                  unoptimized
                />
              </div>
            )}
            {!isDeleteModal && (
              <div className="flex-shrink-0">
                <AlertTriangle className="w-6 h-6 text-yellow-500" />
              </div>
            )}
            <div className="flex-1">
              <h3 className="text-lg font-semibold text-foreground mb-2">{title}</h3>
              <p className="text-sm text-gray-400">{message}</p>
            </div>
            <button onClick={onClose} className="text-gray-400 hover:text-white">
              <X className="w-5 h-5" />
            </button>
          </div>

          <div className="flex gap-3 mt-6">
            <button
              onClick={onClose}
              className="flex-1 px-4 py-2 bg-surface-highlight text-foreground rounded-lg hover:bg-surface-lighter transition-colors"
            >
              {cancelText}
            </button>
            <button
              onClick={() => {
                onConfirm();
                onClose();
              }}
              className={`flex-1 px-4 py-2 rounded-lg transition-colors ${
                isDeleteModal
                  ? 'bg-orange-500 text-white hover:bg-orange-600'
                  : 'bg-primary-600 text-white hover:bg-primary-700'
              }`}
            >
              {confirmText}
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="components/CostComparison.tsx">
'use client';

interface CostComparisonProps {
  costPerMeal: number;
  totalCost?: number;
  estimatedMeals?: number;
  className?: string;
  exceedsBudget?: boolean; // True if costPerMeal > 4.50
}

export function CostComparison({ costPerMeal, totalCost, estimatedMeals, className = '', exceedsBudget = false }: CostComparisonProps) {
  const commercialCost = 4.50; // Average commercial pet food per meal
  const savings = commercialCost - costPerMeal;
  const savingsPercent = savings > 0 ? Math.round((savings / commercialCost) * 100) : 0;
  
  // Don't render if invalid data
  if (!costPerMeal || costPerMeal <= 0) {
    return null;
  }
  
  return (
    <div className={`bg-gradient-to-r from-green-700/35 to-emerald-700/35 rounded-xl p-6 border-2 border-green-500/65 ${className}`}>
      <h4 className="font-bold text-lg text-green-200 mb-4">üí∞ Cost Comparison</h4>
      
      {/* Budget Warning Banner */}
      {exceedsBudget && (
        <div className="mb-4 bg-yellow-900/60 border-2 border-yellow-500/70 rounded-lg p-3">
          <p className="text-sm font-semibold text-yellow-200">
            ‚ö†Ô∏è This meal exceeds the $4.50 target (${costPerMeal.toFixed(2)}/meal)
          </p>
          <p className="text-xs text-yellow-300 mt-1">
            Consider choosing cheaper ingredient alternatives to reduce cost.
          </p>
        </div>
      )}
      
      <div className="grid md:grid-cols-2 gap-4">
        {/* Homemade */}
        <div className="bg-surface rounded-lg p-4 border border-green-700/30">
          <p className="text-sm text-gray-400 mb-2">Homemade (Your Cost)</p>
          <p className="text-3xl font-bold text-green-400">${costPerMeal.toFixed(2)}/meal</p>
          <div className="mt-2 space-y-1">
            <p className="text-xs text-green-300">‚úì Fresh ingredients</p>
            <p className="text-xs text-green-300">‚úì Full control</p>
            <p className="text-xs text-green-300">‚úì Custom nutrition</p>
          </div>
        </div>
        
        {/* Commercial */}
        <div className="bg-surface rounded-lg p-4 border border-gray-700/30">
          <p className="text-sm text-gray-400 mb-2">Commercial Pet Food</p>
          <p className="text-3xl font-bold text-gray-400">${commercialCost.toFixed(2)}/meal</p>
          <p className="text-xs text-gray-500 mt-2">Typical premium brand</p>
        </div>
      </div>
      
      {savings > 0 && (
        <div className="mt-4 bg-green-900/40 border-2 border-green-500/50 rounded-lg p-4 text-center">
          <p className="text-lg font-bold text-green-300">
            You save ${savings.toFixed(2)} per meal ({savingsPercent}%)
          </p>
          <p className="text-sm text-green-200 mt-1">
            That's ${(savings * 30).toFixed(2)} per month!
          </p>
          {estimatedMeals && (
            <p className="text-xs text-green-300 mt-1">
              Total savings from this shopping trip: ${(savings * estimatedMeals).toFixed(2)}
            </p>
          )}
        </div>
      )}
      
      {savings < 0 && (
        <div className="mt-4 bg-yellow-900/40 border-2 border-yellow-500/50 rounded-lg p-4 text-center">
          <p className="text-sm text-yellow-200">
            Your homemade meals cost ${Math.abs(savings).toFixed(2)} more per meal, but you get fresh, customized nutrition!
          </p>
        </div>
      )}
      
      {/* Monthly Projection / Value Breakdown */}
      {totalCost && estimatedMeals && (
        <div className="mt-4 bg-surface rounded-lg p-4 border border-surface-highlight">
          <p className="text-xs font-semibold text-gray-300 mb-3">üìä Value Breakdown:</p>
          <div className="grid grid-cols-3 gap-3 text-xs">
            <div className="text-center">
              <p className="text-gray-400 mb-1">Estimated Meals</p>
              <p className="font-bold text-lg text-green-400">{estimatedMeals}</p>
              <p className="text-gray-500 text-[10px] mt-0.5">from these packages</p>
            </div>
            <div className="text-center">
              <p className="text-gray-400 mb-1">Total Cost</p>
              <p className="font-bold text-lg text-blue-400">${totalCost.toFixed(2)}</p>
              <p className="text-gray-500 text-[10px] mt-0.5">one-time purchase</p>
            </div>
            <div className="text-center">
              <p className="text-gray-400 mb-1">Cost Per Meal</p>
              <p className="font-bold text-lg text-green-400">${costPerMeal.toFixed(2)}</p>
              <p className="text-gray-500 text-[10px] mt-0.5">average</p>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="components/CreatePetModal.tsx">
'use client';

import { useState, useEffect, useMemo, useCallback, memo } from 'react';
import { X, Check, ChevronLeft, ChevronRight } from 'lucide-react';
import { getMascotFaceForPetType } from '@/lib/utils/emojiMapping';
import { getBreedNamesForSpecies } from '@/lib/data/speciesBreeds';
import { getHealthConcernsForSpecies } from '@/lib/data/health-concerns';
import type { Pet } from '@/lib/types';

// --- Type Definitions ---
type PetCategory = 'dogs' | 'cats' | 'birds' | 'reptiles' | 'pocket-pets';
type HealthConcern = string; // Now dynamic based on species
type HealthConcernWithNone = 'none' | HealthConcern;
type ActivityLevel = 'high' | 'medium' | 'low';

interface FormData {
  name: string;
  type: PetCategory | '';
  breed: string;
  weight?: string;
  activityLevel: ActivityLevel | undefined;
  healthConcerns: HealthConcernWithNone[];
  allergies: string[];
  customAllergies: string;
}

interface AddPetModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSubmit: (pet: Pet) => void;
  editingPet?: Pet | null;
}

// --- Static Data ---
// Health concerns will be dynamically generated based on species

const initialFormData: FormData = {
  name: '',
  type: '',
  breed: '',
  weight: '',
  activityLevel: undefined as ActivityLevel | undefined,
  healthConcerns: [],
  allergies: [],
  customAllergies: '',
};

// --- Species-Specific Allergen Options ---
function getAllergenOptionsForSpecies(species: PetCategory | ''): Array<{ value: string; label: string }> {
  if (!species) return [];

  const allergens: Record<PetCategory, Array<{ value: string; label: string }>> = {
    'dogs': [
      { value: 'chicken', label: 'Chicken' },
      { value: 'beef', label: 'Beef' },
      { value: 'pork', label: 'Pork' },
      { value: 'fish', label: 'Fish' },
      { value: 'lamb', label: 'Lamb' },
      { value: 'turkey', label: 'Turkey' },
      { value: 'duck', label: 'Duck' },
      { value: 'rabbit', label: 'Rabbit' },
      { value: 'venison', label: 'Venison' },
      { value: 'dairy', label: 'Dairy' },
      { value: 'egg', label: 'Eggs' },
      { value: 'wheat', label: 'Wheat' },
      { value: 'corn', label: 'Corn' },
      { value: 'soy', label: 'Soy' },
      { value: 'rice', label: 'Rice' },
      { value: 'peanut', label: 'Peanuts' },
    ],
    'cats': [
      { value: 'chicken', label: 'Chicken' },
      { value: 'beef', label: 'Beef' },
      { value: 'pork', label: 'Pork' },
      { value: 'fish', label: 'Fish' },
      { value: 'lamb', label: 'Lamb' },
      { value: 'turkey', label: 'Turkey' },
      { value: 'duck', label: 'Duck' },
      { value: 'rabbit', label: 'Rabbit' },
      { value: 'dairy', label: 'Dairy' },
      { value: 'egg', label: 'Eggs' },
      { value: 'wheat', label: 'Wheat' },
      { value: 'corn', label: 'Corn' },
      { value: 'soy', label: 'Soy' },
    ],
    'birds': [
      { value: 'peanut', label: 'Peanuts' },
      { value: 'sunflower-seeds', label: 'Sunflower Seeds' },
      { value: 'millet', label: 'Millet' },
      { value: 'corn', label: 'Corn' },
      { value: 'wheat', label: 'Wheat' },
      { value: 'soy', label: 'Soy' },
      { value: 'egg', label: 'Eggs' },
      { value: 'dairy', label: 'Dairy' },
      { value: 'chocolate', label: 'Chocolate' },
      { value: 'avocado', label: 'Avocado' },
    ],
    'reptiles': [
      { value: 'crickets', label: 'Crickets' },
      { value: 'mealworms', label: 'Mealworms' },
      { value: 'waxworms', label: 'Waxworms' },
      { value: 'superworms', label: 'Superworms' },
      { value: 'dubia-roaches', label: 'Dubia Roaches' },
      { value: 'spinach', label: 'Spinach' },
      { value: 'kale', label: 'Kale' },
      { value: 'collard-greens', label: 'Collard Greens' },
      { value: 'dandelion-greens', label: 'Dandelion Greens' },
    ],
    'pocket-pets': [
      { value: 'alfalfa', label: 'Alfalfa' },
      { value: 'timothy-hay', label: 'Timothy Hay' },
      { value: 'wheat', label: 'Wheat' },
      { value: 'corn', label: 'Corn' },
      { value: 'soy', label: 'Soy' },
      { value: 'peanuts', label: 'Peanuts' },
      { value: 'sunflower-seeds', label: 'Sunflower Seeds' },
      { value: 'dairy', label: 'Dairy' },
      { value: 'chocolate', label: 'Chocolate' },
    ],
  };

  return allergens[species] || [];
}

// --- Button Components (Defined Outside) ---
const PetTypeButton = memo(({ petType, isSelected, onClick, mascotSrc, label }: { 
  petType: PetCategory; 
  isSelected: boolean; 
  onClick: () => void;
  mascotSrc: string;
  label: string;
}) => (
  <button
    type="button"
    onClick={onClick}
    className={`flex flex-col items-center justify-center p-3 rounded-xl transition-colors duration-150 ${
      isSelected 
        ? 'bg-primary-900/30 shadow-md' 
        : 'bg-surface-lighter hover:bg-surface-highlight'
    }`}
    style={{ 
      contain: 'layout style paint',
      border: isSelected ? '3px solid #f97316' : '3px solid rgba(249, 115, 22, 0.5)'
    }}
  >
    <div className="w-12 h-12 rounded-full overflow-hidden mb-2 flex-shrink-0">
      <img
        src={mascotSrc}
        alt={`${petType} mascot`}
        width={48}
        height={48}
        className="w-full h-full object-cover"
        loading="eager"
      />
    </div>
    <span className={`text-xs font-medium ${isSelected ? 'text-primary-400' : 'text-gray-400'}`}>
      {label}
    </span>
  </button>
));
PetTypeButton.displayName = 'PetTypeButton';

const BreedButton = memo(({ breed, isSelected, onClick }: { 
  breed: string; 
  isSelected: boolean; 
  onClick: () => void;
}) => (
  <button
    type="button"
    onClick={onClick}
    className={`p-3 rounded-xl text-sm text-left transition-colors duration-150 ${
      isSelected
        ? 'bg-primary-900/30 text-primary-200 shadow-md'
        : 'bg-surface-lighter text-gray-300 hover:bg-surface-highlight'
    }`}
    style={{ 
      contain: 'layout style paint',
      border: isSelected ? '3px solid #f97316' : '3px solid rgba(249, 115, 22, 0.5)'
    }}
  >
    {breed}
  </button>
));
BreedButton.displayName = 'BreedButton';

const ActivityButton = memo(({ level, label, isSelected, onClick }: { 
  level: ActivityLevel;
  label: string;
  isSelected: boolean; 
  onClick: () => void;
}) => (
  <button
    type="button"
    onClick={onClick}
    className={`p-3 rounded-xl transition-colors duration-150 ${
      isSelected
        ? 'bg-primary-900/30 text-primary-200 shadow-md'
        : 'bg-surface-lighter text-gray-300 hover:bg-surface-highlight'
    }`}
    style={{ 
      contain: 'layout style paint',
      border: isSelected ? '3px solid #f97316' : '3px solid rgba(249, 115, 22, 0.5)'
    }}
  >
    {label}
  </button>
));
ActivityButton.displayName = 'ActivityButton';

const HealthConcernButton = memo(({ option, isSelected, isDisabled, onClick }: { 
  option: { value: string; label: string };
  isSelected: boolean;
  isDisabled: boolean;
  onClick: () => void;
}) => (
  <button
    type="button"
    onClick={(e) => {
      e.preventDefault();
      e.stopPropagation();
      if (!isDisabled) {
        onClick();
      }
    }}
    disabled={isDisabled}
    className={`flex items-center justify-between p-4 rounded-xl text-left transition-colors duration-150 ${
      isDisabled ? 'bg-surface text-gray-600 cursor-not-allowed opacity-50' : 'cursor-pointer'
    } ${
      isSelected 
        ? 'bg-primary-900/30 text-primary-200 shadow-md' 
        : 'bg-surface-lighter text-gray-300 hover:bg-surface-highlight'
    }`}
    style={{ 
      contain: 'layout style paint',
      border: isDisabled ? '3px solid rgba(249, 115, 22, 0.2)' : isSelected ? '3px solid #f97316' : '3px solid rgba(249, 115, 22, 0.5)',
      pointerEvents: isDisabled ? 'none' : 'auto'
    }}
  >
    <span className="font-medium text-sm">{option.label}</span>
    <div className={`w-5 h-5 rounded-full border flex items-center justify-center ${
      isSelected ? 'bg-primary-600 border-primary-600' : 'bg-surface border-gray-500'
    }`}>
      {isSelected && <Check className="w-3 h-3 text-white" />}
    </div>
  </button>
));
HealthConcernButton.displayName = 'HealthConcernButton';

const AllergyButton = memo(({ allergen, isSelected, onClick }: { 
  allergen: { value: string; label: string };
  isSelected: boolean;
  onClick: () => void;
}) => (
  <button
    type="button"
    onClick={onClick}
    className={`flex items-center justify-between p-3 rounded-xl text-left transition-colors duration-150 ${
      isSelected 
        ? 'bg-primary-900/30 text-primary-200 shadow-md' 
        : 'bg-surface-lighter text-gray-300 hover:bg-surface-highlight'
    }`}
    style={{ 
      contain: 'layout style paint',
      border: isSelected ? '3px solid #f97316' : '3px solid rgba(249, 115, 22, 0.5)'
    }}
  >
    <span className="font-medium text-sm">{allergen.label}</span>
    <div className={`w-5 h-5 rounded-full border flex items-center justify-center ${
      isSelected ? 'bg-primary-600 border-primary-600' : 'bg-surface border-gray-500'
    }`}>
      {isSelected && <Check className="w-3 h-3 text-white" />}
    </div>
  </button>
));
AllergyButton.displayName = 'AllergyButton';

// --- Step Components (Defined Outside with Props) ---
const Step1 = memo(({ 
  formData, 
  error,
  typeLabels,
  mascotPaths,
  petTypeHandlers,
  onNameChange,
  onPrevious
}: {
  formData: FormData;
  error: string | null;
  typeLabels: Record<PetCategory, string>;
  mascotPaths: Record<PetCategory, string>;
  petTypeHandlers: Record<PetCategory, () => void>;
  onNameChange: (value: string) => void;
  onPrevious?: () => void;
}) => (
  <div className="space-y-6">
    <h3 className="text-xl font-semibold text-foreground">1. Basic Info</h3>
    
    <div className="space-y-2">
      <label htmlFor="name" className="text-sm font-medium text-gray-300 block">Pet's Name</label>
      <input
        id="name"
        name="name"
        type="text"
        value={formData.name}
        onChange={(e) => onNameChange(e.target.value)}
        placeholder="e.g., Buster"
        autoFocus
        className="w-full px-4 py-2 border border-surface-highlight bg-surface-lighter text-foreground rounded-xl focus:ring-primary-500 focus:border-primary-500 transition duration-150"
        required
      />
    </div>

    <div className="space-y-2">
      <label className="text-sm font-medium text-gray-300 block">Pet Type</label>
      <div className="grid grid-cols-5 gap-3">
        {(['dogs', 'cats', 'birds', 'reptiles', 'pocket-pets'] as PetCategory[]).map((petType) => (
          <PetTypeButton
            key={petType}
            petType={petType}
            isSelected={formData.type === petType}
            onClick={petTypeHandlers[petType]}
            mascotSrc={mascotPaths[petType]}
            label={typeLabels[petType]}
          />
        ))}
      </div>
      {!formData.type && (
        <p className="text-xs text-gray-500 mt-1">Please select a pet type</p>
      )}
    </div>

    {error && <p className="text-red-400 text-sm mt-4">{error}</p>}

    {onPrevious && (
      <div className="flex justify-start pt-6 border-t border-surface-highlight">
        <button
          type="button"
          onClick={(e) => {
            e.preventDefault();
            e.stopPropagation();
            onPrevious();
          }}
          className="flex items-center px-6 py-3 bg-gray-600 text-white font-medium rounded-xl hover:bg-gray-700 transition-colors duration-150"
        >
          <ChevronLeft className="w-5 h-5 mr-2" />
          Previous
        </button>
      </div>
    )}
  </div>
));
Step1.displayName = 'Step1';

const Step2 = memo(({ 
  formData,
  error,
  sortedBreeds,
  onBreedSelect,
  onPrevious
}: {
  formData: FormData;
  error: string | null;
  sortedBreeds: string[];
  onBreedSelect: (breed: string) => void;
  onPrevious?: () => void;
}) => (
  <div className="space-y-6">
    <h3 className="text-xl font-semibold text-foreground">2. Choose Breed</h3>
    <p className="text-sm text-gray-400">Pick the closest match. If unsure, pick "Mixed".</p>

    <div className="grid grid-cols-1 gap-3 max-h-[320px] overflow-y-auto pr-1">
      {sortedBreeds.map((breed) => (
        <BreedButton
          key={breed}
          breed={breed}
          isSelected={formData.breed === breed}
          onClick={() => onBreedSelect(breed)}
        />
      ))}
    </div>

    {error && <p className="text-red-400 text-sm mt-4">{error}</p>}

    {onPrevious && (
      <div className="flex justify-start pt-6 border-t border-surface-highlight">
        <button
          type="button"
          onClick={onPrevious}
          className="flex items-center px-6 py-3 bg-gray-600 text-white font-medium rounded-xl hover:bg-gray-700 transition-colors duration-150"
        >
          <ChevronLeft className="w-5 h-5 mr-2" />
          Previous
        </button>
      </div>
    )}
  </div>
));
Step2.displayName = 'Step2';

const Step3 = memo(({ 
  formData,
  onWeightChange,
  onActivitySelect,
  onPrevious
}: {
  formData: FormData;
  onWeightChange: (value: string) => void;
  onActivitySelect: (level: ActivityLevel) => void;
  onPrevious?: () => void;
}) => (
  <div className="space-y-6">
    <h3 className="text-xl font-semibold text-foreground">3. Weight & Activity</h3>
    <p className="text-sm text-gray-400">These are informational only and not yet used for calculations.</p>

    <div className="space-y-2">
      <label htmlFor="weight" className="text-sm font-medium text-gray-300 block">Weight (any format)</label>
      <input
        id="weight"
        name="weight"
        type="text"
        value={formData.weight || ''}
        onChange={(e) => onWeightChange(e.target.value)}
        placeholder="e.g., 2.3 kg or 5 lbs"
        className="w-full px-4 py-2 border border-surface-highlight bg-surface-lighter text-foreground rounded-xl focus:ring-primary-500 focus:border-primary-500 transition duration-150"
      />
    </div>

    <div className="space-y-3">
      <p className="text-sm font-medium text-gray-300">Activity Level</p>
      <div className="grid grid-cols-3 gap-3">
        {(['low', 'medium', 'high'] as ActivityLevel[]).map((level) => (
          <ActivityButton
            key={level}
            level={level}
            label={level === 'low' ? 'Low' : level === 'medium' ? 'Medium' : 'High'}
            isSelected={formData.activityLevel === level}
            onClick={() => onActivitySelect(level)}
          />
        ))}
      </div>
    </div>

    {onPrevious && (
      <div className="flex justify-start pt-6 border-t border-surface-highlight">
        <button
          type="button"
          onClick={onPrevious}
          className="flex items-center px-6 py-3 bg-gray-600 text-white font-medium rounded-xl hover:bg-gray-700 transition-colors duration-150"
        >
          <ChevronLeft className="w-5 h-5 mr-2" />
          Previous
        </button>
      </div>
    )}
  </div>
));
Step3.displayName = 'Step3';

const Step4 = memo(({ 
  formData,
  error,
  healthConcernOptions,
  onHealthConcernToggle,
  onSubmit,
  editingPet,
  onPrevious,
  onNext
}: {
  formData: FormData;
  error: string | null;
  healthConcernOptions: Array<{ value: string; label: string }>;
  onHealthConcernToggle: (concern: HealthConcernWithNone) => void;
  onSubmit: () => void;
  editingPet?: Pet | null;
  onPrevious?: () => void;
  onNext?: () => void;
}) => (
  <div className="space-y-6">
    <h3 className="text-xl font-semibold text-foreground">4. Health Concerns</h3>
    <p className="text-sm text-gray-400">Select any concerns your pet currently has. This will tailor their meal plan recommendations.</p>
    
    <div className="grid grid-cols-2 gap-4" style={{ pointerEvents: 'auto' }}>
      {healthConcernOptions.map(option => {
        const isSelected = formData.healthConcerns.includes(option.value as HealthConcernWithNone);
        const isDisabled = option.value !== 'none' && formData.healthConcerns.includes('none');
        
        return (
          <HealthConcernButton
            key={option.value}
            option={option}
            isSelected={isSelected}
            isDisabled={isDisabled}
            onClick={() => onHealthConcernToggle(option.value as HealthConcernWithNone)}
          />
        );
      })}
    </div>

    {error && <p className="text-red-400 text-sm mt-4">{error}</p>}

    {(onPrevious || onNext) && (
      <div className="flex justify-between pt-6 border-t border-surface-highlight">
        {onPrevious && (
          <button
            type="button"
            onClick={(e) => {
              e.preventDefault();
              e.stopPropagation();
              onPrevious();
            }}
            className="flex items-center px-6 py-3 bg-gray-600 text-white font-medium rounded-xl hover:bg-gray-700 transition-colors duration-150"
          >
            <ChevronLeft className="w-5 h-5 mr-2" />
            Previous
          </button>
        )}
        {onNext && (
          <button
            type="button"
            onClick={onNext}
            className="flex items-center px-6 py-3 bg-primary-600 text-white font-medium rounded-xl hover:bg-primary-700 transition-colors duration-150 ml-auto"
          >
            Next
            <ChevronRight className="w-5 h-5 ml-2" />
          </button>
        )}
      </div>
    )}
  </div>
));
Step4.displayName = 'Step4';

const Step5 = memo(({ 
  formData,
  error,
  allergenOptions,
  onAllergyToggle,
  onCustomAllergiesChange,
  onSubmit,
  editingPet,
  onPrevious
}: {
  formData: FormData;
  error: string | null;
  allergenOptions: Array<{ value: string; label: string }>;
  onAllergyToggle: (allergen: string) => void;
  onCustomAllergiesChange: (value: string) => void;
  onSubmit: () => void;
  editingPet?: Pet | null;
  onPrevious?: () => void;
}) => {
  // Get custom allergies (those not in the predefined list)
  const predefinedAllergyValues = allergenOptions.map(o => o.value);
  const customAllergies = formData.allergies.filter(a => !predefinedAllergyValues.includes(a));
  const selectedPredefined = formData.allergies.filter(a => predefinedAllergyValues.includes(a));
  
  return (
  <div className="space-y-6">
    <h3 className="text-xl font-semibold text-foreground">5. Allergies</h3>
    <p className="text-sm text-gray-400">Select any foods your pet is allergic to. Recipes containing these ingredients will be excluded from recommendations.</p>
    
    <div className="grid grid-cols-2 gap-3">
      {allergenOptions.map(allergen => {
        const isSelected = formData.allergies.includes(allergen.value);
        
        return (
          <AllergyButton
            key={allergen.value}
            allergen={allergen}
            isSelected={isSelected}
            onClick={() => onAllergyToggle(allergen.value)}
          />
        );
      })}
    </div>

    <div className="space-y-2">
      <label htmlFor="customAllergies" className="text-sm font-medium text-gray-300 block">Other:</label>
      <input
        id="customAllergies"
        name="customAllergies"
        type="text"
        value={formData.customAllergies}
        onChange={(e) => onCustomAllergiesChange(e.target.value)}
        placeholder="e.g., venison, rabbit, duck (comma-separated)"
        className="w-full px-4 py-2 border border-surface-highlight bg-surface-lighter text-foreground rounded-xl focus:ring-primary-500 focus:border-primary-500 transition duration-150"
      />
      <p className="text-xs text-gray-500">Enter any additional allergies not listed above, separated by commas</p>
    </div>

    {(selectedPredefined.length > 0 || customAllergies.length > 0) && (
      <div className="mt-4 p-3 bg-yellow-900/20 border border-yellow-800/30 rounded-lg">
        <p className="text-sm text-yellow-200">
          <strong>Selected:</strong> {
            [
              ...selectedPredefined.map(a => allergenOptions.find(o => o.value === a)?.label).filter(Boolean),
              ...customAllergies
            ].join(', ')
          }
        </p>
      </div>
    )}

    {error && <p className="text-red-400 text-sm mt-4">{error}</p>}

    <div className="flex justify-between pt-6 border-t border-surface-highlight">
      {onPrevious && (
        <button
          type="button"
          onClick={onPrevious}
          className="flex items-center px-6 py-3 bg-gray-600 text-white font-medium rounded-xl hover:bg-gray-700 transition-colors duration-150"
        >
          <ChevronLeft className="w-5 h-5 mr-2" />
          Previous
        </button>
      )}
      <div className={onPrevious ? '' : 'ml-auto'}>
        <button
          type="button"
          onClick={onSubmit}
          className="flex items-center px-6 py-3 bg-green-600 text-white font-medium rounded-xl hover:bg-green-700 transition-colors duration-150 shadow-lg"
        >
          <Check className="w-5 h-5 mr-2" />
          {editingPet ? 'Save Changes' : 'Create Pet Profile'}
        </button>
      </div>
    </div>
  </div>
  );
});
Step5.displayName = 'Step5';

// --- Main Component ---
const AddPetModal = memo(function AddPetModal({ isOpen, onClose, onSubmit, editingPet }: AddPetModalProps) {
  const [step, setStep] = useState(1);
  const [formData, setFormData] = useState<FormData>(initialFormData);
  const [error, setError] = useState<string | null>(null);

  // Memoize static data - created once, never recreated
  const typeLabels = useMemo(() => ({
    'dogs': 'Dogs',
    'cats': 'Cats',
    'birds': 'Birds',
    'reptiles': 'Reptiles',
    'pocket-pets': 'Pocket Pets'
  }), []);

  const mascotPaths = useMemo(() => {
    const paths: Record<PetCategory, string> = {} as Record<PetCategory, string>;
    (['dogs', 'cats', 'birds', 'reptiles', 'pocket-pets'] as PetCategory[]).forEach((petType) => {
      paths[petType] = getMascotFaceForPetType(petType);
    });
    return paths;
  }, []);

  // Memoize sorted breeds - only recalculate when pet type changes
  const sortedBreeds = useMemo(() => {
    if (!formData.type) return ['Mixed'];
    const breeds = getBreedNamesForSpecies(formData.type);
    return breeds.length ? [...breeds].sort() : ['Mixed'];
  }, [formData.type]);

  // Generate species-specific health concerns dynamically
  const healthConcernOptions = useMemo(() => {
    const options = [{ value: 'none', label: 'None' }];
    
    if (!formData.type) {
      return options;
    }

    // Get species-specific concerns (with breed if available)
    const concerns = getHealthConcernsForSpecies(formData.type, formData.breed || undefined);
    
    // Convert to the format needed by the component
    const concernOptions = concerns.map(concern => ({
      value: concern.toLowerCase().replace(/[^a-z0-9]+/g, '-'),
      label: concern
    }));

    return [...options, ...concernOptions];
  }, [formData.type, formData.breed]);

  // Generate species-specific allergen options dynamically
  const allergenOptions = useMemo(() => {
    return getAllergenOptionsForSpecies(formData.type);
  }, [formData.type]);

  // Stable handlers - useCallback to prevent recreation
  const petTypeHandlers = useMemo(() => {
    const handlers: Record<PetCategory, () => void> = {} as Record<PetCategory, () => void>;
    (['dogs', 'cats', 'birds', 'reptiles', 'pocket-pets'] as PetCategory[]).forEach((petType) => {
      handlers[petType] = () => {
        setFormData(prev => ({ 
          ...prev, 
          type: petType, 
          breed: '', 
          healthConcerns: [], // Don't default to 'none'
          allergies: [] // Clear allergies when species changes (they're species-specific)
        }));
      };
    });
    return handlers;
  }, []);

  const handleNameChange = useCallback((value: string) => {
    setFormData(prev => ({ ...prev, name: value }));
  }, []);

  const handleBreedSelect = useCallback((breed: string) => {
    setFormData(prev => ({ ...prev, breed }));
  }, []);

  const handleWeightChange = useCallback((value: string) => {
    setFormData(prev => ({ ...prev, weight: value }));
  }, []);

  const handleActivitySelect = useCallback((level: ActivityLevel) => {
    setFormData(prev => ({ ...prev, activityLevel: level }));
  }, []);

  const handleHealthConcernToggle = useCallback((concern: HealthConcernWithNone) => {
    console.log('Health concern toggle clicked:', concern); // Debug log
    if (concern === 'none') {
      setFormData(prev => ({ 
        ...prev, 
        healthConcerns: prev.healthConcerns.includes('none') ? [] : ['none'] 
      }));
    } else {
      setFormData(prev => {
        const currentConcerns = prev.healthConcerns.filter(c => c !== 'none') as HealthConcern[];
        let newConcerns: HealthConcernWithNone[];
        
        if (currentConcerns.includes(concern as HealthConcern)) {
          newConcerns = currentConcerns.filter(c => c !== concern) as HealthConcernWithNone[];
        } else {
          newConcerns = [...currentConcerns, concern as HealthConcern] as HealthConcernWithNone[];
        }
        
        // Don't auto-add 'none' if list is empty - let user choose
        return { ...prev, healthConcerns: newConcerns };
      });
    }
  }, []);

  const handleAllergyToggle = useCallback((allergen: string) => {
    setFormData(prev => {
      const currentAllergies = prev.allergies || [];
      if (currentAllergies.includes(allergen)) {
        return { ...prev, allergies: currentAllergies.filter(a => a !== allergen) };
      } else {
        return { ...prev, allergies: [...currentAllergies, allergen] };
      }
    });
  }, []);

  const handleCustomAllergiesChange = useCallback((value: string) => {
    setFormData(prev => {
      // Get predefined allergy values (use current species-specific options)
      const currentAllergenOptions = getAllergenOptionsForSpecies(prev.type);
      const predefinedValues = currentAllergenOptions.map(o => o.value);
      // Remove any existing custom allergies (those not in predefined list)
      const existingPredefined = prev.allergies.filter(a => predefinedValues.includes(a));
      // Parse new custom allergies from the input (comma-separated, trim whitespace)
      const newCustomAllergies = value
        .split(',')
        .map(a => a.trim())
        .filter(a => a.length > 0);
      // Combine predefined and custom allergies
      return { 
        ...prev, 
        customAllergies: value,
        allergies: [...existingPredefined, ...newCustomAllergies]
      };
    });
  }, []);

  const handlePrevious = useCallback(() => {
    setError(null);
    setStep(prev => Math.max(1, prev - 1));
  }, []);

  const handleSubmitInternal = useCallback(() => {
    setError(null);

    // Map activityLevel from local type to shared Pet type
    const mapActivityLevel = (level: ActivityLevel): 'sedentary' | 'moderate' | 'active' | 'very-active' | undefined => {
      if (level === 'high') return 'very-active';
      if (level === 'medium') return 'moderate';
      if (level === 'low') return 'sedentary';
      return undefined;
    };

    // Convert name to names array for consistency
    const namesArray = formData.name.trim() 
      ? [formData.name.trim()] 
      : (editingPet?.names && Array.isArray(editingPet.names) && editingPet.names.length > 0
          ? editingPet.names 
          : ['Unnamed Pet']);

    const newPet: Pet = {
      ...formData,
      id: editingPet?.id || crypto.randomUUID(),
      type: formData.type as string,
      name: formData.name.trim() || undefined,
      names: namesArray,
      age: (editingPet?.age as string) || 'adult',
      breed: formData.breed || (editingPet?.breed as string) || 'Mixed',
      mealPlan: editingPet?.mealPlan || [],
      activityLevel: formData.activityLevel ? mapActivityLevel(formData.activityLevel) : undefined,
      healthConcerns: formData.healthConcerns.filter(c => c !== 'none') as string[],
      allergies: formData.allergies || [],
      savedRecipes: editingPet?.savedRecipes || [],
    };

    onSubmit(newPet);
    onClose();
  }, [formData, editingPet, onSubmit, onClose]);

  // Reset form when modal opens/closes
  useEffect(() => {
    if (isOpen) {
      setError(null);
      setStep(1);
      if (editingPet) {
      setFormData({
        name: editingPet.name || editingPet.names?.[0] || '',
        type: editingPet.type as PetCategory,
        breed: editingPet.breed || '',
        weight: editingPet.weight || '',
        activityLevel: (editingPet.activityLevel ? (editingPet.activityLevel as ActivityLevel) : undefined),
        healthConcerns: (editingPet.healthConcerns?.length ? (editingPet.healthConcerns as HealthConcernWithNone[]) : []) || [],
        allergies: editingPet.allergies || [],
        customAllergies: (() => {
          // Separate custom allergies (not in predefined list) from predefined ones
          const currentAllergenOptions = getAllergenOptionsForSpecies(editingPet.type as PetCategory);
          const predefinedValues = currentAllergenOptions.map(o => o.value);
          const custom = (editingPet.allergies || []).filter(a => !predefinedValues.includes(a));
          return custom.join(', ');
        })(),
      });
      } else {
        setFormData(initialFormData);
      }
    }
  }, [isOpen, editingPet]);

  // Combined auto-advance logic - single effect instead of multiple
  useEffect(() => {
    if (!isOpen) return;
    
    let timer: NodeJS.Timeout;
    
    if (step === 1 && formData.name.trim() && formData.type) {
      timer = setTimeout(() => {
        setStep(2);
        setError(null);
      }, 300);
    } else if (step === 2 && formData.breed) {
      timer = setTimeout(() => {
        setStep(3);
        setError(null);
      }, 300);
    } else if (step === 3 && formData.activityLevel) {
      timer = setTimeout(() => {
        setStep(4);
        setError(null);
      }, 500);
    } else if (step === 4 && formData.healthConcerns && formData.healthConcerns.length > 0 && false) {
      // Auto-advance disabled - users can select multiple health concerns before proceeding
      timer = setTimeout(() => {
        setStep(5);
        setError(null);
      }, 500);
    }
    
    return () => {
      if (timer) clearTimeout(timer);
    };
  }, [step, formData.name, formData.type, formData.breed, formData.activityLevel, formData.healthConcerns, isOpen]);

  if (!isOpen) return null;

  return (
    <div
      className="fixed inset-0 z-50 overflow-y-auto flex items-center justify-center p-4"
      style={{ backgroundColor: 'rgba(15, 44, 15, 0.85)' }}
      onClick={(e) => {
        if (e.target === e.currentTarget) onClose();
      }}
    >
      <div 
        className="rounded-2xl w-full max-w-lg shadow-xl border relative" 
        style={{ backgroundColor: '#1a3d2e', borderColor: '#2d5a47', borderWidth: '2px' }}
        onClick={(e) => e.stopPropagation()}
      >
        <div className="p-6 sm:p-8">
          <div className="flex justify-between items-center mb-6 border-b border-surface-highlight pb-4">
            <h2 className="text-2xl font-bold text-foreground">
              {editingPet ? 'Edit Pet Profile' : 'Create New Pet Profile'}
            </h2>
            <button
              onClick={onClose}
              className="p-2 rounded-full text-gray-400 hover:bg-surface-highlight hover:text-white transition-colors"
              aria-label="Close modal"
            >
              <X className="w-6 h-6" />
            </button>
          </div>

          <div>
            {step === 1 && (
              <Step1
                formData={formData}
                error={error}
                typeLabels={typeLabels}
                mascotPaths={mascotPaths}
                petTypeHandlers={petTypeHandlers}
                onNameChange={handleNameChange}
                onPrevious={step > 1 ? handlePrevious : undefined}
              />
            )}
            {step === 2 && (
              <Step2
                formData={formData}
                error={error}
                sortedBreeds={sortedBreeds}
                onBreedSelect={handleBreedSelect}
                onPrevious={handlePrevious}
              />
            )}
            {step === 3 && (
              <Step3
                formData={formData}
                onWeightChange={handleWeightChange}
                onActivitySelect={handleActivitySelect}
                onPrevious={handlePrevious}
              />
            )}
            {step === 4 && (
              <Step4
                formData={formData}
                error={error}
                healthConcernOptions={healthConcernOptions}
                onHealthConcernToggle={handleHealthConcernToggle}
                onSubmit={handleSubmitInternal}
                editingPet={editingPet}
                onPrevious={handlePrevious}
                onNext={() => setStep(5)}
              />
            )}
            {step === 5 && (
              <Step5
                formData={formData}
                error={error}
                allergenOptions={allergenOptions}
                onAllergyToggle={handleAllergyToggle}
                onCustomAllergiesChange={handleCustomAllergiesChange}
                onSubmit={handleSubmitInternal}
                editingPet={editingPet}
                onPrevious={handlePrevious}
              />
            )}
          </div>

          <div className="flex justify-center mt-6">
            {[1, 2, 3, 4, 5].map((s) => (
              <div 
                key={s} 
                className={`w-8 h-1 rounded-full mx-1 transition-colors ${
                  step === s ? 'bg-primary-600' : 'bg-gray-600'
                }`}
              />
            ))}
          </div>
        </div>
      </div>
    </div>
  );
});

AddPetModal.displayName = 'AddPetModal';

export default AddPetModal;
</file>

<file path="components/EmailCaptureModal.tsx">
'use client';

import React, { useState } from 'react';
import { X, Mail, Download, Sparkles } from 'lucide-react';
import { Pet } from '@/lib/types';

interface EmailCaptureModalProps {
  isOpen: boolean;
  onClose: () => void;
  petType?: string;
  mealCount?: number;
  trigger?: 'exit-intent' | 'meal-view' | 'plan-generated';
}

export default function EmailCaptureModal({
  isOpen,
  onClose,
  petType = 'your pet',
  mealCount = 5,
  trigger = 'meal-view'
}: EmailCaptureModalProps) {
  const [email, setEmail] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isSubmitted, setIsSubmitted] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!email || !email.includes('@')) {
      alert('Please enter a valid email address');
      return;
    }

    setIsSubmitting(true);

    try {
      // Store email in localStorage for now (later: send to email service)
      if (typeof window !== 'undefined') {
        const leads = JSON.parse(localStorage.getItem('email_leads') || '[]');
        leads.push({
          email,
          petType,
          trigger,
          timestamp: new Date().toISOString(),
          mealCount
        });
        localStorage.setItem('email_leads', JSON.stringify(leads));
      }

      // TODO: Send to email service (Mailchimp, ConvertKit, etc.)
      // await fetch('/api/subscribe', {
      //   method: 'POST',
      //   body: JSON.stringify({ email, petType, trigger })
      // });

      setIsSubmitted(true);
      
      // Close after 2 seconds
      setTimeout(() => {
        onClose();
        // Reset state after close animation
        setTimeout(() => {
          setIsSubmitted(false);
          setEmail('');
        }, 300);
      }, 2000);

    } catch (error) {
      console.error('Email capture error:', error);
      alert('Something went wrong. Please try again.');
    } finally {
      setIsSubmitting(false);
    }
  };

  if (!isOpen) return null;

  if (isSubmitted) {
    return (
      <div className="fixed inset-0 z-50 bg-black/70 backdrop-blur-sm flex items-center justify-center p-4">
        <div className="bg-gradient-to-br from-green-600 to-green-700 border-2 border-green-400 rounded-2xl shadow-2xl p-8 max-w-md w-full text-center">
          <div className="text-6xl mb-4 animate-bounce">üéâ</div>
          <h3 className="text-2xl font-bold text-white mb-2">You're In!</h3>
          <p className="text-green-100">
            Check your email for your free meal plan PDF and exclusive tips!
          </p>
        </div>
      </div>
    );
  }

  return (
    <div className="fixed inset-0 z-50 bg-black/70 backdrop-blur-sm flex items-center justify-center p-4">
      <div className="bg-surface border-2 border-orange-500/50 rounded-2xl shadow-2xl max-w-lg w-full overflow-hidden">
        {/* Header */}
        <div className="bg-gradient-to-r from-orange-500 to-orange-600 px-6 py-5 flex items-center justify-between">
          <div className="flex items-center gap-3">
            <div className="w-12 h-12 bg-white/20 rounded-full flex items-center justify-center">
              <Sparkles className="text-white" size={24} />
            </div>
            <div>
              <h2 className="text-2xl font-bold text-white">
                Wait! Get Your Free Meal Plan
              </h2>
              <p className="text-orange-100 text-sm">
                Instant PDF + Weekly nutrition tips
              </p>
            </div>
          </div>
          <button
            onClick={onClose}
            className="text-white/70 hover:text-white transition-colors p-1"
          >
            <X size={24} />
          </button>
        </div>

        {/* Content */}
        <div className="p-8">
          <div className="mb-6">
            <h3 className="text-xl font-semibold text-white mb-3">
              Get {mealCount}+ Personalized Meal Recipes for {petType}
            </h3>
            
            {/* Benefits */}
            <div className="space-y-3 mb-6">
              {[
                'üìß Instant delivery to your inbox',
                'ü•ó Vet-approved, nutritionally balanced',
                'üõí Direct Amazon shopping links',
                'üí∞ 100% FREE - No credit card required',
                'üéÅ BONUS: Weekly nutrition tips'
              ].map((benefit, idx) => (
                <div key={idx} className="flex items-start gap-3">
                  <div className="text-lg mt-0.5">{benefit.split(' ')[0]}</div>
                  <p className="text-gray-300 text-sm">
                    {benefit.split(' ').slice(1).join(' ')}
                  </p>
                </div>
              ))}
            </div>
          </div>

          {/* Email Form */}
          <form onSubmit={handleSubmit} className="space-y-4">
            <div>
              <label htmlFor="email" className="block text-sm font-medium text-gray-300 mb-2">
                Email Address
              </label>
              <input
                type="email"
                id="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                placeholder="your@email.com"
                required
                className="w-full px-4 py-3 bg-surface-highlight border-2 border-surface-highlight focus:border-orange-500 rounded-lg text-white placeholder-gray-500 focus:outline-none transition-colors"
              />
            </div>

            <button
              type="submit"
              disabled={isSubmitting}
              className={`w-full py-4 px-6 rounded-lg font-bold text-lg transition-all transform ${
                isSubmitting
                  ? 'bg-gray-600 cursor-wait text-gray-300 scale-95'
                  : 'bg-gradient-to-r from-green-600 to-green-700 hover:from-green-500 hover:to-green-600 text-white shadow-xl hover:shadow-2xl hover:scale-105 border-3 border-green-400'
              }`}
            >
              {isSubmitting ? (
                <span className="flex items-center justify-center gap-2">
                  <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-white"></div>
                  Sending...
                </span>
              ) : (
                <span className="flex items-center justify-center gap-2">
                  <Download size={20} />
                  Get My Free Meal Plan
                </span>
              )}
            </button>
          </form>

          {/* Privacy Note */}
          <p className="text-xs text-gray-500 text-center mt-4">
            We respect your privacy. Unsubscribe anytime. No spam, ever.
          </p>
        </div>

        {/* Trust Footer */}
        <div className="bg-surface-lighter px-6 py-4 border-t border-surface-highlight">
          <div className="flex items-center justify-center gap-6 text-xs text-gray-400">
            <span className="flex items-center gap-1">
              <span className="text-green-400">‚úì</span> 100% Free
            </span>
            <span className="flex items-center gap-1">
              <span className="text-green-400">‚úì</span> No Credit Card
            </span>
            <span className="flex items-center gap-1">
              <span className="text-green-400">‚úì</span> Instant Access
            </span>
          </div>
        </div>
      </div>
    </div>
  );
}

// Exit intent detector hook
export function useExitIntent(onExitIntent: () => void) {
  React.useEffect(() => {
    let hasShown = false;

    const handleMouseLeave = (e: MouseEvent) => {
      // Detect mouse leaving viewport at top (exit intent)
      if (e.clientY <= 10 && !hasShown) {
        hasShown = true;
        onExitIntent();
      }
    };

    document.addEventListener('mouseleave', handleMouseLeave);

    return () => {
      document.removeEventListener('mouseleave', handleMouseLeave);
    };
  }, [onExitIntent]);
}
</file>

<file path="components/EmojiIcon.tsx">
// components/EmojiIcon.tsx
// Component to replace emojis with custom emoji images
// 
// This component takes a Unicode emoji and displays the corresponding custom image
// from the emoji mapping system. All emojis are mapped in lib/utils/emojiMapping.ts
// which uses the "best" set (4x4 grid) for primary pet and status emojis, with
// fallbacks to amojis (8x10 grid) and copilot_emojis (10x11 grid) sets.

import Image from 'next/image';
import { getEmojiImage } from '@/lib/utils/emojiMapping';

interface EmojiIconProps {
  emoji: string;
  size?: number;
  className?: string;
}

export default function EmojiIcon({ emoji, size = 24, className = '' }: EmojiIconProps) {
  const imagePath = getEmojiImage(emoji);
  
  return (
    <span 
      className={`inline-block align-middle ${className}`}
      style={{ 
        display: 'inline-block', 
        verticalAlign: 'middle',
      }}
    >
      <Image
        src={imagePath}
        alt={emoji}
        width={size}
        height={size}
        className="inline-block align-middle"
        style={{ 
          display: 'inline-block', 
          verticalAlign: 'middle',
          imageRendering: 'crisp-edges',
        }}
        unoptimized
      />
    </span>
  );
}
</file>

<file path="components/ErrorBoundary.tsx">
// components/ErrorBoundary.tsx
// Global error boundary for catching React errors

'use client';

import React, { Component, ReactNode } from 'react';
import { AlertTriangle } from 'lucide-react';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('ErrorBoundary caught an error:', error, errorInfo);
    
    // Log to error tracking service (e.g., Sentry)
    // trackError(error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }

      return (
        <div className="min-h-screen bg-gray-50 flex items-center justify-center p-4">
          <div className="bg-white rounded-xl shadow-lg p-8 max-w-md w-full">
            <div className="flex items-center justify-center w-16 h-16 bg-red-100 rounded-full mx-auto mb-4">
              <AlertTriangle className="w-8 h-8 text-red-600" />
            </div>
            
            <h2 className="text-2xl font-bold text-gray-900 text-center mb-2">
              Something went wrong
            </h2>
            
            <p className="text-gray-600 text-center mb-6">
              We're sorry, but something unexpected happened. Please try refreshing the page.
            </p>
            
            {process.env.NODE_ENV === 'development' && this.state.error && (
              <details className="mb-4">
                <summary className="text-sm text-gray-500 cursor-pointer hover:text-gray-700">
                  Error details (dev only)
                </summary>
                <pre className="mt-2 text-xs bg-gray-100 p-3 rounded overflow-auto max-h-40">
                  {this.state.error.toString()}
                  {'\n'}
                  {this.state.error.stack}
                </pre>
              </details>
            )}
            
            <div className="flex gap-3">
              <button
                onClick={() => window.location.reload()}
                className="flex-1 px-4 py-2 bg-primary-600 text-white rounded-lg hover:bg-primary-700 transition-colors font-medium"
              >
                Refresh Page
              </button>
              <button
                onClick={() => window.location.href = '/'}
                className="flex-1 px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition-colors font-medium"
              >
                Go Home
              </button>
            </div>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}

export default ErrorBoundary;
</file>

<file path="components/ErrorBoundaryWrapper.tsx">
// components/ErrorBoundaryWrapper.tsx
// Client component wrapper for ErrorBoundary

'use client';

import { ErrorBoundary } from './ErrorBoundary';

export default function ErrorBoundaryWrapper({ children }: { children: React.ReactNode }) {
  return (
    <ErrorBoundary>
      {children}
    </ErrorBoundary>
  );
}
</file>

<file path="components/FeedingLogger.tsx">
'use client';

import { useState } from 'react';
import { logMealFed, normalizeIngredientNames } from '@/lib/utils/diversityTracker';

interface FeedingLoggerProps {
  petId: string;
  recipeId: string;
  recipeName: string;
  ingredients: (string | { name?: string; id?: string })[];
  onClose: () => void;
  onLogged?: () => void;
}

export default function FeedingLogger({
  petId,
  recipeId,
  recipeName,
  ingredients,
  onClose,
  onLogged,
}: FeedingLoggerProps) {
  const [fedAt, setFedAt] = useState(() => new Date().toISOString().slice(0, 16));
  const [portion, setPortion] = useState<'all' | 'most' | 'some' | 'none'>('all');

  const handleSubmit = () => {
    const entryDate = fedAt ? new Date(fedAt) : new Date();
    logMealFed({
      petId,
      recipeId,
      recipeName,
      ingredients: normalizeIngredientNames(ingredients as any),
      fedAt: entryDate,
    });
    onLogged?.();
    onClose();
  };

  return (
    <div className="fixed inset-0 z-50 bg-black/50 flex items-center justify-center px-4">
      <div className="bg-surface rounded-xl shadow-2xl border border-surface-highlight w-full max-w-md p-5 space-y-4">
        <div className="flex items-center justify-between">
          <h3 className="text-lg font-semibold text-foreground">Mark as Fed</h3>
          <button onClick={onClose} className="text-gray-400 hover:text-white text-sm">
            ‚úï
          </button>
        </div>
        <div className="space-y-3 text-sm">
          <div>
            <label className="block text-xs text-gray-400 mb-1">Meal</label>
            <div className="text-foreground font-medium">{recipeName}</div>
          </div>
          <div>
            <label className="block text-xs text-gray-400 mb-1" htmlFor="fedAt">
              Date / Time
            </label>
            <input
              id="fedAt"
              type="datetime-local"
              value={fedAt}
              onChange={(e) => setFedAt(e.target.value)}
              className="w-full px-3 py-2 rounded-lg bg-surface-highlight border border-surface-highlight text-foreground text-sm"
            />
          </div>
          <div>
            <label className="block text-xs text-gray-400 mb-1">Portion eaten</label>
            <div className="flex flex-wrap gap-2">
              {(['all', 'most', 'some', 'none'] as const).map((p) => (
                <button
                  key={p}
                  onClick={() => setPortion(p)}
                  className={`px-3 py-2 rounded-lg border text-xs ${
                    portion === p
                      ? 'bg-primary-600 text-white border-primary-500'
                      : 'bg-surface-highlight text-gray-300 border-surface-highlight hover:border-gray-500'
                  }`}
                >
                  {p.charAt(0).toUpperCase() + p.slice(1)}
                </button>
              ))}
            </div>
          </div>
        </div>
        <div className="flex justify-end gap-2">
          <button
            onClick={onClose}
            className="px-4 py-2 text-sm rounded-lg border border-surface-highlight text-gray-300 hover:bg-surface-highlight"
          >
            Cancel
          </button>
          <button
            onClick={handleSubmit}
            className="px-4 py-2 text-sm rounded-lg bg-primary-600 text-white hover:bg-primary-700"
          >
            Save
          </button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="components/FireworksAnimation.tsx">
'use client';

import { useEffect, useState } from 'react';

export default function FireworksAnimation() {
  const [particles, setParticles] = useState<Array<{ id: number; x: number; y: number; colorClass: string; delay: number; duration: number }>>([]);

  useEffect(() => {
    // Generate 30 particles in a circle pattern
    const newParticles = Array.from({ length: 30 }, (_, i) => {
      const angle = (i / 30) * Math.PI * 2;
      const distance = 100 + Math.random() * 50;
      const x = Math.cos(angle) * distance;
      const y = Math.sin(angle) * distance;
      const colorClasses = ['bg-yellow-400', 'bg-red-500', 'bg-blue-500', 'bg-green-500', 'bg-purple-500', 'bg-pink-500'];
      const colorClass = colorClasses[Math.floor(Math.random() * colorClasses.length)];
      
      return {
        id: i,
        x,
        y,
        colorClass,
        delay: Math.random() * 0.2,
        duration: 0.6 + Math.random() * 0.4,
      };
    });
    
    setParticles(newParticles);
  }, []);

  return (
    <>
      <style dangerouslySetInnerHTML={{
        __html: particles.map(particle => `
          @keyframes firework-${particle.id} {
            0% {
              transform: translate(-50%, -50%) scale(0);
              opacity: 1;
            }
            50% {
              opacity: 1;
            }
            100% {
              transform: translate(calc(-50% + ${particle.x}px), calc(-50% + ${particle.y}px)) scale(1.5);
              opacity: 0;
            }
          }
        `).join('\n')
      }} />
      <div className="absolute inset-0 overflow-hidden pointer-events-none">
        {particles.map((particle) => (
          <div
            key={particle.id}
            className={`absolute w-2 h-2 rounded-full ${particle.colorClass}`}
            style={{
              left: '50%',
              top: '50%',
              transform: 'translate(-50%, -50%)',
              animation: `firework-${particle.id} ${particle.duration}s ease-out forwards`,
              animationDelay: `${particle.delay}s`,
            }}
          />
        ))}
      </div>
    </>
  );
}
</file>

<file path="components/Footer.tsx">
import Link from 'next/link';
import MascotIcon from './MascotIcon';

export default function Footer() {
  return (
    <footer className="bg-gray-900 text-white">
      <div className="max-w-7xl mx-auto px-4 py-12">
        <div className="grid grid-cols-1 md:grid-cols-4 gap-8">
          {/* Brand */}
          <div>
            <div className="text-2xl font-bold mb-4">üêæ Paw & Plate</div>
            <p className="text-gray-400">
              Fresh, personalized meal prep for all your pets. Based on AAFCO and WSAVA guidelines.
            </p>
          </div>

          {/* Quick Links */}
          <div>
            <h3 className="text-lg font-semibold mb-4 flex items-center gap-2">
              <MascotIcon mascot="robin-redroute" size={16} />
              Quick Links
            </h3>
            <ul className="space-y-2">
              <li>
                <Link href="/" className="text-gray-400 hover:text-white transition-colors">
                  Home
                </Link>
              </li>
              <li>
                <Link href="/profile" className="text-gray-400 hover:text-white transition-colors">
                  My Pets
                </Link>
              </li>
              <li>
                <Link href="/meal-plans" className="text-gray-400 hover:text-white transition-colors">
                  Meal Plans
                </Link>
              </li>
              <li>
                <Link href="/about" className="text-gray-400 hover:text-white transition-colors">
                  About Us
                </Link>
              </li>
            </ul>
          </div>

          {/* Pet Categories */}
          <div>
            <h3 className="text-lg font-semibold mb-4 flex items-center gap-2">
              <MascotIcon mascot="puppy-prepper" size={16} />
              Pet Categories
            </h3>
            <ul className="space-y-2">
              <li>
                <Link href="/category/dogs" className="text-gray-400 hover:text-white transition-colors flex items-center gap-2">
                  <MascotIcon mascot="puppy-prepper" size={14} /> Dogs
                </Link>
              </li>
              <li>
                <Link href="/category/cats" className="text-gray-400 hover:text-white transition-colors flex items-center gap-2">
                  <MascotIcon mascot="professor-purrfessor" size={14} /> Cats
                </Link>
              </li>
              <li>
                <Link href="/category/birds" className="text-gray-400 hover:text-white transition-colors flex items-center gap-2">
                  <MascotIcon mascot="robin-redroute" size={14} /> Birds
                </Link>
              </li>
              <li>
                <Link href="/category/reptiles" className="text-gray-400 hover:text-white transition-colors flex items-center gap-2">
                  <MascotIcon mascot="sherlock-shells" size={14} /> Reptiles
                </Link>
              </li>
              <li>
                <Link href="/category/pocket-pets" className="text-gray-400 hover:text-white transition-colors flex items-center gap-2">
                  <MascotIcon mascot="farmer-fluff" size={14} /> Pocket Pets
                </Link>
              </li>
            </ul>
          </div>

          {/* Support */}
          <div>
            <h3 className="text-lg font-semibold mb-4 flex items-center gap-2">
              <MascotIcon mascot="professor-purrfessor" size={16} />
              Support
            </h3>
            <ul className="space-y-2">
              <li>
                <Link href="/contact" className="text-gray-400 hover:text-white transition-colors">
                  Contact Us
                </Link>
              </li>
              <li>
                <Link href="/faq" className="text-gray-400 hover:text-white transition-colors">
                  FAQ
                </Link>
              </li>
              <li>
                <Link href="/nutrition-guide" className="text-gray-400 hover:text-white transition-colors">
                  Nutrition Guide
                </Link>
              </li>
              <li>
                <Link href="/privacy" className="text-gray-400 hover:text-white transition-colors">
                  Privacy Policy
                </Link>
              </li>
            </ul>
          </div>
        </div>

        <div className="border-t border-gray-800 mt-8 pt-8 text-center text-gray-400">
          <p>
            &copy; {new Date().getFullYear()} Paw & Plate. All rights reserved.
            Nutritional guidelines based on AAFCO and WSAVA standards.
          </p>
        </div>
      </div>
    </footer>
  );
}
</file>

<file path="components/HealthConcernsDropdown.tsx">
// components/HealthConcernsDropdown.tsx
'use client';

import { useState, useEffect, useRef } from 'react';
import { getHealthConcernsForSpecies } from '@/lib/data/health-concerns';
import { X } from 'lucide-react';

interface HealthConcernsDropdownProps {
  species: string;
  breed?: string;
  selectedConcerns: string[];
  onConcernsChange: (concerns: string[]) => void;
  maxSelections?: number;
  className?: string;
}

export default function HealthConcernsDropdown({
  species,
  breed,
  selectedConcerns,
  onConcernsChange,
  maxSelections = 5,
  className = ''
}: HealthConcernsDropdownProps) {
  const [availableConcerns, setAvailableConcerns] = useState<string[]>([]);
  const prevSpeciesRef = useRef<string>('');
  const prevBreedRef = useRef<string>('');

  // Load concerns when species or breed changes
  useEffect(() => {
    if (species && species.trim()) {
      const concerns = getHealthConcernsForSpecies(species, breed);
      setAvailableConcerns(concerns);
      
      // Clear concerns if species or breed actually changed (not on initial mount)
      // This prevents clearing concerns when editing an existing pet
      const speciesChanged = prevSpeciesRef.current && prevSpeciesRef.current !== species;
      const breedChanged = prevBreedRef.current && prevBreedRef.current !== (breed || '');
      
      if (speciesChanged || breedChanged) {
        onConcernsChange([]);
      }
      
      prevSpeciesRef.current = species;
      prevBreedRef.current = breed || '';
    } else {
      setAvailableConcerns([]);
      prevSpeciesRef.current = '';
      prevBreedRef.current = '';
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [species, breed]); // Depend on both species and breed

  const toggleConcern = (concern: string) => {
    if (selectedConcerns.includes(concern)) {
      onConcernsChange(selectedConcerns.filter(c => c !== concern));
    } else {
      // Enforce max selections
      if (selectedConcerns.length >= maxSelections) {
        return; // Don't add if at max
      }
      onConcernsChange([...selectedConcerns, concern]);
    }
  };

  if (!species || !species.trim()) {
    return (
      <div className={`p-4 bg-gray-50 rounded-lg ${className}`}>
        <p className="text-gray-500">Select a pet species first to see health concerns</p>
      </div>
    );
  }
  
  if (availableConcerns.length === 0) {
    return (
      <div className={`p-4 bg-yellow-50 rounded-lg border border-yellow-200 ${className}`}>
        <p className="text-yellow-700 text-sm">
          No health concerns found for "{species}". Please check the species selection.
        </p>
      </div>
    );
  }

  const fieldsetId = `health-concerns-${species || 'none'}`;
  
  const removeConcern = (concern: string) => {
    onConcernsChange(selectedConcerns.filter(c => c !== concern));
  };
  
  return (
    <fieldset className={`space-y-3 border-0 p-0 m-0 ${className}`} id={fieldsetId}>
      <legend className="mb-1 w-full">
        <h3 className="text-xs font-medium text-gray-700">Health Concerns</h3>
      </legend>

      {/* Side by side layout: Selected concerns on left, checkboxes on right */}
      <div className="grid grid-cols-[300px_1fr] gap-4">
        {/* Selected concerns - Static list with remove buttons */}
        <div className="space-y-2">
          {selectedConcerns.length > 0 ? (
            <div className="bg-gray-50 border border-gray-200 rounded-lg p-3">
              <div className="flex items-center justify-between mb-2">
                <span className="text-sm font-medium text-gray-700">
                  Selected ({selectedConcerns.length})
                </span>
              </div>
              <ul className="space-y-2">
                {selectedConcerns.map(concern => (
                  <li
                    key={concern}
                    className="flex items-center justify-between bg-white border border-gray-200 rounded-md px-2 py-1.5 hover:border-gray-300 transition-colors"
                  >
                    <span className="text-xs text-gray-900 font-medium truncate flex-1">{concern}</span>
                    <button
                      type="button"
                      onClick={() => removeConcern(concern)}
                      className="ml-2 flex-shrink-0 text-gray-400 hover:text-red-600 hover:bg-red-50 rounded-full p-0.5 transition-colors"
                      aria-label={`Remove ${concern}`}
                      title={`Remove ${concern}`}
                    >
                      <X size={14} />
                    </button>
                  </li>
                ))}
              </ul>
            </div>
          ) : (
            <div className="bg-gray-50 border border-gray-200 rounded-lg p-3 text-center">
              <p className="text-xs text-gray-500">No health concerns selected</p>
            </div>
          )}
        </div>

        {/* Concerns checkboxes */}
        <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-1.5">
        {availableConcerns.map(concern => {
          const isSelected = selectedConcerns.includes(concern);
          const inputId = `health-concern-${concern.toLowerCase().replace(/[^a-z0-9]/g, '-')}`;

          return (
            <label
              key={concern}
              htmlFor={inputId}
              className={`
                flex items-center p-1.5 border rounded cursor-pointer text-xs
                transition-colors duration-150
                ${isSelected 
                  ? 'border-blue-500 bg-blue-50' 
                  : 'border-gray-200 hover:bg-gray-50'
                }
              `}
            >
              <input
                id={inputId}
                name={`health-concern-${species}`}
                type="checkbox"
                checked={isSelected}
                onChange={() => toggleConcern(concern)}
                className="mr-1.5 h-3 w-3 text-blue-600 rounded"
                aria-label={`Select ${concern} health concern`}
              />
              <span className={`${isSelected ? 'font-medium' : ''} text-xs leading-tight`}>
                {concern}
              </span>
            </label>
          );
        })}
        </div>
      </div>

      {/* Optional: Select all/none */}
      <div className="flex gap-2 pt-1">
        <button
          type="button"
          onClick={() => onConcernsChange(availableConcerns)}
          className="text-xs text-blue-600 hover:text-blue-800"
        >
          Select All
        </button>
        <span className="text-gray-300">|</span>
        <button
          type="button"
          onClick={() => onConcernsChange([])}
          className="text-xs text-gray-600 hover:text-gray-800"
        >
          Clear All
        </button>
      </div>
    </fieldset>
  );
}
</file>

<file path="components/Image.tsx">
import NextImage from 'next/image';
import { ImageData } from '@/lib/types';
import { getHealthConcernStyle, getPetCategoryStyle } from '@/lib/utils/imageMapping';
import { getMascotImageForCategory } from '@/lib/utils/mascotImageMapping';

interface ImageProps {
  src?: ImageData | string; // Support both ImageData object and string URL
  variant?: 'thumbnail' | 'card' | 'hero' | 'icon' | 'banner';
  alt?: string;
  className?: string;
  priority?: boolean;
  fallbackSrc?: string;
  healthConcern?: string;
  petCategory?: string;
  showOverlays?: boolean;
}

export default function Image({
  src,
  variant = 'card',
  alt = '',
  className = '',
  priority = false,
  fallbackSrc,
  healthConcern,
  petCategory,
  showOverlays = true
}: ImageProps) {
  // Handle string URLs (legacy support)
  const imageUrl = typeof src === 'string' ? src : src?.url;
  const imageAlt = typeof src === 'string' ? alt : src?.alt || alt;
  const imageWidth = typeof src === 'string' ? undefined : src?.width;
  const imageHeight = typeof src === 'string' ? undefined : src?.height;

  // Determine fallback: use mascot image if petCategory provided, otherwise use provided fallback or default
  const mascotFallback = petCategory ? getMascotImageForCategory(petCategory) : null;
  const effectiveFallback = fallbackSrc || mascotFallback || '/images/emojis/Mascots/Mascot-Emoji-Faces.png';

  if (!imageUrl && !effectiveFallback) {
    return (
      <div className={`bg-gray-200 flex items-center justify-center ${className}`}>
        <span className="text-gray-400 text-sm">No image</span>
      </div>
    );
  }

  const getSizes = (variant: string) => {
    switch (variant) {
      case 'thumbnail':
        return '(max-width: 640px) 150px, 300px';
      case 'card':
        return '(max-width: 640px) 300px, 600px';
      case 'hero':
        return '(max-width: 768px) 800px, 1200px';
      case 'icon':
        return '128px';
      case 'banner':
        return '800px';
      default:
        return '600px';
    }
  };

  const getDefaultDimensions = (variant: string) => {
    switch (variant) {
      case 'thumbnail':
        return { width: 300, height: 300 };
      case 'card':
        return { width: 600, height: 400 };
      case 'hero':
        return { width: 1200, height: 600 };
      case 'icon':
        return { width: 128, height: 128 };
      case 'banner':
        return { width: 800, height: 200 };
      default:
        return { width: 600, height: 400 };
    }
  };

  const healthStyle = healthConcern ? getHealthConcernStyle(healthConcern) : null;
  const categoryStyle = petCategory ? getPetCategoryStyle(petCategory) : null;

  const finalUrl = imageUrl || effectiveFallback;
  const dimensions = imageWidth && imageHeight 
    ? { width: imageWidth, height: imageHeight }
    : getDefaultDimensions(variant);

  return (
    <div className={`relative ${className}`}>
      <NextImage
        src={finalUrl}
        alt={imageAlt}
        width={dimensions.width}
        height={dimensions.height}
        className="w-full h-full object-cover"
        sizes={getSizes(variant)}
        priority={priority}
        placeholder="blur"
        blurDataURL="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAIAAoDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAv/xAAhEAACAQMDBQAAAAAAAAAAAAABAgMABAUGIWGRkqGx0f/EABUBAQEAAAAAAAAAAAAAAAAAAAMF/8QAGhEAAgIDAAAAAAAAAAAAAAAAAAECEgMRkf/aAAwDAQACEQMRAD8AltJagyeH0AthI5xdrLcNM91BF5pX2HaH9bcfaSXWGaRmknyJckliyjqTzSlT54b6bk+h0R+IRjWjBqO6O2mhP//Z"
        onError={(e) => {
          const target = e.target as HTMLImageElement;
          // Try mascot image if available, otherwise use effective fallback
          if (mascotFallback && !target.src.includes('Mascots')) {
            target.src = mascotFallback;
          } else if (effectiveFallback && target.src !== effectiveFallback) {
            target.src = effectiveFallback;
          }
        }}
      />

      {/* Health Concern Overlay */}
      {showOverlays && healthStyle && (
        <div className="absolute top-2 right-2 bg-white/90 backdrop-blur-sm rounded-full p-1 shadow-sm">
          <span
            className="text-sm"
            style={{ color: healthStyle.color }}
            title={`Health concern: ${healthConcern}`}
          >
            {healthStyle.symbol}
          </span>
        </div>
      )}

      {/* Pet Category Frame */}
      {showOverlays && categoryStyle && variant === 'card' && (
        <div
          className="absolute inset-0 rounded-lg border-4 pointer-events-none"
          style={{ borderColor: categoryStyle.color + '40' }}
        />
      )}
    </div>
  );
}
</file>

<file path="components/IngredientPicker.tsx">
'use client';

import { useState } from 'react';
import { Search, X } from 'lucide-react';

interface Ingredient {
  name: string;
  category: string;
}

interface IngredientPickerProps {
  ingredients: Ingredient[];
  categories: {
    [key: string]: {
      name: string;
      icon: string;
      ingredients: string[];
    };
  };
  onSelect: (ingredientName: string) => void;
  disabled?: boolean;
}

export default function IngredientPicker({
  ingredients,
  categories,
  onSelect,
  disabled = false
}: IngredientPickerProps) {
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedCategory, setSelectedCategory] = useState<string | null>(null);
  const [isOpen, setIsOpen] = useState(false);

  // Filter ingredients by search and category
  const filteredIngredients = ingredients.filter(ing => {
    const matchesSearch = ing.name.toLowerCase().includes(searchQuery.toLowerCase());
    const matchesCategory = !selectedCategory || 
      categories[selectedCategory]?.ingredients.includes(ing.name);
    return matchesSearch && matchesCategory;
  });

  const categoryKeys = Object.keys(categories);

  return (
    <div className="relative">
      {/* Search Input & Dropdown Toggle */}
      <div className="relative">
        <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400" size={18} />
        <input
          type="text"
          placeholder="Search ingredients..."
          value={searchQuery}
          onChange={(e) => setSearchQuery(e.target.value)}
          onFocus={() => setIsOpen(true)}
          className="w-full pl-10 pr-10 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
          disabled={disabled}
        />
        {searchQuery && (
          <button
            onClick={() => setSearchQuery('')}
            className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600"
          >
            <X size={16} />
          </button>
        )}
      </div>

      {/* Category Filters */}
      {isOpen && (
        <div className="mt-2 flex flex-wrap gap-2">
          <button
            onClick={() => setSelectedCategory(null)}
            className={`px-3 py-1 rounded-full text-xs font-medium transition-colors ${
              selectedCategory === null
                ? 'bg-primary-100 text-primary-700 border border-primary-300'
                : 'bg-gray-100 text-gray-600 border border-gray-200 hover:bg-gray-200'
            }`}
          >
            All
          </button>
          {categoryKeys.map(catKey => (
            <button
              key={catKey}
              onClick={() => setSelectedCategory(catKey)}
              className={`px-3 py-1 rounded-full text-xs font-medium transition-colors flex items-center gap-1 ${
                selectedCategory === catKey
                  ? 'bg-primary-100 text-primary-700 border border-primary-300'
                  : 'bg-gray-100 text-gray-600 border border-gray-200 hover:bg-gray-200'
              }`}
            >
              <span>{categories[catKey].icon}</span>
              {categories[catKey].name}
            </button>
          ))}
        </div>
      )}

      {/* Dropdown Results */}
      {isOpen && filteredIngredients.length > 0 && (
        <div className="absolute z-50 w-full mt-2 bg-white border border-gray-200 rounded-lg shadow-lg max-h-64 overflow-y-auto">
          {filteredIngredients.map((ing, idx) => (
            <button
              key={idx}
              onClick={() => {
                onSelect(ing.name);
                setSearchQuery('');
                setIsOpen(false);
              }}
              className="w-full px-4 py-2 text-left hover:bg-gray-50 transition-colors border-b border-gray-100 last:border-b-0"
            >
              <div className="flex items-center justify-between">
                <span className="text-sm text-gray-900">{ing.name}</span>
                <span className="text-xs text-gray-500">{ing.category}</span>
              </div>
            </button>
          ))}
        </div>
      )}

      {/* Click outside to close */}
      {isOpen && (
        <div
          className="fixed inset-0 z-40"
          onClick={() => setIsOpen(false)}
        />
      )}
    </div>
  );
}
</file>

<file path="components/InteractiveStarRating.tsx">
import React, { useState } from 'react';
import { Star } from 'lucide-react';

interface InteractiveStarRatingProps {
  currentRating?: number;
  onRatingChange: (rating: number) => void;
  size?: 'sm' | 'md' | 'lg';
  disabled?: boolean;
  className?: string;
}

export const InteractiveStarRating: React.FC<InteractiveStarRatingProps> = ({
  currentRating = 0,
  onRatingChange,
  size = 'md',
  disabled = false,
  className = ''
}) => {
  const [hoverRating, setHoverRating] = useState(0);

  const sizeClasses = {
    sm: 'w-5 h-5',
    md: 'w-6 h-6',
    lg: 'w-8 h-8'
  };

  const handleStarClick = (rating: number) => {
    if (disabled) return;
    onRatingChange(rating);
  };

  const handleStarHover = (rating: number) => {
    if (disabled) return;
    setHoverRating(rating);
  };

  const handleMouseLeave = () => {
    if (disabled) return;
    setHoverRating(0);
  };

  const getStarClass = (starIndex: number) => {
    const rating = hoverRating || currentRating;
    const baseClass = `${sizeClasses[size]} cursor-pointer transition-colors`;

    if (disabled) {
      return `${baseClass} text-gray-300 cursor-not-allowed`;
    }

    if (starIndex <= rating) {
      return `${baseClass} text-yellow-400 fill-yellow-400`;
    }

    return `${baseClass} text-gray-300 hover:text-yellow-400`;
  };

  return (
    <div
      className={`flex items-center gap-1 ${className}`}
      onMouseLeave={handleMouseLeave}
      role="radiogroup"
      aria-label="Rate this recipe"
    >
      {[1, 2, 3, 4, 5].map((star) => (
        <button
          key={star}
          type="button"
          className={getStarClass(star)}
          onClick={() => handleStarClick(star)}
          onMouseEnter={() => handleStarHover(star)}
          disabled={disabled}
          aria-label={`Rate ${star} star${star !== 1 ? 's' : ''}`}
          aria-pressed={star <= currentRating}
        >
          <Star />
        </button>
      ))}
      {currentRating > 0 && !disabled && (
        <span className="ml-2 text-sm text-gray-600">
          {currentRating} star{currentRating !== 1 ? 's' : ''}
        </span>
      )}
    </div>
  );
};
</file>

<file path="components/LoadingSpinner.tsx">
// components/LoadingSpinner.tsx
// Reusable loading spinner component

'use client';

import React from 'react';

interface LoadingSpinnerProps {
  size?: 'sm' | 'md' | 'lg' | 'xl';
  message?: string;
  fullScreen?: boolean;
}

const sizeClasses = {
  sm: 'h-4 w-4',
  md: 'h-8 w-8',
  lg: 'h-12 w-12',
  xl: 'h-16 w-16',
};

export function LoadingSpinner({ 
  size = 'md', 
  message,
  fullScreen = false 
}: LoadingSpinnerProps) {
  const spinner = (
    <div className="flex flex-col items-center justify-center gap-3">
      <div className={`animate-spin rounded-full border-b-2 border-primary-600 ${sizeClasses[size]}`} />
      {message && (
        <p className="text-gray-600 text-sm font-medium">{message}</p>
      )}
    </div>
  );

  if (fullScreen) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center">
        {spinner}
      </div>
    );
  }

  return spinner;
}

export default LoadingSpinner;
</file>

<file path="components/MascotAvatar.tsx">
// components/MascotAvatar.tsx
// Component for displaying medium-size mascot avatars
// Used in compatibility panels, recipe results, ingredient detail pages

import Image from 'next/image';
import { getMascotFaceImage } from '@/lib/utils/emojiMapping';

export type MascotName = 
  | 'puppy-prepper' 
  | 'professor-purrfessor' 
  | 'sherlock-shells' 
  | 'farmer-fluff' 
  | 'robin-redroute';

interface MascotAvatarProps {
  mascot: MascotName;
  size?: number;
  className?: string;
  showLabel?: boolean;
  label?: string;
}

/**
 * Medium-size mascot avatar for compatibility panels, recipe results, etc.
 * Larger than MascotIcon, used for more prominent displays
 */
export default function MascotAvatar({ 
  mascot, 
  size = 48, 
  className = '',
  showLabel = false,
  label
}: MascotAvatarProps) {
  const imagePath = getMascotFaceImage(mascot);
  
  const mascotLabels: Record<MascotName, string> = {
    'puppy-prepper': 'Puppy Prepper',
    'professor-purrfessor': 'Professor Purrfessor',
    'sherlock-shells': 'Sherlock Shells',
    'farmer-fluff': 'Farmer Fluff',
    'robin-redroute': 'Robin Redroute',
  };
  
  const displayLabel = label || mascotLabels[mascot];
  
  if (!imagePath) {
    // Fallback to emoji if image not found
    const emojiMap: Record<MascotName, string> = {
      'puppy-prepper': 'üêï',
      'professor-purrfessor': 'üê±',
      'sherlock-shells': 'üê¢',
      'farmer-fluff': 'üêπ',
      'robin-redroute': 'üê¶',
    };
    return (
      <div className={`flex flex-col items-center ${className}`}>
        <span className="text-4xl">{emojiMap[mascot]}</span>
        {showLabel && <span className="text-xs text-gray-600 mt-1">{displayLabel}</span>}
      </div>
    );
  }
  
  return (
    <div className={`flex flex-col items-center ${className}`}>
      <span
        style={{ 
          display: 'inline-block', 
          verticalAlign: 'middle',
        }}
      >
        <Image
          src={imagePath}
          alt={`${displayLabel} mascot`}
          width={size}
          height={size}
          className="inline-block align-middle"
          style={{ 
            display: 'inline-block', 
            verticalAlign: 'middle',
            imageRendering: 'crisp-edges',
          }}
          unoptimized
        />
      </span>
      {showLabel && (
        <span className="text-xs text-gray-600 mt-1 text-center">{displayLabel}</span>
      )}
    </div>
  );
}
</file>

<file path="components/MascotIcon.tsx">
// components/MascotIcon.tsx
// Component for displaying tiny mascot face icons (emoji-style)
// Used in navigation, tooltips, ingredient lists, etc.

import Image from 'next/image';
import { getMascotFaceImage } from '@/lib/utils/emojiMapping';

export type MascotName = 
  | 'puppy-prepper' 
  | 'professor-purrfessor' 
  | 'sherlock-shells' 
  | 'farmer-fluff' 
  | 'robin-redroute';

interface MascotIconProps {
  mascot: MascotName;
  size?: number;
  className?: string;
}

/**
 * Tiny mascot face icon for navigation, tooltips, etc.
 * Uses the mascot face images (not full illustrations)
 */
export default function MascotIcon({ 
  mascot, 
  size = 20, 
  className = '' 
}: MascotIconProps) {
  const imagePath = getMascotFaceImage(mascot);
  
  if (!imagePath) {
    // Fallback to emoji if image not found
    const emojiMap: Record<MascotName, string> = {
      'puppy-prepper': 'üêï',
      'professor-purrfessor': 'üê±',
      'sherlock-shells': 'üê¢',
      'farmer-fluff': 'üêπ',
      'robin-redroute': 'üê¶',
    };
    return <span className={className}>{emojiMap[mascot]}</span>;
  }
  
  return (
    <span 
      className={`inline-block align-middle ${className}`}
      style={{ 
        display: 'inline-block', 
        verticalAlign: 'middle',
      }}
    >
      <Image
        src={imagePath}
        alt={`${mascot} mascot`}
        width={size}
        height={size}
        className={`inline-block align-middle mascot-icon mascot-${mascot}`}
        style={{ 
          display: 'inline-block', 
          verticalAlign: 'middle',
          imageRendering: 'crisp-edges',
        }}
        unoptimized
      />
    </span>
  );
}
</file>

<file path="components/mascots/FarmerFluff.tsx">
'use client';

import React from 'react';
import MascotAnimation from './MascotAnimation';

export interface FarmerFluffProps {
  size?: number;
  activity?: 'idle' | 'active';
  className?: string;
}

/**
 * Farmer Fluff - Ingredient Provider & Farm Manager
 * Role: Grows, gathers, and secures all ingredients, manages supply flow & freshness
 * Accessories: Gardening hoe, suspenders, little basket (NO hat per brand bible)
 * Personality: ADHD, upbeat, impulsive, very productive in bursts
 * Color: Dark brown
 * Activity: Rapid harvesting, organizing
 */
export default function FarmerFluff({
  size = 120,
  activity = 'idle',
  className = ''
}: FarmerFluffProps) {
  return (
    <MascotAnimation
      activity={activity}
      personality="hyperactive"
      className={className}
    >
      <div
        className="relative"
        style={{ width: size, height: size }}
        role="img"
        aria-label="Farmer Fluff, the hamster farmer mascot"
      >
        {/* Hamster body - round, fluffy */}
        <div
          className="absolute inset-0 rounded-full"
          style={{
            background: 'linear-gradient(135deg, #D2B48C 0%, #BC9A6A 100%)',
            boxShadow: '0 4px 8px rgba(0,0,0,0.2)'
          }}
        />
        
        {/* Suspenders */}
        <div
          className="absolute"
          style={{
            top: size * 0.3,
            left: size * 0.2,
            width: size * 0.1,
            height: size * 0.4,
            background: '#8B4513',
            borderRadius: '2px',
            boxShadow: '0 1px 2px rgba(0,0,0,0.2)'
          }}
        />
        <div
          className="absolute"
          style={{
            top: size * 0.3,
            right: size * 0.2,
            width: size * 0.1,
            height: size * 0.4,
            background: '#8B4513',
            borderRadius: '2px',
            boxShadow: '0 1px 2px rgba(0,0,0,0.2)'
          }}
        />
        {/* Suspenders cross */}
        <div
          className="absolute"
          style={{
            top: size * 0.3,
            left: '50%',
            transform: 'translateX(-50%)',
            width: size * 0.2,
            height: size * 0.1,
            background: '#8B4513',
            borderRadius: '2px'
          }}
        />
        
        {/* Eyes - bright, energetic */}
        <div
          className="absolute"
          style={{
            top: size * 0.35,
            left: size * 0.3,
            width: size * 0.1,
            height: size * 0.1,
            background: '#000',
            borderRadius: '50%'
          }}
        />
        <div
          className="absolute"
          style={{
            top: size * 0.35,
            right: size * 0.3,
            width: size * 0.1,
            height: size * 0.1,
            background: '#000',
            borderRadius: '50%'
          }}
        />
        
        {/* Nose */}
        <div
          className="absolute"
          style={{
            top: size * 0.45,
            left: '50%',
            transform: 'translateX(-50%)',
            width: size * 0.08,
            height: size * 0.06,
            background: '#FF69B4',
            borderRadius: '50%'
          }}
        />
        
        {/* Mouth - happy, energetic */}
        <div
          className="absolute"
          style={{
            top: size * 0.52,
            left: '50%',
            transform: 'translateX(-50%)',
            width: size * 0.2,
            height: size * 0.1,
            borderBottom: '3px solid #000',
            borderRadius: '0 0 50% 50%'
          }}
        />
        
        {/* Garden hoe - when active */}
        {activity === 'active' && (
          <div
            className="absolute"
            style={{
              top: size * 0.4,
              right: -size * 0.1,
              width: size * 0.15,
              height: size * 0.4,
              background: '#654321',
              borderRadius: '2px',
              transform: 'rotate(-15deg)',
              boxShadow: '0 2px 4px rgba(0,0,0,0.2)'
            }}
          >
            <div
              className="absolute top-0 left-1/2 transform -translate-x-1/2"
              style={{
                width: size * 0.2,
                height: size * 0.08,
                background: '#C0C0C0',
                clipPath: 'polygon(20% 0%, 80% 0%, 100% 100%, 0% 100%)',
                borderRadius: '2px'
              }}
            />
          </div>
        )}
        
        {/* Basket - when active */}
        {activity === 'active' && (
          <div
            className="absolute"
            style={{
              bottom: -size * 0.05,
              left: size * 0.1,
              width: size * 0.3,
              height: size * 0.2,
              background: '#8B4513',
              borderRadius: '50% 50% 0 0',
              border: '2px solid #654321',
              transform: 'rotate(-10deg)',
              boxShadow: '0 2px 4px rgba(0,0,0,0.2)'
            }}
          >
            {/* Basket handle */}
            <div
              className="absolute top-0 left-1/2 transform -translate-x-1/2 -translate-y-1"
              style={{
                width: size * 0.15,
                height: size * 0.08,
                border: '2px solid #654321',
                borderRadius: '50%',
                background: 'transparent'
              }}
            />
            {/* Basket contents */}
            <div
              className="absolute bottom-2 left-2 right-2"
              style={{
                height: size * 0.1,
                background: 'linear-gradient(135deg, #90EE90 0%, #228B22 100%)',
                borderRadius: '4px'
              }}
            />
          </div>
        )}
      </div>
    </MascotAnimation>
  );
}
</file>

<file path="components/mascots/MascotAnimation.tsx">
'use client';

import React from 'react';
import { useSpring, animated, config } from '@react-spring/web';

export interface MascotAnimationProps {
  children: React.ReactNode;
  activity?: 'idle' | 'active';
  personality?: 'stern' | 'anxious' | 'excitable' | 'thoughtful' | 'hyperactive';
  className?: string;
}

/**
 * Base animation component for mascots
 * Handles idle and activity states with React Spring animations
 * Uses GPU-accelerated transforms for performance
 */
export default function MascotAnimation({
  children,
  activity = 'idle',
  personality = 'thoughtful',
  className = ''
}: MascotAnimationProps) {
  // Breathing animation for idle state
  const breathing = useSpring({
    from: { scale: 1 },
    to: { scale: 1.02 },
    loop: { reverse: true },
    config: { duration: 2000 },
    pause: activity !== 'idle'
  });

  // Activity animations based on personality
  const getActivityProps = () => {
    switch (personality) {
      case 'stern':
        return {
          from: { y: 0, rotate: 0 },
          to: [
            { y: -2, rotate: -1 },
            { y: 0, rotate: 0 },
            { y: -2, rotate: 1 },
            { y: 0, rotate: 0 }
          ],
          config: { duration: 1000 }
        };
      case 'anxious':
        return {
          from: { x: 0, y: 0 },
          to: [
            { x: -1, y: -1 },
            { x: 1, y: 0 },
            { x: -1, y: -1 },
            { x: 0, y: 0 }
          ],
          config: { duration: 600 }
        };
      case 'excitable':
        return {
          from: { y: 0, scale: 1 },
          to: [
            { y: -4, scale: 1.05 },
            { y: 0, scale: 1 },
            { y: -4, scale: 1.05 },
            { y: 0, scale: 1 }
          ],
          config: { duration: 800 }
        };
      case 'thoughtful':
        return {
          from: { y: 0, rotate: 0 },
          to: [
            { y: -1, rotate: -0.5 },
            { y: 0, rotate: 0 },
            { y: -1, rotate: 0.5 },
            { y: 0, rotate: 0 }
          ],
          config: { duration: 2000 }
        };
      case 'hyperactive':
        return {
          from: { y: 0, rotate: 0, scale: 1 },
          to: [
            { y: -3, rotate: -2, scale: 1.03 },
            { y: 0, rotate: 2, scale: 1 },
            { y: -3, rotate: -2, scale: 1.03 },
            { y: 0, rotate: 0, scale: 1 }
          ],
          config: { duration: 500 }
        };
      default:
        return { from: {}, to: {} };
    }
  };

  const activityAnim = useSpring({
    ...getActivityProps(),
    loop: true,
    pause: activity !== 'active'
  });

  // Build transform string based on activity
  if (activity === 'idle') {
    return (
      <animated.div
        style={{
          scale: breathing.scale,
          willChange: 'transform',
          transformOrigin: 'center center'
        }}
        className={`inline-block ${className}`}
      >
        {children}
      </animated.div>
    );
  }

  // Activity animations - use optional chaining and provide defaults
  const style: any = {
    willChange: 'transform',
    transformOrigin: 'center center'
  };

  if ('y' in activityAnim) style.y = activityAnim.y;
  if ('x' in activityAnim) style.x = activityAnim.x;
  if ('rotate' in activityAnim) style.rotate = activityAnim.rotate;
  if ('scale' in activityAnim) style.scale = activityAnim.scale;
  if (!('scale' in activityAnim)) style.scale = 1;

  return (
    <animated.div
      style={style}
      className={`inline-block ${className}`}
    >
      {children}
    </animated.div>
  );
}
</file>

<file path="components/mascots/ProfessorPurrfessor.tsx">
'use client';

import React from 'react';
import MascotAnimation from './MascotAnimation';

export interface ProfessorPurrfessorProps {
  size?: number;
  activity?: 'idle' | 'active';
  className?: string;
}

/**
 * Professor Purrfessor - The Researcher & Recipe Tester
 * Role: Tests ingredients, analyzes compatibility, develops new formulas
 * Accessories: Lab coat, glasses, clipboard
 * Personality: Nerdy, anxious, brilliant, catastrophizes constantly
 * Color: Black/charcoal
 * Activity: Writing notes, examining ingredients
 */
export default function ProfessorPurrfessor({
  size = 120,
  activity = 'idle',
  className = ''
}: ProfessorPurrfessorProps) {
  return (
    <MascotAnimation
      activity={activity}
      personality="anxious"
      className={className}
    >
      <div
        className="relative"
        style={{ width: size, height: size }}
        role="img"
        aria-label="Professor Purrfessor, the cat scientist mascot"
      >
        {/* Cat body - angular, sleek */}
        <div
          className="absolute inset-0"
          style={{
            background: 'linear-gradient(135deg, #8B7355 0%, #6B5B4D 100%)',
            borderRadius: '50% 50% 50% 50% / 60% 60% 40% 40%',
            boxShadow: '0 4px 8px rgba(0,0,0,0.2)'
          }}
        />
        
        {/* Lab coat */}
        <div
          className="absolute bottom-0 left-0 right-0"
          style={{
            height: size * 0.6,
            background: 'white',
            borderRadius: '50% 50% 0 0',
            border: '2px solid #E0E0E0',
            boxShadow: '0 2px 4px rgba(0,0,0,0.1)'
          }}
        />
        
        {/* Glasses */}
        <div
          className="absolute"
          style={{
            top: size * 0.35,
            left: '50%',
            transform: 'translateX(-50%)',
            width: size * 0.5,
            height: size * 0.15,
            border: '3px solid #333',
            borderRadius: '20%',
            background: 'rgba(200, 200, 200, 0.3)'
          }}
        />
        <div
          className="absolute"
          style={{
            top: size * 0.35,
            left: '50%',
            transform: 'translateX(-50%)',
            width: size * 0.2,
            height: size * 0.15,
            borderRight: '2px solid #333'
          }}
        />
        
        {/* Eyes - anxious, wide */}
        <div
          className="absolute"
          style={{
            top: size * 0.38,
            left: size * 0.28,
            width: size * 0.1,
            height: size * 0.1,
            background: '#4A90E2',
            borderRadius: '50%',
            border: '2px solid #000'
          }}
        />
        <div
          className="absolute"
          style={{
            top: size * 0.38,
            right: size * 0.28,
            width: size * 0.1,
            height: size * 0.1,
            background: '#4A90E2',
            borderRadius: '50%',
            border: '2px solid #000'
          }}
        />
        
        {/* Nose */}
        <div
          className="absolute"
          style={{
            top: size * 0.5,
            left: '50%',
            transform: 'translateX(-50%)',
            width: size * 0.08,
            height: size * 0.06,
            background: '#FF69B4',
            borderRadius: '50%'
          }}
        />
        
        {/* Mouth - anxious expression */}
        <div
          className="absolute"
          style={{
            top: size * 0.58,
            left: '50%',
            transform: 'translateX(-50%)',
            width: size * 0.15,
            height: size * 0.08,
            borderBottom: '2px solid #000',
            borderRadius: '0 0 50% 50%'
          }}
        />
        
        {/* Clipboard - held in front */}
        {activity === 'active' && (
          <div
            className="absolute"
            style={{
              top: size * 0.5,
              left: size * 0.65,
              width: size * 0.2,
              height: size * 0.35,
              background: '#FFF',
              border: '2px solid #333',
              borderRadius: '4px',
              transform: 'rotate(-10deg)',
              boxShadow: '0 2px 4px rgba(0,0,0,0.2)'
            }}
          >
            {/* Clipboard lines */}
            {[0, 1, 2].map(i => (
              <div
                key={i}
                className="absolute left-1 right-1"
                style={{
                  top: `${20 + i * 25}%`,
                  height: '2px',
                  background: '#E0E0E0'
                }}
              />
            ))}
            {/* Clipboard clip */}
            <div
              className="absolute top-0 left-1/2 transform -translate-x-1/2"
              style={{
                width: size * 0.08,
                height: size * 0.05,
                background: '#C0C0C0',
                borderRadius: '2px'
              }}
            />
          </div>
        )}
      </div>
    </MascotAnimation>
  );
}
</file>

<file path="components/mascots/PuppyPreper.tsx">
'use client';

import React from 'react';
import MascotAnimation, { MascotAnimationProps } from './MascotAnimation';

export interface PuppyPreperProps {
  size?: number;
  activity?: 'idle' | 'active';
  className?: string;
}

/**
 * Puppy Prepper - The Chef & Meal-Prep Lead
 * Role: Cooks meals, assembles final bowls, oversees kitchen operations
 * Accessories: Chef hat, wooden spoon, metal mixing bowl
 * Personality: Serious chef energy, impatient, slightly Gordon Ramsay; secretly soft-hearted
 * Color: Light gold
 * Activity: Cooking/stirring motion
 */
export default function PuppyPreper({
  size = 120,
  activity = 'idle',
  className = ''
}: PuppyPreperProps) {
  return (
    <MascotAnimation
      activity={activity}
      personality="stern"
      className={className}
    >
      <div
        className="relative"
        style={{ width: size, height: size }}
        role="img"
        aria-label="Puppy Prepper, the chef & meal-prep lead mascot"
      >
        {/* Dog body - rounded, friendly shape */}
        <div
          className="absolute inset-0 rounded-full"
          style={{
            background: 'linear-gradient(135deg, #F4A460 0%, #D2691E 100%)',
            boxShadow: '0 4px 8px rgba(0,0,0,0.2)'
          }}
        />
        
        {/* Chef hat */}
        <div
          className="absolute top-0 left-1/2 transform -translate-x-1/2 -translate-y-2"
          style={{
            width: size * 0.6,
            height: size * 0.3,
            background: 'white',
            borderRadius: '50% 50% 0 0',
            boxShadow: '0 2px 4px rgba(0,0,0,0.1)'
          }}
        />
        <div
          className="absolute top-0 left-1/2 transform -translate-x-1/2"
          style={{
            width: size * 0.5,
            height: size * 0.15,
            background: 'white',
            borderRadius: '50%'
          }}
        />
        
        {/* Eyes - intense, focused */}
        <div
          className="absolute"
          style={{
            top: size * 0.35,
            left: size * 0.3,
            width: size * 0.08,
            height: size * 0.08,
            background: '#000',
            borderRadius: '50%'
          }}
        />
        <div
          className="absolute"
          style={{
            top: size * 0.35,
            right: size * 0.3,
            width: size * 0.08,
            height: size * 0.08,
            background: '#000',
            borderRadius: '50%'
          }}
        />
        
        {/* Nose */}
        <div
          className="absolute"
          style={{
            top: size * 0.45,
            left: '50%',
            transform: 'translateX(-50%)',
            width: size * 0.1,
            height: size * 0.08,
            background: '#000',
            borderRadius: '50%'
          }}
        />
        
        {/* Mouth - stern expression */}
        <div
          className="absolute"
          style={{
            top: size * 0.55,
            left: '50%',
            transform: 'translateX(-50%)',
            width: size * 0.2,
            height: size * 0.05,
            borderBottom: '2px solid #000',
            borderRadius: '0 0 50% 50%'
          }}
        />
        
        {/* Spoon - held in front */}
        {activity === 'active' && (
          <div
            className="absolute"
            style={{
              top: size * 0.6,
              left: size * 0.7,
              width: size * 0.15,
              height: size * 0.3,
              background: '#C0C0C0',
              borderRadius: '2px',
              transform: 'rotate(-20deg)',
              boxShadow: '0 2px 4px rgba(0,0,0,0.2)'
            }}
          >
            <div
              className="absolute top-0 left-1/2 transform -translate-x-1/2"
              style={{
                width: size * 0.08,
                height: size * 0.08,
                background: '#C0C0C0',
                borderRadius: '50%'
              }}
            />
          </div>
        )}
        
        {/* Mixing bowl - on ground */}
        {activity === 'active' && (
          <div
            className="absolute"
            style={{
              bottom: -size * 0.1,
              left: '50%',
              transform: 'translateX(-50%)',
              width: size * 0.4,
              height: size * 0.15,
              background: '#E8E8E8',
              borderRadius: '0 0 50% 50%',
              border: '2px solid #C0C0C0',
              boxShadow: '0 2px 4px rgba(0,0,0,0.2)'
            }}
          />
        )}
      </div>
    </MascotAnimation>
  );
}
</file>

<file path="components/mascots/RobinRedroute.tsx">
'use client';

import React from 'react';
import MascotAnimation from './MascotAnimation';

export interface RobinRedrouteProps {
  size?: number;
  activity?: 'idle' | 'active';
  className?: string;
}

/**
 * Robin Redroute - Packaging & Delivery Specialist
 * Role: Packs orders, prints labels, organizes deliveries, handles inventory and logistics
 * Accessories: Delivery satchel, goggles, tiny pilot cap
 * Personality: Hyper, chatty, easily excited
 * Color: Red
 * Activity: Flying/delivering packages
 */
export default function RobinRedroute({
  size = 120,
  activity = 'idle',
  className = ''
}: RobinRedrouteProps) {
  return (
    <MascotAnimation
      activity={activity}
      personality="excitable"
      className={className}
    >
      <div
        className="relative"
        style={{ width: size, height: size }}
        role="img"
        aria-label="Robin Redroute, the bird delivery mascot"
      >
        {/* Bird body - round, compact */}
        <div
          className="absolute inset-0 rounded-full"
          style={{
            background: 'linear-gradient(135deg, #FF6B6B 0%, #EE5A6F 100%)',
            boxShadow: '0 4px 8px rgba(0,0,0,0.2)'
          }}
        />
        
        {/* Hat */}
        <div
          className="absolute top-0 left-1/2 transform -translate-x-1/2 -translate-y-1"
          style={{
            width: size * 0.5,
            height: size * 0.2,
            background: '#4A4A4A',
            borderRadius: '50% 50% 0 0',
            boxShadow: '0 2px 4px rgba(0,0,0,0.2)'
          }}
        />
        <div
          className="absolute top-0 left-1/2 transform -translate-x-1/2"
          style={{
            width: size * 0.4,
            height: size * 0.12,
            background: '#4A4A4A',
            borderRadius: '50%'
          }}
        />
        
        {/* Goggles */}
        <div
          className="absolute"
          style={{
            top: size * 0.3,
            left: '50%',
            transform: 'translateX(-50%)',
            width: size * 0.4,
            height: size * 0.12,
            background: '#1A1A1A',
            borderRadius: '50%',
            border: '2px solid #333'
          }}
        />
        <div
          className="absolute"
          style={{
            top: size * 0.32,
            left: '50%',
            transform: 'translateX(-50%)',
            width: size * 0.35,
            height: size * 0.1,
            background: 'rgba(100, 150, 200, 0.3)',
            borderRadius: '50%'
          }}
        />
        
        {/* Eyes - excited, wide */}
        <div
          className="absolute"
          style={{
            top: size * 0.33,
            left: size * 0.3,
            width: size * 0.08,
            height: size * 0.08,
            background: '#FFF',
            borderRadius: '50%',
            border: '2px solid #000'
          }}
        >
          <div
            className="absolute inset-0"
            style={{
              background: '#000',
              borderRadius: '50%',
              transform: 'scale(0.6)'
            }}
          />
        </div>
        <div
          className="absolute"
          style={{
            top: size * 0.33,
            right: size * 0.3,
            width: size * 0.08,
            height: size * 0.08,
            background: '#FFF',
            borderRadius: '50%',
            border: '2px solid #000'
          }}
        >
          <div
            className="absolute inset-0"
            style={{
              background: '#000',
              borderRadius: '50%',
              transform: 'scale(0.6)'
            }}
          />
        </div>
        
        {/* Beak */}
        <div
          className="absolute"
          style={{
            top: size * 0.45,
            left: '50%',
            transform: 'translateX(-50%)',
            width: size * 0.12,
            height: size * 0.08,
            background: '#FFA500',
            clipPath: 'polygon(50% 0%, 0% 100%, 100% 100%)'
          }}
        />
        
        {/* Wings - spread when active */}
        {activity === 'active' && (
          <>
            <div
              className="absolute"
              style={{
                top: size * 0.4,
                left: -size * 0.15,
                width: size * 0.3,
                height: size * 0.2,
                background: 'linear-gradient(135deg, #FF6B6B 0%, #EE5A6F 100%)',
                borderRadius: '50%',
                transform: 'rotate(-20deg)',
                boxShadow: '0 2px 4px rgba(0,0,0,0.2)'
              }}
            />
            <div
              className="absolute"
              style={{
                top: size * 0.4,
                right: -size * 0.15,
                width: size * 0.3,
                height: size * 0.2,
                background: 'linear-gradient(135deg, #FF6B6B 0%, #EE5A6F 100%)',
                borderRadius: '50%',
                transform: 'rotate(20deg)',
                boxShadow: '0 2px 4px rgba(0,0,0,0.2)'
              }}
            />
          </>
        )}
        
        {/* Messenger bag */}
        {activity === 'active' && (
          <div
            className="absolute"
            style={{
              bottom: size * 0.2,
              left: size * 0.6,
              width: size * 0.25,
              height: size * 0.3,
              background: '#8B4513',
              borderRadius: '4px',
              border: '2px solid #654321',
              transform: 'rotate(10deg)',
              boxShadow: '0 2px 4px rgba(0,0,0,0.2)'
            }}
          >
            <div
              className="absolute top-0 left-1/2 transform -translate-x-1/2"
              style={{
                width: size * 0.15,
                height: size * 0.08,
                background: '#654321',
                borderRadius: '2px'
              }}
            />
          </div>
        )}
      </div>
    </MascotAnimation>
  );
}
</file>

<file path="components/mascots/SherlockShells.tsx">
'use client';

import React from 'react';
import MascotAnimation from './MascotAnimation';

export interface SherlockShellsProps {
  size?: number;
  activity?: 'idle' | 'active';
  className?: string;
}

/**
 * Sherlock Shells - Explorer & Risk Inspector
 * Role: Discovers existing recipes, catalogs new meals, inspects ingredients for problems
 * Accessories: Deerstalker hat, monocle, magnifying glass
 * Personality: Soft-spoken, melancholy, overly thoughtful
 * Color: Green
 * Activity: Slow investigation, examining
 */
export default function SherlockShells({
  size = 120,
  activity = 'idle',
  className = ''
}: SherlockShellsProps) {
  return (
    <MascotAnimation
      activity={activity}
      personality="thoughtful"
      className={className}
    >
      <div
        className="relative"
        style={{ width: size, height: size }}
        role="img"
        aria-label="Sherlock Shells, the turtle detective mascot"
      >
        {/* Turtle shell - rounded, textured */}
        <div
          className="absolute inset-0 rounded-full"
          style={{
            background: 'linear-gradient(135deg, #228B22 0%, #006400 100%)',
            boxShadow: '0 4px 8px rgba(0,0,0,0.2)',
            border: '3px solid #2F4F2F'
          }}
        />
        
        {/* Shell pattern */}
        {[0, 1, 2, 3, 4].map(i => (
          <div
            key={i}
            className="absolute"
            style={{
              top: '50%',
              left: '50%',
              transform: `translate(-50%, -50%) rotate(${i * 72}deg)`,
              width: size * 0.3,
              height: '2px',
              background: '#2F4F2F'
            }}
          />
        ))}
        
        {/* Head */}
        <div
          className="absolute"
          style={{
            top: -size * 0.15,
            left: '50%',
            transform: 'translateX(-50%)',
            width: size * 0.4,
            height: size * 0.3,
            background: 'linear-gradient(135deg, #8B7355 0%, #6B5B4D 100%)',
            borderRadius: '50%',
            boxShadow: '0 2px 4px rgba(0,0,0,0.2)'
          }}
        />
        
        {/* Deerstalker hat */}
        <div
          className="absolute"
          style={{
            top: -size * 0.2,
            left: '50%',
            transform: 'translateX(-50%)',
            width: size * 0.5,
            height: size * 0.15,
            background: '#4A4A4A',
            borderRadius: '50%',
            boxShadow: '0 2px 4px rgba(0,0,0,0.2)'
          }}
        />
        <div
          className="absolute"
          style={{
            top: -size * 0.25,
            left: '50%',
            transform: 'translateX(-50%)',
            width: size * 0.4,
            height: size * 0.1,
            background: '#4A4A4A',
            borderRadius: '50%'
          }}
        />
        {/* Hat flaps */}
        <div
          className="absolute"
          style={{
            top: -size * 0.15,
            left: -size * 0.1,
            width: size * 0.15,
            height: size * 0.2,
            background: '#4A4A4A',
            borderRadius: '50%',
            transform: 'rotate(-20deg)'
          }}
        />
        <div
          className="absolute"
          style={{
            top: -size * 0.15,
            right: -size * 0.1,
            width: size * 0.15,
            height: size * 0.2,
            background: '#4A4A4A',
            borderRadius: '50%',
            transform: 'rotate(20deg)'
          }}
        />
        
        {/* Monocle */}
        <div
          className="absolute"
          style={{
            top: size * 0.05,
            right: size * 0.15,
            width: size * 0.12,
            height: size * 0.12,
            border: '3px solid #333',
            borderRadius: '50%',
            background: 'rgba(200, 200, 200, 0.3)',
            boxShadow: '0 2px 4px rgba(0,0,0,0.2)'
          }}
        />
        <div
          className="absolute"
          style={{
            top: size * 0.05,
            right: size * 0.15,
            width: size * 0.12,
            height: size * 0.12,
            borderRight: '2px solid #333'
          }}
        />
        
        {/* Eye in monocle */}
        <div
          className="absolute"
          style={{
            top: size * 0.08,
            right: size * 0.18,
            width: size * 0.06,
            height: size * 0.06,
            background: '#4A90E2',
            borderRadius: '50%',
            border: '2px solid #000'
          }}
        />
        
        {/* Other eye */}
        <div
          className="absolute"
          style={{
            top: size * 0.08,
            left: size * 0.2,
            width: size * 0.06,
            height: size * 0.06,
            background: '#4A90E2',
            borderRadius: '50%',
            border: '2px solid #000'
          }}
        />
        
        {/* Mouth - thoughtful expression */}
        <div
          className="absolute"
          style={{
            top: size * 0.2,
            left: '50%',
            transform: 'translateX(-50%)',
            width: size * 0.15,
            height: size * 0.05,
            borderBottom: '2px solid #000',
            borderRadius: '0 0 50% 50%'
          }}
        />
        
        {/* Magnifying glass - when active */}
        {activity === 'active' && (
          <div
            className="absolute"
            style={{
              top: size * 0.1,
              right: -size * 0.1,
              width: size * 0.2,
              height: size * 0.2,
              border: '3px solid #654321',
              borderRadius: '50%',
              background: 'rgba(200, 200, 200, 0.2)',
              transform: 'rotate(-10deg)',
              boxShadow: '0 2px 4px rgba(0,0,0,0.2)'
            }}
          >
            <div
              className="absolute bottom-0 right-0"
              style={{
                width: size * 0.15,
                height: size * 0.05,
                background: '#654321',
                borderRadius: '2px',
                transform: 'rotate(45deg) translate(20%, -20%)'
              }}
            />
          </div>
        )}
      </div>
    </MascotAnimation>
  );
}
</file>

<file path="components/MealBuilderWizard.tsx">
'use client';

import { useState, useMemo } from 'react';
import { X, ChevronRight, ChevronLeft, Check, Star, ArrowUp } from 'lucide-react';
import { createPortal } from 'react-dom';
import Image from 'next/image';
import { INGREDIENT_COMPOSITIONS, getIngredientComposition, type IngredientComposition } from '@/lib/data/ingredientCompositions';
import { getFallbackNutrition } from '@/lib/utils/nutritionFallbacks';

interface Category {
  name: string;
  description: string;
  icon: string;
  ingredients: string[];
  required: boolean;
}

interface MealBuilderWizardProps {
  isOpen: boolean;
  onClose: () => void;
  onComplete: (selections: { [category: string]: string[] }) => void;
  categories: {
    proteins: Category;
    grains: Category;
    greens: Category;
    fruits: Category;
    supplements: Category;
  };
  petName: string;
  petType?: string; // Pet species type (dogs, cats, pocket-pets, etc.)
  recommendedIngredients?: string[]; // List of recommended ingredient names
}

const CATEGORY_ORDER = ['proteins', 'grains', 'greens', 'fruits', 'supplements'] as const;

/**
 * Get the highest nutrient value for an ingredient
 * Returns the nutrient name and a normalized value for comparison
 */
function getTopNutrients(ingredientName: string, count: number = 3): Array<{ name: string; value: number }> {
  // Normalize ingredient name
  const normalized = ingredientName.toLowerCase()
    .trim()
    .replace(/\s+/g, '_')
    .replace(/[^a-z0-9_]/g, '')
    .replace(/_+/g, '_');
  
  // Try to get composition
  let composition: IngredientComposition | null = INGREDIENT_COMPOSITIONS[normalized] || null;
  if (!composition) {
    composition = getIngredientComposition(ingredientName) || null;
  }
  if (!composition) {
    // Try fallback
    composition = getFallbackNutrition(ingredientName);
  }
  
  if (!composition) return [];
  
  // Define nutrients to check with their display names and normalization factors
  const nutrients = [
    { key: 'protein', name: 'Protein', value: composition.protein || 0, factor: 1 },
    { key: 'fat', name: 'Fat', value: composition.fat || 0, factor: 1 },
    { key: 'fiber', name: 'Fiber', value: composition.fiber || 0, factor: 1 },
    { key: 'calcium', name: 'Calcium', value: (composition.calcium || 0) / 100, factor: 100 }, // Convert mg to g for comparison
    { key: 'omega3', name: 'Omega-3', value: composition.omega3 || 0, factor: 1 },
    { key: 'taurine', name: 'Taurine', value: (composition.taurine || 0) / 100, factor: 100 }, // Convert mg to g
    { key: 'vitaminA', name: 'Vitamin A', value: (composition.vitaminA || 0) / 1000, factor: 1000 }, // Convert IU to thousands
    { key: 'vitaminC', name: 'Vitamin C', value: (composition.vitaminC || 0) / 100, factor: 100 }, // Convert mg to g
  ];
  
  // Calculate normalized values and filter out insignificant ones
  const nutrientsWithNormalized = nutrients
    .map(nutrient => ({
      ...nutrient,
      normalizedValue: nutrient.value * nutrient.factor
    }))
    .filter(nutrient => nutrient.normalizedValue > 0.1); // Only include significant values
  
  // Sort by normalized value (descending) and take top N
  const topNutrients = nutrientsWithNormalized
    .sort((a, b) => b.normalizedValue - a.normalizedValue)
    .slice(0, count)
    .map(nutrient => ({
      name: nutrient.name,
      value: nutrient.value
    }));
  
  return topNutrients;
}

export default function MealBuilderWizard({
  isOpen,
  onClose,
  onComplete,
  categories,
  petName,
  petType,
  recommendedIngredients = []
}: MealBuilderWizardProps) {
  const skipProteins = !categories.proteins.required || categories.proteins.ingredients.length === 0;
  const skipFruits = petType && ['dogs', 'cats', 'dog', 'cat'].includes(petType.toLowerCase());
  const stepOrder = CATEGORY_ORDER.filter((key) => {
    if (skipProteins && key === 'proteins') return false;
    if (skipFruits && key === 'fruits') return false;
    return true;
  });

  const [currentStep, setCurrentStep] = useState(0);
  const [selections, setSelections] = useState<{ [key: string]: string[] }>({
    proteins: [],
    grains: [],
    greens: [],
    fruits: [],
    supplements: []
  });

  if (!isOpen) return null;

  const currentCategoryKey = stepOrder[currentStep];
  const currentCategory = categories[currentCategoryKey];
  const isRequired = currentCategory.required;
  const currentSelections = selections[currentCategoryKey] || [];
  const hasSelection = currentSelections.length > 0;
  const hasIngredients = currentCategory.ingredients.length > 0;
  // Allow proceeding if: not required, OR has selection, OR required but no ingredients available
  const canProceed = !isRequired || hasSelection || !hasIngredients;
  const isLastStep = currentStep === stepOrder.length - 1;

  const handleSelect = (ingredient: string) => {
    setSelections(prev => {
      const current = prev[currentCategoryKey] || [];
      const isSelected = current.includes(ingredient);
      return {
        ...prev,
        [currentCategoryKey]: isSelected 
          ? current.filter(ing => ing !== ingredient)
          : [...current, ingredient]
      };
    });
  };

  const handleNext = () => {
    if (isLastStep) {
      onComplete(selections);
      handleClose();
    } else {
      setCurrentStep(prev => prev + 1);
    }
  };

  const handleBack = () => {
    if (currentStep > 0) {
      setCurrentStep(prev => prev - 1);
    }
  };

  const handleClose = () => {
    setCurrentStep(0);
    setSelections({
      proteins: [],
      grains: [],
      greens: [],
      fruits: [],
      supplements: []
    });
    onClose();
  };

  const wizardContent = (
    <div className="fixed inset-0 z-50 flex items-center justify-center p-4" style={{ backgroundColor: '#0f2c0f' }}>
      <div className="rounded-lg shadow-xl max-w-2xl w-full max-h-[90vh] flex flex-col" style={{ backgroundColor: '#143424' }}>
        {/* Header */}
        <div className="flex items-center justify-between p-6 border-b" style={{ borderColor: '#2d5a47' }}>
          <div>
            <h2 className="text-2xl font-bold text-gray-100">
              Create Meal for {petName}
            </h2>
            <p className="text-sm text-gray-300 mt-1">
              Step {currentStep + 1} of {stepOrder.length}
            </p>
          </div>
          <button
            onClick={handleClose}
            className="p-2 hover:opacity-80 rounded-full transition-colors"
            style={{ backgroundColor: '#2d5a47' }}
          >
            <X size={20} className="text-gray-200" />
          </button>
        </div>

        {/* Progress Bar */}
        <div className="px-6 py-4 border-b" style={{ backgroundColor: '#143424', borderColor: '#2d5a47' }}>
          <div className="flex gap-2">
            {stepOrder.map((key, index) => {
              const category = categories[key];
              const isActive = index === currentStep;
              const isCompleted = (selections[key] || []).length > 0;
              const isPast = index < currentStep;

              return (
                <div key={key} className="flex-1">
                  <div className="flex items-center gap-2">
                    <div
                      className={`flex-1 h-2 rounded-full transition-colors ${
                        isActive
                          ? 'bg-primary-600'
                          : isCompleted || isPast
                          ? 'bg-green-500'
                          : 'bg-gray-200'
                      }`}
                    />
                    {isCompleted && !isActive && (
                      <Check size={16} className="text-green-400 flex-shrink-0" />
                    )}
                  </div>
                  <div className="text-xs text-gray-300 mt-1 truncate">
                    {category.icon} {category.name}
                  </div>
                </div>
              );
            })}
          </div>
        </div>

        {/* Category Content */}
        <div className="flex-1 overflow-y-auto p-6">
          <div className="text-center mb-6">
            {currentStep === 0 && (
              <div className="mb-4 flex justify-center">
                <Image
                  src="/images/emojis/Mascots/PrepPuppy/PrepPuppyKitchen.jpg"
                  alt="Puppy Prepper"
                  width={240}
                  height={240}
                  className="w-[240px] h-[240px] object-contain"
                  unoptimized
                />
              </div>
            )}
            <div className="text-4xl mb-2">{currentCategory.icon}</div>
            <h3 className="text-xl font-semibold text-gray-100 mb-1">
              {currentCategory.name}
            </h3>
            <p className="text-sm text-gray-300">{currentCategory.description}</p>
            {isRequired && hasIngredients && (
              <p className="text-xs text-red-400 mt-2">* Required</p>
            )}
            {isRequired && !hasIngredients && (
              <p className="text-xs text-yellow-400 mt-2">‚ö† No ingredients available - you can skip this step</p>
            )}
          </div>

          {/* Ingredient List */}
          <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
            {currentCategory.ingredients.length === 0 ? (
              <div className="col-span-2 text-center py-8 text-gray-400">
                No ingredients available in this category for this pet.
              </div>
            ) : (() => {
              // Separate recommended and regular ingredients
              const recommended = currentCategory.ingredients.filter(ing => 
                recommendedIngredients.includes(ing)
              );
              const regular = currentCategory.ingredients.filter(ing => 
                !recommendedIngredients.includes(ing)
              );
              
              // Sort: recommended first, then regular
              const sortedIngredients = [...recommended, ...regular];
              
              return sortedIngredients.map(ingredient => {
                const isSelected = currentSelections.includes(ingredient);
                const isRecommended = recommendedIngredients.includes(ingredient);
                const topNutrients = getTopNutrients(ingredient, 3);
                
                return (
                  <button
                    key={ingredient}
                    onClick={() => handleSelect(ingredient)}
                    className="p-4 rounded-lg text-left transition-colors duration-200 relative"
                    style={{
                      border: isSelected ? '3px solid #f97316' : isRecommended ? '3px solid #fb923c' : '3px solid rgba(249, 115, 22, 0.5)',
                      backgroundColor: isSelected ? '#2d5a47' : isRecommended ? '#3d4a2e' : '#143424',
                      color: '#e5e7eb'
                    }}
                  >
                    <div className="flex items-center justify-between">
                      <div className="flex items-center gap-2 flex-1 min-w-0">
                        {isRecommended && (
                          <Star size={16} className="text-yellow-400 fill-yellow-400 flex-shrink-0" />
                        )}
                        <span className="text-sm font-medium truncate text-gray-100">
                          {ingredient}
                        </span>
                      </div>
                      {isSelected && (
                        <Check size={18} className="text-green-400 flex-shrink-0 ml-2" />
                      )}
                    </div>
                    <div className="flex items-center justify-between mt-2 flex-wrap gap-2">
                      {isRecommended && (
                        <div className="text-xs text-yellow-300">
                          Recommended
                        </div>
                      )}
                      {topNutrients.length > 0 && (
                        <div className="flex items-center gap-2 ml-auto flex-wrap">
                          {topNutrients.map((nutrient, idx) => (
                            <div key={idx} className="flex items-center gap-1 text-xs text-orange-300">
                              <ArrowUp size={12} className="text-orange-400" />
                              <span>{nutrient.name}</span>
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                  </button>
                );
              });
            })()}
          </div>
        </div>

        {/* Footer Actions */}
        <div className="flex items-center justify-between p-6 border-t" style={{ borderColor: '#2d5a47', backgroundColor: '#143424' }}>
          <button
            onClick={handleBack}
            disabled={currentStep === 0}
            className="flex items-center gap-2 px-4 py-2 text-sm font-medium rounded-md disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
            style={{
              backgroundColor: '#2d5a47',
              border: '3px solid #f97316',
              color: '#e5e7eb'
            }}
          >
            <ChevronLeft size={16} />
            Back
          </button>

          <div className="flex gap-3">
            <button
              onClick={handleNext}
              disabled={!canProceed}
              className="flex items-center gap-2 px-6 py-2 text-sm font-medium text-white rounded-md disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
              style={{
                backgroundColor: '#16a34a',
                border: '3px solid #f97316'
              }}
            >
              {isLastStep ? 'Complete' : 'Next'}
              {!isLastStep && <ChevronRight size={16} />}
            </button>
          </div>
        </div>
      </div>
    </div>
  );

  // Use portal to render modal at root level
  if (typeof window !== 'undefined') {
    return createPortal(wizardContent, document.body);
  }

  return null;
}
</file>

<file path="components/MealCompleteView.tsx">
'use client';

import { useState, useEffect, useRef, useMemo } from 'react';
import { CheckCircle, AlertTriangle, XCircle, Info, Plus, Save, ShoppingCart, Star, ChevronLeft } from 'lucide-react';
import { MealAnalysis, IngredientSelection } from '@/lib/analyzeCustomMeal';
import MealCompositionList from '@/components/MealCompositionList';
import { generateMealName } from '@/lib/utils/mealNameGenerator';
import { saveCustomMeal } from '@/lib/utils/customMealStorage';
import { calculateEnhancedCompatibility, type Pet as EnhancedPet } from '@/lib/utils/enhancedCompatibilityScoring';
import type { Recipe } from '@/lib/types';
import Image from 'next/image';
import Tooltip from '@/components/Tooltip';
import { getPets } from '@/lib/utils/petStorage';
import { getRecommendationsForRecipe } from '@/lib/utils/nutritionalRecommendations';
import { logger } from '@/lib/utils/logger';
import { getProductByIngredient, getProductPrice, getProductUrl } from '@/lib/data/product-prices';
import { ShoppingList } from '@/components/ShoppingList';
import { CostComparison } from '@/components/CostComparison';
import { calculateMealsFromGroceryList } from '@/lib/utils/mealEstimation';
import Link from 'next/link';
import { checkAllBadges } from '@/lib/utils/badgeChecker';
import { ensureSellerId } from '@/lib/utils/affiliateLinks';

interface MealCompleteViewProps {
  petName: string;
  petBreed: string;
  petAge: string;
  petWeight: string;
  petId: string;
  userId: string;
  selectedIngredients: IngredientSelection[];
  analysis: MealAnalysis | null;
  isAnalyzing: boolean;
  onUpdateAmount: (key: string, grams: number) => void;
  onRemove: (key: string) => void;
  onAddMore: () => void;
  onStartOver: () => void;
  getIngredientDisplayName: (key: string) => string;
  getCompatibilityIndicator?: (key: string) => 'safe' | 'warning' | 'blocked' | null;
  isFirstCreation?: boolean; // New prop to indicate if this is the first time creating the meal
  petType?: string; // Pet type (dog, cat, etc.)
}

export default function MealCompleteView({
  petName,
  petBreed,
  petAge,
  petWeight,
  petId,
  userId,
  selectedIngredients,
  analysis,
  isAnalyzing,
  onUpdateAmount,
  onRemove,
  onAddMore,
  onStartOver,
  getIngredientDisplayName,
  getCompatibilityIndicator,
  isFirstCreation = false,
  petType = 'dog' // Default to dog if not provided
}: MealCompleteViewProps) {
  const totalGrams = selectedIngredients.reduce((sum, s) => sum + s.grams, 0);
  const [mealName, setMealName] = useState<string>('');
  const [isSaving, setIsSaving] = useState(false);
  const [isSaved, setIsSaved] = useState(false);
  const [pet, setPet] = useState<any>(null);
  const [healthAnalysis, setHealthAnalysis] = useState<any>(null);
  const [isCalculatingHealthAnalysis, setIsCalculatingHealthAnalysis] = useState(false);
  const [activeTab, setActiveTab] = useState<'ingredients' | 'supplements'>('ingredients');

  const handleSaveMeal = async () => {
    if (!analysis || !mealName.trim()) {
      return;
    }

    setIsSaving(true);
    try {
      await saveCustomMeal(userId, petId, mealName.trim(), selectedIngredients, analysis);
      setIsSaved(true);
    } catch (error) {
      logger.error('Error saving meal:', error);
      setIsSaved(false);
    } finally {
      setIsSaving(false);
    }
  };

  // Load pet data for health analysis
  useEffect(() => {
    async function loadPet() {
      try {
        const pets = await getPets(userId);
        const foundPet = pets.find((p: any) => p.id === petId);
        if (foundPet) {
          setPet(foundPet);
        }
      } catch (error) {
        console.error('Failed to load pet:', error);
      }
    }
    if (userId && petId) {
      loadPet();
    }
  }, [userId, petId]);

  // Diagnostic logging - MOVED BELOW DECLARATIONS to avoid TDZ error

  // Calculate health analysis when analysis and ingredients are available
  // We can work with pet props directly if pet object isn't loaded yet
  useEffect(() => {
    if (!analysis || selectedIngredients.length === 0) {
      setHealthAnalysis(null);
      setIsCalculatingHealthAnalysis(false);
      return;
    }

    // Set calculating state
    setIsCalculatingHealthAnalysis(true);

    try {
      // Convert custom meal to Recipe format
      const recipe: Recipe = {
        id: `custom-meal-${Date.now()}`,
        name: mealName || 'Custom Meal',
        category: petType || 'dog',
        ageGroup: [petAge === 'baby' ? 'baby' : petAge === 'young' ? 'young' : petAge === 'senior' ? 'senior' : 'adult'],
        healthConcerns: [],
        ingredients: selectedIngredients.map((ing, idx) => ({
          id: `${idx + 1}`,
          name: getIngredientDisplayName(ing.key),
          amount: `${ing.grams}g`,
        })),
        instructions: [],
        nutritionalInfo: analysis.nutrients ? {
          protein: {
            min: (analysis.nutrients.protein_g || 0) / (totalGrams / 100),
            max: (analysis.nutrients.protein_g || 0) / (totalGrams / 100),
            unit: '%',
          },
          fat: {
            min: (analysis.nutrients.fat_g || 0) / (totalGrams / 100),
            max: (analysis.nutrients.fat_g || 0) / (totalGrams / 100),
            unit: '%',
          },
        } : undefined,
        // Add nutritionalCalculation field with actual analysis data for enhanced compatibility scoring
        nutritionalCalculation: analysis.nutrients ? {
          protein_g: analysis.nutrients.protein_g || 0,
          fat_g: analysis.nutrients.fat_g || 0,
          ca_mg: analysis.nutrients.ca_mg || 0,
          p_mg: analysis.nutrients.p_mg || 0,
          calories_kcal: analysis.nutrients.calories_kcal || analysis.nutrients.kcal || analysis.nutrients.energy_kcal || 0,
          fiber_g: analysis.nutrients.fiber_g || 0,
          totalGrams: totalGrams,
        } : undefined,
      } as any;

      // Convert pet to EnhancedPet format
      // Use pet object if available, otherwise use props directly
      const enhancedPet: EnhancedPet = {
        id: pet?.id || petId,
        name: petName,
        type: (petType || pet?.type || 'dog') as 'dog' | 'cat' | 'bird' | 'reptile' | 'pocket-pet',
        breed: petBreed || pet?.breed || '',
        age: petAge === 'baby' ? 0.5 : petAge === 'young' ? 2 : petAge === 'senior' ? 10 : 5,
        weight: parseFloat(petWeight) || pet?.weightKg || 10,
        activityLevel: pet?.activityLevel || 'moderate',
        healthConcerns: pet?.healthConcerns || [],
        dietaryRestrictions: pet?.allergies || [],
        allergies: pet?.allergies || [],
      };

      const enhanced = calculateEnhancedCompatibility(recipe, enhancedPet);
      
      // Get nutritional recommendations
      const nutritionalGaps = enhanced.detailedBreakdown.nutritionalGaps || [];
      const recommendations = getRecommendationsForRecipe(
        nutritionalGaps,
        enhancedPet.type,
        enhancedPet.healthConcerns || []
      );
      
      // Format breakdown similar to recipe detail page
      const getReasonWithIssues = (factor: typeof enhanced.factors.ingredientSafety) => {
        if (factor.issues.length > 0) {
          return factor.issues.join('; ') + (factor.reasoning ? ` (${factor.reasoning})` : '');
        }
        return factor.reasoning || '';
      };

      setHealthAnalysis({
        overallScore: enhanced.overallScore,
        compatibility: enhanced.grade === 'A+' || enhanced.grade === 'A' ? 'excellent' :
                       enhanced.grade === 'B+' || enhanced.grade === 'B' ? 'good' :
                       enhanced.grade === 'C+' || enhanced.grade === 'C' ? 'fair' : 'poor',
        breakdown: {
          petTypeMatch: { 
            score: enhanced.factors.ingredientSafety.score,
            weightedContribution: Math.round(enhanced.factors.ingredientSafety.score * enhanced.factors.ingredientSafety.weight),
            weight: enhanced.factors.ingredientSafety.weight,
            reason: getReasonWithIssues(enhanced.factors.ingredientSafety)
          },
          ageAppropriate: { 
            score: enhanced.factors.lifeStageFit.score,
            weightedContribution: Math.round(enhanced.factors.lifeStageFit.score * enhanced.factors.lifeStageFit.weight),
            weight: enhanced.factors.lifeStageFit.weight,
            reason: getReasonWithIssues(enhanced.factors.lifeStageFit)
          },
          nutritionalFit: { 
            score: enhanced.factors.nutritionalAdequacy.score,
            weightedContribution: Math.round(enhanced.factors.nutritionalAdequacy.score * enhanced.factors.nutritionalAdequacy.weight),
            weight: enhanced.factors.nutritionalAdequacy.weight,
            reason: getReasonWithIssues(enhanced.factors.nutritionalAdequacy),
            recommendations: recommendations // Add recommendations to nutritional fit
          },
          healthCompatibility: { 
            score: enhanced.factors.healthAlignment.score,
            weightedContribution: Math.round(enhanced.factors.healthAlignment.score * enhanced.factors.healthAlignment.weight),
            weight: enhanced.factors.healthAlignment.weight,
            reason: getReasonWithIssues(enhanced.factors.healthAlignment)
          },
          activityFit: {
            score: enhanced.factors.activityFit.score,
            weightedContribution: Math.round(enhanced.factors.activityFit.score * enhanced.factors.activityFit.weight),
            weight: enhanced.factors.activityFit.weight,
            reason: getReasonWithIssues(enhanced.factors.activityFit)
          },
          allergenSafety: { 
            score: enhanced.factors.allergenSafety.score,
            weightedContribution: Math.round(enhanced.factors.allergenSafety.score * enhanced.factors.allergenSafety.weight),
            weight: enhanced.factors.allergenSafety.weight,
            reason: getReasonWithIssues(enhanced.factors.allergenSafety)
          },
        },
        warnings: enhanced.detailedBreakdown.warnings,
        strengths: enhanced.detailedBreakdown.healthBenefits,
        nutritionalGaps: nutritionalGaps,
        recommendations: recommendations,
      });

      // Check badges if score is 100% (Nutrient Navigator)
      if (enhanced.overallScore === 100 && userId && petId) {
        checkAllBadges(userId, petId, {
          action: 'meal_created',
          compatibilityScore: enhanced.overallScore,
        }).catch(err => {
          logger.error('Failed to check badges', err);
        });
      }

      // Successfully calculated
      setIsCalculatingHealthAnalysis(false);
    } catch (error) {
      // Log error but don't hide the compatibility score
      console.error('Error calculating enhanced health analysis:', error);
      logger.error('Error calculating enhanced health analysis', error);
      // Keep existing healthAnalysis if there was one, otherwise null
      // Don't set to null here - let the fallback score show instead
      setIsCalculatingHealthAnalysis(false);
    }
  }, [pet, analysis, selectedIngredients, mealName, petName, petBreed, petAge, petWeight, petType, petId, getIngredientDisplayName, totalGrams, userId]);

  // Generate meal name when ingredients are first set
  useEffect(() => {
    if (selectedIngredients.length > 0 && !mealName) {
      const ingredientKeys = selectedIngredients.map(ing => ing.key);
      
      // Extract nutritional profile from analysis
      const nutritionalProfile = analysis ? {
        protein: analysis.nutrients?.protein_g ? (analysis.nutrients.protein_g / totalGrams) * 100 : undefined,
        fat: analysis.nutrients?.fat_g ? (analysis.nutrients.fat_g / totalGrams) * 100 : undefined,
        fiber: analysis.nutrients?.fiber_g ? (analysis.nutrients.fiber_g / totalGrams) * 100 : undefined,
      } : undefined;
      
      const result = generateMealName(ingredientKeys, {
        petName,
        petBreed,
        petSpecies: petType,
        healthConcerns: pet?.healthConcerns || [],
        nutritionalProfile,
        mealType: 'complete',
        isCustomMeal: true,
      });
      
      setMealName(result.fullName);
    }
  }, [selectedIngredients, mealName, analysis, totalGrams, petName, petBreed, petType, pet]);


  // Calculate recommended amounts per ingredient based on total recommended serving
  const calculateRecommendedAmounts = (): { [key: string]: number } => {
    if (!analysis || !analysis.recommendedServingGrams || analysis.recommendedServingGrams <= 0) {
      return {};
    }

    const recommendedTotal = analysis.recommendedServingGrams;
    const currentTotal = totalGrams;
    
    if (currentTotal <= 0) return {};

    // Distribute recommended total proportionally based on current ingredient ratios
    const recommendedAmounts: { [key: string]: number } = {};
    selectedIngredients.forEach(ing => {
      const ratio = ing.grams / currentTotal;
      recommendedAmounts[ing.key] = Math.round(recommendedTotal * ratio);
    });

    return recommendedAmounts;
  };

  const recommendedAmounts = calculateRecommendedAmounts();

  const getScoreColor = (score: number) => {
    if (score >= 80) return 'text-green-600 bg-green-50 border-green-200';
    if (score >= 60) return 'text-yellow-600 bg-yellow-50 border-yellow-200';
    return 'text-red-600 bg-red-50 border-red-200';
  };

  const getScoreIcon = (score: number) => {
    if (score >= 80) return <CheckCircle size={24} className="text-green-600" />;
    if (score >= 60) return <AlertTriangle size={24} className="text-yellow-600" />;
    return <XCircle size={24} className="text-red-600" />;
  };

  const getProgressGradientColor = (score: number) => {
    if (score === 0) return '#dc2626'; // red-600
    if (score <= 10) return '#dc2626'; // red-600
    if (score <= 20) return '#ea580c'; // orange-600
    if (score <= 30) return '#d97706'; // amber-600
    if (score <= 40) return '#ca8a04'; // yellow-600
    if (score <= 50) return '#a3a3a3'; // gray-400 (neutral)
    if (score <= 60) return '#84cc16'; // lime-500
    if (score <= 70) return '#65a30d'; // lime-700
    if (score <= 80) return '#16a34a'; // green-600
    if (score <= 90) return '#15803d'; // green-700
    return '#166534'; // green-800
  };


  // Get display score and compatibility
  const displayScore = healthAnalysis?.overallScore ?? (analysis?.score ?? 0);
  const compatibility = healthAnalysis?.compatibility ?? 
    (displayScore >= 80 ? 'excellent' : displayScore >= 60 ? 'good' : displayScore >= 40 ? 'fair' : 'poor');

  // Prepare ingredients for ShoppingList (memoized)
  const ingredientsWithASINs = useMemo(() => {
    console.log('[MealCompleteView] ========== ingredientsWithASINs Calculation ==========');
    console.log('[MealCompleteView] selectedIngredients:', selectedIngredients);
    console.log('[MealCompleteView] selectedIngredients.length:', selectedIngredients.length);
    
    const result = selectedIngredients
      .map((ing, index) => {
        console.log(`[MealCompleteView] Processing ingredient ${index + 1}:`, ing);
        const displayName = getIngredientDisplayName(ing.key);
        console.log(`[MealCompleteView]   Display name from getIngredientDisplayName:`, displayName);
        
        const link = getProductUrl(displayName);
        console.log(`[MealCompleteView]   Product-prices purchase link:`, link);
        
        if (link) {
          const item = {
            id: ing.key,
            name: displayName,
            amount: `${ing.grams}g`,
            asinLink: ensureSellerId(link)
          };
          console.log(`[MealCompleteView]   ‚úÖ Added to ingredientsWithASINs:`, item);
          return item;
        }
        console.log(`[MealCompleteView]   ‚ùå No link found, skipping ingredient`);
        return null;
      })
      .filter(Boolean) as Array<{ id: string; name: string; amount: string; asinLink: string }>;
    
    console.log('[MealCompleteView] Final ingredientsWithASINs array:', result);
    console.log('[MealCompleteView] ingredientsWithASINs.length:', result.length);
    console.log('[MealCompleteView] =====================================================');
    return result;
  }, [selectedIngredients, getIngredientDisplayName]);

  const ingredientsWithoutASINs = useMemo(() => {
    return selectedIngredients
      .filter(ing => {
        const displayName = getIngredientDisplayName(ing.key);
        const link = getProductUrl(displayName);
        return !link;
      })
      .map(ing => ({
        id: ing.key,
        name: getIngredientDisplayName(ing.key),
        amount: `${ing.grams}g`,
      }));
  }, [selectedIngredients, getIngredientDisplayName]);

  // Get recommended supplements
  const recommendedSupplements = healthAnalysis?.recommendations || [];

  // Calculate meal estimate only for CostComparison component
  const mealEstimateForCost = useMemo(() => {
    console.log('[MealCompleteView] Calculating mealEstimateForCost...');
    console.log('[MealCompleteView] ingredientsWithASINs:', ingredientsWithASINs);
    
    if (!ingredientsWithASINs || ingredientsWithASINs.length === 0) {
      console.log('[MealCompleteView] No ingredients with ASINs, returning null');
      return null;
    }
    
    try {
      const shoppingListItems = ingredientsWithASINs.map(ing => {
        return {
          id: ing.id,
          name: ing.name,
          amount: ing.amount,
          category: undefined
        };
      });
      
      console.log('[MealCompleteView] Shopping list items for calculation:', shoppingListItems);
      
      // Calculate total cost using product-prices.json when available, otherwise fall back to package estimates
      const totalCost = ingredientsWithASINs.reduce((sum, item) => {
        const price = getProductPrice(item.name);
        return typeof price === 'number' ? sum + price : sum;
      }, 0);
      
      const result = calculateMealsFromGroceryList(shoppingListItems);
      // Override totalCost with the one calculated from ShoppingList logic to ensure they match
      if (result) {
        result.totalCost = totalCost;
        result.costPerMeal = result.estimatedMeals > 0 ? totalCost / result.estimatedMeals : 0;
      }
      console.log('[MealCompleteView] mealEstimateForCost result:', result);
      return result;
    } catch (error) {
      console.error('[MealCompleteView] Error calculating meal estimate for cost:', error);
      return null;
    }
  }, [ingredientsWithASINs]);

  // Diagnostic logging - NOW AFTER DECLARATIONS
  useEffect(() => {
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/0b2cb572-34bf-468c-9297-dd079c8c4c2d',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'MealCompleteView.tsx:463',message:'Diagnostic useEffect executing',data:{hasIngredientsWithASINs:!!ingredientsWithASINs,length:ingredientsWithASINs?.length,hasMealEstimate:!!mealEstimateForCost},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
    // #endregion
    console.group('üîç MealCompleteView Diagnostic');
    console.log('selectedIngredients:', selectedIngredients);
    console.log('selectedIngredients.length:', selectedIngredients.length);
    console.log('ingredientsWithASINs:', ingredientsWithASINs);
    console.log('ingredientsWithASINs.length:', ingredientsWithASINs.length);
    if (ingredientsWithASINs.length > 0) {
      const testItem = ingredientsWithASINs[0];
      console.log('First ingredient:', testItem);
      const pricedUrl = getProductUrl(testItem.name);
      console.log('Product-prices url for first ingredient:', pricedUrl);
    }
    console.log('mealEstimateForCost:', mealEstimateForCost);
    console.groupEnd();
  }, [selectedIngredients, ingredientsWithASINs, mealEstimateForCost]);

  return (
    <div className="min-h-screen bg-background py-12 font-sans text-foreground">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        {/* Breadcrumb */}
        <Link
          href={`/profile/pet/${petId}`}
          className="inline-flex items-center text-gray-400 hover:text-primary-400 mb-6 font-medium transition-colors"
        >
          <ChevronLeft className="w-5 h-5 mr-1" />
          Back to Pet Profile
        </Link>

        <div className="grid grid-cols-1 lg:grid-cols-5 gap-10">
          <main className="lg:col-span-3">
            {/* Recipe Info Card */}
            <div className="bg-surface rounded-2xl shadow-xl overflow-hidden mb-8 border border-surface-highlight">
              <div className="p-8">
                {/* Meal Name Input */}
                <div className="mb-4">
                  <label className="block text-xs font-medium text-gray-400 mb-2">Meal Name</label>
                  <input
                    type="text"
                    value={mealName}
                    onChange={(e) => setMealName(e.target.value)}
                    className="w-full px-4 py-2 text-4xl font-extrabold text-foreground bg-surface-highlight border border-surface-highlight rounded-lg focus:outline-none focus:ring-2 focus:ring-orange-500"
                    placeholder="Enter meal name..."
                  />
            </div>

                {/* Health Concerns */}
                {pet?.healthConcerns && pet.healthConcerns.length > 0 && (
                  <div className="mb-4 flex flex-wrap gap-2">
                    {pet.healthConcerns.map((concern: string) => (
                      <span
                        key={concern}
                        className="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-orange-900/40 text-orange-200 border border-orange-700/50"
                      >
                        {concern.replace(/-/g, ' ').replace(/\b\w/g, (l: string) => l.toUpperCase())}
                      </span>
                    ))}
                  </div>
                )}

                {/* Compatibility Score - Big Progress Bar */}
                {analysis && (
                  <div className={`mb-6 rounded-xl border-2 p-6 ${
                    displayScore >= 80 ? 'bg-green-900/20 border-green-700/50 text-green-200' :
                    displayScore >= 60 ? 'bg-yellow-900/20 border-yellow-700/50 text-yellow-200' :
                    'bg-red-900/20 border-red-700/50 text-red-200'
                  }`}>
                    <div className="flex items-center justify-between mb-4">
                      <div className="flex items-center gap-2">
                        {displayScore >= 80 ? <CheckCircle size={24} className="text-green-400" /> :
                         displayScore >= 60 ? <AlertTriangle size={24} className="text-yellow-400" /> :
                         <XCircle size={24} className="text-red-400" />}
                        <h3 className="font-semibold text-xl">Compatibility Score</h3>
                      </div>
                      <div className="text-4xl font-bold">{displayScore}/100</div>
                    </div>
                    
                    {/* Progress Bar */}
                    <div className="w-full bg-black/30 rounded-full h-4 mb-3">
                      <div
                        className={`h-4 rounded-full transition-[width] duration-500 ease-out will-change-[width] ${
                          displayScore >= 80 ? 'bg-green-600' :
                          displayScore >= 60 ? 'bg-yellow-600' :
                          'bg-red-600'
                        }`}
                        style={{ width: `${displayScore}%` }}
                      />
                    </div>

                    <div className="text-sm opacity-90">
                      {isCalculatingHealthAnalysis && !healthAnalysis && 'Calculating enhanced score...'}
                      {healthAnalysis && (displayScore >= 80 ? '‚úì Excellent match for your pet' :
                                         displayScore >= 60 ? '‚ö† Good, but could be improved' :
                                         '‚úó Needs adjustments for safety')}
                      {!isCalculatingHealthAnalysis && !healthAnalysis && (displayScore >= 80 ? '‚úì Excellent match for your pet' :
                                         displayScore >= 60 ? '‚ö† Good, but could be improved' :
                                         '‚úó Needs adjustments for safety')}
                    </div>
                  </div>
                )}

                {/* Action Buttons */}
                <div className="flex gap-3 mb-6">
              {isSaved ? (
                    <div className="flex items-center gap-2 px-4 py-2 text-sm font-medium text-green-600 bg-green-900/40 border border-green-700/50 rounded-md">
                  <CheckCircle size={16} />
                  Meal Saved
                </div>
              ) : (
                <button
                  onClick={handleSaveMeal}
                  disabled={isSaving || !analysis || !mealName.trim()}
                  className="flex items-center gap-2 px-4 py-2 text-sm font-medium text-white bg-primary-600 rounded-md hover:bg-primary-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  <Save size={16} />
                  {isSaving ? 'Saving...' : 'Save Meal'}
                </button>
              )}
              <button
                onClick={onAddMore}
                    className="flex items-center gap-2 px-4 py-2 text-sm font-medium text-gray-300 bg-surface-highlight border border-surface-highlight rounded-md hover:bg-surface-highlight/80 transition-colors"
              >
                <Plus size={16} />
                Add More Ingredients
              </button>
              <button
                onClick={onStartOver}
                className="flex items-center gap-2 px-4 py-2 text-sm font-medium text-white bg-primary-600 rounded-md hover:bg-primary-700 transition-colors"
              >
                <Plus size={16} />
                Create New Meal
              </button>
            </div>

                {/* Description placeholder */}
                <p className="text-gray-300 mb-8 leading-relaxed text-lg">
                  Custom meal created for {petName}. Adjust ingredient amounts to optimize nutritional balance.
                </p>

                {/* Tags */}
                <div className="flex flex-wrap gap-2 mb-8">
                  <span className="bg-surface-highlight text-gray-300 px-3 py-1 rounded-full text-sm font-medium border border-surface-highlight">
                    custom
                  </span>
                  <span className="bg-surface-highlight text-gray-300 px-3 py-1 rounded-full text-sm font-medium border border-surface-highlight">
                    user-created
                  </span>
          </div>
        </div>
      </div>

            {/* Ingredients & Supplements Tabs */}
            <div className="bg-surface rounded-2xl shadow-lg p-8 mb-8 border border-surface-highlight">
              {/* Tab Navigation */}
              <div className="flex border-b border-surface-highlight mb-6">
                <button
                  onClick={() => setActiveTab('ingredients')}
                  className={`px-6 py-3 font-semibold text-sm border-b-2 transition-colors ${
                    activeTab === 'ingredients'
                      ? 'border-orange-500 text-orange-400'
                      : 'border-transparent text-gray-500 hover:text-gray-300'
                  }`}
                >
                  Ingredients
                </button>
                <button
                  onClick={() => setActiveTab('supplements')}
                  className={`px-6 py-3 font-semibold text-sm border-b-2 transition-colors ${
                    activeTab === 'supplements'
                      ? 'border-orange-500 text-orange-400'
                      : 'border-transparent text-gray-500 hover:text-gray-300'
                  }`}
                >
                  Supplements
                </button>
              </div>

              {/* Tab Content */}
              {activeTab === 'ingredients' && (
                <div className="relative">
                  <div className="space-y-6">
                    {/* Ingredients with ASIN links */}
                    {ingredientsWithASINs.length > 0 && (
                      <ShoppingList
                        ingredients={ingredientsWithASINs}
                        recipeName={mealName || 'Custom Meal'}
                        userId={userId}
                        selectedIngredients={selectedIngredients}
                        totalGrams={totalGrams}
                        recommendedServingGrams={analysis?.recommendedServingGrams}
                      />
                    )}
                    
                    {/* Ingredients without ASIN links */}
                    {ingredientsWithoutASINs.length > 0 && (
                      <div className="bg-surface-lighter rounded-lg border border-surface-highlight p-6">
                        <h3 className="text-lg font-semibold text-foreground mb-4">
                          Additional Ingredients
                        </h3>
                        <div className="space-y-2">
                          {ingredientsWithoutASINs.map((ing, index) => (
                            <div
                              key={ing.id || index}
                              className="flex items-center justify-between p-3 bg-surface rounded-lg border border-surface-highlight"
                            >
                              <div className="flex-1">
                                <div className="font-medium text-gray-200">{ing.name}</div>
                                <div className="text-sm text-gray-400 mt-1">
                                  {ing.amount}
                                  {recommendedAmounts[ing.id] && recommendedAmounts[ing.id] !== parseFloat(ing.amount.replace('g', '')) && (
                                    <span className="text-orange-400 ml-2">
                                      (Recommended: {recommendedAmounts[ing.id]}g)
                                    </span>
                                  )}
                                </div>
                              </div>
                              <button
                                onClick={() => onRemove(ing.id)}
                                className="p-1.5 rounded hover:bg-red-900/30 text-gray-400 hover:text-red-400 transition-colors ml-2"
                                title="Remove ingredient"
                              >
                                <XCircle size={18} />
                              </button>
                            </div>
                          ))}
                        </div>
                      </div>
                    )}

                    {selectedIngredients.length === 0 && (
                      <div className="text-center py-8 text-gray-400 text-sm">
                        No ingredients added yet.
                      </div>
                    )}
                  </div>
                </div>
              )}

              {activeTab === 'supplements' && (
                <div className="relative space-y-6">
                  {/* Recommended Supplements */}
                  {recommendedSupplements.length > 0 && (
                    <div className="bg-orange-900/20 border border-orange-700/50 rounded-lg p-6">
                      <h3 className="text-lg font-semibold text-orange-200 mb-4 flex items-center gap-2">
                        <span>üíä</span>
                        Recommended Supplements
                      </h3>
                      <p className="text-sm text-gray-400 mb-4">
                        These supplements can help address nutritional deficiencies in this meal:
                      </p>
                      <div className="space-y-3">
                        {recommendedSupplements.map((supplement: any, index: number) => (
                          <div key={index} className="bg-surface rounded-lg p-4 border border-surface-highlight">
                            <div className="flex items-start justify-between gap-4">
                              <div className="flex-1">
                                <h5 className="font-semibold text-gray-200">{supplement.productName || supplement.name}</h5>
                                <p className="text-sm text-gray-400 mt-1">{supplement.description}</p>
                                <p className="text-xs text-orange-300 mt-2">
                                  Addresses: {supplement.addressesDeficiency}
                                </p>
                                <p className="text-sm text-gray-300 mt-2">
                                  <strong>Benefits:</strong> {supplement.benefits}
                                </p>
                                <p className="text-sm text-gray-400 mt-1">
                                  <strong>Amount:</strong> {supplement.defaultAmount}
                                </p>
                              </div>
                            </div>
                          </div>
                        ))}
                      </div>
                    </div>
                  )}

                  {recommendedSupplements.length === 0 && (
                    <div className="text-center py-8 text-gray-500">
                      <p>No supplements recommended for this meal.</p>
                      <p className="text-sm mt-2">Check the ingredients tab for all components.</p>
                    </div>
                  )}
                </div>
              )}
            </div>

            {/* Safety Alerts */}
            {analysis && (analysis.toxicityWarnings.length > 0 || analysis.allergyWarnings.length > 0) && (
              <div className="bg-red-900/20 border border-red-700/50 rounded-lg p-6 mb-8">
                <div className="flex items-center gap-2 mb-4">
                  <AlertTriangle size={20} className="text-red-400" />
                  <h2 className="text-lg font-semibold text-red-200">Safety Alerts</h2>
                </div>
                <div className="space-y-3">
                  {analysis.toxicityWarnings.map((warning, idx) => (
                    <div key={idx} className="text-sm text-red-300">
                      <div className="font-medium">‚ö†Ô∏è {warning.ingredientName || warning.ingredientKey}</div>
                      <div className="text-xs mt-1 opacity-90">{warning.message}</div>
                    </div>
                  ))}
                  {analysis.allergyWarnings.map((warning, idx) => (
                    <div key={idx} className="text-sm text-red-300">
                      <div className="font-medium">‚ö†Ô∏è {typeof warning === 'string' ? warning : warning.message}</div>
                    </div>
                  ))}
                </div>
              </div>
            )}

            {/* Recommendations */}
            {analysis && analysis.suggestions.length > 0 && (
              <div className="bg-blue-900/20 border border-blue-700/50 rounded-lg p-6 mb-8">
                <div className="flex items-center gap-2 mb-4">
                  <Info size={20} className="text-blue-400" />
                  <h2 className="text-lg font-semibold text-blue-200">Recommendations</h2>
                </div>
                <div className="space-y-2">
                  {analysis.suggestions.map((suggestion, idx) => (
                    <div key={idx} className="text-sm text-blue-300">
                      üí° {typeof suggestion === 'string' ? suggestion : suggestion.message}
                    </div>
                  ))}
                </div>
              </div>
            )}

            {/* Cost Comparison */}
            {ingredientsWithASINs.length > 0 && mealEstimateForCost && mealEstimateForCost.costPerMeal > 0 && (
              <div className="mb-8">
                <CostComparison 
                  costPerMeal={mealEstimateForCost.costPerMeal}
                  totalCost={mealEstimateForCost.totalCost}
                  estimatedMeals={mealEstimateForCost.estimatedMeals}
                  exceedsBudget={mealEstimateForCost.exceedsBudget || false}
                />
              </div>
            )}
          </main>

          {/* Sidebar */}
          <aside className="lg:col-span-2 space-y-6">
            {/* Health Analysis Panel */}
            {healthAnalysis && (
              <div className="bg-surface rounded-2xl shadow-lg p-6 border-l-4 border-green-500 border border-surface-highlight">
                <h4 className="text-lg font-bold mb-4 flex items-center justify-center text-gray-200">
                  <span className="text-2xl mr-2">üè•</span>
                  Health Analysis
                </h4>
                <div className="mb-4 flex justify-center">
                  <Image
                    src="/images/emojis/Mascots/Proffessor Purfessor/PUrfessorDesk.jpg"
                    alt="Professor Purfessor"
                    width={280}
                    height={210}
                    className="rounded-lg object-contain"
                    unoptimized
                  />
                </div>
                <p className="text-xs text-gray-400 mb-4">
                  Proffessor Purfessor has found these individual factors that contribute to the overall compatibility score
                </p>
                <div className="space-y-3">
                  {Object.entries(healthAnalysis.breakdown).map(([key, factor]) => {
                    const f = factor as { score: number; weightedContribution?: number; weight: number; reason?: string; recommendations?: any[] };
                    const score = f.score || 0;
                    const weightedContribution = f.weightedContribution ?? Math.round(score * (f.weight || 0));
                    const weight = f.weight || 0;

                    let bgColor = 'bg-green-900/20 border-green-700/50';
                    let icon = '‚úÖ';
                    let textColor = 'text-green-200';

                    if (score < 70) {
                      bgColor = 'bg-yellow-900/20 border-yellow-700/50';
                      icon = '‚ö†Ô∏è';
                      textColor = 'text-yellow-200';
                    }
                    if (score < 40) {
                      bgColor = 'bg-red-900/20 border-red-700/50';
                      icon = '‚ùå';
                      textColor = 'text-red-200';
                    }

                    const factorName = key.replace(/([A-Z])/g, ' $1').toLowerCase();
                    const formattedFactorName = factorName.charAt(0).toUpperCase() + factorName.slice(1);
                    
                    let tooltipContent = `üìä ${formattedFactorName}\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\nRaw Score: ${score}%\nWeight: ${(weight * 100).toFixed(0)}%\nContribution: ${weightedContribution} points\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n${f.reason ? `üí° ${f.reason}` : 'No additional details available'}`;
                    
                    if (key === 'nutritionalFit' && f.recommendations && f.recommendations.length > 0) {
                      tooltipContent += '\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\nüíä Recommendations:\n';
                      const supplements = f.recommendations.filter((r: any) => !r.isIngredient);
                      const ingredients = f.recommendations.filter((r: any) => r.isIngredient);
                      
                      if (supplements.length > 0) {
                        tooltipContent += `\nCheck Supplements tab for: ${supplements.map((r: any) => r.productName || r.name).join(', ')}`;
                      }
                      if (ingredients.length > 0) {
                        tooltipContent += `\nCheck Ingredients tab for: ${ingredients.map((r: any) => r.name).join(', ')}`;
                      }
                    }

                    return (
                      <Tooltip key={key} content={tooltipContent} wide={key === 'nutritionalFit'}>
                        <div className={`flex items-center justify-between p-3 ${bgColor} rounded-lg border cursor-help hover:opacity-80 transition-colors`}>
                          <div className="flex items-center gap-2">
                            <span className="text-sm">{icon}</span>
                            <span className={`text-sm font-medium capitalize ${textColor}`}>
                              {factorName}
                            </span>
                          </div>
                          <div className="flex flex-col items-end">
                            <span className={`text-sm font-bold ${textColor}`}>
                              {score}%
                            </span>
                            <span className="text-xs text-gray-400">
                              +{weightedContribution} pts
                            </span>
                          </div>
                        </div>
                      </Tooltip>
                    );
                  })}
                </div>

                {/* Compatibility Score Summary */}
                <div className="mt-4 pt-4 border-t border-surface-highlight">
                  <div className="flex items-center justify-between">
                    <span className="text-sm text-gray-300">Compatibility Score:</span>
                    <span className={`text-lg font-bold ${
                      healthAnalysis.overallScore >= 80 ? 'text-green-400' :
                      healthAnalysis.overallScore >= 60 ? 'text-yellow-400' :
                      'text-red-400'
                    }`}>
                      {healthAnalysis.overallScore}%
                    </span>
                  </div>
                  <p className="text-xs text-gray-400 mt-2">
                    {healthAnalysis.overallScore >= 80 ? 'Excellent nutritional balance for your pet!' :
                     healthAnalysis.overallScore >= 60 ? 'Good balance with some areas for improvement.' :
                     'Needs nutritional adjustments for optimal health.'}
                  </p>
                </div>
              </div>
            )}

            {/* Nutritional Summary */}
            {analysis && (
              <div className="bg-surface rounded-lg border border-surface-highlight p-6">
                <h3 className="text-sm font-semibold text-gray-200 mb-3">Nutritional Summary</h3>
                <div className="space-y-2 text-sm">
                  <div className="flex justify-between">
                    <span className="text-gray-400">Total Weight:</span>
                    <span className="font-medium text-gray-200">{totalGrams}g</span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-gray-400">Calories:</span>
                    <span className="font-medium text-gray-200">
                      {((analysis.nutrients as any).kcal ?? (analysis.nutrients as any).calories_kcal ?? (analysis.nutrients as any).energy_kcal ?? 0).toFixed(0)} kcal
                    </span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-gray-400">Protein:</span>
                    <span className="font-medium text-gray-200">
                      {((analysis.nutrients as any).protein_g ?? 0).toFixed(1)}g
                    </span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-gray-400">Fat:</span>
                    <span className="font-medium text-gray-200">
                      {((analysis.nutrients as any).fat_g ?? 0).toFixed(1)}g
                    </span>
                  </div>
                  {analysis.caToPratio && (
                    <div className="flex justify-between">
                      <span className="text-gray-400">Ca:P Ratio:</span>
                      <span className="font-medium text-gray-200">{analysis.caToPratio.toFixed(2)}</span>
                    </div>
                  )}
                  {analysis.recommendedServingGrams > 0 && (
                    <div className="flex justify-between pt-2 border-t border-surface-highlight">
                      <span className="text-gray-300 font-medium">Recommended Serving:</span>
                      <span className="font-semibold text-orange-400">{analysis.recommendedServingGrams}g</span>
                    </div>
                  )}
                </div>
              </div>
            )}
          </aside>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="components/MealCompositionList.tsx">
'use client';

import { X, ExternalLink } from 'lucide-react';
import { IngredientSelection } from '@/lib/analyzeCustomMeal';
import { ensureSellerId } from '@/lib/utils/affiliateLinks';
import { getProductPriceAmount, getProductPriceUrl } from '@/lib/data/product-prices';

// Format price for display
const formatPrice = (price: number) => {
  return `$${price.toFixed(2)}`;
};

interface MealCompositionListProps {
  ingredients: IngredientSelection[];
  onRemove: (key: string) => void;
  getIngredientDisplayName: (key: string) => string;
  getCompatibilityIndicator?: (key: string) => 'safe' | 'warning' | 'blocked' | null;
  recommendedAmounts?: { [key: string]: number }; // Recommended grams per ingredient
}

export default function MealCompositionList({
  ingredients,
  onRemove,
  getIngredientDisplayName,
  getCompatibilityIndicator,
  recommendedAmounts = {}
}: MealCompositionListProps) {
  return (
    <div className="space-y-4">
      <div className="space-y-2">
        {ingredients.length === 0 ? (
          <div className="text-center py-8 text-gray-400 text-sm">
            No ingredients added yet. Search and select ingredients above.
          </div>
        ) : (
          ingredients.map(ing => {
            const displayName = getIngredientDisplayName(ing.key);
            const indicator = getCompatibilityIndicator?.(ing.key) || null;
            const purchaseLink = getProductPriceUrl(displayName);
            const hasPurchaseLink = !!purchaseLink;
            const price = getProductPriceAmount(displayName);
            
            return (
              <div
                key={ing.key}
                className="flex items-center justify-between gap-3 p-3 bg-surface-lighter rounded-lg border border-surface-highlight hover:border-gray-500 transition-all duration-200"
              >
                <div className="flex items-center gap-3 flex-1 min-w-0">
                  {/* Compatibility Indicator */}
                  {indicator && (
                    <div className={`w-2 h-2 rounded-full flex-shrink-0 ${
                      indicator === 'safe' ? 'bg-green-500' :
                      indicator === 'warning' ? 'bg-yellow-500' :
                      'bg-red-500'
                    }`} />
                  )}

                  {/* Ingredient Name */}
                  <div className="flex-1 min-w-0 pr-2">
                    <div className="font-medium text-gray-200 truncate">
                      {displayName}
                    </div>
                    <div className="flex items-center gap-3 mt-1 text-xs text-gray-400">
                      <span>Current: {ing.grams}g</span>
                      {recommendedAmounts[ing.key] && recommendedAmounts[ing.key] !== ing.grams && (
                        <span className="text-orange-400 font-medium">
                          Recommended: {recommendedAmounts[ing.key]}g
                        </span>
                      )}
                    </div>
                  </div>
                </div>

                {/* Price Display */}
                {price && (
                  <div className="text-right mr-3">
                    <div className="text-lg font-bold text-orange-400">{formatPrice(price)}</div>
                  </div>
                )}

                {/* Action Buttons */}
                <div className="flex items-center gap-2 flex-shrink-0">
                  {/* Buy Button */}
                  {hasPurchaseLink && (
                    <a
                      href={ensureSellerId(purchaseLink)}
                      target="_blank"
                      rel="noopener noreferrer"
                      className="flex items-center gap-2 px-4 py-2 bg-[#FF9900] hover:bg-[#E07704] text-black rounded-lg transition-all duration-200 text-sm font-semibold whitespace-nowrap hover:shadow-md"
                    >
                      Buy
                      <ExternalLink size={14} />
                    </a>
                  )}

                  {/* Delete Button */}
                  <button
                    onClick={() => onRemove(ing.key)}
                    className="p-1.5 rounded hover:bg-red-900/30 text-gray-400 hover:text-red-400 transition-colors"
                    title="Remove ingredient"
                  >
                    <X size={18} />
                  </button>
                </div>
              </div>
            );
          })
        )}
      </div>
    </div>
  );
}
</file>

<file path="components/MultiPetShoppingModal.tsx">
'use client';

import React, { useState, useMemo } from 'react';
import { X, ShoppingCart, Check } from 'lucide-react';
import { Pet } from '@/lib/types';
import { addPurchase } from '@/lib/utils/purchaseTracking';
import { useVillageStore } from '@/lib/state/villageStore';
import { ensureSellerId } from '@/lib/utils/affiliateLinks';
import { getProductPrice } from '@/lib/data/product-prices';

// Format price for display
const formatPrice = (price: number) => {
  return `$${price.toFixed(2)}`;
};

interface MultiPetShoppingModalProps {
  isOpen: boolean;
  onClose: () => void;
  pets: Pet[];
  userId: string;
}

export default function MultiPetShoppingModal({
  isOpen,
  onClose,
  pets,
  userId
}: MultiPetShoppingModalProps) {
  const [selectedPets, setSelectedPets] = useState<Set<string>>(new Set(pets.map(p => p.id)));
  const [isOpening, setIsOpening] = useState(false);
  const { refreshFromLocal } = useVillageStore();

  const togglePet = (petId: string) => {
    const newSelected = new Set(selectedPets);
    if (newSelected.has(petId)) {
      newSelected.delete(petId);
    } else {
      newSelected.add(petId);
    }
    setSelectedPets(newSelected);
  };

  // Aggregate all ingredients from all selected pets' saved meals
  const allIngredients = useMemo(() => {
    const ingredientMap = new Map<string, {
      name: string;
      asinLink: string;
      count: number;
      petNames: string[];
    }>();

    pets.forEach(pet => {
      if (!selectedPets.has(pet.id)) return;
      
      const petName = pet.names?.[0] || 'Pet';
      const savedRecipes = pet.savedRecipes || [];
      
      savedRecipes.forEach(recipeId => {
        const recipe = recipes.find(r => r.id === recipeId);
        if (!recipe) return;
        
        recipe.ingredients?.forEach(ing => {
          const link = (ing as any).asinLink || ing.amazonLink;
          if (!link) return;
          
          const key = `${ing.name}-${link}`;
          const existing = ingredientMap.get(key);
          
          if (existing) {
            existing.count++;
            if (!existing.petNames.includes(petName)) {
              existing.petNames.push(petName);
            }
          } else {
            ingredientMap.set(key, {
              name: ing.name,
              asinLink: link,
              count: 1,
              petNames: [petName]
            });
          }
        });
      });
    });

    return Array.from(ingredientMap.values());
  }, [pets, selectedPets]);

  const totalItems = allIngredients.length;
  const selectedPetCount = selectedPets.size;

  // Calculate total price
  const totalPrice = useMemo(() => {
    return allIngredients.reduce((sum, ing) => {
      const price = getProductPrice(ing.name);
      if (typeof price === 'number') return sum + price;
      return sum;
    }, 0);
  }, [allIngredients]);

  const handleBuyAll = async () => {
    setIsOpening(true);

    // Open first tab
    if (allIngredients.length > 0) {
      window.open(ensureSellerId(allIngredients[0].asinLink), '_blank');
      if (userId) {
        addPurchase(userId, allIngredients[0].name, false, allIngredients[0].name);
      }
    }

    // Open remaining tabs
    for (let i = 1; i < allIngredients.length; i++) {
      await new Promise(resolve => setTimeout(resolve, 800));
      window.open(ensureSellerId(allIngredients[i].asinLink), '_blank');
      if (userId) {
        addPurchase(userId, allIngredients[i].name, false, allIngredients[i].name);
      }
    }

    refreshFromLocal();

    setTimeout(() => {
      setIsOpening(false);
      onClose();
    }, 1000);
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 z-50 bg-black/70 backdrop-blur-sm flex items-center justify-center p-4">
      <div className="bg-surface border-2 border-orange-500/50 rounded-2xl shadow-2xl w-full max-w-3xl max-h-[85vh] overflow-hidden">
        {/* Header */}
        <div className="bg-gradient-to-r from-[#043136] to-[#0f2c0f] px-6 py-5 border-b-2 border-orange-500/30 flex items-center justify-between">
          <div>
            <h2 className="text-2xl font-bold text-white flex items-center gap-2">
              <ShoppingCart className="text-orange-400" size={28} />
              Shop for All Your Pets
            </h2>
            <p className="text-gray-300 text-sm mt-1">
              Bundle ingredients and save time
            </p>
          </div>
          <button
            onClick={onClose}
            className="text-gray-400 hover:text-white transition-colors p-2"
          >
            <X size={28} />
          </button>
        </div>

        {/* Content */}
        <div className="p-6 overflow-y-auto max-h-[calc(85vh-200px)]">
          {/* Pet Selection */}
          <div className="mb-6">
            <h3 className="text-lg font-semibold text-white mb-3">
              Select pets to shop for:
            </h3>
            <div className="grid grid-cols-2 md:grid-cols-3 gap-3">
              {pets.map(pet => {
                const petName = pet.names?.[0] || 'Pet';
                const isSelected = selectedPets.has(pet.id);
                
                return (
                  <button
                    key={pet.id}
                    onClick={() => togglePet(pet.id)}
                    className={`p-4 rounded-xl border-2 transition-all ${
                      isSelected
                        ? 'bg-orange-500/20 border-orange-500 text-white'
                        : 'bg-surface-highlight border-surface-highlight text-gray-400 hover:border-gray-500'
                    }`}
                  >
                    <div className="flex items-center gap-2">
                      <div className={`w-6 h-6 rounded border-2 flex items-center justify-center ${
                        isSelected ? 'bg-orange-500 border-orange-400' : 'bg-transparent border-gray-500'
                      }`}>
                        {isSelected && <Check size={16} className="text-white" />}
                      </div>
                      <div className="text-left">
                        <div className="font-semibold">{petName}</div>
                        <div className="text-xs capitalize">{pet.type}</div>
                      </div>
                    </div>
                  </button>
                );
              })}
            </div>
          </div>

          {/* Summary */}
          {selectedPetCount > 0 && (
            <div className="bg-green-900/20 border border-green-700/30 rounded-xl p-5 mb-6">
              <div className="grid grid-cols-3 gap-4 text-center">
                <div>
                  <div className="text-3xl font-bold text-orange-400">{selectedPetCount}</div>
                  <div className="text-xs text-gray-400 mt-1">Pets Selected</div>
                </div>
                <div>
                  <div className="text-3xl font-bold text-green-400">{totalItems}</div>
                  <div className="text-xs text-gray-400 mt-1">Ingredients</div>
                </div>
                <div>
                  <div className="text-3xl font-bold text-blue-400">
                    {Math.max(...allIngredients.map(i => i.count))}x
                  </div>
                  <div className="text-xs text-gray-400 mt-1">Max Uses</div>
                </div>
              </div>
            </div>
          )}

          {/* Ingredient Preview */}
          {totalItems > 0 && (
            <div className="mb-6">
              <h3 className="text-sm font-semibold text-gray-400 mb-3">
                Combined Shopping List:
              </h3>
              <div className="max-h-60 overflow-y-auto space-y-2">
                {allIngredients.slice(0, 10).map((ing, idx) => (
                  <div
                    key={idx}
                    className="flex items-center justify-between p-2 bg-surface-highlight rounded-lg text-sm"
                  >
                    <span className="text-gray-300">{ing.name}</span>
                    <span className="text-orange-400 font-semibold">
                      Used in {ing.count} meal{ing.count > 1 ? 's' : ''}
                    </span>
                  </div>
                ))}
                {totalItems > 10 && (
                  <p className="text-xs text-gray-500 text-center py-2">
                    + {totalItems - 10} more ingredients
                  </p>
                )}
              </div>
            </div>
          )}

          {/* Big CTA Button */}
          <button
            onClick={handleBuyAll}
            disabled={isOpening || selectedPetCount === 0}
            className={`w-full py-6 px-8 rounded-xl font-black text-2xl transition-all transform ${
              isOpening || selectedPetCount === 0
                ? 'bg-gray-600 cursor-not-allowed text-gray-400 scale-95'
                : 'bg-gradient-to-r from-[#FF9900] via-[#F08804] to-[#FF9900] hover:from-[#E07704] hover:via-[#D07604] hover:to-[#E07704] text-black shadow-2xl hover:shadow-orange-500/50 hover:scale-105 border-4 border-orange-300 animate-pulse'
            }`}
          >
            {isOpening ? (
              <span className="flex items-center justify-center gap-3">
                <div className="animate-spin rounded-full h-7 w-7 border-b-4 border-white"></div>
                OPENING TABS...
              </span>
            ) : (
              <span className="flex flex-col items-center justify-center gap-1">
                <span className="flex items-center gap-3">
                  <ShoppingCart size={32} />
                  BUY ALL FOR {selectedPetCount} PET{selectedPetCount > 1 ? 'S' : ''}!
                </span>
                {totalPrice > 0 && (
                  <span className="text-2xl font-bold">
                    Total: {formatPrice(totalPrice)}
                  </span>
                )}
              </span>
            )}
          </button>

          {selectedPetCount === 0 && (
            <p className="text-center text-gray-500 text-sm mt-3">
              Select at least one pet to continue
            </p>
          )}
        </div>

        {/* Trust Footer */}
        <div className="bg-surface-lighter px-6 py-4 border-t border-surface-highlight">
          <p className="text-xs text-gray-400 text-center leading-relaxed">
            <span className="font-semibold text-green-400">üåü Smart Shopping:</span> We've combined all ingredients across your pets' meal plans, 
            so you buy each item once. Your price stays the same, and you support free pet nutrition resources!
          </p>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="components/Navigation.tsx">
'use client';

import Link from 'next/link';
import Image from 'next/image';
import { Menu, X } from 'lucide-react';
import { useState } from 'react';
import { useUser, UserButton } from '@clerk/nextjs';

export default function Navigation() {
  const [isOpen, setIsOpen] = useState(false);
  const { isSignedIn, isLoaded } = useUser();

  return (
    <nav className="bg-surface border-b border-surface-highlight sticky top-0 z-50">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="flex justify-between items-center h-16">
          <Link href="/" className="flex items-center space-x-2">
            <div className="h-10 w-10 relative">
              <Image
                src="/images/emojis/GREENPAW.jpeg"
                alt="Paw & Plate logo"
                fill
                className="object-contain rounded-md"
                sizes="40px"
                priority
              />
            </div>
            <div className="flex flex-col">
              <span className="text-2xl font-bold text-foreground">Paw & Plate</span>
              <span className="text-xs text-gray-400 -mt-1 leading-tight">Meal prep made easy, for ALL your pets!</span>
            </div>
          </Link>

          <div className="hidden md:flex items-center space-x-8">
            <Link href="/about" className="text-gray-300 hover:text-orange-400 transition-colors">
              About
            </Link>
            <Link href="/blog" className="text-gray-300 hover:text-orange-400 transition-colors">
              Blog
            </Link>
            <Link href="/forum" className="text-gray-300 hover:text-orange-400 transition-colors">
              Community
            </Link>
            
            {isLoaded && (
              <>
                {!isSignedIn ? (
                  <Link
                    href="/sign-in"
                    className="btn btn-primary btn-md btn-ripple"
                  >
                    Sign In
                  </Link>
                ) : (
                  <>
                    <Link href="/profile" className="text-gray-300 hover:text-orange-400 transition-colors">
                      My Pets
                    </Link>
                    <UserButton afterSignOutUrl="/" />
                  </>
                )}
              </>
            )}
          </div>

          <div className="md:hidden">
            <button
              onClick={() => setIsOpen(!isOpen)}
              className="btn btn-ghost btn-icon"
            >
              {isOpen ? <X className="h-6 w-6" /> : <Menu className="h-6 w-6" />}
            </button>
          </div>
        </div>

        {isOpen && (
          <div className="md:hidden pb-4">
            <div className="flex flex-col space-y-4">
              <Link href="/about" className="text-gray-300 hover:text-orange-400">
                About
              </Link>
              <Link href="/blog" className="text-gray-300 hover:text-orange-400">
                Blog
              </Link>
              <Link href="/forum" className="text-gray-300 hover:text-orange-400">
                Community
              </Link>
              
              {isLoaded && (
                <>
                  {!isSignedIn ? (
                    <Link
                      href="/sign-in"
                      className="btn btn-primary btn-md btn-ripple"
                    >
                      Sign In
                    </Link>
                  ) : (
                    <>
                      <Link href="/profile" className="text-gray-300 hover:text-orange-400">
                        My Pets
                      </Link>
                      <UserButton afterSignOutUrl="/" />
                    </>
                  )}
                </>
              )}
            </div>
          </div>
        )}
      </div>
    </nav>
  );
}
</file>

<file path="components/NutritionDashboard.tsx">
'use client';

import React from 'react';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, BarChart, Bar } from 'recharts';
import { Activity, Target, TrendingUp } from 'lucide-react';
import { DailyNutrition, NutritionTargets } from '@/lib/nutrition/nutritionHistory';

interface NutritionDashboardProps {
  daily: DailyNutrition[];
  targets: NutritionTargets;
  petName: string;
}

export function NutritionDashboard({ daily, targets, petName }: NutritionDashboardProps) {
  const summary = {
    avgCalories: daily.reduce((sum, d) => sum + d.calories, 0) / daily.length || 0,
    avgProtein: daily.reduce((sum, d) => sum + d.protein, 0) / daily.length || 0,
    avgFat: daily.reduce((sum, d) => sum + d.fat, 0) / daily.length || 0,
    avgCarbs: daily.reduce((sum, d) => sum + d.carbs, 0) / daily.length || 0,
    avgFiber: daily.reduce((sum, d) => sum + (d.fiber || 0), 0) / daily.length || 0,
  };

  const getStatusColor = (value: number, range?: [number, number]) => {
    if (!range) return 'text-gray-500';
    if (value >= range[0] && value <= range[1]) return 'text-green-600';
    return 'text-amber-600';
  };

  const getStatusText = (value: number, range?: [number, number]) => {
    if (!range) return 'No target';
    if (value >= range[0] && value <= range[1]) return 'On target';
    return 'Outside range';
  };

  return (
    <div className="space-y-6">
      <div className="text-center">
        <h1 className="text-3xl font-bold text-gray-900 mb-2">Nutrition Dashboard</h1>
        <p className="text-lg text-gray-600">Weekly nutrition overview for {petName}</p>
      </div>

      {/* Summary Cards */}
      <div className="grid grid-cols-2 md:grid-cols-5 gap-4">
        <div className="bg-white p-4 rounded-lg shadow border">
          <div className="flex items-center justify-between">
            <div>
              <p className="text-sm text-gray-600">Avg Calories</p>
              <p className="text-2xl font-bold">{Math.round(summary.avgCalories)}</p>
            </div>
            <Activity className="w-8 h-8 text-orange-500" />
          </div>
        </div>

        <div className="bg-white p-4 rounded-lg shadow border">
          <div className="flex items-center justify-between">
            <div>
              <p className="text-sm text-gray-600">Avg Protein (g)</p>
              <p className={`text-2xl font-bold ${getStatusColor(summary.avgProtein, targets.proteinRange)}`}>
                {summary.avgProtein.toFixed(1)}
              </p>
              <p className="text-xs text-gray-500">{getStatusText(summary.avgProtein, targets.proteinRange)}</p>
            </div>
            <Target className="w-8 h-8 text-blue-500" />
          </div>
        </div>

        <div className="bg-white p-4 rounded-lg shadow border">
          <div className="flex items-center justify-between">
            <div>
              <p className="text-sm text-gray-600">Avg Fat (g)</p>
              <p className={`text-2xl font-bold ${getStatusColor(summary.avgFat, targets.fatRange)}`}>
                {summary.avgFat.toFixed(1)}
              </p>
              <p className="text-xs text-gray-500">{getStatusText(summary.avgFat, targets.fatRange)}</p>
            </div>
            <Target className="w-8 h-8 text-red-500" />
          </div>
        </div>

        <div className="bg-white p-4 rounded-lg shadow border">
          <div className="flex items-center justify-between">
            <div>
              <p className="text-sm text-gray-600">Avg Carbs (g)</p>
              <p className={`text-2xl font-bold ${getStatusColor(summary.avgCarbs, targets.carbsRange)}`}>
                {summary.avgCarbs.toFixed(1)}
              </p>
              <p className="text-xs text-gray-500">{getStatusText(summary.avgCarbs, targets.carbsRange)}</p>
            </div>
            <TrendingUp className="w-8 h-8 text-green-500" />
          </div>
        </div>

        <div className="bg-white p-4 rounded-lg shadow border">
          <div className="flex items-center justify-between">
            <div>
              <p className="text-sm text-gray-600">Avg Fiber (g)</p>
              <p className={`text-2xl font-bold ${getStatusColor(summary.avgFiber, targets.fiberRange)}`}>
                {summary.avgFiber.toFixed(1)}
              </p>
              <p className="text-xs text-gray-500">{getStatusText(summary.avgFiber, targets.fiberRange)}</p>
            </div>
            <Target className="w-8 h-8 text-orange-500" />
          </div>
        </div>
      </div>

      {/* Charts */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        {/* Calories Chart */}
        <div className="bg-white p-6 rounded-lg shadow border">
          <h3 className="text-lg font-semibold mb-4">Daily Calories</h3>
          <ResponsiveContainer width="100%" height={300}>
            <LineChart data={daily}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="day" />
              <YAxis />
              <Tooltip />
              <Line type="monotone" dataKey="calories" stroke="#f97316" strokeWidth={2} />
            </LineChart>
          </ResponsiveContainer>
        </div>

        {/* Protein Chart */}
        <div className="bg-white p-6 rounded-lg shadow border">
          <h3 className="text-lg font-semibold mb-4">Daily Protein</h3>
          <ResponsiveContainer width="100%" height={300}>
            <BarChart data={daily}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="day" />
              <YAxis />
              <Tooltip />
              <Bar dataKey="protein" fill="#3b82f6" />
            </BarChart>
          </ResponsiveContainer>
        </div>

        {/* Fat Chart */}
        <div className="bg-white p-6 rounded-lg shadow border">
          <h3 className="text-lg font-semibold mb-4">Daily Fat</h3>
          <ResponsiveContainer width="100%" height={300}>
            <BarChart data={daily}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="day" />
              <YAxis />
              <Tooltip />
              <Bar dataKey="fat" fill="#ef4444" />
            </BarChart>
          </ResponsiveContainer>
        </div>

        {/* Carbs & Fiber Chart */}
        <div className="bg-white p-6 rounded-lg shadow border">
          <h3 className="text-lg font-semibold mb-4">Daily Carbs & Fiber</h3>
          <ResponsiveContainer width="100%" height={300}>
            <LineChart data={daily}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="day" />
              <YAxis />
              <Tooltip />
              <Line type="monotone" dataKey="carbs" stroke="#10b981" strokeWidth={2} />
              <Line type="monotone" dataKey="fiber" stroke="#8b5cf6" strokeWidth={2} />
            </LineChart>
          </ResponsiveContainer>
        </div>
      </div>

      {/* Target Ranges Info */}
      <div className="bg-blue-50 p-6 rounded-lg border border-blue-200">
        <h3 className="text-lg font-semibold text-blue-900 mb-3">Target Ranges</h3>
        <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
          <div>
            <p className="font-medium">Protein:</p>
            <p className="text-blue-700">
              {targets.proteinRange ? `${targets.proteinRange[0]}-${targets.proteinRange[1]}g` : 'No target'}
            </p>
          </div>
          <div>
            <p className="font-medium">Fat:</p>
            <p className="text-blue-700">
              {targets.fatRange ? `${targets.fatRange[0]}-${targets.fatRange[1]}g` : 'No target'}
            </p>
          </div>
          <div>
            <p className="font-medium">Carbs:</p>
            <p className="text-blue-700">
              {targets.carbsRange ? `${targets.carbsRange[0]}-${targets.carbsRange[1]}g` : 'No target'}
            </p>
          </div>
          <div>
            <p className="font-medium">Fiber:</p>
            <p className="text-blue-700">
              {targets.fiberRange ? `${targets.fiberRange[0]}-${targets.fiberRange[1]}g` : 'No target'}
            </p>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="components/OfflineBanner.tsx">
// components/OfflineBanner.tsx
// Banner to show when app is offline

'use client';

import React from 'react';
import { WifiOff } from 'lucide-react';
import { useOfflineDetector } from '@/hooks/useOfflineDetector';

export function OfflineBanner() {
  const { isOffline } = useOfflineDetector();

  if (!isOffline) return null;

  return (
    <div className="fixed top-0 left-0 right-0 z-50 bg-amber-500 text-white px-4 py-2 shadow-lg">
      <div className="max-w-7xl mx-auto flex items-center justify-center gap-2">
        <WifiOff size={18} />
        <span className="text-sm font-medium">
          You're offline. Changes will sync when you reconnect.
        </span>
      </div>
    </div>
  );
}

export default OfflineBanner;
</file>

<file path="components/OneClickCheckoutModal.tsx">
'use client';

import { useState, useEffect, useMemo } from 'react';
import { X, ShoppingCart, Check, Loader2 } from 'lucide-react';
import { addPurchase } from '@/lib/utils/purchaseTracking';
import { useVillageStore } from '@/lib/state/villageStore';
import { ensureSellerId } from '@/lib/utils/affiliateLinks';
import { getProductPrice } from '@/lib/data/product-prices';
import { calculateMealsFromShoppingList } from '@/lib/utils/mealCalculator';

// Format price for display
const formatPrice = (price: number) => {
  return `$${price.toFixed(2)}`;
};

interface CheckoutItem {
  id: string;
  name: string;
  asinLink: string;
  amount?: string;
  asin?: string;
}

interface OneClickCheckoutModalProps {
  isOpen: boolean;
  onClose: () => void;
  items: CheckoutItem[];
  recipeName?: string;
  userId?: string; // Optional userId for purchase tracking
  // Optional props for meal calculation
  selectedIngredients?: Array<{ key: string; grams: number }>;
  totalGrams?: number;
  recommendedServingGrams?: number;
}

export default function OneClickCheckoutModal({
  isOpen,
  onClose,
  items,
  recipeName = 'Recipe',
  userId,
  selectedIngredients,
  totalGrams,
  recommendedServingGrams
}: OneClickCheckoutModalProps) {
  // Get userId from localStorage if not provided
  const getUserId = () => {
    if (userId) return userId;
    if (typeof window === 'undefined') return '';
    return localStorage.getItem('last_user_id') || '';
  };
  const { refreshFromLocal } = useVillageStore();
  const [currentStep, setCurrentStep] = useState(0);
  const [addedItems, setAddedItems] = useState<Set<number>>(new Set());
  const [isAdding, setIsAdding] = useState(false);
  const [mode, setMode] = useState<'manual' | 'auto' | null>(null);

  // Reset when modal opens
  useEffect(() => {
    if (isOpen) {
      setCurrentStep(0);
      setAddedItems(new Set());
      setIsAdding(false);
      setMode(null);
    }
  }, [isOpen]);

  // Helper to extract ASIN from URL
  const extractASIN = (url: string): string | undefined => {
    // Try /dp/ASIN pattern
    const dpMatch = url.match(/\/dp\/([A-Z0-9]{10})/);
    if (dpMatch) return dpMatch[1];
    
    // Try /gp/product/ASIN pattern
    const gpMatch = url.match(/\/gp\/product\/([A-Z0-9]{10})/);
    if (gpMatch) return gpMatch[1];
    
    // Try ASIN parameter
    const asinParam = new URL(url).searchParams.get('ASIN');
    if (asinParam) return asinParam;
    
    return undefined;
  };

  // Add item via hidden iframe (most reliable method)
  const addItemViaIframe = async (item: CheckoutItem, index: number): Promise<boolean> => {
    return new Promise((resolve) => {
      const currentUserId = getUserId();
      
      // Track purchase when item is added (pending confirmation)
      if (currentUserId) {
        addPurchase(currentUserId, item.id || item.name, false, item.name);
        refreshFromLocal(); // Update village store
      }
      
      // Extract ASIN from URL if available
      let asin = item.asin;
      if (!asin && item.asinLink) {
        asin = extractASIN(item.asinLink);
      }

      if (asin) {
        // Use Amazon's add-to-cart API
        const iframe = document.createElement('iframe');
        iframe.style.cssText = 'position:fixed;top:-10000px;left:-10000px;width:1px;height:1px;opacity:0;pointer-events:none;';
        iframe.src = `https://www.amazon.com/gp/aws/cart/add.html?ASIN.1=${asin}&Quantity.1=1&tag=robinfrench-20`;
        
        iframe.onload = () => {
          setTimeout(() => {
            try {
              document.body.removeChild(iframe);
            } catch (e) {
              // Iframe might already be removed
            }
            resolve(true);
          }, 1500);
        };
        
        iframe.onerror = () => {
          try {
            document.body.removeChild(iframe);
          } catch (e) {}
          resolve(false);
        };
        
        document.body.appendChild(iframe);
      } else {
        // Fallback: open in new tab (ensure seller ID)
        window.open(ensureSellerId(item.asinLink), '_blank');
        resolve(true);
      }
    });
  };

  // Add next item manually
  const addNextItem = async () => {
    if (currentStep >= items.length || isAdding) return;
    
    setIsAdding(true);
    const item = items[currentStep];
    
    const success = await addItemViaIframe(item, currentStep);
    
    if (success) {
      setAddedItems(new Set([...addedItems, currentStep]));
      setCurrentStep(currentStep + 1);
    }
    
    setIsAdding(false);
  };

  // Add all items automatically
  const addAllAutomatically = async () => {
    if (isAdding) return;
    
    setMode('auto');
    setIsAdding(true);
    
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      setCurrentStep(i);
      
      await addItemViaIframe(item, i);
      setAddedItems(new Set([...addedItems, i]));
      
      // Wait between items to avoid rate limiting
      if (i < items.length - 1) {
        await new Promise(resolve => setTimeout(resolve, 2000));
      }
    }
    
    setIsAdding(false);
    setCurrentStep(items.length);
  };

  // Open all in new tabs (manual method)
  const openAllInTabs = () => {
    setMode('manual');
    const currentUserId = getUserId();
    items.forEach((item, index) => {
      setTimeout(() => {
        window.open(ensureSellerId(item.asinLink), '_blank');
        // Track purchase when item is opened
        if (currentUserId) {
          addPurchase(currentUserId, item.id || item.name, false, item.name);
        }
        setAddedItems(new Set([...addedItems, index]));
      }, index * 500); // Stagger opens
    });
    if (currentUserId) {
      refreshFromLocal(); // Update village store after all items
    }
    setCurrentStep(items.length);
  };

  if (!isOpen) return null;

  // Safety check for empty items
  if (items.length === 0) {
    return (
      <div className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 p-4 backdrop-blur-sm">
        <div className="bg-surface rounded-2xl shadow-2xl border border-surface-highlight max-w-md w-full p-6">
          <div className="flex items-center justify-between mb-4">
            <h2 className="text-xl font-bold text-foreground">No Items Available</h2>
            <button
              onClick={onClose}
              className="text-gray-400 hover:text-gray-200 transition-colors"
            >
              <X size={24} />
            </button>
          </div>
          <p className="text-gray-400 mb-4">This recipe doesn't have any ingredients with purchase links.</p>
          <button
            onClick={onClose}
            className="w-full bg-primary-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-primary-700 transition-colors"
          >
            Close
          </button>
        </div>
      </div>
    );
  }

  // Calculate total price
  const totalPrice = useMemo(() => {
    return items.reduce((sum, item) => {
      const price = getProductPrice(item.name);
      if (typeof price === 'number') return sum + price;
      return sum;
    }, 0);
  }, [items]);

  // Calculate how many meals this shopping list will provide
  const mealsCount = useMemo(() => {
    if (selectedIngredients && totalGrams && recommendedServingGrams) {
      return calculateMealsFromShoppingList(
        items.map(item => ({ id: item.id, name: item.name, amount: item.amount || '' })),
        selectedIngredients,
        totalGrams,
        recommendedServingGrams
      );
    }
    return null;
  }, [items, selectedIngredients, totalGrams, recommendedServingGrams]);

  const progress = (currentStep / items.length) * 100;
  const allAdded = currentStep >= items.length;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 p-4 backdrop-blur-sm">
      <div className="bg-surface rounded-2xl shadow-2xl border border-surface-highlight max-w-2xl w-full max-h-[90vh] overflow-y-auto">
        {/* Header */}
        <div className="sticky top-0 bg-surface border-b border-surface-highlight p-6 flex items-center justify-between">
          <div>
            <h2 className="text-2xl font-bold text-foreground">One-Click Shopping</h2>
            <p className="text-sm text-gray-400 mt-1">Add all ingredients to your Amazon cart</p>
            {mealsCount !== null && mealsCount > 0 && (
              <p className="text-sm text-orange-400 font-semibold mt-1">
                This shopping list will provide approximately <strong>{mealsCount} meal{mealsCount !== 1 ? 's' : ''}</strong>
              </p>
            )}
          </div>
          <button
            onClick={onClose}
            className="text-gray-400 hover:text-gray-200 transition-colors"
          >
            <X size={24} />
          </button>
        </div>

        {/* Progress Bar */}
        <div className="px-6 pt-6">
          <div className="flex items-center justify-between mb-2">
            <span className="text-sm font-medium text-gray-400">
              {currentStep} of {items.length} items
            </span>
            <span className="text-sm font-medium text-gray-400">
              {Math.round(progress)}%
            </span>
          </div>
          <div className="w-full bg-surface-highlight rounded-full h-3 overflow-hidden">
            <div
              className="bg-primary-600 h-full transition-all duration-300 ease-out"
              style={{ width: `${progress}%` }}
            />
          </div>
        </div>

        {/* Item List */}
        <div className="px-6 py-4 space-y-2 max-h-96 overflow-y-auto">
          {items.map((item, index) => {
            const isAdded = addedItems.has(index);
            const isCurrent = index === currentStep && isAdding;
            
            return (
              <div
                key={item.id || index}
                className={`flex items-center justify-between p-3 rounded-lg border-2 transition-all ${
                  isAdded
                    ? 'bg-green-900/20 border-green-500/50'
                    : isCurrent
                    ? 'bg-blue-900/20 border-blue-500/50'
                    : 'bg-surface-lighter border-surface-highlight'
                }`}
              >
                <div className="flex-1">
                  <div className="font-medium text-gray-200">{item.name}</div>
                  {item.amount && (
                    <div className="text-sm text-gray-400">{item.amount}</div>
                  )}
                </div>
                {/* Price Display */}
                {(() => {
                  const price = getProductPrice(item.name);
                  return price ? (
                    <div className="text-right mr-3">
                      <div className="text-lg font-bold text-orange-400">{formatPrice(price)}</div>
                    </div>
                  ) : null;
                })()}
                <div className="flex items-center gap-3">
                  {isAdded ? (
                    <div className="flex items-center gap-2 text-green-400">
                      <Check size={20} />
                      <span className="text-sm font-medium">Added</span>
                    </div>
                  ) : isCurrent ? (
                    <div className="flex items-center gap-2 text-blue-400">
                      <Loader2 size={20} className="animate-spin" />
                      <span className="text-sm font-medium">Adding...</span>
                    </div>
                  ) : (
                    <button
                      onClick={() => {
                        setCurrentStep(index);
                        addItemViaIframe(item, index).then(success => {
                          if (success) {
                            setAddedItems(new Set([...addedItems, index]));
                          }
                        });
                      }}
                      className="text-sm text-blue-400 hover:text-blue-300 font-medium"
                      disabled={isAdding}
                    >
                      Add Now
                    </button>
                  )}
                </div>
              </div>
            );
          })}
        </div>

        {/* Action Buttons */}
        <div className="sticky bottom-0 bg-surface border-t border-surface-highlight p-6 space-y-3">
          {!allAdded && (
            <div className="flex gap-3">
              <button
                onClick={addNextItem}
                disabled={isAdding || currentStep >= items.length}
                className="flex-1 bg-primary-600 text-white font-semibold py-3 px-4 rounded-lg hover:bg-primary-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-2"
              >
                {isAdding && mode === null ? (
                  <>
                    <Loader2 size={20} className="animate-spin" />
                    Adding...
                  </>
                ) : (
                  <>
                    <ShoppingCart size={20} />
                    Add Next Item
                  </>
                )}
              </button>

              <button
                onClick={addAllAutomatically}
                disabled={isAdding}
                className="flex-1 bg-green-600 text-white font-semibold py-3 px-4 rounded-lg hover:bg-green-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-2"
              >
                {isAdding && mode === 'auto' ? (
                  <>
                    <Loader2 size={20} className="animate-spin" />
                    Adding All...
                  </>
                ) : (
                  <>
                    <ShoppingCart size={20} />
                    Add All Automatically
                  </>
                )}
              </button>
            </div>
          )}

          {allAdded && (
            <a
              href="https://www.amazon.com/gp/cart/view.html"
              target="_blank"
              rel="noopener noreferrer"
              className="block w-full bg-green-600 text-white font-semibold py-3 px-4 rounded-lg hover:bg-green-700 transition-colors text-center flex items-center justify-center gap-2"
            >
              <ShoppingCart size={20} />
              Go to Amazon Cart ({items.length} items)
              {totalPrice > 0 && (
                <span className="ml-2 text-xl font-bold">
                  ‚Ä¢ {formatPrice(totalPrice)}
                </span>
              )}
            </a>
          )}

          {/* Alternative: Open all in tabs */}
          {!allAdded && (
            <button
              onClick={openAllInTabs}
              className="w-full text-gray-400 hover:text-gray-300 font-medium py-2 text-sm transition-colors"
            >
              Or open all links in new tabs (manual)
            </button>
          )}

          {/* Instructions */}
          <div className="mt-4 p-4 bg-blue-900/20 rounded-lg border border-blue-800/30">
            <p className="text-sm text-blue-300 font-medium mb-2">How this works:</p>
            <ol className="text-xs text-blue-200 space-y-1 list-decimal list-inside">
              <li>We add each item to your Amazon cart one by one</li>
              <li>This happens in the background (you may see tabs open/close)</li>
              <li>When complete, click "Go to Amazon Cart" to checkout</li>
            </ol>
          </div>
        </div>
      </div>

    </div>
  );
}
</file>

<file path="components/PetBadges.tsx">
// components/PetBadges.tsx
// Badge display component for pet profile cards

'use client';

import { useEffect, useState } from 'react';
import type { PetBadges as PetBadgesType, BadgeType } from '@/lib/types/badges';
import { getPetBadges } from '@/lib/utils/badgeStorage';
import { getBadgeDefinition, getTierDefinition } from '@/lib/data/badgeDefinitions';
import Image from 'next/image';
import Tooltip from './Tooltip';

interface PetBadgesProps {
  petId: string;
  userId: string;
  className?: string;
}

export default function PetBadges({ petId, userId, className = '' }: PetBadgesProps) {
  const [badges, setBadges] = useState<PetBadgesType>({ badges: [] });

  useEffect(() => {
    if (!petId || !userId) return;
    
    const loadedBadges = getPetBadges(userId, petId);
    setBadges(loadedBadges);
    
    // Listen for badge updates
    const handleBadgeUpdate = () => {
      const updatedBadges = getPetBadges(userId, petId);
      setBadges(updatedBadges);
    };
    
    window.addEventListener('badgesUpdated', handleBadgeUpdate);
    return () => window.removeEventListener('badgesUpdated', handleBadgeUpdate);
  }, [petId, userId]);

  if (!badges.badges || badges.badges.length === 0) {
    return null;
  }

  return (
    <div className={`flex flex-wrap gap-2 ${className}`}>
      {badges.badges.map((badge) => {
        const definition = getBadgeDefinition(badge.type);
        if (!definition) return null;

        // Get icon path (use tier-specific for progressive badges)
        let iconPath = definition.iconPath;
        if (definition.isProgressive && badge.tier) {
          const tierDef = getTierDefinition(badge.type, badge.tier);
          if (tierDef) {
            iconPath = tierDef.iconPath;
          }
        }

        // Get display name
        let displayName = definition.name;
        if (definition.isProgressive && badge.tier) {
          const tierDef = getTierDefinition(badge.type, badge.tier);
          if (tierDef) {
            displayName = tierDef.name;
          }
        }

        // Build tooltip content
        let tooltipContent = `${displayName}\n\n${definition.description}`;
        if (definition.isProgressive && badge.progress !== undefined) {
          tooltipContent += `\n\nProgress: ${badge.progress}`;
          if (badge.nextTierThreshold) {
            tooltipContent += ` / ${badge.nextTierThreshold}`;
          }
        }

        return (
          <Tooltip key={`${badge.type}-${badge.tier || 'single'}`} content={tooltipContent} wide={true}>
            <div className="relative group">
              <div className="w-10 h-10 rounded-full bg-surface-highlight border border-white/10 flex items-center justify-center hover:scale-110 transition-transform cursor-help">
                <Image
                  src={iconPath}
                  alt={displayName}
                  width={32}
                  height={32}
                  className="object-contain no-invert-badge"
                  unoptimized
                  onError={(e) => {
                    // Fallback to placeholder if image doesn't exist
                    (e.target as HTMLImageElement).src = '/images/badges/placeholder.png';
                  }}
                />
              </div>
              {/* Progress indicator for progressive badges */}
              {definition.isProgressive && badge.progress !== undefined && badge.nextTierThreshold && (
                <div className="absolute -bottom-1 left-0 right-0 h-1 bg-gray-700 rounded-full overflow-hidden">
                  <div
                    className="h-full bg-orange-400 transition-all"
                    style={{
                      width: `${Math.min(100, (badge.progress / badge.nextTierThreshold) * 100)}%`,
                    }}
                  />
                </div>
              )}
            </div>
          </Tooltip>
        );
      })}
    </div>
  );
}

/**
 * Badge preview grid component (optional, for profile editor)
 */
export function BadgePreviewGrid({ className = '' }: { className?: string }) {
  const { BADGE_DEFINITIONS } = require('@/lib/data/badgeDefinitions');
  const definitions = Object.values(BADGE_DEFINITIONS);

  return (
    <div className={`grid grid-cols-2 md:grid-cols-4 gap-4 ${className}`}>
      {definitions.map((def: any) => {
        if (def.isProgressive && def.tiers) {
          return def.tiers.map((tier: any) => (
            <div key={`${def.type}-${tier.tier}`} className="text-center">
              <div className="w-16 h-16 mx-auto mb-2 rounded-full bg-surface-highlight border border-white/10 flex items-center justify-center">
                <Image
                  src={tier.iconPath}
                  alt={tier.name}
                  width={48}
                  height={48}
                  className="object-contain opacity-50 no-invert-badge"
                  unoptimized
                  onError={(e) => {
                    (e.target as HTMLImageElement).src = '/images/badges/placeholder.png';
                  }}
                />
              </div>
              <p className="text-xs text-gray-400">{tier.name}</p>
            </div>
          ));
        } else {
          return (
            <div key={def.type} className="text-center">
              <div className="w-16 h-16 mx-auto mb-2 rounded-full bg-surface-highlight border border-white/10 flex items-center justify-center">
                <Image
                  src={def.iconPath}
                  alt={def.name}
                  width={48}
                  height={48}
                  className="object-contain opacity-50 no-invert-badge"
                  unoptimized
                  onError={(e) => {
                    (e.target as HTMLImageElement).src = '/images/badges/placeholder.png';
                  }}
                />
              </div>
              <p className="text-xs text-gray-400">{def.name}</p>
            </div>
          );
        }
      })}
    </div>
  );
}
</file>

<file path="components/PetVillageWidget.tsx">
'use client';

import React, { useState } from 'react';
import { Plus, Minus } from 'lucide-react';

interface PetVillageWidgetProps {
  initialStreak?: number;
  onStreakChange?: (streak: number) => void;
  className?: string;
}

type VillagePhase = 'struggle' | 'suburbs' | 'paradise' | 'utopia' | 'legendary' | 'mythical' | 'eternal' | 'cosmic' | 'infinite' | 'divine';

const PetVillageWidget: React.FC<PetVillageWidgetProps> = ({
  initialStreak = 0,
  onStreakChange,
  className = ''
}) => {
  const [streak, setStreak] = useState(initialStreak);

  // Calculate current phase
  const getCurrentPhase = (currentStreak: number): VillagePhase => {
    if (currentStreak < 10) return 'struggle';
    if (currentStreak < 20) return 'suburbs';
    if (currentStreak < 30) return 'paradise';
    if (currentStreak < 40) return 'utopia';
    if (currentStreak < 50) return 'legendary';
    if (currentStreak < 60) return 'mythical';
    if (currentStreak < 70) return 'eternal';
    if (currentStreak < 80) return 'cosmic';
    if (currentStreak < 90) return 'infinite';
    return 'divine';
  };

  const phase = getCurrentPhase(streak);

  const incrementStreak = () => {
    const newStreak = streak + 1;
    setStreak(newStreak);
    onStreakChange?.(newStreak);
  };

  const decrementStreak = () => {
    const newStreak = Math.max(0, streak - 1);
    setStreak(newStreak);
    onStreakChange?.(newStreak);
  };

  // Get village representation based on phase
  const getVillageDisplay = () => {
    switch (phase) {
      case 'struggle':
        return { emoji: 'üè†', color: 'text-amber-600', bg: 'bg-amber-50' };
      case 'suburbs':
        return { emoji: 'üèòÔ∏è', color: 'text-green-600', bg: 'bg-green-50' };
      case 'paradise':
        return { emoji: 'üè∞', color: 'text-yellow-600', bg: 'bg-yellow-50' };
      case 'utopia':
        return { emoji: 'üèõÔ∏è', color: 'text-purple-600', bg: 'bg-purple-50' };
      case 'legendary':
        return { emoji: '‚öîÔ∏è', color: 'text-red-600', bg: 'bg-red-50' };
      case 'mythical':
        return { emoji: 'üêâ', color: 'text-indigo-600', bg: 'bg-indigo-50' };
      case 'eternal':
        return { emoji: '‚è≥', color: 'text-cyan-600', bg: 'bg-cyan-50' };
      case 'cosmic':
        return { emoji: 'üåå', color: 'text-violet-600', bg: 'bg-violet-50' };
      case 'infinite':
        return { emoji: '‚ôæÔ∏è', color: 'text-pink-600', bg: 'bg-pink-50' };
      case 'divine':
        return { emoji: 'üëë', color: 'text-gold-600', bg: 'bg-yellow-100' };
      default:
        return { emoji: 'üè†', color: 'text-gray-600', bg: 'bg-gray-50' };
    }
  };

  const village = getVillageDisplay();

  return (
    <div className={`flex flex-col items-center justify-center p-2 ${village.bg} rounded-lg border ${className}`}>
      {/* Village Icon */}
      <div className={`text-2xl mb-1 ${village.color}`}>
        {village.emoji}
      </div>

      {/* Streak Counter */}
      <div className="text-center">
        <div className="text-lg font-bold text-gray-800">{streak}</div>
        <div className="text-xs text-gray-600">meals</div>
      </div>

      {/* Phase Indicator */}
      <div className="text-xs font-medium text-gray-700 mt-1 capitalize">
        {phase}
      </div>

      {/* Mini Progress Bar */}
      <div className="w-full bg-gray-200 rounded-full h-1 mt-2">
        <div
          className="bg-primary-600 h-1 rounded-full transition-all duration-300"
          style={{
            width: `${Math.min(((streak % 10) / 10) * 100, 100)}%`
          }}
        />
      </div>

      {/* Control Buttons */}
      <div className="mt-2 flex gap-1">
        <button
          onClick={decrementStreak}
          className="w-5 h-5 bg-red-500 text-white rounded-full flex items-center justify-center hover:bg-red-600 transition-colors text-xs"
          title="Remove meal"
        >
          <Minus size={10} />
        </button>
        <button
          onClick={incrementStreak}
          className="w-5 h-5 bg-primary-600 text-white rounded-full flex items-center justify-center hover:bg-primary-700 transition-colors text-xs"
          title="Add meal"
        >
          <Plus size={10} />
        </button>
      </div>
    </div>
  );
};

export default PetVillageWidget;
</file>

<file path="components/ProfileSelector.tsx">
'use client';

import { useState, useEffect } from 'react';
import { Plus, User, Dog, Cat, Bird, Fish, Rabbit, X } from 'lucide-react';

const petIcons = {
  dogs: Dog,
  cats: Cat,
  birds: Bird,
  reptiles: Fish,
  'pocket-pets': Rabbit,
};

const petTypes = [
  { id: 'dogs', name: 'Dog', icon: Dog },
  { id: 'cats', name: 'Cat', icon: Cat },
  { id: 'birds', name: 'Bird', icon: Bird },
  { id: 'reptiles', name: 'Reptile', icon: Fish },
  { id: 'pocket-pets', name: 'Pocket Pet', icon: Rabbit },
];

const ageGroups = [
  { id: 'baby', name: 'Baby', description: '0-1 years' },
  { id: 'young', name: 'Young Adult', description: '1-3 years' },
  { id: 'adult', name: 'Adult', description: '3-7 years' },
  { id: 'senior', name: 'Senior', description: '7+ years' },
];

const healthConcernOptions = [
  { id: 'none', name: 'No Special Concerns' },
  { id: 'weight-management', name: 'Weight Management' },
  { id: 'allergies', name: 'Food Allergies' },
  { id: 'joint-health', name: 'Joint Health' },
  { id: 'digestive', name: 'Digestive Issues' },
  { id: 'kidney', name: 'Kidney Support' },
  { id: 'dental', name: 'Dental Health' },
];

import { getBreedNamesForSpecies } from '@/lib/data/speciesBreeds';

// Get breeds from centralized source
const getBreedsByType = () => {
  return {
    dogs: getBreedNamesForSpecies('dogs'),
    cats: getBreedNamesForSpecies('cats'),
    birds: getBreedNamesForSpecies('birds'),
    reptiles: getBreedNamesForSpecies('reptiles'),
    'pocket-pets': getBreedNamesForSpecies('pocket-pets'),
  };
};

const breedsByType = getBreedsByType();

export default function ProfileSelector() {
  const [pets, setPets] = useState([
    { id: '1', name: 'Max', type: 'dogs', breed: 'Labrador', age: 'adult', healthConcerns: ['none'] },
    { id: '2', name: 'Whiskers', type: 'cats', breed: 'Persian', age: 'senior', healthConcerns: ['kidney'] },
  ]);
  
  const [selectedPet, setSelectedPet] = useState(pets[0]?.id || '');
  const [showModal, setShowModal] = useState(false);
  const [step, setStep] = useState(1);
  const [formData, setFormData] = useState({
    name: '',
    type: 'dogs',
    breed: '',
    age: 'adult',
    healthConcerns: ['none'],
  });

  const handleAddPet = () => {
    const newPet = {
      id: Date.now().toString(),
      ...formData,
    };
    setPets([...pets, newPet]);
    setSelectedPet(newPet.id);
    setShowModal(false);
    setStep(1);
    setFormData({
      name: '',
      type: 'dogs',
      breed: '',
      age: 'adult',
      healthConcerns: ['none'],
    });
  };

  const toggleHealthConcern = (concern: string) => {
    if (concern === 'none') {
      setFormData({ ...formData, healthConcerns: ['none'] });
    } else {
      const filtered = formData.healthConcerns.filter(c => c !== 'none');
      if (filtered.includes(concern)) {
        const updated = filtered.filter(c => c !== concern);
        setFormData({ ...formData, healthConcerns: updated.length ? updated : ['none'] });
      } else {
        setFormData({ ...formData, healthConcerns: [...filtered, concern] });
      }
    }
  };

  return (
    <div className="bg-white rounded-lg shadow-md p-6">
      <div className="flex items-center justify-between mb-4">
        <h2 className="text-2xl font-bold text-gray-900">My Pets</h2>
        <button 
          onClick={() => setShowModal(true)}
          className="btn btn-md btn-darkgreen"
        >
          <Plus size={20} />
          Add Pet
        </button>
      </div>

      {pets.length === 0 ? (
        <div className="text-center py-12">
          <User size={48} className="mx-auto text-gray-400 mb-4" />
          <p className="text-gray-600 mb-4">No pets added yet</p>
          <button 
            onClick={() => setShowModal(true)}
            className="btn btn-md btn-darkgreen w-full justify-center"
          >
            Add Your First Pet
          </button>
        </div>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {pets.map((pet) => {
            const Icon = petIcons[pet.type as keyof typeof petIcons];
             return (
              <button
                key={pet.id}
                onClick={() => setSelectedPet(pet.id)}
                className={`p-4 rounded-lg border-2 transition-colors duration-200 text-left ${
                  selectedPet === pet.id
                    ? 'border-orange-600 bg-orange-50'
                    : 'border-gray-200 bg-white hover:border-orange-300'
                }`}
              >
                <div className="flex items-start gap-3">
                  <div className={`p-2 rounded-lg ${selectedPet === pet.id ? 'bg-dark-green' : 'bg-gray-100'}`}>
                    <Icon size={24} className={selectedPet === pet.id ? 'text-orange-400' : 'text-gray-600'} />
                  </div>
                  <div className="flex-1">
                    <h3 className="font-bold text-gray-900">{pet.name}</h3>
                    <p className="text-sm text-gray-600 capitalize">{pet.breed.replace('-', ' ')}</p>
                    <p className="text-xs text-gray-500 mt-1 capitalize">{pet.age}</p>
                  </div>
                </div>
                {selectedPet === pet.id && (
                  <div className="mt-3 pt-3 border-t">
                    <a
                      href={`/category/${pet.type}`}
                      className="text-sm text-orange-600 hover:text-orange-700 font-medium"
                    >
                      View {pet.name}'s Recipes ‚Üí
                    </a>
                  </div>
                )}
              </button>
            );
          })}
        </div>
      )}

      {/* Add Pet Modal */}
      {showModal && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
          <div className="bg-white rounded-lg max-w-2xl w-full max-h-[90vh] overflow-y-auto">
            <div className="sticky top-0 bg-white border-b px-6 py-4 flex items-center justify-between">
              <h2 className="text-2xl font-bold text-gray-900">Add Your Pet</h2>
              <button 
                onClick={() => {
                  setShowModal(false);
                  setStep(1);
                }}
                className="p-2 hover:bg-gray-100 rounded-lg"
              >
                <X size={24} />
              </button>
            </div>

            <div className="p-6">
              {/* Step 1: Pet Type */}
              {step === 1 && (
                <div className="space-y-6">
                  <div>
                    <label className="block text-lg font-semibold text-gray-900 mb-4">
                      What type of pet do you have?
                    </label>
                    <div className="grid grid-cols-2 md:grid-cols-3 gap-4">
                      {petTypes.map((type) => {
                        const Icon = type.icon;
                        return (
                          <button
                            key={type.id}
                            type="button"
                            onClick={() => {
                              setFormData({ ...formData, type: type.id, breed: '' });
                              setStep(2);
                            }}
                            className="p-6 rounded-lg border-2 transition-all hover:border-primary-500 border-gray-200 hover:bg-primary-900/10"
                          >
                            <Icon size={32} className="mx-auto mb-2 text-orange-600" />
                            <div className="font-semibold text-gray-900">{type.name}</div>
                          </button>
                        );
                      })}
                    </div>
                  </div>
                </div>
              )}

              {/* Step 2: Name & Breed */}
              {step === 2 && (
                <div className="space-y-6">
                  <div>
                    <label className="block text-sm font-semibold text-gray-700 mb-2">
                      What's your pet's name?
                    </label>
                    <input
                      type="text"
                      value={formData.name}
                      onChange={(e) => setFormData({ ...formData, name: e.target.value })}
                      placeholder="Enter pet name"
                      className="w-full px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-orange-500"
                    />
                  </div>

                  <div>
                    <label className="block text-sm font-semibold text-gray-700 mb-2">
                      Select breed/type
                    </label>
                    <select
                      value={formData.breed}
                      onChange={(e) => setFormData({ ...formData, breed: e.target.value })}
                      className="w-full px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-orange-500"
                    >
                      <option value="">Choose a breed</option>
                      {breedsByType[formData.type as keyof typeof breedsByType].map((breed) => (
                        <option key={breed} value={breed.toLowerCase().replace(' ', '-')}>
                          {breed}
                        </option>
                      ))}
                    </select>
                  </div>

                  <div className="flex gap-3">
                    <button
                      type="button"
                      onClick={() => setStep(1)}
                      className="px-6 py-3 border border-gray-300 text-gray-700 rounded-lg hover:bg-gray-50"
                    >
                      Back
                    </button>
                    <button
                      type="button"
                      onClick={() => setStep(3)}
                      disabled={!formData.name || !formData.breed}
                      className="flex-1 btn btn-md btn-darkgreen disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                      Next
                    </button>
                  </div>
                </div>
              )}

              {/* Step 3: Age */}
              {step === 3 && (
                <div className="space-y-6">
                  <div>
                    <label className="block text-lg font-semibold text-gray-900 mb-4">
                      How old is {formData.name}?
                    </label>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                      {ageGroups.map((age) => (
                        <button
                          key={age.id}
                          type="button"
                          onClick={() => {
                            setFormData({ ...formData, age: age.id });
                            setStep(4);
                          }}
                          className="p-4 rounded-lg border-2 text-left transition-all hover:border-primary-500 border-gray-200 hover:bg-primary-900/10"
                        >
                          <div className="font-bold text-gray-900">{age.name}</div>
                          <div className="text-sm text-gray-600">{age.description}</div>
                        </button>
                      ))}
                    </div>
                  </div>

                  <button
                    type="button"
                    onClick={() => setStep(2)}
                    className="px-6 py-3 border border-gray-300 text-gray-700 rounded-lg hover:bg-gray-50"
                  >
                    Back
                  </button>
                </div>
              )}

              {/* Step 4: Health Concerns */}
              {step === 4 && (
                <div className="space-y-6">
                  <div>
                    <label className="block text-lg font-semibold text-gray-900 mb-4">
                      Any health concerns? (Select all that apply)
                    </label>
                    <div className="space-y-3">
                      {healthConcernOptions.map((concern) => (
                        <label
                          key={concern.id}
                          className={`flex items-center gap-3 p-4 rounded-lg border-2 cursor-pointer transition-all ${
                            formData.healthConcerns.includes(concern.id)
                              ? 'border-primary-500 bg-primary-900/10'
                              : 'border-gray-200 hover:border-primary-300'
                          }`}
                        >
                          <input
                            type="checkbox"
                            checked={formData.healthConcerns.includes(concern.id)}
                            onChange={() => toggleHealthConcern(concern.id)}
                            className="w-5 h-5 text-orange-600 rounded focus:ring-orange-500"
                          />
                          <span className="font-medium text-gray-900">{concern.name}</span>
                        </label>
                      ))}
                    </div>
                  </div>

                  <div className="flex gap-3">
                    <button
                      type="button"
                      onClick={() => setStep(3)}
                      className="px-6 py-3 border border-gray-300 text-gray-700 rounded-lg hover:bg-gray-50"
                    >
                      Back
                    </button>
                    <button
                      type="button"
                      onClick={handleAddPet}
                      className="flex-1 btn btn-md btn-darkgreen font-semibold"
                    >
                      Add {formData.name}
                    </button>
                  </div>
                </div>
              )}
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="components/PurchaseConfirmationModal.tsx">
'use client';

import React, { useState, useEffect } from 'react';
import { X, CheckCircle, ShoppingCart, Sparkles } from 'lucide-react';
import { confirmPurchaseWithDetails } from '@/lib/utils/purchaseTracking';
import { getNextVillageLevel } from '@/lib/data/villageLevels';
import { useVillageStore, useVillageProgress } from '@/lib/state/villageStore';
import { confirmPetPurchase, getPetPurchaseCount } from '@/lib/utils/petPurchaseTracking';
import { checkAllBadges } from '@/lib/utils/badgeChecker';

export interface PurchaseConfirmationModalProps {
  isOpen: boolean;
  onClose: () => void;
  ingredientId: string;
  ingredientName: string;
  userId?: string;
  amazonOrderId?: string;
  petId?: string; // Optional pet ID for per-pet purchase tracking
}

/**
 * Modal that appears after clicking "Buy" buttons
 * Allows user to confirm purchase manually (fallback)
 * Shows progress toward next village level
 */
export default function PurchaseConfirmationModal({
  isOpen,
  onClose,
  ingredientId,
  ingredientName,
  userId,
  amazonOrderId,
  petId
}: PurchaseConfirmationModalProps) {
  const [confirmed, setConfirmed] = useState(false);
  const { refreshFromLocal, setUserId } = useVillageStore();
  const { count, level, progress, nextLevelThreshold, ingredientsRemaining } = useVillageProgress();

  // Get userId from localStorage if not provided
  const getUserId = () => {
    if (userId) return userId;
    if (typeof window === 'undefined') return '';
    return localStorage.getItem('last_user_id') || '';
  };

  useEffect(() => {
    if (isOpen) {
      const currentUserId = getUserId();
      if (currentUserId) {
        setUserId(currentUserId);
        setConfirmed(false);
      }
    }
  }, [isOpen, userId, setUserId]);

  const handleConfirm = async () => {
    const currentUserId = getUserId();
    if (currentUserId) {
      // Confirm global purchase (for village)
      const result = confirmPurchaseWithDetails(currentUserId, ingredientId, ingredientName, amazonOrderId);
      if (result.success) {
        refreshFromLocal(); // Update village store
        
        // Also track per-pet purchase if petId is provided
        if (petId) {
          await confirmPetPurchase(
            currentUserId,
            petId,
            ingredientId,
            ingredientName,
            undefined, // recipeId - not available here
            amazonOrderId
          );
          
          // Check badges for per-pet purchase
          const purchaseCount = getPetPurchaseCount(currentUserId, petId);
          await checkAllBadges(currentUserId, petId, {
            action: 'purchase_confirmed',
            purchaseCount,
          });
        }
        
        setConfirmed(true);
        
        // Auto-close after 2 seconds
        setTimeout(() => {
          onClose();
        }, 2000);
      }
    }
  };

  const handleSkip = () => {
    onClose();
  };

  if (!isOpen) return null;

  const nextLevel = level ? getNextVillageLevel(level.id) : null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full max-h-[90vh] overflow-y-auto">
        {/* Header */}
        <div className="sticky top-0 bg-white border-b p-6 flex items-center justify-between rounded-t-2xl">
          <div>
            <h2 className="text-2xl font-bold text-gray-900">Confirm Purchase</h2>
            <p className="text-sm text-gray-600 mt-1">Did you purchase this ingredient?</p>
          </div>
          <button
            onClick={onClose}
            className="text-gray-400 hover:text-gray-600 transition-colors"
            aria-label="Close"
          >
            <X size={24} />
          </button>
        </div>

        {/* Content */}
        <div className="p-6 space-y-6">
          {/* Ingredient Info */}
          <div className="bg-gray-50 rounded-lg p-4 border-2 border-gray-200">
            <div className="flex items-center gap-3">
              <ShoppingCart size={32} className="text-amber-600" />
              <div>
                <h3 className="font-bold text-gray-900 text-lg">{ingredientName}</h3>
                <p className="text-sm text-gray-600">Confirm when you've completed your purchase</p>
              </div>
            </div>
          </div>

          {/* Current Stats */}
          {level && (
            <div className="space-y-4">
              {/* Current Level */}
              <div className="bg-gradient-to-br from-amber-50 to-orange-50 rounded-lg p-4 border-2 border-amber-200">
                <div className="flex items-center justify-between mb-2">
                  <span className="text-sm font-semibold text-gray-700">Current Village</span>
                  <span className="text-lg font-bold text-gray-900">{level.name}</span>
                </div>
                <div className="text-xs text-gray-600">
                  Level {level.id} ‚Ä¢ {count} ingredients purchased
                </div>
              </div>

              {/* Progress to Next Level */}
              {nextLevel && ingredientsRemaining > 0 && (
                <div className="bg-blue-50 rounded-lg p-4 border-2 border-blue-200">
                  <div className="flex items-center gap-2 mb-2">
                    <Sparkles size={20} className="text-blue-600" />
                    <span className="text-sm font-semibold text-gray-700">
                      Progress to {nextLevel.name}
                    </span>
                  </div>
                  <div className="w-full bg-gray-200 rounded-full h-3 mb-2">
                    <div
                      className="bg-gradient-to-r from-blue-500 to-blue-600 h-3 rounded-full transition-[width] duration-500 ease-out will-change-[width]"
                      style={{ width: `${(progress / 10) * 100}%` }}
                    />
                  </div>
                  <div className="text-xs text-gray-600">
                    {ingredientsRemaining} more ingredient{ingredientsRemaining !== 1 ? 's' : ''} to unlock!
                  </div>
                </div>
              )}

              {/* Max Level Reached */}
              {!nextLevel && (
                <div className="bg-green-50 rounded-lg p-4 border-2 border-green-200">
                  <div className="flex items-center gap-2">
                    <CheckCircle size={20} className="text-green-600" />
                    <span className="text-sm font-semibold text-green-900">
                      üéâ Maximum level reached! Your village is complete!
                    </span>
                  </div>
                </div>
              )}
            </div>
          )}

          {/* Confirmation Message */}
          {confirmed && (
            <div className="bg-green-50 rounded-lg p-4 border-2 border-green-200">
              <div className="flex items-center gap-2">
                <CheckCircle size={24} className="text-green-600" />
                <span className="font-semibold text-green-900">
                  Purchase confirmed! Your village is growing! üéâ
                </span>
              </div>
            </div>
          )}
        </div>

        {/* Action Buttons */}
        <div className="sticky bottom-0 bg-white border-t p-6 space-y-3 rounded-b-2xl">
          {!confirmed ? (
            <>
              <button
                onClick={handleConfirm}
                className="w-full bg-gradient-to-r from-amber-500 to-orange-500 hover:from-amber-600 hover:to-orange-600 text-white font-semibold py-3 px-4 rounded-lg transition-all shadow-lg hover:shadow-xl"
              >
                <div className="flex items-center justify-center gap-2">
                  <CheckCircle size={20} />
                  Yes, I Purchased This
                </div>
              </button>
              <button
                onClick={handleSkip}
                className="w-full bg-gray-100 hover:bg-gray-200 text-gray-700 font-semibold py-3 px-4 rounded-lg transition-colors"
              >
                Skip for Now
              </button>
            </>
          ) : (
            <button
              onClick={onClose}
              className="w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-3 px-4 rounded-lg transition-colors"
            >
              Close
            </button>
          )}

          {/* Helper Text */}
          <p className="text-xs text-gray-500 text-center">
            Confirming purchases helps track your village progress. You can always confirm later!
          </p>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="components/QuickPreviewModal.tsx">
'use client';

import React, { useState, useEffect } from 'react';
import { X, ShoppingCart, Sparkles, ArrowRight } from 'lucide-react';
import Image from 'next/image';
import Link from 'next/link';
import { getButtonCopy, trackButtonClick, type ButtonCopyVariant } from '@/lib/utils/abTesting';
import { ensureSellerId } from '@/lib/utils/affiliateLinks';
import { getProductByIngredient } from '@/lib/data/product-prices';

// Format price for display
const formatPrice = (price: number) => {
  return `$${price.toFixed(2)}`;
};

type PetCategory = 'dogs' | 'cats' | 'birds' | 'reptiles' | 'pocket-pets';

interface QuickPreviewModalProps {
  isOpen: boolean;
  onClose: () => void;
}

const PET_TYPES: { id: PetCategory; emoji: string; label: string }[] = [
  { id: 'dogs', emoji: 'üêï', label: 'Dogs' },
  { id: 'cats', emoji: 'üêà', label: 'Cats' },
  { id: 'birds', emoji: 'ü¶ú', label: 'Birds' },
  { id: 'reptiles', emoji: 'ü¶é', label: 'Reptiles' },
  { id: 'pocket-pets', emoji: 'üê∞', label: 'Small Pets' },
];

export default function QuickPreviewModal({ isOpen, onClose }: QuickPreviewModalProps) {
  const [selectedType, setSelectedType] = useState<PetCategory>('dogs');
  const [hoveredRecipe, setHoveredRecipe] = useState<string | null>(null);
  const [recipes, setRecipes] = useState<any[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  
  // A/B Testing: Get assigned button copy
  const [buttonCopy, setButtonCopy] = useState<ButtonCopyVariant | null>(null);
  
  useEffect(() => {
    setButtonCopy(getButtonCopy(false));
  }, []);

  // Fetch recipes when pet type changes
  useEffect(() => {
    if (!isOpen) return;
    
    const fetchRecipes = async () => {
      setIsLoading(true);
      try {
        const response = await fetch('/api/recipes/generate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            species: selectedType,
            count: 3, // Only need 3 for preview
          }),
        });
        
        if (response.ok) {
          const data = await response.json();
          setRecipes(data.recipes || []);
        } else {
          setRecipes([]);
        }
      } catch (error) {
        console.error('Failed to fetch recipes:', error);
        setRecipes([]);
      } finally {
        setIsLoading(false);
      }
    };
    
    fetchRecipes();
  }, [selectedType, isOpen]);

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 z-50 bg-black/70 backdrop-blur-sm flex items-center justify-center p-4 animate-fadeIn">
      <div className="bg-[#0f2c0f] border-2 border-orange-500/50 rounded-2xl shadow-2xl w-full max-w-5xl max-h-[90vh] overflow-hidden">
        {/* Header */}
        <div className="bg-gradient-to-r from-[#043136] to-[#0f2c0f] px-6 py-5 border-b-2 border-orange-500/30 flex items-center justify-between">
          <div>
            <h2 className="text-2xl font-bold text-white flex items-center gap-2">
              <Sparkles className="text-orange-400" size={28} />
              See Perfect Meals for Your Pet
            </h2>
            <p className="text-gray-300 text-sm mt-1">
              No signup required ‚Ä¢ Instant results
            </p>
          </div>
          <button
            onClick={onClose}
            className="text-gray-400 hover:text-white transition-colors p-2"
          >
            <X size={28} />
          </button>
        </div>

        {/* Content */}
        <div className="p-6 overflow-y-auto max-h-[calc(90vh-180px)]">
          {/* Pet Type Selector */}
          <div className="mb-6">
            <p className="text-gray-300 text-sm mb-3 text-center">
              üëá Pick your pet type to see example meals
            </p>
            <div className="flex justify-center gap-3 flex-wrap">
              {PET_TYPES.map(type => (
                <button
                  key={type.id}
                  onClick={() => setSelectedType(type.id)}
                  className={`flex items-center gap-2 px-6 py-3 rounded-xl font-semibold transition-all ${
                    selectedType === type.id
                      ? 'bg-orange-500 text-white shadow-lg scale-105 border-2 border-orange-400'
                      : 'bg-surface-highlight text-gray-300 hover:bg-surface hover:text-white border-2 border-transparent'
                  }`}
                >
                  <span className="text-2xl">{type.emoji}</span>
                  <span>{type.label}</span>
                </button>
              ))}
            </div>
          </div>

          {/* Recipe Grid or Loading */}
          {isLoading ? (
            <div className="text-center py-12">
              <Sparkles className="text-orange-400 mx-auto mb-4 animate-spin" size={48} />
              <h3 className="text-xl font-bold text-white mb-2">
                Generating Perfect Meals...
              </h3>
              <p className="text-gray-300">
                Creating personalized recipes for your {selectedType.replace('-', ' ')}
              </p>
            </div>
          ) : recipes.length > 0 ? (
            <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
              {recipes.map(recipe => {
                // Get ingredients with purchase links
                const ingredientsWithLinks = recipe.ingredients?.filter((ing: any) => 
                  ing.asinLink || ing.amazonLink
                ) || [];
                
                // Calculate total price using our high-quality product-prices system
                const recipeTotalPrice = ingredientsWithLinks.reduce((sum: number, ing: any) => {
                  const product = getProductByIngredient(ing.name);
                  if (product?.price?.amount) {
                    return sum + product.price.amount;
                  }
                  return sum;
                }, 0);
                
                return (
                  <div
                    key={recipe.id}
                    onMouseEnter={() => setHoveredRecipe(recipe.id)}
                    onMouseLeave={() => setHoveredRecipe(null)}
                    className="bg-surface rounded-xl border-2 border-surface-highlight hover:border-orange-500 transition-all shadow-lg hover:shadow-2xl overflow-hidden"
                  >
                    {/* Recipe Image */}
                    {recipe.imageUrl && (
                      <div className="relative w-full h-40 bg-surface-highlight">
                        <Image
                          src={recipe.imageUrl}
                          alt={recipe.name}
                          fill
                          className="object-cover"
                          unoptimized
                        />
                      </div>
                    )}

                    <div className="p-4">
                      <h3 className="text-lg font-bold text-white mb-2 line-clamp-2">
                        {recipe.name}
                      </h3>
                      
                      <p className="text-gray-400 text-sm mb-3 line-clamp-3">
                        {recipe.description}
                      </p>

                      {/* Ingredients Preview */}
                      <div className="mb-4 pb-3 border-b border-surface-highlight">
                        <p className="text-xs text-gray-500 mb-2">Key Ingredients:</p>
                        <div className="flex flex-wrap gap-1">
                          {recipe.ingredients?.slice(0, 4).map((ing: any, idx: number) => (
                            <span
                              key={idx}
                              className="text-xs bg-green-900/40 text-green-300 px-2 py-1 rounded"
                            >
                              {ing.name}
                            </span>
                          ))}
                          {recipe.ingredients && recipe.ingredients.length > 4 && (
                            <span className="text-xs text-gray-500">
                              +{recipe.ingredients.length - 4} more
                            </span>
                          )}
                        </div>
                      </div>

                      {/* CTA Buttons */}
                      <div className="space-y-2">
                        {/* Shop Ingredients Button */}
                        {ingredientsWithLinks.length > 0 && (
                          <button
                            onClick={() => {
                              // Open first ingredient link
                              const firstIng = ingredientsWithLinks[0];
                              const link = firstIng.asinLink || firstIng.amazonLink;
                              if (link) {
                                window.open(ensureSellerId(link), '_blank');
                                // Track affiliate click
                                if (typeof window !== 'undefined') {
                                  localStorage.setItem('last_affiliate_click', JSON.stringify({
                                    recipeId: recipe.id,
                                    timestamp: Date.now(),
                                    source: 'quick-preview-modal'
                                  }));
                                }
                                // A/B Test tracking
                                if (buttonCopy) {
                                  trackButtonClick(buttonCopy.id, 'preview', recipe.name);
                                }
                              }
                            }}
                            className="w-full py-3 px-4 rounded-lg font-bold text-base bg-gradient-to-r from-[#FF9900] to-[#F08804] hover:from-[#F08804] hover:to-[#E07704] text-black shadow-lg hover:shadow-xl transition-all flex items-center justify-center gap-2 border-2 border-orange-400"
                          >
                            <ShoppingCart size={18} />
                            {buttonCopy?.text || 'Shop Ingredients'} ({ingredientsWithLinks.length} items)
                            {recipeTotalPrice > 0 && (
                              <span className="ml-2 text-sm font-normal opacity-90">
                                ‚Ä¢ {formatPrice(recipeTotalPrice)}
                              </span>
                            )}
                          </button>
                        )}

                        {/* View Full Recipe */}
                        <Link
                          href={`/recipe/${recipe.id}`}
                          className="w-full py-2 px-4 rounded-lg font-semibold text-sm bg-surface-highlight hover:bg-surface text-gray-300 hover:text-white transition-colors flex items-center justify-center gap-2 border border-surface-highlight"
                        >
                          View Recipe
                          <ArrowRight size={16} />
                        </Link>
                      </div>
                    </div>
                  </div>
                );
              })}
            </div>
          ) : (
            <div className="text-center py-12">
              <Sparkles className="text-orange-400 mx-auto mb-4" size={48} />
              <h3 className="text-xl font-bold text-white mb-2">
                Personalized Meals Await!
              </h3>
              <p className="text-gray-300 mb-6">
                Create a free account to generate cost-optimized meal plans tailored to your {selectedType.replace('-', ' ')}'s specific needs, age, and health concerns.
              </p>
            </div>
          )}

          {/* Bottom CTA */}
          <div className="mt-8 pt-6 border-t-2 border-orange-500/30">
            <div className="bg-gradient-to-r from-orange-500/20 to-green-900/20 rounded-xl p-6 text-center border border-orange-500/30">
              <h3 className="text-2xl font-bold text-white mb-2">
                Want Personalized Recommendations?
              </h3>
              <p className="text-gray-300 mb-4">
                Create a profile for your {selectedType.replace('-', ' ')} and get meals tailored to their specific needs, age, and health concerns.
              </p>
              <Link
                href="/sign-up"
                className="inline-flex items-center gap-2 px-8 py-4 bg-gradient-to-r from-green-700 to-green-600 hover:from-green-600 hover:to-green-500 text-white font-bold rounded-lg shadow-lg hover:shadow-xl transition-all border-3 border-orange-500"
              >
                Create Free Account
                <ArrowRight size={20} />
              </Link>
              <p className="text-xs text-gray-500 mt-3">
                Free forever ‚Ä¢ No credit card required
              </p>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="components/RatingBreakdown.tsx">
import React from 'react';
import { CompatibilityRating } from '@/lib/utils/petRatingSystem';

interface RatingBreakdownProps {
  rating: CompatibilityRating;
  className?: string;
}

export const RatingBreakdown: React.FC<RatingBreakdownProps> = ({
  rating,
  className = ''
}) => {
  const getProgressBarColor = (score: number) => {
    if (score >= 80) return 'bg-green-500';
    if (score >= 60) return 'bg-blue-500';
    if (score >= 40) return 'bg-yellow-500';
    return 'bg-red-500';
  };

  const formatFactorName = (key: string) => {
    switch (key) {
      case 'petTypeMatch':
        return 'Pet Type Match';
      case 'ageAppropriate':
        return 'Age Appropriate';
      case 'nutritionalFit':
        return 'Nutritional Fit';
      case 'healthCompatibility':
        return 'Health Compatibility';
      case 'allergenSafety':
        return 'Allergen Safety';
      default:
        return key;
    }
  };

  return (
    <div className={`bg-white rounded-lg shadow-md p-6 ${className}`}>
      <h3 className="text-xl font-bold text-gray-900 mb-6">Compatibility Analysis</h3>

      {/* Overall Score */}
      <div className="mb-6 p-4 bg-gray-50 rounded-lg">
        <div className="flex items-center justify-between mb-2">
          <span className="text-lg font-semibold text-gray-900">Overall Compatibility</span>
          <span className="text-2xl font-bold text-gray-900">{rating.overallScore}%</span>
        </div>
        <div className="w-full bg-gray-200 rounded-full h-3">
          <div
            className={`h-3 rounded-full transition-all duration-300 ${getProgressBarColor(rating.overallScore)}`}
            style={{ width: `${rating.overallScore}%` }}
          />
        </div>
        <p className="text-sm text-gray-600 mt-2 capitalize">{rating.compatibility} match for your pet</p>
      </div>

      {/* Detailed Breakdown */}
      <div className="space-y-4 mb-6">
        <h4 className="text-lg font-semibold text-gray-900">Detailed Breakdown</h4>
        {Object.entries(rating.breakdown).map(([key, factor]) => (
          <div key={key} className="flex items-center justify-between">
            <div className="flex-1">
              <div className="flex items-center justify-between mb-1">
                <span className="text-sm font-medium text-gray-700">
                  {formatFactorName(key)}
                </span>
                <span className="text-sm text-gray-600">
                  {factor.score}% ({factor.weight}% weight)
                </span>
              </div>
              <div className="w-full bg-gray-200 rounded-full h-2">
                <div
                  className={`h-2 rounded-full transition-all duration-300 ${getProgressBarColor(factor.score)}`}
                  style={{ width: `${factor.score}%` }}
                />
              </div>
              <p className="text-xs text-gray-500 mt-1">{factor.reason}</p>
            </div>
          </div>
        ))}
      </div>

      {/* Warnings */}
      {rating.warnings.length > 0 && (
        <div className="mb-6">
          <h4 className="text-lg font-semibold text-red-700 mb-3 flex items-center">
            <span className="mr-2">‚ö†Ô∏è</span>
            Important Considerations
          </h4>
          <ul className="space-y-2">
            {rating.warnings.map((warning, index) => (
              <li key={index} className="flex items-start text-sm text-red-700">
                <span className="mr-2 mt-1">‚Ä¢</span>
                <span>{warning}</span>
              </li>
            ))}
          </ul>
        </div>
      )}

      {/* Strengths */}
      {rating.strengths.length > 0 && (
        <div className="mb-6">
          <h4 className="text-lg font-semibold text-green-700 mb-3 flex items-center">
            <span className="mr-2">‚úÖ</span>
            Recipe Strengths
          </h4>
          <ul className="space-y-2">
            {rating.strengths.map((strength, index) => (
              <li key={index} className="flex items-start text-sm text-green-700">
                <span className="mr-2 mt-1">‚Ä¢</span>
                <span>{strength}</span>
              </li>
            ))}
          </ul>
        </div>
      )}

      {/* Recommendations */}
      {rating.recommendations.length > 0 && (
        <div>
          <h4 className="text-lg font-semibold text-blue-700 mb-3 flex items-center">
            <span className="mr-2">üí°</span>
            Recommendations
          </h4>
          <ul className="space-y-2">
            {rating.recommendations.map((recommendation, index) => (
              <li key={index} className="flex items-start text-sm text-blue-700">
                <span className="mr-2 mt-1">‚Ä¢</span>
                <span>{recommendation}</span>
              </li>
            ))}
          </ul>
        </div>
      )}
    </div>
  );
};
</file>

<file path="components/RatingDistribution.tsx">
import React from 'react';

interface RatingDistributionProps {
  distribution: { [key: number]: number };
  totalReviews: number;
  className?: string;
}

export const RatingDistribution: React.FC<RatingDistributionProps> = ({
  distribution,
  totalReviews,
  className = ''
}) => {
  if (totalReviews === 0) {
    return (
      <div className={`text-center py-8 ${className}`}>
        <p className="text-gray-500">No ratings yet</p>
        <p className="text-sm text-gray-400 mt-1">Be the first to rate this recipe!</p>
      </div>
    );
  }

  return (
    <div className={`space-y-2 ${className}`}>
      {[5, 4, 3, 2, 1].map((stars) => {
        const count = distribution[stars] || 0;
        const percentage = totalReviews > 0 ? (count / totalReviews) * 100 : 0;

        return (
          <div key={stars} className="flex items-center gap-3">
            <div className="flex items-center gap-1 min-w-[60px]">
              <span className="text-sm font-medium text-gray-700">{stars}</span>
              <svg className="w-4 h-4 text-yellow-400 fill-yellow-400" viewBox="0 0 24 24">
                <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
              </svg>
            </div>

            <div className="flex-1 bg-gray-200 rounded-full h-2">
              <div
                className="bg-yellow-400 h-2 rounded-full transition-all duration-300 ease-out"
                style={{ width: `${percentage}%` }}
              />
            </div>

            <div className="min-w-[40px] text-right">
              <span className="text-sm text-gray-600">{count}</span>
            </div>
          </div>
        );
      })}
    </div>
  );
};
</file>

<file path="components/RecipeCard.tsx">
'use client';

import { useState } from 'react';
import Link from 'next/link';
import { Clock, Users } from 'lucide-react';
import { Recipe } from '@/lib/types';
import { CompatibilityBadge } from './CompatibilityBadge';
import { calculateEnhancedCompatibility, type Pet as EnhancedPet } from '@/lib/utils/enhancedCompatibilityScoring';
import type { Pet } from '@/lib/utils/petRatingSystem';
import RecipeScoreModal from './RecipeScoreModal';


interface RecipeCardProps {
  recipe: Recipe;
  pet?: Pet | null;
}

// Helper to convert grade to compatibility level
function gradeToCompatibility(grade: 'A+' | 'A' | 'B+' | 'B' | 'C+' | 'C' | 'D' | 'F'): 'excellent' | 'good' | 'fair' | 'poor' {
  if (grade === 'A+' || grade === 'A') return 'excellent';
  if (grade === 'B+' || grade === 'B') return 'good';
  if (grade === 'C+' || grade === 'C') return 'fair';
  return 'poor';
}

export default function RecipeCard({ recipe, pet }: RecipeCardProps) {
  const [isModalOpen, setIsModalOpen] = useState(false);

  // Calculate compatibility rating if pet is provided
  const enhancedScore = pet ? (() => {
    const enhancedPet: EnhancedPet = {
      id: pet.id,
      name: pet.name,
      type: pet.type as 'dog' | 'cat' | 'bird' | 'reptile' | 'pocket-pet',
      breed: pet.breed,
      age: typeof pet.age === 'string' ? parseFloat(pet.age) || 1 : pet.age || 1,
      weight: pet.weight || pet.weightKg || 10,
      activityLevel: pet.activityLevel,
      healthConcerns: pet.healthConcerns || [],
      dietaryRestrictions: pet.dietaryRestrictions || [],
      allergies: pet.allergies || [],
    };
    return calculateEnhancedCompatibility(recipe, enhancedPet);
  })() : null;
  
  const compatibilityRating = enhancedScore ? {
    overallScore: enhancedScore.overallScore,
    compatibility: gradeToCompatibility(enhancedScore.grade),
    breakdown: enhancedScore.factors,
    warnings: enhancedScore.detailedBreakdown.warnings,
    strengths: enhancedScore.detailedBreakdown.healthBenefits,
    recommendations: enhancedScore.detailedBreakdown.recommendations,
  } : null;

  return (
    <>
      <Link
        href={`/recipe/${recipe.id}${pet ? `?petId=${pet.id}` : ''}`}
        className="group bg-surface rounded-lg shadow-md border border-surface-highlight hover:shadow-lg hover:border-orange-500/50 transition-shadow duration-200 overflow-hidden"
      >
        <div className="bg-surface-highlight px-4 py-3 border-b border-surface-highlight flex items-center justify-between">
          <div className="flex items-center gap-2">
            <div className="text-xs font-semibold text-foreground uppercase tracking-wide">
              {recipe.category}
            </div>
            {(recipe.needsReview === true || (recipe as any).usesFallbackNutrition) && (
              <span className="inline-flex items-center px-2 py-0.5 rounded-full text-[10px] font-medium bg-amber-900/40 text-amber-200 border border-amber-700/50">
                ‚ö†Ô∏è Experimental / Topper Only
              </span>
            )}
          </div>
          <div className="text-[11px] text-gray-400">
            {recipe.servings} servings ‚Ä¢ {recipe.prepTime}
          </div>
        </div>
        <div className="p-4">
          <h3 className="text-xl font-bold text-foreground mb-2 group-hover:text-primary-400 transition-colors">
            {recipe.name}
          </h3>
          <p className="text-gray-400 text-sm mb-4 line-clamp-2">
            {recipe.description}
          </p>

          {/* Explainable scoring */}
          {enhancedScore && (
            <div className="bg-blue-50 border-l-4 border-blue-500 p-4 rounded-r-lg mb-4">
              <div className="flex items-start gap-2">
                <span className="text-lg">‚ÑπÔ∏è</span>
                <p className="text-sm text-blue-900">Compatibility score: {enhancedScore.overallScore}% ({enhancedScore.grade})</p>
              </div>
            </div>
          )}
          {compatibilityRating?.recommendations && compatibilityRating.recommendations.length > 0 && (
            <div className="bg-amber-50 border-l-4 border-amber-500 p-4 rounded-r-lg mb-4">
              <div className="flex items-start gap-2">
                <span className="text-lg">üí°</span>
                <div className="flex-1">
                  <h4 className="font-semibold text-amber-900 mb-2">Suggestions:</h4>
                  <ul className="text-sm text-amber-800 space-y-1">
                    {compatibilityRating.recommendations.map((rec, i) => (
                      <li key={i}>‚Ä¢ {rec}</li>
                    ))}
                  </ul>
                </div>
              </div>
            </div>
          )}


          {/* Meta Information */}
          {(recipe as any).meta && (
            <div className="mb-4 space-y-1">
              {(recipe as any).meta.texture && (
                <div className="text-xs text-gray-500">
                  <span className="font-medium">Texture:</span> {(recipe as any).meta.texture}
                </div>
              )}
              {(recipe as any).meta.estimatedCost && (
                <div className="text-xs text-gray-500">
                  <span className="font-medium">Cost:</span> {(recipe as any).meta.estimatedCost}
                </div>
              )}
              {(recipe as any).meta.shelfLife && (
                <div className="text-xs text-gray-500">
                  <span className="font-medium">Storage:</span> {(recipe as any).meta.shelfLife}
                </div>
              )}
              {(recipe as any).meta.season && (recipe as any).meta.season.length > 0 && (
                <div className="text-xs text-gray-500">
                  <span className="font-medium">Season:</span> {(recipe as any).meta.season.join(', ')}
                </div>
              )}
            </div>
          )}
  
          {/* Compatibility Rating Display */}
          {compatibilityRating && (
            <div className="flex items-center gap-2 mb-3">
              <button
                onClick={(e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  setIsModalOpen(true);
                }}
                className="cursor-pointer"
              >
                <CompatibilityBadge
                  compatibility={compatibilityRating.compatibility}
                  score={compatibilityRating.overallScore}
                />
              </button>
            </div>
          )}

          <div className="flex items-center justify-between text-sm text-gray-500 mb-3">
            <div className="flex items-center gap-1">
              <Clock size={16} />
              <span>{recipe.prepTime}</span>
            </div>
            <div className="flex items-center gap-1">
              <Users size={16} />
              <span>{recipe.servings} servings</span>
            </div>
          </div>
        </div>
      </Link>

      {isModalOpen && (
        <RecipeScoreModal
          recipe={recipe}
          pet={pet}
          onClose={() => setIsModalOpen(false)}
        />
      )}
    </>
  );
}
</file>

<file path="components/RecipeRatingSection.tsx">
import React, { useState, useEffect } from 'react';
import { StarRating } from './StarRating';
import { InteractiveStarRating } from './InteractiveStarRating';
import { RatingDistribution } from './RatingDistribution';
import {
  saveUserRating,
  getUserRating,
  hasUserRated,
  getRecipeRatingData
} from '@/lib/utils/ratings';
import { CheckCircle, X, MessageSquare, ThumbsUp, ThumbsDown } from 'lucide-react';
import { logger } from '@/lib/utils/logger';

interface RecipeRatingSectionProps {
  recipeId: string;
  recipeName: string;
  userId?: string;
  className?: string;
}

export const RecipeRatingSection: React.FC<RecipeRatingSectionProps> = ({
  recipeId,
  recipeName,
  userId,
  className = ''
}) => {
  const [ratingData, setRatingData] = useState({
    averageRating: 0,
    totalReviews: 0,
    distribution: { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 } as { [key: number]: number }
  });
  const [userCurrentRating, setUserCurrentRating] = useState<number | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [message, setMessage] = useState<string | null>(null);
  const [showLoginPrompt, setShowLoginPrompt] = useState(false);
  const [showDetailedReview, setShowDetailedReview] = useState(false);

  // Enhanced feedback state
  const [petAcceptance, setPetAcceptance] = useState<boolean | null>(null);
  const [prepEase, setPrepEase] = useState<number | null>(null);
  const [nutritionOutcome, setNutritionOutcome] = useState<boolean | null>(null);
  const [valueRating, setValueRating] = useState<number | null>(null);
  const [reviewText, setReviewText] = useState('');
  const [modifications, setModifications] = useState('');

  useEffect(() => {
    loadRatingData();
  }, [recipeId]);

  useEffect(() => {
    if (userId) {
      const userRating = getUserRating(userId, recipeId);
      setUserCurrentRating(userRating);
    } else {
      setUserCurrentRating(null);
    }
  }, [userId, recipeId]);

  const loadRatingData = () => {
    const data = getRecipeRatingData(recipeId);
    setRatingData(data);
  };

  const handleRatingSubmit = async (rating: number) => {
    if (!userId) {
      setShowLoginPrompt(true);
      return;
    }

    setIsSubmitting(true);
    setMessage(null);

    try {
      // Save basic rating
      saveUserRating(userId, recipeId, rating);
      setUserCurrentRating(rating);

      // If detailed review is provided, save it too
      if (showDetailedReview && (petAcceptance !== null || prepEase || nutritionOutcome !== null || valueRating || reviewText.trim() || modifications.trim())) {
        const detailedReview = {
          petAcceptance,
          prepEase,
          nutritionOutcome,
          valueRating,
          reviewText: reviewText.trim(),
          modifications: modifications.trim(),
          timestamp: new Date().toISOString()
        };

        // Save detailed review (we'll implement this storage later)
        const existingReviews = JSON.parse(localStorage.getItem(`recipe_reviews_${recipeId}`) || '[]');
        const userReviewIndex = existingReviews.findIndex((r: any) => r.userId === userId);

        if (userReviewIndex >= 0) {
          existingReviews[userReviewIndex] = { ...detailedReview, userId, rating };
        } else {
          existingReviews.push({ ...detailedReview, userId, rating });
        }

        localStorage.setItem(`recipe_reviews_${recipeId}`, JSON.stringify(existingReviews));
      }

      // Reload rating data to show updated averages
      loadRatingData();

      setMessage('Thank you for your feedback! ‚≠ê');
      setTimeout(() => setMessage(null), 3000);

      // Reset form
      setShowDetailedReview(false);
      setPetAcceptance(null);
      setPrepEase(null);
      setNutritionOutcome(null);
      setValueRating(null);
      setReviewText('');
      setModifications('');
    } catch (error) {
      logger.error('Error saving rating:', error);
      setMessage('Failed to save rating. Please try again.');
      setTimeout(() => setMessage(null), 3000);
    } finally {
      setIsSubmitting(false);
    }
  };

  const hasUserAlreadyRated = userId ? hasUserRated(userId, recipeId) : false;

  return (
    <div className={`bg-surface rounded-2xl shadow-lg p-3 border-l-4 border-green-500 border border-surface-highlight ${className}`}>
      <h3 className="text-base font-bold text-green-300 mb-3">Pet Reviews</h3>

      {/* Overall Rating Summary */}
      <div className="flex items-center gap-3 mb-3 p-2 bg-green-900/20 rounded-lg border border-green-700/30">
        <div className="text-center">
          <div className="text-xl font-bold text-green-300">
            {ratingData.averageRating.toFixed(1)}
          </div>
          <StarRating rating={ratingData.averageRating} size="sm" />
          <div className="text-xs text-green-400 mt-1">
            {ratingData.totalReviews} {ratingData.totalReviews === 1 ? 'review' : 'reviews'}
          </div>
        </div>

        {/* Rating Distribution */}
        <div className="flex-1">
          <RatingDistribution
            distribution={ratingData.distribution}
            totalReviews={ratingData.totalReviews}
          />
        </div>
      </div>

      {/* User Rating Section */}
      <div className="border-t border-surface-highlight pt-4">
        <h4 className="text-sm font-semibold text-gray-300 mb-3">
          {hasUserAlreadyRated ? 'Your Rating' : 'Rate This Recipe'}
        </h4>

        {userId ? (
          <div className="space-y-4">
            {hasUserAlreadyRated ? (
              <div className="flex items-center gap-3">
                <span className="text-gray-300 text-sm">You rated this recipe:</span>
                <InteractiveStarRating
                  currentRating={userCurrentRating || 0}
                  onRatingChange={handleRatingSubmit}
                  disabled={isSubmitting}
                />
              </div>
            ) : (
              <div className="space-y-3">
                <div className="space-y-2">
                  <p className="text-gray-300 text-sm">
                    How would you rate "{recipeName}"?
                  </p>
                  <InteractiveStarRating
                    currentRating={userCurrentRating || 0}
                    onRatingChange={handleRatingSubmit}
                    disabled={isSubmitting}
                    size="lg"
                  />
                </div>

                {/* Detailed Review Toggle */}
                <div className="border-t border-green-700/30 pt-2">
                  <button
                    onClick={() => setShowDetailedReview(!showDetailedReview)}
                    className="flex items-center gap-1.5 text-green-400 hover:text-green-300 font-medium text-xs"
                  >
                    <MessageSquare className="w-3.5 h-3.5" />
                    {showDetailedReview ? 'Hide' : 'Add'} Detailed Review
                  </button>
                  <p className="text-[10px] text-gray-500 mt-0.5">
                    Help improve this recipe for other pet parents
                  </p>
                </div>

                {/* Detailed Review Form */}
                {showDetailedReview && (
                  <div className="border border-gray-200 rounded-lg p-4 bg-gray-50 space-y-4">
                    {/* Pet Acceptance */}
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-2">
                        Did your pet eat this meal?
                      </label>
                      <div className="flex gap-4">
                        <button
                          onClick={() => setPetAcceptance(true)}
                          className={`flex items-center gap-2 px-4 py-2 rounded-lg border transition-colors ${
                            petAcceptance === true
                              ? 'bg-green-100 border-green-300 text-green-800'
                              : 'bg-white border-gray-300 text-gray-700 hover:bg-gray-50'
                          }`}
                        >
                          <ThumbsUp className="w-4 h-4" />
                          Yes, ate it all
                        </button>
                        <button
                          onClick={() => setPetAcceptance(false)}
                          className={`flex items-center gap-2 px-4 py-2 rounded-lg border transition-colors ${
                            petAcceptance === false
                              ? 'bg-red-100 border-red-300 text-red-800'
                              : 'bg-white border-gray-300 text-gray-700 hover:bg-gray-50'
                          }`}
                        >
                          <ThumbsDown className="w-4 h-4" />
                          No, refused it
                        </button>
                      </div>
                    </div>

                    {/* Preparation Ease */}
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-2">
                        How easy was this to prepare? (1-5 stars)
                      </label>
                      <InteractiveStarRating
                        currentRating={prepEase || 0}
                        onRatingChange={setPrepEase}
                        disabled={false}
                        size="sm"
                      />
                      <div className="flex justify-between text-xs text-gray-500 mt-1">
                        <span>Very difficult</span>
                        <span>Very easy</span>
                      </div>
                    </div>

                    {/* Nutritional Outcome */}
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-2">
                        Did this meet your nutritional expectations?
                      </label>
                      <div className="flex gap-4">
                        <button
                          onClick={() => setNutritionOutcome(true)}
                          className={`flex items-center gap-2 px-4 py-2 rounded-lg border transition-colors ${
                            nutritionOutcome === true
                              ? 'bg-green-100 border-green-300 text-green-800'
                              : 'bg-white border-gray-300 text-gray-700 hover:bg-gray-50'
                          }`}
                        >
                          <CheckCircle className="w-4 h-4" />
                          Yes, very balanced
                        </button>
                        <button
                          onClick={() => setNutritionOutcome(false)}
                          className={`flex items-center gap-2 px-4 py-2 rounded-lg border transition-colors ${
                            nutritionOutcome === false
                              ? 'bg-yellow-100 border-yellow-300 text-yellow-800'
                              : 'bg-white border-gray-300 text-gray-700 hover:bg-gray-50'
                          }`}
                        >
                          <X className="w-4 h-4" />
                          Could be improved
                        </button>
                      </div>
                    </div>

                    {/* Value Rating */}
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-2">
                        Value for money (1-5 stars)
                      </label>
                      <InteractiveStarRating
                        currentRating={valueRating || 0}
                        onRatingChange={setValueRating}
                        disabled={false}
                        size="sm"
                      />
                      <div className="flex justify-between text-xs text-gray-500 mt-1">
                        <span>Poor value</span>
                        <span>Excellent value</span>
                      </div>
                    </div>

                    {/* Modifications Made */}
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-2">
                        Any modifications you made? (Optional)
                      </label>
                      <textarea
                        value={modifications}
                        onChange={(e) => setModifications(e.target.value)}
                        placeholder="e.g., Added more carrots, reduced protein portion..."
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent"
                        rows={2}
                      />
                    </div>

                    {/* Review Text */}
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-2">
                        Additional feedback (Optional)
                      </label>
                      <textarea
                        value={reviewText}
                        onChange={(e) => setReviewText(e.target.value)}
                        placeholder="Share your experience, tips for other pet parents..."
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent"
                        rows={3}
                      />
                    </div>

                    {/* Submit Button */}
                    <button
                      onClick={() => handleRatingSubmit(userCurrentRating || 0)}
                      disabled={isSubmitting}
                      className="w-full px-6 py-3 bg-primary-600 text-white font-semibold rounded-lg hover:bg-primary-700 disabled:bg-gray-400 transition-colors"
                    >
                      {isSubmitting ? 'Submitting...' : 'Submit Detailed Review'}
                    </button>
                  </div>
                )}
              </div>
            )}

            {isSubmitting && (
              <div className="text-sm text-blue-600">
                Saving your rating...
              </div>
            )}
          </div>
        ) : (
          <div className="text-center py-6">
            <p className="text-gray-600 mb-4">
              Sign in to rate and review recipes
            </p>
            <button
              onClick={() => setShowLoginPrompt(true)}
              className="px-6 py-2 bg-blue-600 text-white font-semibold rounded-lg hover:bg-blue-700 transition-colors"
            >
              Sign In to Rate
            </button>
          </div>
        )}

        {/* Success/Error Messages */}
        {message && (
          <div className={`mt-4 p-3 rounded-lg text-sm font-medium ${
            message.includes('Thank you')
              ? 'bg-green-100 text-green-800'
              : 'bg-red-100 text-red-800'
          }`}>
            {message}
          </div>
        )}

        {/* Login Prompt Modal (simple implementation) */}
        {showLoginPrompt && (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div className="bg-white rounded-xl p-6 max-w-md mx-4">
              <h3 className="text-xl font-bold text-gray-900 mb-4">
                Sign In Required
              </h3>
              <p className="text-gray-600 mb-6">
                You need to be signed in to rate and review recipes. This helps us maintain quality ratings.
              </p>
              <div className="flex gap-3">
                <button
                  onClick={() => setShowLoginPrompt(false)}
                  className="flex-1 px-4 py-2 border border-gray-300 text-gray-700 rounded-lg hover:bg-gray-50"
                >
                  Cancel
                </button>
                <button
                  onClick={() => {
                    // Redirect to sign in page
                    window.location.href = '/sign-in';
                  }}
                  className="flex-1 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
                >
                  Sign In
                </button>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};
</file>

<file path="components/RecipeScoreModal.tsx">
'use client';

import React, { useEffect } from 'react';
import { X, AlertTriangle, CheckCircle, Info, Star } from 'lucide-react';
import type { Pet } from '@/lib/utils/petRatingSystem';
import {
  calculateEnhancedCompatibility,
  type Pet as EnhancedPet,
} from '@/lib/utils/enhancedCompatibilityScoring';
import type { Recipe } from '@/lib/types';
import healthConcerns from '@/lib/data/healthConcerns';
import { actionNeededBeep } from '@/lib/utils/beep';

interface Props {
  recipe: Recipe;
  pet?: Pet | null;
  onClose?: () => void;
}

// simple button style helper (you probably already have similar)
const Btn: React.FC<React.ButtonHTMLAttributes<HTMLButtonElement>> = ({ children, ...p }) => (
  <button {...p} className={`px-3 py-2 rounded-md text-sm font-semibold bg-primary-600 text-white hover:opacity-95 ${p.className ?? ''}`}>
    {children}
  </button>
);

export default function RecipeScoreModal({ recipe, pet, onClose }: Props) {
  // Use improved scoring if available, fallback to original
  let rating: any = null;

  if (pet) {
    try {
      const enhancedPet: EnhancedPet = {
        id: pet.id,
        name: pet.name,
        type: pet.type as 'dog' | 'cat' | 'bird' | 'reptile' | 'pocket-pet',
        breed: pet.breed,
        age: typeof pet.age === 'string' ? parseFloat(pet.age) || 1 : pet.age || 1,
        weight: pet.weight || 10,
        activityLevel: pet.activityLevel,
        healthConcerns: pet.healthConcerns || [],
        dietaryRestrictions: pet.dietaryRestrictions || [],
        allergies: pet.allergies || [],
      };
      const enhancedScore = calculateEnhancedCompatibility(recipe, enhancedPet);
      // Convert enhanced score to expected format
      const stars = Math.round(enhancedScore.overallScore / 20);
      rating = {
        overallScore: enhancedScore.overallScore,
        stars: stars,
        recommendation: enhancedScore.grade === 'A+' || enhancedScore.grade === 'A' ? 'excellent' :
                       enhancedScore.grade === 'B+' || enhancedScore.grade === 'B' ? 'good' :
                       enhancedScore.grade === 'C+' || enhancedScore.grade === 'C' ? 'fair' : 'poor',
        summaryReasoning: `Compatibility score: ${enhancedScore.overallScore}% (${enhancedScore.grade})`,
        compatibility: enhancedScore.grade === 'A+' || enhancedScore.grade === 'A' ? 'excellent' :
                       enhancedScore.grade === 'B+' || enhancedScore.grade === 'B' ? 'good' :
                       enhancedScore.grade === 'C+' || enhancedScore.grade === 'C' ? 'fair' : 'poor',
        breakdown: {
          petTypeMatch: { score: enhancedScore.factors.ingredientSafety.score },
          ageAppropriate: { score: enhancedScore.factors.lifeStageFit.score },
          nutritionalFit: { score: enhancedScore.factors.nutritionalAdequacy.score },
          healthCompatibility: { score: enhancedScore.factors.healthAlignment.score },
          activityFit: { score: enhancedScore.factors.activityFit.score },
          allergenSafety: { score: enhancedScore.factors.allergenSafety.score },
        },
        warnings: enhancedScore.detailedBreakdown.warnings,
        strengths: enhancedScore.detailedBreakdown.healthBenefits,
        recommendations: enhancedScore.detailedBreakdown.recommendations,
      };
    } catch (error) {
      console.error('Error calculating compatibility:', error);
      rating = null;
    }
  }

  if (!rating) {
    return (
      <div className="fixed inset-0 z-50 flex items-center justify-center p-6 bg-black/50 backdrop-blur-sm">
        <div className="w-full max-w-2xl bg-surface rounded-xl shadow-lg border border-surface-highlight p-6">
          <div className="flex justify-between items-center mb-4">
            <h3 className="text-lg font-bold text-foreground">Recipe Compatibility</h3>
            <button onClick={onClose} className="text-gray-400 hover:text-white"><X /></button>
          </div>
          <p className="text-sm text-gray-400">Select a pet to view compatibility details.</p>
        </div>
      </div>
    );
  }

  // Play a short cue when the modal opens to prompt user action.
  useEffect(() => {
    actionNeededBeep();
  }, []);

  const { overallScore, compatibility, breakdown, warnings, strengths, recommendations, stars, summaryReasoning, recommendation } = rating;

  function openAmazon(link: string) {
    if (!link) return;
    // Add affiliate tag to Amazon links
    const affiliateLink = link.includes('amazon.com') && !link.includes('tag=') ?
      link + (link.includes('?') ? '&' : '?') + 'tag=robinfrench-20' : link;
    window.open(affiliateLink, '_blank', 'noopener,noreferrer');
  }

  // Build quick-swap buttons from healthConcerns mapping for relevant pet issues
  const concernRecs = (pet?.healthConcerns || [])
    .map(c => healthConcerns.find(h => h.value === c))
    .filter(Boolean) as (typeof healthConcerns[0])[];

  return (
    <div className="fixed inset-0 z-50 flex items-start justify-center pt-16 px-4 sm:px-6 bg-black/60 backdrop-blur-sm">
      <div className="w-full max-w-3xl bg-surface rounded-xl shadow-2xl overflow-hidden border border-surface-highlight">
        <div className="flex items-start justify-between p-5 border-b border-surface-highlight bg-surface">
          <div>
            <h2 className="text-xl font-bold text-foreground">{recipe.name}</h2>
            <p className="text-sm text-gray-400 mt-1">{recipe.description}</p>
          </div>
          <div className="flex flex-col items-end gap-2">
            <div className="flex items-center gap-2">
              <span className="text-xs text-gray-400">Score</span>
              <div className={`px-3 py-1 rounded-md font-semibold ${overallScore >= 85 ? 'bg-green-900/30 text-green-400 border border-green-800' : overallScore >= 70 ? 'bg-amber-900/30 text-amber-400 border border-amber-800' : 'bg-red-900/30 text-red-400 border border-red-800'}`}>
                {overallScore} / 100
              </div>
            </div>
            <div className="flex items-center gap-1 text-yellow-500" aria-label="star rating">
              {[1,2,3,4,5].map(i => (
                <Star key={i} className={`w-4 h-4 ${stars && i <= stars ? 'fill-yellow-400 text-yellow-400' : 'text-gray-600'}`} />
              ))}
              <span className="text-xs text-gray-400 ml-1">{recommendation || compatibility}</span>
            </div>
            <button onClick={onClose} className="p-2 rounded text-gray-400 hover:bg-surface-highlight hover:text-white">
              <X />
            </button>
          </div>
        </div>

        <div className="p-5 grid grid-cols-1 md:grid-cols-3 gap-4 bg-surface">
          {/* Left: Breakdown */}
          <div className="md:col-span-2">
            <div className="flex items-center justify-between mb-3">
              <h4 className="text-sm font-semibold text-gray-200">Why this score</h4>
            </div>
            {summaryReasoning && (
              <div className="mb-3 text-sm text-gray-300 font-semibold italic">
                {summaryReasoning}
              </div>
            )}
            <div className="space-y-2 text-sm text-gray-400">
              <div className="flex items-center justify-between">
                <div>Ingredient Safety</div>
                <div className="font-mono text-gray-300">{breakdown.petTypeMatch.score}%</div>
              </div>
              <div className="flex items-center justify-between">
                <div>Nutritional Adequacy</div>
                <div className="font-mono text-gray-300">{breakdown.nutritionalFit.score}%</div>
              </div>
              <div className="flex items-center justify-between">
                <div>Health Alignment</div>
                <div className="font-mono text-gray-300">{breakdown.healthCompatibility.score}%</div>
              </div>
              <div className="flex items-center justify-between">
                <div>Life Stage Fit</div>
                <div className="font-mono text-gray-300">{breakdown.ageAppropriate.score}%</div>
              </div>
              <div className="flex items-center justify-between">
                <div>Allergen Safety</div>
                <div className="font-mono text-gray-300">{breakdown.allergenSafety.score}%</div>
              </div>
            </div>

            {/* Strengths */}
            {strengths.length > 0 && (
              <div className="mt-4">
                <h5 className="text-sm font-semibold text-green-400">Strengths</h5>
                <ul className="list-disc ml-5 text-sm text-gray-400">
                  {strengths.map((s: string, i: number) => <li key={i}>{s}</li>)}
                </ul>
              </div>
            )}

            {/* Warnings */}
            {warnings.length > 0 && (
              <div className="mt-4">
                <h5 className="text-sm font-semibold text-red-400">Warnings</h5>
                <ul className="list-disc ml-5 text-sm text-red-300/80">
                  {warnings.map((w: string, i: number) => <li key={i}>{w}</li>)}
                </ul>
              </div>
            )}

            {/* Recommendations (generic) */}
            <div className="mt-4">
              <h5 className="text-sm font-semibold text-gray-200">Quick recommendations</h5>
              <div className="flex flex-wrap gap-2 mt-2">
                {concernRecs.map((c) => (
                  <button
                    key={c.value}
                    onClick={() => {
                      const first = c.recommendedProducts?.[0];
                      if (first?.affiliateUrl) openAmazon(first.affiliateUrl);
                    }}
                    className="px-3 py-1 rounded-md border border-surface-highlight text-sm bg-surface-lighter text-gray-300 hover:bg-surface-highlight hover:text-white"
                    title={c.label}
                  >
                    {c.label} ‚Üí Suggested
                  </button>
                ))}

                <button
                  onClick={() => {
                    openAmazon('https://www.amazon.com/s?k=dog+joint+supplement');
                  }}
                  className="px-3 py-1 rounded-md border border-primary-800 text-sm bg-primary-900/20 text-primary-300 hover:bg-primary-900/40"
                >
                  Browse supplements
                </button>
              </div>
            </div>
          </div>

          {/* Right: Quick edits / portion & swaps */}
          <div>
            <h4 className="text-sm font-semibold mb-2 text-gray-200">Quick fixes</h4>

            <div className="space-y-3 text-sm">
              {/* Portion hint */}
              <div className="p-3 border border-surface-highlight rounded-md bg-surface-lighter">
                <div className="flex items-start gap-2">
                  <Info className="w-5 h-5 text-gray-400" />
                  <div>
                    <div className="text-xs text-gray-500">Portion suggestion</div>
                    <div className="font-semibold text-gray-200">{recipe.servings} serving(s) ‚Äî reduce by 10% if weight loss is target</div>
                  </div>
                </div>
              </div>

              {/* Swap protein (example action) */}
              <div className="p-3 border border-surface-highlight rounded-md bg-surface-lighter">
                <div className="text-xs text-gray-500">Swap protein</div>
                <div className="mt-2 flex gap-2">
                  <button
                    onClick={() => openAmazon('https://www.amazon.com/s?k=novel+protein+venison')}
                    className="px-3 py-1 rounded-md border border-surface-highlight text-gray-300 hover:bg-surface-highlight hover:text-white text-sm"
                  >
                    Venison topper
                  </button>
                  <button
                    onClick={() => openAmazon('https://www.amazon.com/s?k=novel+protein=rabbit')}
                    className="px-3 py-1 rounded-md border border-surface-highlight text-gray-300 hover:bg-surface-highlight hover:text-white text-sm"
                  >
                    Rabbit topper
                  </button>
                </div>
              </div>

              {/* Save recipe to pet quick CTA */}
              <div className="p-3 border border-surface-highlight rounded-md bg-surface-lighter">
                <div className="text-xs text-gray-500">Save / Add</div>
                <div className="mt-2 flex gap-2">
                  <Btn onClick={() => {
                    if (!pet) { alert('Select a pet first'); return; }
                    const key = `saved_recipes_${pet.id}`;
                    const existing = localStorage.getItem(key);
                    const arr = existing ? JSON.parse(existing) : [];
                    if (!arr.find((r:any) => r.id === recipe.id)) {
                      arr.push({ id: recipe.id, name: recipe.name, savedAt: new Date().toISOString() });
                      localStorage.setItem(key, JSON.stringify(arr));
                      alert(`Saved to ${pet.name}`);
                    } else {
                      alert('Already saved');
                    }
                  }}>Add to {pet?.name ?? 'Pet'}</Btn>

                  <button onClick={() => {
                    window.location.href = `/recipe/${recipe.id}?petId=${pet?.id ?? ''}`;
                  }} className="px-3 py-1 rounded-md border border-surface-highlight text-gray-300 hover:bg-surface-highlight hover:text-white">View recipe</button>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div className="p-5 border-t border-surface-highlight bg-surface flex justify-end gap-3">
          <button onClick={onClose} className="px-3 py-2 rounded-md border border-surface-highlight text-gray-300 hover:bg-surface-highlight hover:text-white">Close</button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="components/ScoringProgress.tsx">
// components/ScoringProgress.tsx
// Progress indicator for chunked recipe scoring

'use client';

interface ScoringProgressProps {
  progress: number;
  totalMeals: number;
  scoredCount: number;
  currentRecipe?: string;
}

export default function ScoringProgress({
  progress,
  totalMeals,
  scoredCount,
  currentRecipe,
}: ScoringProgressProps) {
  return (
    <div className="bg-surface rounded-lg shadow-md border border-surface-highlight p-6 mb-6">
      <div className="flex items-center justify-between mb-4">
        <div>
          <h3 className="text-lg font-semibold text-foreground">
            Analyzing Recipes
          </h3>
          <p className="text-sm text-gray-400">
            Finding the best matches for your pet
          </p>
        </div>
        <div className="text-right">
          <div className="text-2xl font-bold text-orange-500">
            {progress}%
          </div>
          <div className="text-xs text-gray-500">complete</div>
        </div>
      </div>

      <div className="mb-4">
        <div className="flex justify-between text-sm text-gray-400 mb-1">
          <span>Progress</span>
          <span>{scoredCount}/{totalMeals} recipes</span>
        </div>
        <div className="w-full bg-gray-200 rounded-full h-3">
          <div
            className="bg-gradient-to-r from-orange-400 to-orange-500 h-3 rounded-full transition-all duration-500 ease-out"
            style={{ width: `${progress}%` }}
          />
        </div>
      </div>

      {currentRecipe && (
        <div className="mb-4 p-3 bg-orange-50 rounded-lg border border-orange-200">
          <div className="flex items-center">
            <div className="mr-3">
              <div className="w-2 h-2 bg-orange-500 rounded-full animate-pulse" />
            </div>
            <div className="flex-1">
              <div className="text-sm font-medium text-gray-800">
                Currently scoring
              </div>
              <div className="text-sm text-gray-600 truncate">
                {currentRecipe}
              </div>
            </div>
          </div>
        </div>
      )}

      <div className="text-xs text-gray-500 text-center">
        Scoring happens in the background ‚Ä¢ You can continue browsing
      </div>
    </div>
  );
}
</file>

<file path="components/SEOHead.tsx">
'use client';

import Head from 'next/head';
import { usePathname } from 'next/navigation';

interface SEOHeadProps {
  title?: string;
  description?: string;
  keywords?: string[];
  structuredData?: any;
  noindex?: boolean;
}

// Client-side SEO component for dynamic pages
export default function SEOHead({ 
  title, 
  description, 
  keywords = [],
  structuredData,
  noindex = false 
}: SEOHeadProps) {
  const pathname = usePathname();
  const baseUrl = 'https://petplatesmealplatform-ldvstwjsy-plateandpaw.vercel.app';
  const canonicalUrl = `${baseUrl}${pathname}`;

  const fullTitle = title 
    ? `${title} | Paw & Plate` 
    : 'Paw & Plate - Fresh Meal Prep for All Pets';

  return (
    <Head>
      <title>{fullTitle}</title>
      {description && <meta name="description" content={description} />}
      {keywords.length > 0 && (
        <meta name="keywords" content={keywords.join(', ')} />
      )}
      <link rel="canonical" href={canonicalUrl} />
      
      {noindex && <meta name="robots" content="noindex,nofollow" />}
      
      {/* Open Graph */}
      <meta property="og:title" content={fullTitle} />
      {description && <meta property="og:description" content={description} />}
      <meta property="og:url" content={canonicalUrl} />
      
      {/* Twitter Card */}
      <meta name="twitter:title" content={fullTitle} />
      {description && <meta name="twitter:description" content={description} />}
      
      {/* Structured Data */}
      {structuredData && (
        <script
          type="application/ld+json"
          dangerouslySetInnerHTML={{
            __html: JSON.stringify(structuredData)
          }}
        />
      )}
    </Head>
  );
}
</file>

<file path="components/ShoppingList.tsx">
'use client';

import { useState, useEffect, useMemo } from 'react';
import { ShoppingCart, CheckCircle } from 'lucide-react';
import { addPurchase } from '@/lib/utils/purchaseTracking';
import { useVillageStore } from '@/lib/state/villageStore';
import { getButtonCopy, trackButtonClick, type ButtonCopyVariant } from '@/lib/utils/abTesting';
import { getProductByIngredient } from '@/lib/data/product-prices';

interface Ingredient {
  id: string;
  name: string;
  amount: string;
  asinLink?: string;
}

interface ShoppingListProps {
  ingredients: Ingredient[];
  recipeName?: string;
  userId?: string;
}

// Helper to get generic ingredient name
function getGenericIngredientName(name: string): string {
  // Remove brand names and product-specific terms
  return name
    .toLowerCase()
    .replace(/freeze[- ]dried/gi, '')
    .replace(/fresh is best/gi, '')
    .replace(/organic/gi, '')
    .replace(/premium/gi, '')
    .replace(/\s+/g, ' ')
    .trim();
}

// Helper to find product data
function getProductData(ingredientName: string) {
  const genericName = getGenericIngredientName(ingredientName);
  
  // Try exact match first
  let product = getProductByIngredient(genericName);
  
  // Try partial match if exact fails
  if (!product) {
    product = getProductByIngredient(genericName);
  }
  
  return product;
}

export function ShoppingList({ 
  ingredients, 
  recipeName = 'this recipe', 
  userId
}: ShoppingListProps) {
  const [isOpening, setIsOpening] = useState(false);
  const [openedCount, setOpenedCount] = useState(0);
  const { refreshFromLocal } = useVillageStore();
  
  const [buttonCopy, setButtonCopy] = useState<ButtonCopyVariant | null>(null);
  const [buyAllCopy, setBuyAllCopy] = useState<ButtonCopyVariant | null>(null);
  
  useEffect(() => {
    setButtonCopy(getButtonCopy(false));
    setBuyAllCopy(getButtonCopy(true));
  }, []);

  const getUserId = () => {
    if (userId) return userId;
    if (typeof window === 'undefined') return '';
    return localStorage.getItem('last_user_id') || '';
  };

  // Process ingredients - get product data from SINGLE SOURCE OF TRUTH
  const shoppingItems = useMemo(() => {
    return ingredients
      .map(ing => {
        const product = getProductByIngredient(ing.name);
        
        if (!product) return null;
        
        return {
          id: ing.id,
          genericName: product.ingredient,
          recipeAmount: ing.amount,
          packageQuantity: product.quantity || '',
          price: product.price.amount,
          asin: product.asin,
          link: product.url,
        };
      })
      .filter(Boolean) as Array<{
        id: string;
        genericName: string;
        recipeAmount: string;
        packageQuantity: string;
        price: number;
        asin: string;
        link: string;
      }>;
  }, [ingredients]);

  const totalPrice = useMemo(() => {
    return shoppingItems.reduce((sum, item) => sum + item.price, 0);
  }, [shoppingItems]);

  const openAllInTabs = async () => {
    setIsOpening(true);
    setOpenedCount(0);
    const currentUserId = getUserId();

    // Open first tab immediately
    if (shoppingItems.length > 0) {
      window.open(shoppingItems[0].link, '_blank');
      setOpenedCount(1);
      if (currentUserId) {
        addPurchase(currentUserId, shoppingItems[0].id, false, shoppingItems[0].genericName);
        refreshFromLocal();
      }
    }

    // Open remaining tabs with delays
    for (let i = 1; i < shoppingItems.length; i++) {
      await new Promise(resolve => setTimeout(resolve, 800));
      const newWindow = window.open(shoppingItems[i].link, '_blank');
      setOpenedCount(i + 1);
      
      if (currentUserId) {
        addPurchase(currentUserId, shoppingItems[i].id, false, shoppingItems[i].genericName);
        refreshFromLocal();
      }
      
      // Retry if blocked
      if (!newWindow || newWindow.closed || typeof newWindow.closed === 'undefined') {
        await new Promise(resolve => setTimeout(resolve, 1000));
        window.open(shoppingItems[i].link, '_blank');
      }
    }

    setTimeout(() => {
      setIsOpening(false);
      setOpenedCount(0);
    }, 1000);
  };

  if (shoppingItems.length === 0) {
    return (
      <div className="bg-surface rounded-lg border border-surface-highlight p-6">
        <p className="text-gray-400">No products available for purchase at this time.</p>
      </div>
    );
  }

  return (
    <div className="bg-surface rounded-lg border border-surface-highlight p-6">
      {/* Header */}
      <div className="flex items-center justify-between mb-4">
        <div>
          <h3 className="text-xl font-bold text-foreground flex items-center gap-2">
            <ShoppingCart size={24} />
            Shopping List
          </h3>
          <p className="text-sm text-gray-400 mt-1">
            {shoppingItems.length} ingredient{shoppingItems.length !== 1 ? 's' : ''} for {recipeName}
          </p>
        </div>
      </div>

      {/* Individual Ingredient List */}
      <div className="space-y-2 mb-6 max-h-96 overflow-y-auto pr-2">
        {shoppingItems.map((item, index) => (
          <div
            key={`${item.id}-${index}`}
            className="flex items-center justify-between gap-3 p-3 bg-surface-lighter rounded-lg border border-surface-highlight hover:border-gray-500 transition-all duration-200"
          >
            <div className="flex-1 min-w-0 pr-2">
              <div className="font-medium text-gray-200 capitalize">{item.genericName}</div>
              <div className="text-sm text-gray-400">
                Recipe needs: {item.recipeAmount}
              </div>
              <div className="text-xs text-gray-500">
                Package size: {item.packageQuantity}
              </div>
            </div>
            
            {/* Price Display */}
            <div className="text-right mr-3">
              <div className="text-lg font-bold text-orange-400">
                ${item.price.toFixed(2)}
              </div>
            </div>
            
            <a
              href={item.link}
              target="_blank"
              rel="noopener noreferrer"
              onClick={() => {
                const currentUserId = getUserId();
                if (currentUserId) {
                  addPurchase(currentUserId, item.id, false, item.genericName);
                  refreshFromLocal();
                }
                if (buttonCopy) {
                  trackButtonClick(buttonCopy.id, 'individual', item.genericName);
                }
              }}
              className="flex items-center gap-2 px-4 py-2 bg-[#FF9900] hover:bg-[#E07704] text-black rounded-lg transition-colors duration-200 text-sm font-semibold whitespace-nowrap"
            >
              <ShoppingCart size={16} />
              {buttonCopy?.text || 'Buy'}
            </a>
          </div>
        ))}
      </div>

      {/* Buy All Button */}
      <div className="border-t border-surface-highlight pt-6">
        <button
          onClick={() => {
            openAllInTabs();
            if (buyAllCopy) {
              trackButtonClick(buyAllCopy.id, 'buy-all');
            }
          }}
          disabled={isOpening}
          className={`w-full py-3 px-6 rounded-lg font-bold text-base transition-colors ${
            isOpening
              ? 'bg-gray-600 cursor-wait text-gray-300'
              : 'bg-[#FF9900] hover:bg-[#E07704] text-black'
          }`}
        >
          {isOpening ? (
            <span className="flex items-center justify-center gap-3">
              <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-white"></div>
              Opening {openedCount}/{shoppingItems.length}...
            </span>
          ) : (
            <span className="flex items-center justify-center gap-2">
              <ShoppingCart size={20} />
              Buy All ({shoppingItems.length} items)
              {totalPrice > 0 && (
                <span className="ml-2 text-xl font-bold">
                  ‚Ä¢ ${totalPrice.toFixed(2)}
                </span>
              )}
            </span>
          )}
        </button>
        
        {/* Value Prop */}
        <div className="mt-3 flex items-center justify-center gap-4 text-xs text-gray-400">
          <span>‚úì Prime eligible</span>
          <span>‚úì Free returns</span>
          <span>‚úì Supports Paw & Plate</span>
        </div>

        {/* Helper Text */}
        <div className="mt-4 space-y-2">
          <div className="flex items-start gap-2 text-sm text-gray-400">
            <CheckCircle size={16} className="text-green-500 mt-0.5 flex-shrink-0" />
            <span>
              Opens {shoppingItems.length} Amazon tabs so you can quickly add all ingredients to your cart
            </span>
          </div>
          
          <div className="flex items-start gap-2 text-sm text-gray-400">
            <CheckCircle size={16} className="text-green-500 mt-0.5 flex-shrink-0" />
            <span>
              <strong>Tip:</strong> If your browser blocks pop-ups, click "Always allow" for this site
            </span>
          </div>
        </div>

        {/* Affiliate Disclosure */}
        <div className="mt-6 p-4 bg-green-900/20 border border-green-700/30 rounded-lg">
          <p className="text-xs text-gray-300 text-center leading-relaxed">
            <span className="font-semibold text-green-400">üíö You're supporting independent pet nutrition!</span><br/>
            As an Amazon Associate, we earn a small commission at no extra cost to you.
          </p>
        </div>
      </div>

      {/* Browser Warning */}
      {isOpening && (
        <div className="mt-4 p-4 bg-yellow-900/30 border border-yellow-700/50 rounded-lg">
          <p className="text-sm text-yellow-200">
            <strong>Browser blocking pop-ups?</strong> Look for a blocked pop-up icon in your address bar 
            and click "Always allow pop-ups from this site"
          </p>
        </div>
      )}
    </div>
  );
}
</file>

<file path="components/ShoppingListSummary.tsx">
'use client';

import { calculateMealsFromGroceryList, type MealEstimate, type ShoppingListItem } from '@/lib/utils/mealEstimation';
import { getProductPrice } from '@/lib/data/product-prices';
import { Info } from 'lucide-react';
import { useState, useMemo } from 'react';

interface ShoppingListSummaryProps {
  shoppingList: ShoppingListItem[];
  className?: string;
}

export function ShoppingListSummary({ shoppingList, className = '' }: ShoppingListSummaryProps) {
  const [showBreakdown, setShowBreakdown] = useState(false);
  
  // Calculate total cost using the same logic as ShoppingList component
  const totalCost = useMemo(() => {
    if (!shoppingList || shoppingList.length === 0) {
      return 0;
    }
    
    return shoppingList.reduce((sum, item) => {
      const price = getProductPrice(item.name);
      if (typeof price === 'number') return sum + price;
      return sum;
    }, 0);
  }, [shoppingList]);

  // Calculate estimate with error handling and memoization
  const estimate = useMemo(() => {
    if (!shoppingList || shoppingList.length === 0) {
      console.log('[ShoppingListSummary] No shopping list provided');
      return null;
    }
    
    console.log('[ShoppingListSummary] Calculating estimate for', shoppingList.length, 'ingredients');
    console.log('[ShoppingListSummary] Shopping list:', shoppingList);
    
    try {
      const result = calculateMealsFromGroceryList(shoppingList);
      console.log('[ShoppingListSummary] Estimate calculated:', result);
      console.log('[ShoppingListSummary] UI totalCost prop (not used):', totalCost);
      return result;
    } catch (error) {
      console.error('[ShoppingListSummary] Error calculating meals:', error);
      return null;
    }
  }, [shoppingList, totalCost]);
  
  // Don't show if no estimate or invalid
  if (!estimate || estimate.estimatedMeals === 0) {
    console.log('[ShoppingListSummary] Showing error fallback - estimate:', estimate, 'estimatedMeals:', estimate?.estimatedMeals);
    // Show fallback message instead of returning null to verify component is being called
    return (
      <div className="bg-red-500 border-2 border-red-700 rounded-xl p-6 text-white">
        <h3 className="text-xl font-bold mb-2">‚ö†Ô∏è Shopping Summary Error</h3>
        <p className="mb-2">Unable to calculate meal estimate</p>
        <details className="text-sm">
          <summary className="cursor-pointer font-semibold mb-2">Debug Info</summary>
          <pre className="bg-red-700 p-2 rounded mt-2 overflow-auto max-h-48 text-xs">
            {JSON.stringify({ 
              estimate, 
              shoppingListLength: shoppingList?.length,
              hasEstimate: !!estimate,
              estimatedMeals: estimate?.estimatedMeals,
              breakdownLength: estimate?.breakdown?.length
            }, null, 2)}
          </pre>
        </details>
        <p className="text-xs mt-2 opacity-90">
          This message indicates the component is rendering but calculation returned {estimate?.estimatedMeals ?? 0} meals.
        </p>
      </div>
    );
  }
  
  return (
    <div className={`bg-gradient-to-r from-green-900/20 to-blue-900/20 rounded-xl p-6 border-2 border-green-700/50 ${className}`}>
      <h3 className="text-2xl font-bold text-green-200 mb-4">Shopping Summary</h3>
      
      <div className="grid md:grid-cols-3 gap-6 mb-4">
        {/* Estimated Meals */}
        <div className="bg-surface rounded-lg p-4 shadow-sm border border-green-700/30">
          <p className="text-sm text-gray-400 mb-1">Estimated Meals</p>
          <p className="text-4xl font-bold text-green-400">{estimate.estimatedMeals}</p>
          <p className="text-xs text-gray-500 mt-1">from these packages</p>
        </div>
        
        {/* Total Cost */}
        <div className="bg-surface rounded-lg p-4 shadow-sm border border-blue-700/30">
          <p className="text-sm text-gray-400 mb-1">Total Cost</p>
          <p className="text-4xl font-bold text-blue-400">${estimate.totalCost.toFixed(2)}</p>
          <p className="text-xs text-gray-500 mt-1">one-time purchase</p>
        </div>
        
        {/* Cost Per Meal */}
        <div className="bg-surface rounded-lg p-4 shadow-sm border border-purple-700/30">
          <p className="text-sm text-gray-400 mb-1">Cost Per Meal</p>
          <p className="text-4xl font-bold text-purple-400">${estimate.costPerMeal.toFixed(2)}</p>
          <p className="text-xs text-gray-500 mt-1">average</p>
        </div>
      </div>
      
      {/* Notes */}
      {estimate.notes && estimate.notes.length > 0 && (
        <div className="bg-blue-900/30 border-l-4 border-blue-500 p-4 rounded-r-lg mb-4">
          <div className="flex items-start gap-2">
            <Info className="text-blue-400 mt-0.5 flex-shrink-0" size={18} />
            <div className="flex-1">
              <p className="text-sm font-semibold text-blue-300 mb-1">Good to know:</p>
              <ul className="text-sm text-blue-200 space-y-1">
                {estimate.notes.map((note, i) => (
                  <li key={i}>‚Ä¢ {note}</li>
                ))}
              </ul>
            </div>
          </div>
        </div>
      )}
      
      {/* Breakdown (collapsible) */}
      <details 
        className="mt-4 cursor-pointer"
        onToggle={(e) => setShowBreakdown((e.target as HTMLDetailsElement).open)}
      >
        <summary className="text-sm font-semibold text-gray-300 hover:text-white transition-colors list-none">
          <span className="flex items-center gap-2">
            <span>{showBreakdown ? '‚ñº' : '‚ñ∂'}</span>
            <span>View detailed breakdown</span>
          </span>
        </summary>
        <div className="mt-3 space-y-2">
          {estimate.breakdown && estimate.breakdown.length > 0 ? (
            estimate.breakdown.map((item, i) => (
              <div key={i} className="bg-surface rounded-lg p-3 text-sm border border-surface-highlight">
                <div className="flex justify-between items-start">
                  <div className="flex-1">
                    <p className="font-medium text-gray-200">{item.ingredient}</p>
                    <p className="text-xs text-gray-500 mt-1">
                      Recipe needs {item.recipeAmount.toFixed(1)}g per meal
                    </p>
                    <p className="text-xs text-gray-500">
                      Package contains {item.packageSize}g ({item.packageSize / 453.592 < 1 ? `${(item.packageSize / 28.3495).toFixed(1)} oz` : `${(item.packageSize / 453.592).toFixed(1)} lb`})
                    </p>
                  </div>
                  <div className="text-right ml-4">
                    <p className="font-semibold text-green-400">
                      ~{Math.round(item.mealsFromPackage)} meals
                    </p>
                    <p className="text-xs text-gray-500">${item.packageCost}</p>
                  </div>
                </div>
              </div>
            ))
          ) : (
            <div className="text-sm text-gray-400 italic">No breakdown available</div>
          )}
        </div>
      </details>
      
      {/* Disclaimer */}
      <p className="text-xs text-gray-500 mt-4 italic">
        * Estimates based on typical package sizes available online. Actual quantities may vary.
      </p>
    </div>
  );
}
</file>

<file path="components/SocialProof.tsx">
'use client';

import React from 'react';
import { Star, Users, ShoppingBag, TrendingUp } from 'lucide-react';

// Social proof component - builds trust BEFORE signup
export default function SocialProof() {
  // Simulated but believable stats (update with real data later)
  const stats = [
    {
      icon: Users,
      value: '12,847',
      label: 'Meals Generated',
      color: 'text-green-400'
    },
    {
      icon: ShoppingBag,
      value: '3,421',
      label: 'Ingredients Purchased',
      color: 'text-orange-400'
    },
    {
      icon: Star,
      value: '4.8/5',
      label: 'Average Rating',
      color: 'text-yellow-400'
    },
    {
      icon: TrendingUp,
      value: '23%',
      label: 'Healthier Pets*',
      color: 'text-blue-400'
    }
  ];

  return (
    <div className="bg-gradient-to-r from-surface/50 to-surface-highlight/50 backdrop-blur-sm rounded-2xl border border-surface-highlight p-8">
      <h3 className="text-2xl font-bold text-white text-center mb-6">
        Join Thousands of Pet Parents
      </h3>
      
      <div className="grid grid-cols-2 md:grid-cols-4 gap-6">
        {stats.map((stat, idx) => {
          const Icon = stat.icon;
          return (
            <div key={idx} className="text-center">
              <div className="flex justify-center mb-3">
                <div className="w-14 h-14 bg-surface rounded-full flex items-center justify-center border border-surface-highlight">
                  <Icon size={28} className={stat.color} />
                </div>
              </div>
              <div className={`text-3xl font-black ${stat.color} mb-1`}>
                {stat.value}
              </div>
              <div className="text-sm text-gray-400">
                {stat.label}
              </div>
            </div>
          );
        })}
      </div>

      <p className="text-xs text-gray-500 text-center mt-6">
        *Based on owner-reported health improvements after switching to fresh meal prep
      </p>
    </div>
  );
}

// Testimonial component (for later use)
export function TestimonialSection() {
  const testimonials = [
    {
      name: "Sarah M.",
      petType: "Golden Retriever",
      text: "My dog lost 5 lbs in 2 months using these meal plans. She's more energetic and her coat is shinier!",
      rating: 5
    },
    {
      name: "Mike T.",
      petType: "Tabby Cat",
      text: "Finally found meal plans that work for my cat's kidney issues. The vet was impressed with the nutritional balance.",
      rating: 5
    },
    {
      name: "Jessica L.",
      petType: "African Grey Parrot",
      text: "Can't believe there's finally a meal planner for birds! My parrot's feathers have never looked better.",
      rating: 5
    }
  ];

  return (
    <div className="bg-surface rounded-2xl border border-surface-highlight p-8">
      <h3 className="text-2xl font-bold text-white text-center mb-8">
        What Pet Parents Are Saying
      </h3>
      
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
        {testimonials.map((testimonial, idx) => (
          <div key={idx} className="bg-surface-highlight rounded-xl p-6 border border-white/5">
            {/* Stars */}
            <div className="flex gap-1 mb-3">
              {[...Array(testimonial.rating)].map((_, i) => (
                <Star key={i} size={16} className="fill-orange-400 text-orange-400" />
              ))}
            </div>
            
            {/* Quote */}
            <p className="text-gray-300 text-sm mb-4 italic leading-relaxed">
              "{testimonial.text}"
            </p>
            
            {/* Author */}
            <div className="border-t border-surface pt-3">
              <p className="text-white font-semibold text-sm">{testimonial.name}</p>
              <p className="text-gray-500 text-xs">{testimonial.petType} owner</p>
            </div>
          </div>
        ))}
      </div>
      
      {/* Trust Badge */}
      <div className="mt-8 pt-6 border-t border-surface-highlight text-center">
        <div className="inline-flex items-center gap-2 bg-green-900/30 border border-green-700/50 rounded-full px-6 py-3">
          <span className="text-2xl">‚úì</span>
          <span className="text-green-400 font-semibold">Vet-Approved Nutrition</span>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="components/StarRating.tsx">
import React from 'react';
import { Star } from 'lucide-react';

interface StarRatingProps {
  rating: number;
  size?: 'sm' | 'md' | 'lg';
  showValue?: boolean;
  className?: string;
}

export const StarRating: React.FC<StarRatingProps> = ({
  rating,
  size = 'md',
  showValue = false,
  className = ''
}) => {

  const sizeClasses = {
    sm: 'w-4 h-4',
    md: 'w-5 h-5',
    lg: 'w-6 h-6'
  };

  const textSizeClasses = {
    sm: 'text-sm',
    md: 'text-base',
    lg: 'text-lg'
  };

  const renderStars = () => {
    const stars = [];
    const fullStars = Math.floor(rating);
    const hasPartialStar = rating % 1 !== 0;
    const emptyStars = 5 - Math.ceil(rating);

    // Full stars
    for (let i = 0; i < fullStars; i++) {
      stars.push(
        <Star
          key={i}
          className={`${sizeClasses[size]} text-yellow-400 fill-yellow-400`}
        />
      );
    }

    // Partial star
    if (hasPartialStar) {
      const partialPercentage = (rating - fullStars) * 100;
      stars.push(
        <div key="partial" className="relative">
          <Star className={`${sizeClasses[size]} text-gray-300`} />
          <div
            className="absolute top-0 left-0 overflow-hidden"
            style={{ width: `${partialPercentage}%` }}
          >
            <Star className={`${sizeClasses[size]} text-yellow-400 fill-yellow-400`} />
          </div>
        </div>
      );
    }

    // Empty stars
    for (let i = 0; i < emptyStars; i++) {
      stars.push(
        <Star
          key={`empty-${i}`}
          className={`${sizeClasses[size]} text-gray-300`}
        />
      );
    }

    return stars;
  };

  return (
    <div className={`flex items-center gap-1 ${className}`}>
      <div className="flex items-center gap-0.5">
        {renderStars()}
      </div>
      {showValue && (
        <span className={`${textSizeClasses[size]} font-semibold text-gray-700 ml-1`}>
          {rating.toFixed(1)}
        </span>
      )}
    </div>
  );
};
</file>

<file path="components/SuggestedIngredients.tsx">
'use client';

import { Info } from 'lucide-react';

interface SuggestedIngredient {
  name: string;
  reason: string;
  category: string;
}

interface SuggestedIngredientsProps {
  suggestions: SuggestedIngredient[];
  onSelect: (ingredientName: string) => void;
  selectedIngredients: string[];
}

export default function SuggestedIngredients({
  suggestions,
  onSelect,
  selectedIngredients
}: SuggestedIngredientsProps) {
  if (suggestions.length === 0) {
    return null;
  }

  // Filter out already selected ingredients
  const availableSuggestions = suggestions.filter(
    sug => !selectedIngredients.includes(sug.name)
  );

  if (availableSuggestions.length === 0) {
    return null;
  }

  return (
    <div className="bg-blue-50 rounded-lg border border-blue-200 p-6">
      <div className="flex items-center gap-2 mb-4">
        <Info size={18} className="text-blue-600" />
        <h3 className="font-semibold text-blue-900 text-lg">Suggested Ingredients</h3>
      </div>
      <p className="text-sm text-blue-800 mb-4">
        These ingredients are recommended for your pet based on their profile:
      </p>
      <div className="space-y-3">
        {availableSuggestions.map((suggestion, idx) => (
          <button
            key={idx}
            onClick={() => onSelect(suggestion.name)}
            className="w-full text-left bg-white rounded-lg border border-blue-200 p-4 hover:border-blue-400 hover:shadow-sm transition-all group"
          >
            <div className="flex items-start justify-between gap-3">
              <div className="flex-1">
                <div className="font-medium text-gray-900 mb-1 group-hover:text-blue-700">
                  {suggestion.name}
                </div>
                <div className="text-xs text-gray-600 leading-relaxed">
                  {suggestion.reason}
                </div>
              </div>
              <div className="flex-shrink-0">
                <span className="text-xs px-2 py-1 bg-blue-100 text-blue-700 rounded-full">
                  {suggestion.category}
                </span>
              </div>
            </div>
          </button>
        ))}
      </div>
    </div>
  );
}
</file>

<file path="components/Tooltip.tsx">
import { ReactNode } from 'react';
import MascotIcon, { MascotName } from './MascotIcon';

interface TooltipProps {
  content: string;
  children: ReactNode;
  className?: string;
  mascot?: MascotName; // Optional mascot face in tooltip header
  wide?: boolean; // Make tooltip extra wide (for nutritional fit, etc.)
}

export default function Tooltip({ content, children, className = '', mascot, wide = false }: TooltipProps) {
  const widthClass = wide ? 'max-w-4xl w-[500px]' : 'max-w-2xl';
  return (
    <div className={`relative group ${className}`}>
      {children}
      {/* Tooltip positioned below the element to avoid cutoff at top */}
      <div className={`absolute top-full left-1/2 transform -translate-x-1/2 mt-2 ${wide ? 'px-4 py-3' : 'px-5 py-4'} bg-surface text-foreground ${wide ? 'text-xs' : 'text-sm'} rounded-xl opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none z-50 ${widthClass} shadow-2xl border-2 border-surface-highlight`}>
        {mascot && (
          <div className="flex items-center gap-2 mb-3 pb-3 border-b border-surface-highlight">
            <MascotIcon mascot={mascot} size={14} />
            <span className="font-semibold text-xs text-foreground">
              {mascot === 'puppy-prepper' && 'Puppy Prepper says'}
              {mascot === 'professor-purrfessor' && 'Professor Purrfessor says'}
              {mascot === 'sherlock-shells' && 'Sherlock Shells says'}
              {mascot === 'farmer-fluff' && 'Farmer Fluff says'}
              {mascot === 'robin-redroute' && 'Robin Redroute says'}
            </span>
          </div>
        )}
        <div className={mascot ? 'text-xs leading-tight text-gray-300' : wide ? 'text-xs leading-tight text-gray-200' : 'text-sm leading-relaxed text-gray-200'} style={{ whiteSpace: 'pre-line' }}>{content}</div>
        {/* Arrow pointing up to the element */}
        <div className="absolute bottom-full left-1/2 transform -translate-x-1/2 border-4 border-transparent border-b-surface-highlight"></div>
      </div>
    </div>
  );
}
</file>

<file path="components/TrustBadges.tsx">
'use client';

import React from 'react';
import { Shield, Award, Heart, CheckCircle } from 'lucide-react';

export default function TrustBadges() {
  const badges = [
    {
      icon: Shield,
      title: 'AAFCO Compliant',
      subtitle: 'Meets nutritional standards',
      color: 'text-green-400'
    },
    {
      icon: Award,
      title: 'WSAVA Guidelines',
      subtitle: 'Veterinary approved',
      color: 'text-blue-400'
    },
    {
      icon: Heart,
      title: 'All Pet Types',
      subtitle: 'Dogs, cats, birds, reptiles',
      color: 'text-orange-400'
    },
    {
      icon: CheckCircle,
      title: 'Science-Backed',
      subtitle: 'Evidence-based nutrition',
      color: 'text-green-400'
    }
  ];

  return (
    <div className="flex flex-wrap justify-center gap-4 py-6">
      {badges.map((badge, idx) => {
        const Icon = badge.icon;
        return (
          <div
            key={idx}
            className="flex items-center gap-3 bg-surface-highlight border border-surface rounded-lg px-4 py-3 hover:border-orange-500/50 transition-colors"
          >
            <Icon className={`${badge.color} flex-shrink-0`} size={24} />
            <div>
              <div className="font-semibold text-white text-sm">{badge.title}</div>
              <div className="text-xs text-gray-400">{badge.subtitle}</div>
            </div>
          </div>
        );
      })}
    </div>
  );
}
</file>

<file path="components/ValidationMessages.tsx">
// components/ValidationMessages.tsx
'use client';

import { AlertCircle, AlertTriangle, CheckCircle } from 'lucide-react';

interface ValidationMessagesProps {
  errors?: string[];
  warnings?: string[];
  success?: string[];
  className?: string;
}

export default function ValidationMessages({
  errors = [],
  warnings = [],
  success = [],
  className = ''
}: ValidationMessagesProps) {
  if (errors.length === 0 && warnings.length === 0 && success.length === 0) {
    return null;
  }

  return (
    <div className={`space-y-2 ${className}`}>
      {/* Success Messages */}
      {success.length > 0 && (
        <div className="bg-green-50 border border-green-200 rounded-lg p-3">
          <div className="flex items-start gap-2">
            <CheckCircle className="w-5 h-5 text-green-600 flex-shrink-0 mt-0.5" />
            <div className="flex-1">
              <h4 className="text-sm font-medium text-green-800 mb-1">Success</h4>
              <ul className="text-sm text-green-700 space-y-1">
                {success.map((msg, index) => (
                  <li key={index}>‚Ä¢ {msg}</li>
                ))}
              </ul>
            </div>
          </div>
        </div>
      )}

      {/* Error Messages */}
      {errors.length > 0 && (
        <div className="bg-red-50 border border-red-200 rounded-lg p-3">
          <div className="flex items-start gap-2">
            <AlertCircle className="w-5 h-5 text-red-600 flex-shrink-0 mt-0.5" />
            <div className="flex-1">
              <h4 className="text-sm font-medium text-red-800 mb-1">Errors</h4>
              <ul className="text-sm text-red-700 space-y-1">
                {errors.map((error, index) => (
                  <li key={index}>‚Ä¢ {error}</li>
                ))}
              </ul>
            </div>
          </div>
        </div>
      )}

      {/* Warning Messages */}
      {warnings.length > 0 && (
        <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-3">
          <div className="flex items-start gap-2">
            <AlertTriangle className="w-5 h-5 text-yellow-600 flex-shrink-0 mt-0.5" />
            <div className="flex-1">
              <h4 className="text-sm font-medium text-yellow-800 mb-1">Warnings</h4>
              <ul className="text-sm text-yellow-700 space-y-1">
                {warnings.map((warning, index) => (
                  <li key={index}>‚Ä¢ {warning}</li>
                ))}
              </ul>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="components/VillageBackground.tsx">
'use client';

import React from 'react';
import { VillageLevel } from '@/lib/data/villageLevels';

export interface VillageBackgroundProps {
  villageLevel: VillageLevel;
  className?: string;
}

/**
 * Renders background based on village level
 * Handles parallax scrolling effects
 */
export default function VillageBackground({
  villageLevel,
  className = ''
}: VillageBackgroundProps) {
  const { palette, environment } = villageLevel;
  
  // Create gradient from palette colors
  const gradientColors = `${palette.background}, ${palette.accent}, ${palette.neutral}`;
  const backgroundStyle = {
    background: `linear-gradient(135deg, ${gradientColors})`,
    minHeight: '400px'
  };

  return (
    <div
      className={`relative overflow-hidden rounded-2xl ${className}`}
      style={backgroundStyle}
      role="img"
      aria-label={`Village background: ${environment}`}
    >
      {/* Sky gradient */}
      <div
        className="absolute inset-0 opacity-80"
        style={{
          background: `linear-gradient(to bottom, ${palette.accent} 0%, ${palette.background} 100%)`
        }}
      />
      
      {/* Ground/landscape */}
      <div
        className="absolute bottom-0 left-0 right-0 h-1/3"
        style={{
          background: `linear-gradient(to top, ${palette.neutral} 0%, transparent 100%)`
        }}
      />
      
      {/* Environmental features as decorative elements */}
      <div className="absolute inset-0 flex items-end justify-center pb-8">
        <div className="text-center text-white/60 text-sm font-semibold">
          {villageLevel.buildings.map((building, idx) => (
            <span key={idx} className="mx-2">
              {building}
            </span>
          ))}
        </div>
      </div>
      
      {/* Parallax layers for depth */}
      <div
        className="absolute inset-0 opacity-20"
        style={{
          backgroundImage: 'radial-gradient(circle at 20% 50%, rgba(255,255,255,0.3) 0%, transparent 50%)',
          backgroundSize: '200% 200%',
          animation: 'float 20s ease-in-out infinite'
        }}
      />
    </div>
  );
}
</file>

<file path="components/VillageBuildings.tsx">
'use client';

import React from 'react';
import { VillageLevel } from '@/lib/data/villageLevels';
import PuppyPreper from './mascots/PuppyPreper';
import ProfessorPurrfessor from './mascots/ProfessorPurrfessor';
import RobinRedroute from './mascots/RobinRedroute';
import SherlockShells from './mascots/SherlockShells';
import FarmerFluff from './mascots/FarmerFluff';

export interface VillageBuildingsProps {
  villageLevel: VillageLevel;
  activity?: 'idle' | 'active';
  className?: string;
}

/**
 * Renders buildings appropriate for current level
 * Positions mascots near their "work areas"
 */
export default function VillageBuildings({
  villageLevel,
  activity = 'idle',
  className = ''
}: VillageBuildingsProps) {
  const { buildings, mascotStates } = villageLevel;

  // Building positions in a grid layout
  const buildingPositions = [
    { id: 'dog', x: '10%', y: '60%' },
    { id: 'cat', x: '30%', y: '60%' },
    { id: 'bird', x: '50%', y: '50%' },
    { id: 'turtle', x: '70%', y: '60%' },
    { id: 'hamster', x: '90%', y: '60%' }
  ];

  const getMascotComponent = (id: string) => {
    switch (id) {
      case 'dog':
        return <PuppyPreper size={100} activity={activity} />;
      case 'cat':
        return <ProfessorPurrfessor size={100} activity={activity} />;
      case 'bird':
        return <RobinRedroute size={100} activity={activity} />;
      case 'turtle':
        return <SherlockShells size={100} activity={activity} />;
      case 'hamster':
        return <FarmerFluff size={100} activity={activity} />;
      default:
        return null;
    }
  };

  const getBuildingStyle = (level: number) => {
    // Building size and complexity increases with level
    const baseSize = 80 + (level * 10);
    const height = baseSize + (level * 20);
    
    return {
      width: `${baseSize}px`,
      height: `${height}px`,
      borderRadius: level > 2 ? '8px' : '4px',
      boxShadow: level > 1 
        ? '0 8px 16px rgba(0,0,0,0.3)' 
        : '0 4px 8px rgba(0,0,0,0.2)'
    };
  };

  return (
    <div className={`relative w-full h-full ${className}`}>
      {buildingPositions.map((pos) => {
        // Get building type from buildings array (use first building as default)
        const buildingType = buildings[0] || 'strawHut';
        // Get mascot activity state
        const activityDesc = mascotStates[pos.id] || 'idle';
        const level = villageLevel.id;
        
        return (
          <div
            key={pos.id}
            className="absolute"
            style={{
              left: pos.x,
              top: pos.y,
              transform: 'translate(-50%, -50%)'
            }}
          >
            {/* Building structure */}
            <div
              className="relative"
              style={getBuildingStyle(level)}
            >
              {/* Building base */}
              <div
                className="absolute inset-0"
                style={{
                  background: level > 2
                    ? 'linear-gradient(135deg, #8B7355 0%, #6B5B4D 100%)'
                    : level > 0
                    ? 'linear-gradient(135deg, #A0826D 0%, #8B7355 100%)'
                    : 'linear-gradient(135deg, #C4A484 0%, #A0826D 100%)',
                  border: '2px solid rgba(0,0,0,0.2)',
                  borderRadius: level > 2 ? '8px' : '4px'
                }}
              />
              
              {/* Building roof/window details based on level */}
              {level > 0 && (
                <div
                  className="absolute top-0 left-0 right-0"
                  style={{
                    height: '30%',
                    background: level > 2
                      ? 'linear-gradient(135deg, #654321 0%, #4A2C1A 100%)'
                      : 'linear-gradient(135deg, #8B4513 0%, #654321 100%)',
                    borderRadius: level > 2 ? '8px 8px 0 0' : '4px 4px 0 0'
                  }}
                />
              )}
              
              {/* Windows for higher levels */}
              {level > 1 && (
                <>
                  <div
                    className="absolute"
                    style={{
                      top: '40%',
                      left: '20%',
                      width: '20%',
                      height: '20%',
                      background: 'rgba(255, 255, 200, 0.8)',
                      borderRadius: '2px',
                      border: '1px solid rgba(0,0,0,0.2)'
                    }}
                  />
                  <div
                    className="absolute"
                    style={{
                      top: '40%',
                      right: '20%',
                      width: '20%',
                      height: '20%',
                      background: 'rgba(255, 255, 200, 0.8)',
                      borderRadius: '2px',
                      border: '1px solid rgba(0,0,0,0.2)'
                    }}
                  />
                </>
              )}
              
              {/* Mascot positioned in front of building */}
              <div
                className="absolute"
                style={{
                  bottom: '-20px',
                  left: '50%',
                  transform: 'translateX(-50%)',
                  zIndex: 10
                }}
                title={activityDesc}
              >
                {getMascotComponent(pos.id)}
              </div>
            </div>
            
            {/* Building label */}
            <div
              className="absolute -bottom-8 left-1/2 transform -translate-x-1/2 text-xs text-white/80 font-semibold whitespace-nowrap"
              style={{ textShadow: '0 1px 2px rgba(0,0,0,0.5)' }}
            >
              {buildingType.split(' ')[0]} {/* First word of building type */}
            </div>
          </div>
        );
      })}
    </div>
  );
}
</file>

<file path="components/VillagePlaceholder.tsx">
'use client';

import React, { useEffect, useState } from 'react';
import { Construction, Sparkles, ShoppingCart } from 'lucide-react';
import { getPurchaseStats } from '@/lib/utils/purchaseTracking';
import { useVillageStore, useVillageProgress } from '@/lib/state/villageStore';

interface VillagePlaceholderProps {
  className?: string;
  userId?: string;
}

export default function VillagePlaceholder({ className = '', userId }: VillagePlaceholderProps) {
  const { setUserId, refreshFromLocal } = useVillageStore();
  const { count, level, progress, nextLevelThreshold, ingredientsRemaining, progressPercent } = useVillageProgress();
  const [isClient, setIsClient] = useState(false);
  const [currentUserId, setCurrentUserId] = useState<string>('');

  // Only access localStorage on client side to prevent hydration mismatch
  useEffect(() => {
    setIsClient(true);
    const id = userId || (typeof window !== 'undefined' ? localStorage.getItem('last_user_id') || '' : '');
    setCurrentUserId(id);
    if (id) {
      setUserId(id);
    }
  }, [userId, setUserId]);

  // Get stats only on client
  const stats = isClient && currentUserId ? getPurchaseStats(currentUserId) : null;

  return (
    <div className={`bg-gradient-to-br from-amber-50 to-orange-50 rounded-2xl shadow-lg border-2 border-amber-200 p-8 ${className}`}>
      <div className="flex flex-col items-center justify-center text-center space-y-4">
        <div className="relative">
          <Construction size={64} className="text-amber-600 animate-pulse" />
          <Sparkles 
            size={32} 
            className="absolute -top-2 -right-2 text-yellow-400 animate-spin" 
            style={{ animationDuration: '3s' }}
          />
        </div>
        <div>
          <h3 className="text-2xl font-bold text-gray-900 mb-2">
            {level ? `${level.name} Village` : 'Mascot Village Coming Soon!'}
          </h3>
          <p className="text-gray-700 max-w-md">
            {level 
              ? `${level.name} - ${level.buildings.join(', ')}`
              : 'Watch your village grow as you purchase ingredients! The more you shop, the more your mascots\' village evolves.'
            }
          </p>
        </div>

        {/* Purchase Stats - Only render on client to prevent hydration mismatch */}
        {isClient && currentUserId && (
          <div className="mt-4 w-full max-w-md space-y-3">
            <div className="p-4 bg-white/60 rounded-lg border border-amber-200">
              <div className="flex items-center justify-center gap-2 mb-2">
                <ShoppingCart size={20} className="text-amber-600" />
                <span className="text-lg font-bold text-gray-900">
                  {count} Ingredient{count !== 1 ? 's' : ''} Purchased
                </span>
              </div>
              {stats && stats.pendingPurchases > 0 && (
                <p className="text-sm text-amber-700">
                  {stats.pendingPurchases} pending confirmation
                </p>
              )}
            </div>

            {/* Progress to Next Level */}
            {ingredientsRemaining > 0 && ingredientsRemaining <= 10 && (
              <div className="p-4 bg-white/60 rounded-lg border border-amber-200">
                <p className="text-sm font-semibold text-gray-900 mb-2">
                  Progress to Next Level: {progress}/10
                </p>
                <div className="w-full bg-gray-200 rounded-full h-3 mb-2">
                  <div
                    className="bg-gradient-to-r from-amber-500 to-orange-500 h-3 rounded-full transition-all duration-500"
                    style={{ width: `${progressPercent}%` }}
                  />
                </div>
                <p className="text-xs text-gray-600">
                  {ingredientsRemaining} more ingredient{ingredientsRemaining !== 1 ? 's' : ''} to unlock the next level!
                </p>
              </div>
            )}

            {ingredientsRemaining === 0 && (
              <div className="p-4 bg-green-50 rounded-lg border border-green-200">
                <p className="text-sm font-semibold text-green-900">
                  üéâ Maximum level reached! Your village is complete!
                </p>
              </div>
            )}
          </div>
        )}

        <div className="mt-4 p-4 bg-white/60 rounded-lg border border-amber-200">
          <p className="text-sm text-gray-600">
            <strong>How it works:</strong> Each ingredient purchase helps build the village. 
            Purchase 10 ingredients to unlock the next level!
          </p>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="components/VillageScene.tsx">
'use client';

import React, { useEffect, useState } from 'react';
import { useVillageStore, useVillageProgress } from '@/lib/state/villageStore';
import VillageBackground from './VillageBackground';
import VillageBuildings from './VillageBuildings';

export interface VillageSceneProps {
  userId?: string;
  className?: string;
}

/**
 * Main village component that renders the entire scene
 * Uses Zustand store for reactive state management
 */
export default function VillageScene({
  userId,
  className = ''
}: VillageSceneProps) {
  const { setUserId, refreshFromLocal } = useVillageStore();
  const { count, level, progress } = useVillageProgress();
  const [activity, setActivity] = useState<'idle' | 'active'>('idle');

  // Get userId from localStorage if not provided
  const getUserId = () => {
    if (userId) return userId;
    if (typeof window === 'undefined') return '';
    return localStorage.getItem('last_user_id') || '';
  };

  useEffect(() => {
    const currentUserId = getUserId();
    if (currentUserId) {
      setUserId(currentUserId);
    }
  }, [userId, setUserId]);

  // Alternate between idle and active every 5 seconds
  useEffect(() => {
    const interval = setInterval(() => {
      setActivity(prev => prev === 'idle' ? 'active' : 'idle');
    }, 5000);
    
    return () => clearInterval(interval);
  }, []);

  if (!level) {
    return (
      <div className={`bg-gray-100 rounded-2xl p-8 text-center ${className}`}>
        <p className="text-gray-600">Loading village...</p>
      </div>
    );
  }

  return (
    <div className={`relative ${className}`}>
      {/* Village Level Badge */}
      <div className="absolute top-4 left-4 z-20">
        <div className="bg-white/90 backdrop-blur-sm rounded-lg px-4 py-2 shadow-lg border-2 border-amber-300">
          <div className="text-xs font-semibold text-gray-600 uppercase tracking-wide">
            {level.name} Village
          </div>
          <div className="text-lg font-bold text-gray-900">
            Level {level.id}
          </div>
          <div className="text-xs text-gray-600 mt-1">
            {count} ingredient{count !== 1 ? 's' : ''} purchased
          </div>
        </div>
      </div>

      {/* Progress to Next Level */}
      {progress < 10 && (
        <div className="absolute top-4 right-4 z-20">
          <div className="bg-white/90 backdrop-blur-sm rounded-lg px-4 py-2 shadow-lg border-2 border-amber-300">
            <div className="text-xs font-semibold text-gray-600 mb-1">
              Progress: {progress}/10
            </div>
            <div className="w-32 bg-gray-200 rounded-full h-2">
              <div
                className="bg-gradient-to-r from-amber-500 to-orange-500 h-2 rounded-full transition-[width] duration-500 ease-out will-change-[width]"
                style={{ width: `${(progress / 10) * 100}%` }}
              />
            </div>
          </div>
        </div>
      )}

      {/* Village Background */}
      <VillageBackground villageLevel={level} className="h-96" />

      {/* Village Buildings with Mascots */}
      <div className="absolute inset-0 z-10">
        <VillageBuildings
          villageLevel={level}
          activity={activity}
          className="h-full"
        />
      </div>

      {/* Village Description */}
      <div className="absolute bottom-4 left-4 right-4 z-20">
        <div className="bg-white/90 backdrop-blur-sm rounded-lg px-4 py-3 shadow-lg border-2 border-amber-300">
          <p className="text-sm text-gray-700 font-medium">
            {level.name} - {level.buildings.join(', ')}
          </p>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="config/deploy.yml">
name: Deploy Next.js to GitHub Pages

on:
  push:
    branches:
      - main

permissions:
  contents: write

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Setup Node.js environment
        uses: actions/setup-node@v3
        with:
          node-version: 20

      - name: Install dependencies
        run: npm install

      - name: Build static site
        run: npm run build

      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./out
</file>

<file path="config/firestore.rules">
// firestore.rules
// Firestore Security Rules for Pet Plates

rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    function isValidPet(pet) {
      return pet.keys().hasAll(['id', 'names', 'type', 'breed', 'age']) &&
             pet.names is list &&
             pet.names.size() > 0 &&
             pet.type in ['dogs', 'cats', 'birds', 'reptiles', 'pocket-pets'] &&
             pet.age in ['baby', 'young', 'adult', 'senior'];
    }
    
    function isValidMeal(meal) {
      return meal.keys().hasAll(['id', 'petId', 'userId', 'name', 'ingredients', 'analysis']) &&
             meal.ingredients is list &&
             meal.ingredients.size() > 0;
    }
    
    // App artifacts structure: artifacts/{appId}/users/{userId}
    match /artifacts/{appId}/users/{userId} {
      
      // Pets collection
      match /pets/{petId} {
        // Read: only owner
        allow read: if isOwner(userId);
        
        // Create: only owner, must be valid
        allow create: if isOwner(userId) && isValidPet(request.resource.data);
        
        // Update: only owner, must remain valid
        allow update: if isOwner(userId) && isValidPet(request.resource.data);
        
        // Delete: only owner
        allow delete: if isOwner(userId);
      }
      
      // Custom meals collection
      match /custom_meals/{mealId} {
        // Read: only owner
        allow read: if isOwner(userId);
        
        // Create: only owner, must be valid
        allow create: if isOwner(userId) && 
                         isValidMeal(request.resource.data) &&
                         request.resource.data.userId == userId;
        
        // Update: only owner, must remain valid
        allow update: if isOwner(userId) && 
                         isValidMeal(request.resource.data) &&
                         request.resource.data.userId == userId;
        
        // Delete: only owner
        allow delete: if isOwner(userId);
      }
    }
    
    // Deny all other access
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
</file>

<file path="config/globals.d.ts">
declare const __app_id: string;
declare const __firebase_config: string;
declare const __initial_auth_token: string;
</file>

<file path="config/tailwind.config.ts">
import type { Config } from "tailwindcss";

const config: Config = {
  content: [
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  safelist: [
    'text-[#0f2c0f]',
  ],
  corePlugins: {
    // Disable filter utilities to prevent any filter-related CSS from being generated
    filter: false,
    backdropFilter: false,
  },
  theme: {
    extend: {
      colors: {
        background: 'rgb(var(--background-start-rgb))',
        foreground: 'rgb(var(--foreground-rgb))',
        'dark-green': '#0f2c0f',
        surface: {
           DEFAULT: '#143424', // Slightly lighter than background (approx rgb(20, 52, 36))
           highlight: '#1e4a36',
           lighter: '#2a6148',
        },
        primary: {
          50: '#f0fdf4',
          100: '#dcfce7',
          200: '#bbf7d0',
          300: '#86efac',
          400: '#4ade80',
          500: '#22c55e',
          600: '#16a34a',
          700: '#15803d',
          800: '#166534',
          900: '#14532d',
        },
        secondary: {
          50: '#fff7ed',
          100: '#ffedd5',
          200: '#fed7aa',
          300: '#fdba74',
          400: '#fb923c',
          500: '#f97316',
          600: '#ea580c',
          700: '#c2410c',
          800: '#9a3412',
          900: '#7c2d12',
        },
      },
    },
  },
  plugins: [],
};
export default config;
</file>

<file path="config/vitest.config.ts">
import { defineConfig } from 'vitest/config';
import path from 'path';

export default defineConfig({
  test: {
    environment: 'jsdom',
    include: ['**/*.{test,spec}.{js,mjs,cjs,ts,mts,cts,jsx,tsx}'],
    exclude: ['**/node_modules/**', '**/dist/**', '.{idea,git,cache,output,temp}/**'],
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './'),
    },
  },
});
</file>

<file path="hooks/useAsyncOperation.ts">
// hooks/useAsyncOperation.ts
// Custom hook for handling async operations with loading/error states

import { useState, useCallback } from 'react';
import { handleError, getErrorMessage } from '@/lib/utils/errorHandler';

interface AsyncOperationState<T> {
  data: T | null;
  loading: boolean;
  error: string | null;
}

export function useAsyncOperation<T, Args extends any[]>(
  asyncFn: (...args: Args) => Promise<T>
) {
  const [state, setState] = useState<AsyncOperationState<T>>({
    data: null,
    loading: false,
    error: null,
  });

  const execute = useCallback(
    async (...args: Args) => {
      setState({ data: null, loading: true, error: null });
      
      try {
        const result = await asyncFn(...args);
        setState({ data: result, loading: false, error: null });
        return result;
      } catch (error) {
        const appError = handleError(error);
        const errorMessage = getErrorMessage(appError);
        setState({ data: null, loading: false, error: errorMessage });
        throw appError;
      }
    },
    [asyncFn]
  );

  const reset = useCallback(() => {
    setState({ data: null, loading: false, error: null });
  }, []);

  return {
    ...state,
    execute,
    reset,
  };
}
</file>

<file path="hooks/useOfflineDetector.ts">
// hooks/useOfflineDetector.ts
// Hook to detect online/offline status

import { useState, useEffect } from 'react';

export function useOfflineDetector() {
  const [isOnline, setIsOnline] = useState<boolean>(
    typeof window !== 'undefined' ? navigator.onLine : true
  );

  useEffect(() => {
    const handleOnline = () => {
      setIsOnline(true);
      console.log('App is online');
    };

    const handleOffline = () => {
      setIsOnline(false);
      console.log('App is offline');
    };

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  return { isOnline, isOffline: !isOnline };
}
</file>

<file path="hooks/useProgressiveMealCount.ts">
import { useState, useEffect } from 'react';

interface UseProgressiveMealCountOptions {
  target: number;
  duration?: number; // Animation duration in milliseconds
  steps?: number; // Number of animation steps
}

interface UseProgressiveMealCountResult {
  displayCount: number;
  isCounting: boolean;
}

/**
 * Hook that animates a count from 0 to target over a specified duration.
 * 
 * This creates an engaging UX where the count appears to be "searching" and
 * counting up in real-time.
 * 
 * @param options Configuration options
 * @returns Current display count and whether counting is in progress
 */
export function useProgressiveMealCount({
  target,
  duration = 1000,
  steps = 20,
}: UseProgressiveMealCountOptions): UseProgressiveMealCountResult {
  const [displayCount, setDisplayCount] = useState(0);
  const [isCounting, setIsCounting] = useState(true);

  useEffect(() => {
    if (target === 0) {
      setDisplayCount(0);
      setIsCounting(false);
      return;
    }

    setIsCounting(true);
    let current = 0;
    const increment = Math.ceil(target / steps);
    const stepDuration = duration / steps;

    const timer = setInterval(() => {
      current += increment;
      if (current >= target) {
        current = target;
        clearInterval(timer);
        setIsCounting(false);
      }
      setDisplayCount(current);
    }, stepDuration);

    return () => clearInterval(timer);
  }, [target, duration, steps]);

  return { displayCount, isCounting };
}
</file>

<file path="lib/analyzeCustomMeal.ts">
// lib/analyzeCustomMeal.ts

// Gamified custom meal analysis engine for PetPlates

// - Exports generateCustomMealAnalysis(petProfile, selections)

// - Returns a pet-specific, gamified MealAnalysis (score 0..100)

// - Uses INGREDIENT_COMPOSITIONS for per-100g nutrient values

//

// Replace / extend species rules with your canonical FEDIAF/AAFCO tables when ready.

import { INGREDIENT_COMPOSITIONS, type IngredientComposition } from '@/lib/data/ingredientCompositions';
import { getIngredientDisplayName } from '@/lib/utils/allIngredients';

export type Species =
  | 'dog'
  | 'cat'
  | 'bearded-dragon'
  | 'parrot'
  | 'guinea-pig'
  | 'hamster'
  | string;

export type PetProfile = {
  id?: string;
  name?: string;
  species: Species;
  lifeStage?: string; // e.g., 'adult', 'juvenile', 'pregnant'
  weightKg?: number;
  allergies?: string[]; // ingredient keys or names
  meds?: string[]; // medication identifiers (optional)
  activity?: 'low' | 'moderate' | 'high';
};

export type IngredientSelection = {
  key: string; // composition key or display name (we attempt mapping)
  grams: number;
};

export type WarningItem = {
  id?: string;
  ingredientKey?: string;
  ingredientName?: string;
  message: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
};

export type Suggestion = {
  message: string;
  action?: string; // e.g., "add_calcium", "reduce_liver", "swap_to_bsfl"
  confidence?: 'low' | 'medium' | 'high';
};

export type MealAnalysis = {
  nutrients: Record<string, number>; // totals for entire serving analyzed (mg/g units per chosen keys)
  totalRecipeGrams: number;
  energyDensityKcalPerGram: number;
  recommendedServingGrams: number;
  score: number; // 0..100 gamified
  breakdown: {
    nutrientCoverageScore: number; // 0..100
    toxicityPenalty: number; // 0..100 (penalty applied)
    balanceVarietyScore: number; // 0..100
  };
  toxicityWarnings: WarningItem[];
  allergyWarnings: WarningItem[];
  nutrientWarnings: WarningItem[]; // deficiencies / excesses
  suggestions: Suggestion[];
  // Legacy fields for backward compatibility
  dmNutrients?: Record<string, number>;
  dryMatterPercent?: number;
  totalWeight_g?: number;
  caToPratio?: number;
  deficiencies?: string[];
  excesses?: string[];
  adequacies?: string[];
  scoreBreakdown?: {
    baseScore?: number;
    nutritionPenalty?: number;
    balancePenalty?: number;
  };
};

// ---------- Helper accesses ----------

function safeGetIngredient(key: string) {
  // Try direct key then fallback to slugified match by name
  const direct = (INGREDIENT_COMPOSITIONS as Record<string, any>)[key];
  if (direct) return direct;
  
  const slug = key.toLowerCase().replace(/\s+/g, '_').replace(/[^a-z0-9_]/g, '');
  const bySlug = (INGREDIENT_COMPOSITIONS as Record<string, any>)[slug];
  if (bySlug) return bySlug;
  
  // Try name match
  const values = Object.values(INGREDIENT_COMPOSITIONS) as any[];
  const found = values.find(v => (v.name || '').toLowerCase() === key.toLowerCase());
  if (found) return found;
  
  // Common fallback mappings for missing ingredients
  const fallbackMappings: Record<string, string> = {
    'salmon_oil': 'fish_oil',
    'herring_oil': 'fish_oil',
    'mackerel_oil': 'fish_oil',
    'sardine_oil': 'fish_oil',
    'cod_liver_oil': 'fish_oil',
    'olive_oil': 'fish_oil',
    'coconut_oil': 'fish_oil',
    'avocado_oil': 'fish_oil',
    'ground_chicken': 'chicken_breast',
    'ground_turkey': 'turkey_breast',
    'ground_beef': 'ground_beef_lean',
    'white_rice': 'brown_rice_cooked',
    'pumpkin_puree': 'sweet_potato',
  };
  
  const fallback = fallbackMappings[slug] || fallbackMappings[key.toLowerCase()];
  if (fallback && (INGREDIENT_COMPOSITIONS as Record<string, any>)[fallback]) {
    return (INGREDIENT_COMPOSITIONS as Record<string, any>)[fallback];
  }
  
  // Return a minimal placeholder instead of throwing - allows scoring to continue
  // Ingredient not found in composition DB - using placeholder
  return {
    protein: 0,
    fat: 0,
    calcium: 0,
    phosphorus: 0,
    moisture: 0,
    kcal: 0,
    name: key
  };
}

// ---------- Basic nutrition math ----------
  
function sumRecipeTotals(selections: IngredientSelection[]) {
  const totals: Record<string, number> = {};
  let totalGrams = 0;
  const ingredientsNotFound: string[] = []; // Track ingredients not in DB
  
  for (const sel of selections) {
    if (!sel || !sel.key || !sel.grams || sel.grams <= 0) continue;
    
    const ing = safeGetIngredient(sel.key);
    
    // Track if ingredient was found in DB (placeholder has name === 'Unknown')
    if (ing.name === 'Unknown' || !ing.name) {
      ingredientsNotFound.push(sel.key);
    }
    
    const factor = sel.grams / 100;
    totalGrams += sel.grams;

    // Map ingredient composition properties to standard nutrient keys
    // Current structure: { protein, fat, calcium, phosphorus, moisture, kcal, etc. }
    // Map to: { protein_g, fat_g, ca_mg, p_mg, moisture_g, calories_kcal, etc. }
    
    const mappings: Record<string, string> = {
      'protein': 'protein_g',
      'fat': 'fat_g',
      'calcium': 'ca_mg',
      'phosphorus': 'p_mg',
      'moisture': 'moisture_g',
      'kcal': 'calories_kcal',
      'omega3': 'omega3_g',
      'vitaminA': 'vit_a_IU',
      'vitaminC': 'vit_c_mg',
      'taurine': 'taurine_mg',
      'fiber': 'fiber_g',
      'carbs': 'carbs_g',
    };
    
    // Try per100g structure first (new format)
    const per100g = (ing as any).per100g || (ing as any).per100g_raw || (ing as any).per100gData;
    if (per100g && typeof per100g === 'object') {
      for (const [k, v] of Object.entries(per100g)) {
        if (typeof v === 'number') {
          const mappedKey = mappings[k] || k;
          totals[mappedKey] = (totals[mappedKey] ?? 0) + v * factor;
        }
      }
    } else {
      // Use direct properties (current format in ingredientCompositions.ts)
      for (const [key, mappedKey] of Object.entries(mappings)) {
        const value = (ing as any)[key];
        if (typeof value === 'number') {
          totals[mappedKey] = (totals[mappedKey] ?? 0) + value * factor;
        }
      }
      
      // Also handle direct property access for any other numeric fields
      for (const [k, v] of Object.entries(ing)) {
        if (k !== 'source' && k !== 'name' && typeof v === 'number' && !mappings[k]) {
          // Preserve original key if not in mappings
          totals[k] = (totals[k] ?? 0) + v * factor;
        }
      }
    }
  }

  return { totals, totalGrams, ingredientsNotFound };
}

function computeEnergyDensityKcalPerGram(nutrients: Record<string, number>) {
  // Expect calories_kcal total per recipe -> kcal per gram
  const kcalTotal = nutrients['calories_kcal'] ?? nutrients['energy_kcal'] ?? 0;
  return kcalTotal;
}

// ---------- Pet energy target (simple, adjustable) ----------

function computeDailyKcalTarget(pet: PetProfile) {
  const weight = Math.max(0.1, pet.weightKg ?? 5);

  // Use simplified MER approximations (not authoritative; replace with FEDIAF/AFFCO later)
  let factor = 1.6; // default moderate
  if (pet.activity === 'low') factor = 1.3;
  if (pet.activity === 'high') factor = 2.0;

  switch ((pet.species || '').toLowerCase()) {
    case 'dog':
      // RER = 70 * kg^0.75, MER ~ RER * factor
      return Math.round(70 * Math.pow(weight, 0.75) * factor);
    case 'cat':
      // cats: more kcal/kg (approx)
      return Math.round(50 * Math.pow(weight, 0.75) * factor);
    case 'bearded-dragon':
      // reptiles: single feeding approach, use simpler target scaled to small kg
      return Math.round(30 * weight * (pet.activity === 'high' ? 1.5 : 1.0));
    case 'guinea-pig':
      return Math.round(80 * weight); // placeholder
    default:
      return Math.round(60 * Math.pow(weight, 0.75));
  }
}

// ---------- Species-specific quick checks ----------

function normalizeSpecies(species: string): 'dog' | 'cat' | 'bird' | 'reptile' | 'pocket-pet' | string {
  const s = (species || '').toLowerCase();
  if (s.includes('dog')) return 'dog';
  if (s.includes('cat')) return 'cat';
  if (s.includes('bird') || s.includes('parrot') || s.includes('finch')) return 'bird';
  if (s.includes('reptile') || s.includes('lizard') || s.includes('bearded') || s.includes('dragon')) return 'reptile';
  if (s.includes('pocket') || s.includes('rabbit') || s.includes('guinea') || s.includes('hamster') || s.includes('gerbil')) return 'pocket-pet';
  return s;
}

function checkToxicityAndAllergies(
  pet: PetProfile,
  selections: IngredientSelection[],
  totalGrams: number,
): { toxicityWarnings: WarningItem[]; allergyWarnings: WarningItem[]; inclusionWarnings: WarningItem[] } {
  const tox: WarningItem[] = [];
  const allergy: WarningItem[] = [];
  const inclusion: WarningItem[] = [];
  const petAllergiesLower = (pet.allergies || []).map(a => a.toLowerCase());
  const normalizedSpecies = normalizeSpecies(pet.species || '');
  
  for (const sel of selections) {
    try {
      const ing = safeGetIngredient(sel.key);
      // FIXED: Use original ingredient name for display, not composition key
      // This ensures warnings show "bok choi" not "kale_raw"
      const displayName = getIngredientDisplayName(sel.key) || sel.key;
      const ingPercent = totalGrams > 0 ? (sel.grams / totalGrams) : 0;

      // Check species compatibility (NEW)
      if (ing.speciesCompatibility && normalizedSpecies) {
        const compat = ing.speciesCompatibility[normalizedSpecies as keyof typeof ing.speciesCompatibility];
        if (compat === 'avoid') {
          tox.push({
            ingredientKey: sel.key,
            ingredientName: displayName,
            message: `${displayName} should be avoided for ${pet.species}. ${ing.notesBySpecies?.[normalizedSpecies as keyof typeof ing.notesBySpecies] || ''}`,
            severity: 'critical',
          });
        } else if (compat === 'limit') {
          tox.push({
            ingredientKey: sel.key,
            ingredientName: displayName,
            message: `${displayName} should be limited for ${pet.species}. ${ing.notesBySpecies?.[normalizedSpecies as keyof typeof ing.notesBySpecies] || ''}`,
            severity: 'medium',
          });
        } else if (compat === 'caution') {
          tox.push({
          ingredientKey: sel.key,
            ingredientName: displayName,
            message: `${displayName} requires caution for ${pet.species}. ${ing.notesBySpecies?.[normalizedSpecies as keyof typeof ing.notesBySpecies] || ''}`,
            severity: 'low',
          });
        }
      }

      // Check max inclusion percentage (NEW)
      if (ing.maxInclusionPercentBySpecies && normalizedSpecies && totalGrams > 0) {
        const maxPercent = ing.maxInclusionPercentBySpecies[normalizedSpecies as keyof typeof ing.maxInclusionPercentBySpecies];
        if (maxPercent !== undefined && ingPercent > maxPercent) {
          const overage = ((ingPercent - maxPercent) * 100).toFixed(1);
          inclusion.push({
            ingredientKey: sel.key,
            ingredientName: displayName,
            message: `${displayName} exceeds recommended maximum (${(maxPercent * 100).toFixed(0)}% of meal). Currently ${(ingPercent * 100).toFixed(1)}% (+${overage}%). ${ing.notesBySpecies?.[normalizedSpecies as keyof typeof ing.notesBySpecies] || ''}`,
            severity: ingPercent > maxPercent * 1.5 ? 'high' : 'medium',
          });
        }
      }

      // Legacy toxicity check
      if (ing.toxicFor && Array.isArray(ing.toxicFor)) {
        const affectsPet = ing.toxicFor.map((s: string) => s.toLowerCase()).includes(normalizedSpecies) || ing.toxicFor.includes('all');
        if (affectsPet) {
          tox.push({
            ingredientKey: sel.key,
            ingredientName: displayName,
            message: `${displayName} flagged as potentially toxic/contraindicated for ${pet.species}`,
            severity: (ing.toxicSeverity as any) ?? 'high',
          });
        }
      }

      // User allergies
      if (petAllergiesLower.length > 0) {
        const nameLower = displayName.toLowerCase();
        for (const a of petAllergiesLower) {
          if (nameLower.includes(a) || sel.key.toLowerCase().includes(a)) {
            allergy.push({
              ingredientKey: sel.key,
              ingredientName: displayName,
              message: `${displayName} matches pet allergy "${a}"`,
              severity: 'high',
            });
          }
        }
      }
    } catch (e) {
      // ignore missing compositions (should be validated earlier)
    }
  }

  return { toxicityWarnings: tox, allergyWarnings: allergy, inclusionWarnings: inclusion };
}

// ---------- Nutrient checks & simple coverage scoring (gamified) ----------

function speciesKey(p: PetProfile) {
  const raw = (p.species || 'unknown').toLowerCase();
  if (raw.includes('pocket') || raw.includes('hamster') || raw.includes('guinea')) return 'pocket-pet';
  if (raw.includes('bird') || raw.includes('parrot')) return 'bird';
  if (raw.includes('reptile') || raw.includes('dragon')) return 'bearded-dragon';
  if (raw.includes('cat')) return 'cat';
  if (raw.includes('dog')) return 'dog';
  return raw;
}

// ---------- Fixed Nutrient checks & lenient coverage scoring ----------

function computeNutrientCoverageAndWarnings(
  pet: PetProfile,
  totals: Record<string, number>,
  totalGrams: number,
  recommendedServingGrams?: number, // NEW: Use recommended serving for warnings
) {
  // Nutritional warnings have been removed - return empty array
  // Keep coverage scores for scoring purposes only
  const warnings: WarningItem[] = [];
  const coverageScores: Record<string, number> = {}; // 0..1 for each tracked nutrient

  const species = speciesKey(pet);

  // Calculate coverage scores for scoring purposes only (no warnings generated)
  const servingGrams = recommendedServingGrams && recommendedServingGrams > 0 
    ? recommendedServingGrams 
    : totalGrams;
  
  // Scale nutrients to per-serving values
  const servingRatio = totalGrams > 0 ? servingGrams / totalGrams : 1;
  const prot = (totals['protein_g'] ?? 0) * servingRatio;
  const fat = (totals['fat_g'] ?? 0) * servingRatio;
  const fiber = (totals['fiber_g'] ?? 0) * servingRatio;
  const ca = (totals['ca_mg'] ?? 0) * servingRatio;
  const p = (totals['p_mg'] ?? 0) * servingRatio;
  const taurine = (totals['taurine_mg'] ?? 0) * servingRatio;

  const targetsBySpecies: Record<string, Record<string, number>> = {
    dog: {
      protein_per_100g: 5,
      fat_per_100g: 2,
      fiber_per_100g: 0.5,
    },
    cat: {
      protein_per_100g: 8,
      fat_per_100g: 3,
      taurine_per_100g: 20,
    },
    'bearded-dragon': {
      ca_p_ratio: 1.0,
      ca_per_100g: 100,
    },
    'guinea-pig': {
      vit_c_per_kg: 5,
    },
    'pocket-pet': {
      protein_per_100g: 4,
      fat_per_100g: 1.2,
      fiber_per_100g: 1.2,
      ca_per_100g: 80,
      p_per_100g: 40,
      ca_p_ratio: 1.5,
    },
    bird: {
      protein_per_100g: 4,
      fat_per_100g: 1.5,
      fiber_per_100g: 0.8,
    },
  };

  const gramsPer100 = servingGrams / 100 || 1;
  const selectedTargets = targetsBySpecies[species] || targetsBySpecies['dog'];

  if (selectedTargets) {
    const t = selectedTargets;

    if (t.protein_per_100g) {
      const expectedProtein = t.protein_per_100g * gramsPer100;
      const ratio = prot / Math.max(1, expectedProtein);
      coverageScores['protein'] = Math.min(1.5, ratio);
    }

    if (t.fat_per_100g) {
      const expectedFat = t.fat_per_100g * gramsPer100;
      const ratio = fat / Math.max(0.1, expectedFat);
      coverageScores['fat'] = Math.min(1.5, ratio);
    }

    if (t.fiber_per_100g) {
      const expectedFiber = t.fiber_per_100g * gramsPer100;
      const ratio = fiber / Math.max(0.1, expectedFiber);
      coverageScores['fiber'] = Math.min(1.2, ratio);
    }

    if (species === 'cat' && t.taurine_per_100g) {
      const expectedTaurine = t.taurine_per_100g * gramsPer100;
      const ratio = taurine / Math.max(1, expectedTaurine);
      coverageScores['taurine'] = Math.min(1.5, ratio);
    }

    if (species === 'bearded-dragon' && typeof p === 'number' && p > 0) {
      const ratio = ca / p;
      const desired = t.ca_p_ratio;
      coverageScores['ca_p'] = Math.min(1.2, (ratio / desired) * 1.2);
    }
  }

  return { coverageScores, warnings };
}

// ---------- FIXED Scoring model (more generous) ----------

function calculateGamifiedScore(
  pet: PetProfile,
  totals: Record<string, number>,
  totalGrams: number,
  toxicityWarnings: WarningItem[],
  allergyWarnings: WarningItem[],
  nutrientWarnings: WarningItem[],
  ingredientsNotFound?: string[],
  totalIngredientCount?: number,
) {
  const { coverageScores } = computeNutrientCoverageAndWarnings(pet, totals, totalGrams);

  const keys = Object.keys(coverageScores);
  const foundIngredientCount = (totalIngredientCount || 0) - (ingredientsNotFound?.length || 0);
  let avgCoverage = 0;
  const presentCats = new Set<string>();
  if ((totals['protein_g'] ?? 0) > 0) presentCats.add('protein');
  if ((totals['fiber_g'] ?? 0) > 0 || (totals['ca_mg'] ?? 0) > 0) presentCats.add('greens');
  if ((totals['carbs_g'] ?? 0) > 0) presentCats.add('carbs');
  if ((totals['fat_g'] ?? 0) > 0) presentCats.add('fat');
  
  if (keys.length > 0) {
    const totalCoverage = Object.values(coverageScores).reduce((a, b) => a + b, 0);
    // FIXED: If some ingredients found, don't penalize as much - align with recipe scoring generosity
    // Recipe scoring gives 50 base + bonuses, so custom meals should be similarly generous
    if (foundIngredientCount > 0) {
      // If we have coverage data, use it (but be generous)
      // If some ingredients missing, still give good score (like recipe scoring does)
      const baseCoverage = totalCoverage / keys.length;
      avgCoverage = ingredientsNotFound && ingredientsNotFound.length > 0 
        ? Math.max(0.75, baseCoverage) // At least 75% if some ingredients found
        : Math.max(0.8, baseCoverage); // Prefer to floor higher when coverage present
    } else {
      avgCoverage = 0.6; // No ingredients found in DB but had coverage map
    }
  } else {
    // More dynamic fallback when we don't have coverage data
    const catCount = presentCats.size;
    if (catCount >= 3) avgCoverage = 0.92;
    else if (catCount === 2) avgCoverage = 0.85;
    else if (catCount === 1) avgCoverage = 0.72;
    else avgCoverage = foundIngredientCount > 0 ? 0.6 : 0.5;
  }
  
  const nutrientCoverageScore = Math.min(100, Math.round(avgCoverage * 100));

  // FIXED: Less harsh toxicity penalties
  let toxPenaltyRaw = 0;
  for (const t of toxicityWarnings) {
    if (t.severity === 'critical' || t.severity === 'high') toxPenaltyRaw += 30; // FIXED: Was 40
    else if (t.severity === 'medium') toxPenaltyRaw += 15; // FIXED: Was 20
    else toxPenaltyRaw += 5; // FIXED: Was 8
  }
  for (const a of allergyWarnings) {
    toxPenaltyRaw += 40; // FIXED: Was 50 (still heavy but not instant kill)
  }
  const toxicityPenalty = Math.min(100, toxPenaltyRaw);

  // FIXED: Give full credit for 2+ categories (most meals have protein + carbs or protein + greens)
  // This aligns with recipe scoring which doesn't require all categories
  const varietyScore = presentCats.size >= 2 ? 1.0 : (presentCats.size / 2); // Full credit at 2+
  const balanceVarietyScore = Math.round(varietyScore * 100);

  // FIXED: Better base score calculation - align with recipe scoring
  // Recipe scoring: 50 base + 15 age + 15 health + 15 nutrition = 95 (very generous)
  // Custom meals should be similarly generous, so weight nutrient coverage more
  const base = Math.max(60, Math.round(nutrientCoverageScore * 0.8 + balanceVarietyScore * 0.2));

  // FIXED: Cap penalty at 40% of base score (more generous than before)
  // Recipe scoring rarely goes below 30, so custom meals should be similar
  const maxPenalty = Math.round(base * 0.4);
  const penaltyApplied = Math.min(maxPenalty, Math.round((toxicityPenalty / 100) * base));
  
  const finalScore = Math.max(20, base - penaltyApplied);
  
  return {
    nutrientCoverageScore,
    toxicityPenalty,
    balanceVarietyScore,
    finalScore,
    base,
    penaltyApplied,
  };
}

// ---------- Suggestion generator (concrete, gamified) ----------

function generatePetSpecificSuggestions(
  pet: PetProfile,
  totals: Record<string, number>,
  totalGrams: number,
  toxicityWarnings: WarningItem[],
  allergyWarnings: WarningItem[],
) {
  const suggestions: Suggestion[] = [];
  const species = speciesKey(pet);

  // If cat and taurine low
  if (species === 'cat') {
    const taurine = totals['taurine_mg'] ?? 0;
    const gramsPer100 = Math.max(1, totalGrams / 100);
    const expectedTaurinePerBatch = 50 * gramsPer100; // placeholder desired mg per batch
    if (taurine < expectedTaurinePerBatch * 0.75) {
      suggestions.push({
        message: 'Taurine is low ‚Äî add 0.1g taurine supplement per 100g serving or include more heart/liver.',
        action: 'add_taurine',
        confidence: 'high',
      });
    }
  }

  // Bearded dragon Ca:P
  if (species === 'bearded-dragon') {
    const ca = totals['ca_mg'] ?? 0;
    const p = totals['p_mg'] ?? 0;
    const ratio = p === 0 ? 0 : ca / p;
    if (ratio < 1.5) {
      // compute delta
      const desiredCa = 1.5 * (p || 1);
      const deltaMg = Math.max(0, desiredCa - ca);
      // grams CaCO3 (400 mg elemental Ca per 1 g CaCO3)
      const gramsCaCO3 = +(deltaMg / 400).toFixed(2);
      suggestions.push({
        message: `Ca:P low (${ratio.toFixed(2)}). Add ~${gramsCaCO3} g calcium carbonate per batch to improve ratio.`,
        action: 'add_calcium',
        confidence: 'high',
      });
    }
  }

  // Guinea pig vitamin C
  if (species === 'guinea-pig') {
    const vitC = totals['vit_c_mg'] ?? 0;
    const weight = pet.weightKg ?? 1;
    const required = 10 * weight; // mg/day placeholder
    if (vitC < required) {
      suggestions.push({
        message: `Vitamin C seems low for this guinea pig. Aim to include vitamin C rich greens or a supplement (target ~${required} mg/day).`,
        action: 'add_vitC',
        confidence: 'medium',
      });
    }
  }

  // Generic: if liver present and vit A high risk
  if ((totals['vit_a_IU'] ?? 0) > 50000) {
    suggestions.push({
      message: 'Batch contains large amounts of vitamin A (from liver). Rotate liver less frequently to avoid excess vitamin A.',
      action: 'reduce_liver_frequency',
      confidence: 'high',
    });
  }

  // Toxicity-driven suggestion examples
  for (const t of toxicityWarnings) {
    // FIXED: Use ingredientName (display name) instead of ingredientKey (composition key)
    const ingDisplayName = t.ingredientName || t.ingredientKey || 'this ingredient';
    suggestions.push({
      message: `Consider removing or reducing ${ingDisplayName}: ${t.message}`,
      action: 'remove_toxic',
      confidence: t.severity === 'high' ? 'high' : 'medium',
    });
  }

  for (const a of allergyWarnings) {
    suggestions.push({
      message: `Ingredient flagged for allergy: ${a.message}. Replace with hypoallergenic alternative (duck, rabbit, or novel protein).`,
      action: 'replace_allergen',
      confidence: 'high',
    });
  }

  // Variety suggestion: if only 1 category present
  const presentCats = new Set<string>();
  if ((totals['protein_g'] ?? 0) > 0) presentCats.add('protein');
  if ((totals['fiber_g'] ?? 0) > 0 || (totals['ca_mg'] ?? 0) > 0) presentCats.add('greens');
  if ((totals['carbs_g'] ?? 0) > 0) presentCats.add('carbs');
  if ((totals['fat_g'] ?? 0) > 0) presentCats.add('fat');

  if (presentCats.size <= 1) {
    suggestions.push({
      message: 'This batch is dominated by a single category. Add a vegetable or healthy fat for balance.',
      action: 'add_variety',
      confidence: 'low',
    });
  }
  
  return suggestions;
}

// ---------- Recommended serving calculation ----------

function computeRecommendedServingGrams(nutrients: Record<string, number>, totalGrams: number, pet: PetProfile) {
  const kcalTotal = nutrients['calories_kcal'] ?? nutrients['energy_kcal'] ?? 0;
  if (kcalTotal <= 0 || totalGrams <= 0) return 0;

  const kcalPerGram = kcalTotal / totalGrams;
  const dailyKcal = computeDailyKcalTarget(pet);

  // meals per day default
  const mealsPerDay = pet.species?.toLowerCase() === 'cat' ? 3 : 2;
  const targetMealKcal = Math.max(40, Math.round(dailyKcal / mealsPerDay)); // lower bound guard
  const serving = Math.round(targetMealKcal / kcalPerGram);

  // Safety cap: do not recommend more than 50% daily kcal in one serving
  const maxSingleMealKcal = Math.max(targetMealKcal * 2, Math.round(dailyKcal * 0.5));
  if (serving * kcalPerGram > maxSingleMealKcal) {
    return Math.round(maxSingleMealKcal / kcalPerGram);
  }

  return Math.max(0, serving);
}

// ---------- Public API: generateCustomMealAnalysis ----------

/**
 * Analyzes a custom meal composition for a specific pet profile.
 * 
 * Calculates nutritional totals, checks for toxicity/allergies, computes compatibility score (0-100),
 * and provides recommendations for improvement.
 * 
 * @param petProfile - Pet profile with species, life stage, weight, allergies, activity level
 * @param selections - Array of ingredient selections with keys (composition keys) and grams
 * @returns MealAnalysis with nutrients, score, warnings, suggestions, and recommended serving size
 * 
 * @example
 * ```ts
 * const analysis = generateCustomMealAnalysis(
 *   { species: 'dog', lifeStage: 'adult', weightKg: 20 },
 *   [{ key: 'chicken_breast', grams: 200 }, { key: 'brown_rice_cooked', grams: 100 }]
 * );
 * console.log(analysis.score); // 85
 * console.log(analysis.recommendedServingGrams); // 350
 * ```
 * 
 * @contract
 * - Input: PetProfile (from localStorage/backend), IngredientSelection[] (from UI)
 * - Output: MealAnalysis with standardized structure
 * - Side effects: None (pure function)
 * - Migration: Compatible with Firebase/Supabase (receives objects, not storage)
 * - Ingredient keys: Must match INGREDIENT_COMPOSITIONS keys (auto-mapped via safeGetIngredient)
 */
export function generateCustomMealAnalysis(petProfile: PetProfile, selections: IngredientSelection[]): MealAnalysis {
  // Defensive: ensure selections are valid
  const safeSelections = (selections || []).filter(s => s && s.key && s.grams && s.grams > 0);
  const { totals, totalGrams, ingredientsNotFound } = sumRecipeTotals(safeSelections);
  
  // Log ingredients not found in DB
  if (ingredientsNotFound && ingredientsNotFound.length > 0) {
    console.warn('Ingredients not found in composition DB:', ingredientsNotFound);
  }

  // Compute energy density
  const kcalTotal = totals['calories_kcal'] ?? totals['energy_kcal'] ?? 0;
  const energyDensity = totalGrams > 0 ? kcalTotal / totalGrams : 0;

  // Toxicity & allergies
  const { toxicityWarnings, allergyWarnings, inclusionWarnings } = checkToxicityAndAllergies(petProfile, safeSelections, totalGrams);

  // Suggested serving (calculate early so we can use it for warnings)
  const recommendedServingGrams = computeRecommendedServingGrams(totals, totalGrams, petProfile);

  // Nutrient warnings from species heuristics (now uses recommended serving size)
  const { coverageScores } = computeNutrientCoverageAndWarnings(petProfile, totals, totalGrams, recommendedServingGrams);

  // Nutritional warnings have been removed - return empty array
  const nutrientWarnings: WarningItem[] = [];

  // Scoring (pass ingredientsNotFound for better scoring)
  const scoreInfo = calculateGamifiedScore(petProfile, totals, totalGrams, toxicityWarnings, allergyWarnings, nutrientWarnings, ingredientsNotFound, safeSelections.length);

  // Suggestions
  const suggestions = generatePetSpecificSuggestions(petProfile, totals, totalGrams, toxicityWarnings, allergyWarnings);

  // Calculate Ca:P ratio for legacy compatibility
  const ca = totals['ca_mg'] ?? 0;
  const p = totals['p_mg'] ?? 0;
  const caToPratio = p > 0 ? ca / p : undefined;

  // Legacy compatibility fields
  const dmNutrients: Record<string, number> = {};
  const moisture = totals['moisture_g'] ?? 0;
  const dryMatter = totalGrams - moisture;
  const dryMatterPercent = totalGrams > 0 ? (dryMatter / totalGrams) * 100 : 0;

  if (dryMatter > 0) {
    for (const [key, value] of Object.entries(totals)) {
      if (key !== 'moisture_g') {
        dmNutrients[`${key}_percent`] = (value / dryMatter) * 100;
      }
    }
  }

  // Convert nutrientWarnings to legacy deficiencies/excesses format
  // (empty since warnings have been removed)
  const deficiencies: string[] = [];
  const excesses: string[] = [];

  // Final MealAnalysis object
  const analysis: MealAnalysis = {
    nutrients: totals,
    totalRecipeGrams: totalGrams,
    energyDensityKcalPerGram: energyDensity,
    recommendedServingGrams,
    score: scoreInfo.finalScore,
    breakdown: {
      nutrientCoverageScore: scoreInfo.nutrientCoverageScore,
      toxicityPenalty: scoreInfo.toxicityPenalty,
      balanceVarietyScore: scoreInfo.balanceVarietyScore,
    },
      toxicityWarnings,
      allergyWarnings,
    nutrientWarnings,
    suggestions,
    // Legacy compatibility fields
    dmNutrients,
    dryMatterPercent,
    totalWeight_g: totalGrams,
    caToPratio,
      deficiencies,
      excesses,
    adequacies: coverageScores['protein'] > 0.8 && coverageScores['fat'] > 0.8 ? ['Protein and fat levels look adequate'] : [],
      scoreBreakdown: {
      baseScore: scoreInfo.base,
      nutritionPenalty: scoreInfo.penaltyApplied,
        balancePenalty: 0,
      },
    };

  return analysis;
}
</file>

<file path="lib/applyModifiers.ts">
import type { Recipe, ModifiedRecipeResult, PetNutritionProfile, PortionPlan, ShoppingListItem, WeeklyPlanEntry, AppliedModifierSummary } from './types';
import { dogModifiers } from './data/nutrition-dog-modifiers';
import { catModifiers } from './data/nutrition-cat-modifiers';
import { scoreRecipeImproved } from './scoreRecipe';
import { getPortionPlan } from './portionCalc';
import { scaleAmount } from './portionCalc';
import { getVettedProduct, getAllAffiliateLinks, getGenericIngredientName } from './data/vetted-products'; // <--- UPDATED to use expanded vetted products with commission optimization
import { matchesSpecies } from './utils/recipeRecommendations';

interface ApplyModifiersResult {
  modifiedRecipe: Recipe;
  addedIngredients: Array<{
    name: string;
    benefit: string;
    amazon: string;
    forConcern: string;
  }>;
}

const concernToModifierKey: Record<string, string> = {
  allergies: 'allergies',
  'joint-health': 'joint_issues',
  'weight-management': 'weight_management',
  digestive: 'gi_issues',
  'gi-issues': 'gi_issues',
  'kidney': 'kidney_support',
  'kidney/urinary-support': 'kidney_support',
  'urinary-health': 'urinary_health',
  diabetes: 'diabetes',
  'skin-coat': 'allergies', // approximate
};

const formatIngredientNameForDisplay = (value: string): string => {
  return String(value)
    .trim()
    .replace(/[-_]+/g, ' ')
    .split(' ')
    .filter(Boolean)
    .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
    .join(' ');
};

export function applyModifiers(recipe: Recipe, pet: any): ApplyModifiersResult & { conflictCount: number; hasHydrationSupport: boolean } {
  const modifiers = pet.type === 'dogs' ? dogModifiers : pet.type === 'cats' ? catModifiers : {};
  const modifiedRecipe: Recipe = JSON.parse(JSON.stringify(recipe)); // Deep clone to modify

  let addedIngredients: ApplyModifiersResult['addedIngredients'] = [];
  let conflictCount = 0;
  let hasHydrationSupport = false;

  // 1. Apply Health Concern Modifiers (Supplements/Additions)
  // Import normalizeHealthConcernForMatching from scoreRecipe (or define locally)
  const normalizeConcern = (c: string): string => {
    const normalized = c.toLowerCase().trim();
    // Map human-readable to normalized format
    const mapping: Record<string, string> = {
      'arthritis/joint pain': 'joint-health',
      'joint pain': 'joint-health',
      'arthritis': 'joint-health',
      'obesity/weight management': 'weight-management',
      'obesity': 'weight-management',
      'weight management': 'weight-management',
      'kidney disease': 'kidney-disease',
      'kidney': 'kidney-disease',
      'urinary problems': 'urinary-health',
      'urinary tract issues': 'urinary-health',
      'dental problems': 'dental-issues',
      'dental disease': 'dental-issues',
      'digestive issues': 'digestive-issues',
      'allergies/skin issues': 'allergies',
      'skin issues': 'allergies',
    };
    return mapping[normalized] || normalized.replace(/[^a-z0-9]+/g, '-');
  };

  for (const concern of pet.healthConcerns || []) {
    const normalizedConcern = normalizeConcern(concern);
    const modKey = concernToModifierKey[normalizedConcern] || concernToModifierKey[concern.toLowerCase()];
    if (modKey && (modifiers as any)[modKey]) {
      const modifier = (modifiers as any)[modKey];

      // Add supplements required by the modifier
      for (const supplement of modifier.add) {
        // Check if there's a vetted product for this supplement (pass pet.type for species filtering, preferBudget=true for cost control)
        const vettedProduct = getVettedProduct(supplement.name, pet.type, true);
        addedIngredients.push({
          name: supplement.name,
          benefit: supplement.benefit,
          amazon: vettedProduct?.asinLink || supplement.amazon, // Use vetted ASIN link if available
          forConcern: concern,
        });
      }

      // Check for conflicts (already handled in scoreRecipe, but kept for full loop)
      const ingredientText = (recipe.ingredients || []).map((i) => i.name.toLowerCase()).join(' ');
      for (const avoid of modifier.avoid) {
          if (ingredientText.includes(avoid.toLowerCase())) {
            conflictCount += 1; // Track conflicts
          }
      }

      // Check for hydration support
      if (concern.includes('kidney') || concern.includes('urinary')) {
          hasHydrationSupport = true;
      }
    }
  }

  // 2. Map Ingredients to Vetted Products (The core fix)
  // This is the new logic that replaces generic ingredients with specific vetted products
  modifiedRecipe.ingredients = modifiedRecipe.ingredients.map(ing => {
    const genericKey = getGenericIngredientName(ing.name);
    const genericName = genericKey ? formatIngredientNameForDisplay(genericKey) : ing.name;
    // Pass pet.type for species-aware product matching, preferBudget=true for cost control
    const vettedProduct = getVettedProduct(genericName, pet.type, true);
    if (vettedProduct) {
        // Overwrite the generic ingredient details with the Vetted Product details
        return {
            ...ing,
            name: genericName,
            productName: vettedProduct.productName,
            asinLink: vettedProduct.asinLink,
            notes: (ing as any).notes ? `${(ing as any).notes} | VET NOTE: ${vettedProduct.vetNote}` : `VET NOTE: ${vettedProduct.vetNote}`,
        };
    }
    // If no vetted product, remove asinLink to ensure only vetted products have buy links
    return {
      ...ing,
      asinLink: undefined,
    };
  });

  // 3. Map Supplements to Vetted Products (ensure all buy links are vetted)
  if ((modifiedRecipe as any).supplements) {
    (modifiedRecipe as any).supplements = (modifiedRecipe as any).supplements.map((supplement: any) => {
      const genericKey = getGenericIngredientName(supplement.name);
      const genericName = genericKey ? formatIngredientNameForDisplay(genericKey) : supplement.name;
      // Pass pet.type for species-aware product matching, preferBudget=true for cost control
      const vettedProduct = getVettedProduct(genericName, pet.type, true);
      if (vettedProduct) {
        return {
          ...supplement,
          name: genericName,
          productName: vettedProduct.productName,
          asinLink: vettedProduct.asinLink,
          notes: supplement.notes ? `${supplement.notes} | VET NOTE: ${vettedProduct.vetNote}` : `VET NOTE: ${vettedProduct.vetNote}`,
        };
      }
      // If no vetted product, remove asinLink to ensure only vetted products have buy links
      return {
        ...supplement,
        asinLink: undefined,
      };
    });
  }

  return {
    modifiedRecipe,
    addedIngredients,
    conflictCount,
    hasHydrationSupport,
  };
}

export function generateModifiedRecommendations({ profile, recipeIds, limit, minCompatibilityScore = 30 }: { profile: PetNutritionProfile, recipeIds: string[], limit: number, minCompatibilityScore?: number }): ModifiedRecipeResult[] {
    console.log('üîç generateModifiedRecommendations called:', {
        species: profile.species,
        ageGroup: profile.ageGroup,
        healthConcerns: profile.healthConcerns,
        limit,
        minCompatibilityScore
    });
    
    // NOTE: 'recipes' is imported from './data/recipes-complete'
    // Use matchesSpecies instead of strict equality to support subtype matching
    const petForMatching = {
        id: '',
        name: '',
        type: profile.species,
        breed: profile.breed || '',
        age: profile.ageGroup,
        healthConcerns: profile.healthConcerns || []
    };
    
    // Use matchesSpecies for sophisticated matching (handles subtypes)
    let allRecipesForCategory = recipes.filter(r => matchesSpecies(r, petForMatching));
    console.log(`üìä Found ${allRecipesForCategory.length} recipes for species "${profile.species}"`);
    
    // Fallback: If no matches, try simple normalization (cat/cats, dog/dogs)
    if (allRecipesForCategory.length === 0) {
        const normalizeSpecies = (species: string) => species.toLowerCase().replace(/s$/, '');
        const normalizedPet = normalizeSpecies(profile.species);
        allRecipesForCategory = recipes.filter(r => {
            const normalizedRecipe = normalizeSpecies(r.category);
            return normalizedPet === normalizedRecipe;
        });
    }
    
    // Log for debugging
    if (allRecipesForCategory.length === 0) {
        console.warn(`No recipes found for species: ${profile.species}, breed: ${profile.breed}, age: ${profile.ageGroup}`);
        console.warn(`Total recipes available: ${recipes.length}`);
        console.warn(`Sample recipe categories: ${recipes.slice(0, 5).map(r => r.category).join(', ')}`);
    }
    
    const targetRecipes = recipeIds.length > 0
        ? allRecipesForCategory.filter(r => recipeIds.includes(r.id))
        : allRecipesForCategory.slice(0, 50); // Use a subset if no IDs provided

    // 1. Score all recipes
    console.log(`üéØ Scoring ${targetRecipes.length} recipes...`);
    const scoredRecipes = targetRecipes.map((recipe, idx) => {
        // Convert PetNutritionProfile to pet object format expected by scoreRecipeImproved
        const petForScoring = {
            id: '',
            name: profile.petName || '',
            type: profile.species,
            breed: profile.breed || '',
            age: profile.ageGroup,
            weight: profile.weightKg,
            weightKg: profile.weightKg,
            activityLevel: undefined,
            healthConcerns: profile.healthConcerns || [],
            dietaryRestrictions: profile.allergies || [],
            allergies: profile.allergies || [],
        };
        const petRating = scoreRecipeImproved(recipe, petForScoring);
        if (idx < 3) { // Log first 3 for debugging
            console.log(`  Recipe "${recipe.name}": ${petRating.compatibilityScore || petRating.matchScore}% (${petRating.reasoning.goodMatches.length} matches, ${petRating.reasoning.conflicts.length} conflicts)`);
        }
        return { recipe, petRating };
    });

    // 2. Filter by minimum compatibility threshold
    const filteredByThreshold = scoredRecipes.filter(({ petRating }) => {
        const score = petRating.compatibilityScore || petRating.matchScore;
        return score >= minCompatibilityScore;
    });
    
    console.log(`üìä Filtered ${scoredRecipes.length} recipes to ${filteredByThreshold.length} above threshold (${minCompatibilityScore}%)`);
    
    // 3. Sort by score and take the top N
    const topScored = filteredByThreshold
        .sort((a, b) => (b.petRating.compatibilityScore || b.petRating.matchScore) - (a.petRating.compatibilityScore || a.petRating.matchScore))
        .slice(0, limit);

    // 4. Apply modifiers to the top N recipes
    const results = topScored.map(({ recipe, petRating }) => {
        // Convert PetNutritionProfile to pet object format expected by applyModifiers
        const petForModifiers = {
            type: profile.species,
            age: profile.ageGroup,
            breed: profile.breed || '',
            healthConcerns: profile.healthConcerns || [],
            allergies: profile.allergies || [],
            weightKg: profile.weightKg,
        };
        // Apply modifiers, which now performs the ingredient vetting lookup (Step 2 in applyModifiers)
        const { modifiedRecipe, addedIngredients, conflictCount, hasHydrationSupport } = applyModifiers(recipe, petForModifiers);

        const portionPlan = getPortionPlan(recipe, profile);

        const shoppingList: ShoppingListItem[] = [
            // 1. Original recipe ingredients (NOW VETTED AND MODIFIED with commission optimization)
            ...modifiedRecipe.ingredients.map(ing => {
                // Find the best affiliate link for this ingredient (prioritizing commission)
                const allLinks = getAllAffiliateLinks(ing.name.toLowerCase());
                const bestLink = allLinks[0]; // Already sorted by commission descending

                // Use vetted product name if available, otherwise keep original
                const vettedProduct = getVettedProduct(ing.name.toLowerCase());

                return {
                    name: vettedProduct?.productName || ing.name,
                    amount: scaleAmount(ing.amount, portionPlan.multiplier) || ing.amount,
                    asinLink: bestLink?.url || ing.asinLink, // Use best commission link
                    notes: (ing as any).notes,
                    category: (ing as any).category,
                };
            }),
            // 2. Added supplements/modifiers
            ...addedIngredients.map(add => ({
                name: add.name,
                amount: '1 dose/day', // Default amount for a supplement
                asinLink: add.amazon,
                notes: `Added for ${add.forConcern} support. Benefit: ${add.benefit}`,
                category: 'Supplement',
            })),
        ];

        // Group the shopping list items by category or name for display... (not implemented here)

        return {
            recipe: modifiedRecipe,
            adjustedIngredients: modifiedRecipe.ingredients,
            appliedRules: [], // TODO: implement applied rules
            nutritionChanges: {}, // TODO: implement nutrition changes
            portionPlan,
            shoppingList,
            explanation: '', // avoid noisy banner text
            weeklyPlan: [], // TODO: implement weekly plan
            score: petRating.compatibilityScore || petRating.matchScore,
        };
    });

    return results;
}
</file>

<file path="lib/audit/RecipeNutritionalAudit.ts">
// Recipe Nutritional Accuracy Audit - Verify portion calculations and nutritional totals
// Tests if recipes meet species-specific requirements and calculations are correct

import { RecipeBuilder, GenerationConstraints } from '../generator/RecipeBuilder';
import type { Species } from '@/lib/data/ingredients';
import { getNutritionalStandard } from '@/lib/data/aafco-standards';
import * as fs from 'fs';
import * as path from 'path';

interface NutritionalAccuracyMetrics {
  species: Species;
  recipesGenerated: number;
  recipesValid: number;
  avgTotalGrams: number;
  avgProteinPercent: number;
  avgFatPercent: number;
  avgCarbsPercent: number;
  avgCalories: number;
  portionSizeIssues: number;
  nutritionalBalanceIssues: number;
  calculationErrors: number;
}

export class RecipeNutritionalAudit {
  private results: Map<Species, NutritionalAccuracyMetrics> = new Map();
  
  async runAudit(): Promise<void> {
    console.log('='.repeat(80));
    console.log('RECIPE NUTRITIONAL ACCURACY AUDIT');
    console.log('='.repeat(80));
    console.log();
    
    const species: Species[] = ['dogs', 'cats', 'birds', 'reptiles', 'pocket-pets'];
    
    for (const sp of species) {
      console.log(`Testing ${sp}...`);
      await this.testSpeciesNutrition(sp);
    }
    
    this.generateReport();
  }
  
  private async testSpeciesNutrition(species: Species): Promise<void> {
    const testCases = [
      { weight: 2, label: 'very small' },
      { weight: 5, label: 'small' },
      { weight: 15, label: 'medium' },
      { weight: 30, label: 'large' },
      { weight: 50, label: 'very large' },
    ];
    
    let recipesGenerated = 0;
    let recipesValid = 0;
    let totalGrams = 0;
    let totalProtein = 0;
    let totalFat = 0;
    let totalCarbs = 0;
    let totalCalories = 0;
    let portionSizeIssues = 0;
    let nutritionalBalanceIssues = 0;
    let calculationErrors = 0;
    
    for (const testCase of testCases) {
      for (let i = 0; i < 5; i++) {
        const constraints: GenerationConstraints = {
          species,
          lifeStage: 'adult',
          petWeightKg: testCase.weight,
          healthConcerns: [],
          allergies: [],
        };
        
        try {
          const builder = new RecipeBuilder(constraints, 'standard', 'medium');
          const recipe = await builder.generate();
          
          if (recipe && recipe.ingredients.length > 0) {
            recipesGenerated++;
            
            // Calculate nutritional totals
            let recipeProtein = 0;
            let recipeFat = 0;
            let recipeCarbs = 0;
            let recipeCalories = 0;
            let calculatedTotalGrams = 0;
            
            for (const portioned of recipe.ingredients) {
              const grams = portioned.grams;
              calculatedTotalGrams += grams;
              
              const comp = portioned.ingredient.composition;
              recipeProtein += (comp.protein || 0) * grams / 100;
              recipeFat += (comp.fat || 0) * grams / 100;
              recipeCarbs += (comp.carbs || 0) * grams / 100;
              recipeCalories += (comp.kcal || 0) * grams / 100;
            }
            
            // Verify total grams matches
            if (Math.abs(calculatedTotalGrams - recipe.totalGrams) > 0.1) {
              calculationErrors++;
              console.warn(`  Calculation error: ${calculatedTotalGrams.toFixed(1)}g calculated vs ${recipe.totalGrams}g reported`);
            }
            
            // Check portion size appropriateness
            const expectedGramsPerKg = this.getExpectedGramsPerKg(species);
            const expectedTotal = testCase.weight * expectedGramsPerKg;
            const portionDifference = Math.abs(recipe.totalGrams - expectedTotal) / expectedTotal;
            
            if (portionDifference > 0.3) {
              portionSizeIssues++;
            }
            
            // Check nutritional balance
            const proteinPercent = (recipeProtein / recipe.totalGrams) * 100;
            const fatPercent = (recipeFat / recipe.totalGrams) * 100;
            const carbsPercent = (recipeCarbs / recipe.totalGrams) * 100;
            
            const standard = getNutritionalStandard(species, 'adult');
            
            if (standard.protein && (proteinPercent < standard.protein.min || proteinPercent > (standard.protein.max || 100))) {
              nutritionalBalanceIssues++;
            }
            
            if (standard.fat && (fatPercent < standard.fat.min || fatPercent > (standard.fat.max || 100))) {
              nutritionalBalanceIssues++;
            }
            
            recipesValid++;
            totalGrams += recipe.totalGrams;
            totalProtein += proteinPercent;
            totalFat += fatPercent;
            totalCarbs += carbsPercent;
            totalCalories += recipeCalories;
          }
        } catch (error) {
          // Skip failed recipes
        }
      }
    }
    
    this.results.set(species, {
      species,
      recipesGenerated,
      recipesValid,
      avgTotalGrams: recipesValid > 0 ? totalGrams / recipesValid : 0,
      avgProteinPercent: recipesValid > 0 ? totalProtein / recipesValid : 0,
      avgFatPercent: recipesValid > 0 ? totalFat / recipesValid : 0,
      avgCarbsPercent: recipesValid > 0 ? totalCarbs / recipesValid : 0,
      avgCalories: recipesValid > 0 ? totalCalories / recipesValid : 0,
      portionSizeIssues,
      nutritionalBalanceIssues,
      calculationErrors,
    });
  }
  
  private getExpectedGramsPerKg(species: Species): number {
    switch (species) {
      case 'dogs': return 60;
      case 'cats': return 70;
      case 'birds': return 80;
      case 'reptiles': return 50;
      case 'pocket-pets': return 100;
      default: return 60;
    }
  }
  
  private generateReport(): void {
    console.log();
    console.log('='.repeat(80));
    console.log('NUTRITIONAL ACCURACY RESULTS');
    console.log('='.repeat(80));
    console.log();
    
    for (const [species, metrics] of this.results) {
      console.log(`${species.toUpperCase()}`);
      console.log('-'.repeat(80));
      console.log(`Recipes generated: ${metrics.recipesGenerated}`);
      console.log(`Recipes valid: ${metrics.recipesValid}`);
      console.log();
      
      console.log('Average nutritional composition:');
      console.log(`  Total grams: ${metrics.avgTotalGrams.toFixed(1)}g`);
      console.log(`  Protein: ${metrics.avgProteinPercent.toFixed(1)}%`);
      console.log(`  Fat: ${metrics.avgFatPercent.toFixed(1)}%`);
      console.log(`  Carbs: ${metrics.avgCarbsPercent.toFixed(1)}%`);
      console.log(`  Calories: ${metrics.avgCalories.toFixed(0)} kcal`);
      console.log();
      
      // Check against standards
      const standard = getNutritionalStandard(species, 'adult');
      
      console.log('Compliance with standards:');
      if (standard.protein) {
        const proteinOk = metrics.avgProteinPercent >= standard.protein.min && 
                         metrics.avgProteinPercent <= (standard.protein.max || 100);
        console.log(`  Protein: ${proteinOk ? '‚úÖ' : '‚ùå'} ${metrics.avgProteinPercent.toFixed(1)}% (target: ${standard.protein.min}-${standard.protein.max || '‚àû'}%)`);
      }
      
      if (standard.fat) {
        const fatOk = metrics.avgFatPercent >= standard.fat.min && 
                     metrics.avgFatPercent <= (standard.fat.max || 100);
        console.log(`  Fat: ${fatOk ? '‚úÖ' : '‚ùå'} ${metrics.avgFatPercent.toFixed(1)}% (target: ${standard.fat.min}-${standard.fat.max || '‚àû'}%)`);
      }
      
      console.log();
      
      console.log('Issues detected:');
      console.log(`  Portion size issues: ${metrics.portionSizeIssues}`);
      console.log(`  Nutritional balance issues: ${metrics.nutritionalBalanceIssues}`);
      console.log(`  Calculation errors: ${metrics.calculationErrors}`);
      console.log();
      
      if (metrics.calculationErrors > 0) {
        console.log('‚ö†Ô∏è  Calculation errors detected - portion totals may be incorrect');
      }
      
      if (metrics.portionSizeIssues > metrics.recipesValid * 0.2) {
        console.log('‚ö†Ô∏è  Many portion sizes outside expected range - review multipliers');
      }
      
      if (metrics.nutritionalBalanceIssues > 0) {
        console.log('‚ö†Ô∏è  Some recipes outside nutritional standards - review ingredient selection');
      }
      
      console.log();
    }
    
    this.generateRecommendations();
    this.saveDetailedReport();
  }
  
  private generateRecommendations(): void {
    console.log('='.repeat(80));
    console.log('RECOMMENDATIONS');
    console.log('='.repeat(80));
    console.log();
    
    for (const [species, metrics] of this.results) {
      const issues: string[] = [];
      
      if (metrics.calculationErrors > 0) {
        issues.push('Fix calculation errors in portion totaling');
      }
      
      if (metrics.portionSizeIssues > metrics.recipesValid * 0.2) {
        issues.push('Adjust portion multipliers for better sizing');
      }
      
      if (metrics.nutritionalBalanceIssues > metrics.recipesValid * 0.1) {
        issues.push('Review ingredient selection to meet nutritional standards');
      }
      
      const standard = getNutritionalStandard(species, 'adult');
      if (standard.protein && metrics.avgProteinPercent < standard.protein.min) {
        issues.push(`Increase protein content (currently ${metrics.avgProteinPercent.toFixed(1)}%, need ${standard.protein.min}%+)`);
      }
      
      if (standard.fat && metrics.avgFatPercent < standard.fat.min) {
        issues.push(`Increase fat content (currently ${metrics.avgFatPercent.toFixed(1)}%, need ${standard.fat.min}%+)`);
      }
      
      if (issues.length > 0) {
        console.log(`${species}:`);
        issues.forEach(issue => console.log(`  - ${issue}`));
        console.log();
      }
    }
  }
  
  private saveDetailedReport(): void {
    const report = {
      timestamp: new Date().toISOString(),
      results: Array.from(this.results.entries()).map(([species, metrics]) => ({
        species,
        ...metrics,
      })),
    };
    
    const outputPath = path.join(process.cwd(), 'RECIPE_NUTRITIONAL_AUDIT.json');
    fs.writeFileSync(outputPath, JSON.stringify(report, null, 2), 'utf-8');
    
    console.log(`Detailed report saved to: ${outputPath}`);
    console.log();
  }
}

// Run the audit
const audit = new RecipeNutritionalAudit();
audit.runAudit().catch(console.error);
</file>

<file path="lib/audit/RecipePalatabilityAudit.ts">
// Recipe Palatability Audit - Analyze palatability scoring system
// Verifies scores make sense and high-palatability ingredients are preferred

import { getIngredientsForSpecies, type Ingredient, type Species } from '@/lib/data/ingredients';
import { RecipeBuilder, GenerationConstraints } from '../generator/RecipeBuilder';
import * as fs from 'fs';
import * as path from 'path';

interface PalatabilityMetrics {
  species: Species;
  totalIngredients: number;
  avgPalatability: number;
  palatabilityDistribution: {
    veryHigh: number; // 9-10
    high: number;     // 7-8
    medium: number;   // 5-6
    low: number;      // 3-4
    veryLow: number;  // 0-2
  };
  topIngredients: Array<{ name: string; score: number }>;
  bottomIngredients: Array<{ name: string; score: number }>;
  recipePalatabilityScores: number[];
  avgRecipePalatability: number;
}

export class RecipePalatabilityAudit {
  private results: Map<Species, PalatabilityMetrics> = new Map();
  
  async runAudit(): Promise<void> {
    console.log('='.repeat(80));
    console.log('RECIPE PALATABILITY AUDIT');
    console.log('='.repeat(80));
    console.log();
    
    const species: Species[] = ['dogs', 'cats', 'birds', 'reptiles', 'pocket-pets'];
    
    for (const sp of species) {
      console.log(`Analyzing ${sp}...`);
      await this.analyzeSpeciesPalatability(sp);
    }
    
    this.generateReport();
  }
  
  private async analyzeSpeciesPalatability(species: Species): Promise<void> {
    // Get all ingredients for this species
    const ingredients = getIngredientsForSpecies(species);
    
    // Analyze palatability scores
    const palatabilityScores = ingredients
      .map(ing => ing.palatability?.[species] || 0)
      .filter(score => score > 0);
    
    const avgPalatability = palatabilityScores.reduce((a, b) => a + b, 0) / palatabilityScores.length;
    
    // Distribution
    const distribution = {
      veryHigh: palatabilityScores.filter(s => s >= 9).length,
      high: palatabilityScores.filter(s => s >= 7 && s < 9).length,
      medium: palatabilityScores.filter(s => s >= 5 && s < 7).length,
      low: palatabilityScores.filter(s => s >= 3 && s < 5).length,
      veryLow: palatabilityScores.filter(s => s < 3).length,
    };
    
    // Top and bottom ingredients
    const sorted = ingredients
      .map(ing => ({ name: ing.name, score: ing.palatability?.[species] || 0 }))
      .filter(item => item.score > 0)
      .sort((a, b) => b.score - a.score);
    
    const topIngredients = sorted.slice(0, 10);
    const bottomIngredients = sorted.slice(-10).reverse();
    
    // Generate recipes and check their palatability
    const recipePalatabilityScores = await this.generateAndScoreRecipes(species, 20);
    const avgRecipePalatability = recipePalatabilityScores.reduce((a, b) => a + b, 0) / recipePalatabilityScores.length;
    
    this.results.set(species, {
      species,
      totalIngredients: ingredients.length,
      avgPalatability,
      palatabilityDistribution: distribution,
      topIngredients,
      bottomIngredients,
      recipePalatabilityScores,
      avgRecipePalatability,
    });
  }
  
  private async generateAndScoreRecipes(species: Species, count: number): Promise<number[]> {
    const scores: number[] = [];
    
    for (let i = 0; i < count; i++) {
      const constraints: GenerationConstraints = {
        species,
        lifeStage: 'adult',
        petWeightKg: this.getTypicalWeight(species),
        healthConcerns: [],
        allergies: [],
      };
      
      try {
        const builder = new RecipeBuilder(constraints, 'standard', 'medium');
        const recipe = await builder.generate();
        
        if (recipe && recipe.ingredients.length > 0) {
          // Calculate recipe palatability (weighted average)
          let totalPalatability = 0;
          let totalWeight = 0;
          
          for (const portioned of recipe.ingredients) {
            const palatability = portioned.ingredient.palatability?.[species] || 5;
            totalPalatability += palatability * portioned.grams;
            totalWeight += portioned.grams;
          }
          
          const avgPalatability = totalWeight > 0 ? totalPalatability / totalWeight : 5;
          scores.push(avgPalatability);
        }
      } catch (error) {
        // Skip failed recipes
      }
    }
    
    return scores;
  }
  
  private getTypicalWeight(species: Species): number {
    switch (species) {
      case 'dogs': return 15;
      case 'cats': return 5;
      case 'birds': return 0.5;
      case 'reptiles': return 0.3;
      case 'pocket-pets': return 1;
      default: return 10;
    }
  }
  
  private generateReport(): void {
    console.log();
    console.log('='.repeat(80));
    console.log('PALATABILITY AUDIT RESULTS');
    console.log('='.repeat(80));
    console.log();
    
    for (const [species, metrics] of this.results) {
      console.log(`${species.toUpperCase()}`);
      console.log('-'.repeat(80));
      console.log(`Total ingredients: ${metrics.totalIngredients}`);
      console.log(`Average palatability: ${metrics.avgPalatability.toFixed(2)}/10`);
      console.log();
      
      console.log('Palatability distribution:');
      console.log(`  Very High (9-10): ${metrics.palatabilityDistribution.veryHigh} (${((metrics.palatabilityDistribution.veryHigh / metrics.totalIngredients) * 100).toFixed(1)}%)`);
      console.log(`  High (7-8):       ${metrics.palatabilityDistribution.high} (${((metrics.palatabilityDistribution.high / metrics.totalIngredients) * 100).toFixed(1)}%)`);
      console.log(`  Medium (5-6):     ${metrics.palatabilityDistribution.medium} (${((metrics.palatabilityDistribution.medium / metrics.totalIngredients) * 100).toFixed(1)}%)`);
      console.log(`  Low (3-4):        ${metrics.palatabilityDistribution.low} (${((metrics.palatabilityDistribution.low / metrics.totalIngredients) * 100).toFixed(1)}%)`);
      console.log(`  Very Low (0-2):   ${metrics.palatabilityDistribution.veryLow} (${((metrics.palatabilityDistribution.veryLow / metrics.totalIngredients) * 100).toFixed(1)}%)`);
      console.log();
      
      console.log('Top 10 most palatable ingredients:');
      metrics.topIngredients.forEach((ing, idx) => {
        console.log(`  ${idx + 1}. ${ing.name}: ${ing.score}/10`);
      });
      console.log();
      
      console.log('Bottom 10 least palatable ingredients:');
      metrics.bottomIngredients.forEach((ing, idx) => {
        console.log(`  ${idx + 1}. ${ing.name}: ${ing.score}/10`);
      });
      console.log();
      
      console.log(`Recipe palatability (${metrics.recipePalatabilityScores.length} recipes tested):`);
      console.log(`  Average: ${metrics.avgRecipePalatability.toFixed(2)}/10`);
      console.log(`  Min: ${Math.min(...metrics.recipePalatabilityScores).toFixed(2)}/10`);
      console.log(`  Max: ${Math.max(...metrics.recipePalatabilityScores).toFixed(2)}/10`);
      console.log();
      
      // Check if recipes favor high-palatability ingredients
      const ingredientAvg = metrics.avgPalatability;
      const recipeAvg = metrics.avgRecipePalatability;
      const difference = recipeAvg - ingredientAvg;
      
      if (difference > 0.5) {
        console.log(`‚úÖ Recipes favor high-palatability ingredients (+${difference.toFixed(2)} vs ingredient avg)`);
      } else if (difference < -0.5) {
        console.log(`‚ö†Ô∏è  Recipes may not prioritize palatability enough (${difference.toFixed(2)} vs ingredient avg)`);
      } else {
        console.log(`‚úì Recipes have balanced palatability (${difference > 0 ? '+' : ''}${difference.toFixed(2)} vs ingredient avg)`);
      }
      
      console.log();
    }
    
    this.generateRecommendations();
    this.saveDetailedReport();
  }
  
  private generateRecommendations(): void {
    console.log('='.repeat(80));
    console.log('RECOMMENDATIONS');
    console.log('='.repeat(80));
    console.log();
    
    for (const [species, metrics] of this.results) {
      const issues: string[] = [];
      
      // Check if palatability scores are well-distributed
      const veryHighPct = metrics.palatabilityDistribution.veryHigh / metrics.totalIngredients;
      const veryLowPct = metrics.palatabilityDistribution.veryLow / metrics.totalIngredients;
      
      if (veryHighPct < 0.1) {
        issues.push('Too few very high palatability ingredients - consider adding more treats/favorites');
      }
      
      if (veryLowPct > 0.3) {
        issues.push('Too many low palatability ingredients - may affect recipe appeal');
      }
      
      // Check if recipes prioritize palatability
      const difference = metrics.avgRecipePalatability - metrics.avgPalatability;
      if (difference < 0) {
        issues.push('Recipes not prioritizing high-palatability ingredients - increase palatability weight in scoring');
      }
      
      // Check palatability range
      if (metrics.avgPalatability < 5) {
        issues.push('Overall palatability too low - review ingredient scores');
      }
      
      if (issues.length > 0) {
        console.log(`${species}:`);
        issues.forEach(issue => console.log(`  - ${issue}`));
        console.log();
      }
    }
  }
  
  private saveDetailedReport(): void {
    const report = {
      timestamp: new Date().toISOString(),
      results: Array.from(this.results.entries()).map(([species, metrics]) => ({
        species,
        totalIngredients: metrics.totalIngredients,
        avgPalatability: metrics.avgPalatability,
        palatabilityDistribution: metrics.palatabilityDistribution,
        topIngredients: metrics.topIngredients,
        bottomIngredients: metrics.bottomIngredients,
        avgRecipePalatability: metrics.avgRecipePalatability,
        recipePalatabilityScores: metrics.recipePalatabilityScores,
      })),
    };
    
    const outputPath = path.join(process.cwd(), 'RECIPE_PALATABILITY_AUDIT.json');
    fs.writeFileSync(outputPath, JSON.stringify(report, null, 2), 'utf-8');
    
    console.log(`Detailed report saved to: ${outputPath}`);
    console.log();
  }
}

// Run the audit
const audit = new RecipePalatabilityAudit();
audit.runAudit().catch(console.error);
</file>

<file path="lib/audit/RecipeVarietyAudit.ts">
// Recipe Variety Audit - Analyze diversity mechanisms across all species
// Tests if recipes actually vary between generations and ingredient rotation

import { RecipeBuilder, GenerationConstraints } from '../generator/RecipeBuilder';
import type { Species } from '@/lib/data/ingredients';
import * as fs from 'fs';
import * as path from 'path';

interface VarietyMetrics {
  species: Species;
  totalRecipes: number;
  uniqueIngredients: Set<string>;
  ingredientFrequency: Map<string, number>;
  uniqueRecipes: number;
  duplicateRecipes: number;
  averageIngredientsPerRecipe: number;
  ingredientRotation: number; // 0-1, higher = better rotation
  diversityScore: number; // 0-100, higher = better variety
}

interface RecipeSignature {
  ingredients: string[];
  hash: string;
}

export class RecipeVarietyAudit {
  private results: Map<Species, VarietyMetrics> = new Map();
  
  async runAudit(): Promise<void> {
    console.log('='.repeat(80));
    console.log('RECIPE VARIETY AUDIT');
    console.log('='.repeat(80));
    console.log();
    
    const species: Species[] = ['dogs', 'cats', 'birds', 'reptiles', 'pocket-pets'];
    const recipesPerSpecies = 50; // Generate 50 recipes per species
    
    for (const sp of species) {
      console.log(`Testing ${sp}...`);
      await this.testSpeciesVariety(sp, recipesPerSpecies);
    }
    
    this.generateReport();
  }
  
  private async testSpeciesVariety(species: Species, count: number): Promise<void> {
    const recipes: RecipeSignature[] = [];
    const ingredientFrequency = new Map<string, number>();
    const uniqueIngredients = new Set<string>();
    let totalIngredients = 0;
    
    // Generate recipes with different diversity modes
    const diversityModes = ['high', 'medium', 'low', 'none'] as const;
    const recipesPerMode = Math.floor(count / diversityModes.length);
    
    for (const mode of diversityModes) {
      for (let i = 0; i < recipesPerMode; i++) {
        const constraints: GenerationConstraints = {
          species,
          lifeStage: 'adult',
          petWeightKg: this.getTypicalWeight(species),
          healthConcerns: [],
          allergies: [],
        };
        
        try {
          const builder = new RecipeBuilder(constraints, 'standard', mode);
          const recipe = await builder.generate();
          
          if (recipe && recipe.ingredients.length > 0) {
            // Track ingredients
            const ingredientNames = recipe.ingredients.map(ing => ing.ingredient.name).sort();
            const hash = this.hashIngredients(ingredientNames);
            
            recipes.push({ ingredients: ingredientNames, hash });
            totalIngredients += ingredientNames.length;
            
            ingredientNames.forEach(name => {
              uniqueIngredients.add(name);
              ingredientFrequency.set(name, (ingredientFrequency.get(name) || 0) + 1);
            });
          }
        } catch (error) {
          console.error(`  Failed to generate recipe: ${error}`);
        }
      }
    }
    
    // Calculate metrics
    const uniqueHashes = new Set(recipes.map(r => r.hash));
    const uniqueRecipes = uniqueHashes.size;
    const duplicateRecipes = recipes.length - uniqueRecipes;
    const averageIngredientsPerRecipe = totalIngredients / recipes.length;
    
    // Calculate ingredient rotation score
    const rotationScore = this.calculateRotationScore(ingredientFrequency, recipes.length);
    
    // Calculate diversity score
    const diversityScore = this.calculateDiversityScore(
      uniqueRecipes,
      recipes.length,
      uniqueIngredients.size,
      rotationScore
    );
    
    this.results.set(species, {
      species,
      totalRecipes: recipes.length,
      uniqueIngredients,
      ingredientFrequency,
      uniqueRecipes,
      duplicateRecipes,
      averageIngredientsPerRecipe,
      ingredientRotation: rotationScore,
      diversityScore,
    });
  }
  
  private getTypicalWeight(species: Species): number {
    switch (species) {
      case 'dogs': return 15;
      case 'cats': return 5;
      case 'birds': return 0.5;
      case 'reptiles': return 0.3;
      case 'pocket-pets': return 1;
      default: return 10;
    }
  }
  
  private hashIngredients(ingredients: string[]): string {
    return ingredients.join('|');
  }
  
  private calculateRotationScore(
    frequency: Map<string, number>,
    totalRecipes: number
  ): number {
    // Perfect rotation = each ingredient used equally
    // Score 0-1, where 1 = perfect rotation
    
    const frequencies = Array.from(frequency.values());
    const avgFrequency = frequencies.reduce((a, b) => a + b, 0) / frequencies.length;
    
    // Calculate variance
    const variance = frequencies.reduce((sum, freq) => {
      return sum + Math.pow(freq - avgFrequency, 2);
    }, 0) / frequencies.length;
    
    // Lower variance = better rotation
    // Normalize to 0-1 scale
    const maxVariance = Math.pow(totalRecipes, 2);
    const normalizedVariance = Math.min(variance / maxVariance, 1);
    
    return 1 - normalizedVariance;
  }
  
  private calculateDiversityScore(
    uniqueRecipes: number,
    totalRecipes: number,
    uniqueIngredients: number,
    rotationScore: number
  ): number {
    // Weighted score:
    // 40% - Recipe uniqueness
    // 30% - Ingredient variety
    // 30% - Ingredient rotation
    
    const recipeUniqueness = (uniqueRecipes / totalRecipes) * 40;
    const ingredientVariety = Math.min(uniqueIngredients / 20, 1) * 30; // 20+ ingredients = max
    const rotation = rotationScore * 30;
    
    return recipeUniqueness + ingredientVariety + rotation;
  }
  
  private generateReport(): void {
    console.log();
    console.log('='.repeat(80));
    console.log('VARIETY AUDIT RESULTS');
    console.log('='.repeat(80));
    console.log();
    
    let totalScore = 0;
    let count = 0;
    
    for (const [species, metrics] of this.results) {
      console.log(`${species.toUpperCase()}`);
      console.log('-'.repeat(80));
      console.log(`Total recipes generated: ${metrics.totalRecipes}`);
      console.log(`Unique recipes: ${metrics.uniqueRecipes} (${((metrics.uniqueRecipes / metrics.totalRecipes) * 100).toFixed(1)}%)`);
      console.log(`Duplicate recipes: ${metrics.duplicateRecipes}`);
      console.log(`Unique ingredients used: ${metrics.uniqueIngredients.size}`);
      console.log(`Avg ingredients per recipe: ${metrics.averageIngredientsPerRecipe.toFixed(1)}`);
      console.log(`Ingredient rotation score: ${(metrics.ingredientRotation * 100).toFixed(1)}%`);
      console.log(`Overall diversity score: ${metrics.diversityScore.toFixed(1)}/100`);
      
      // Show most/least used ingredients
      const sorted = Array.from(metrics.ingredientFrequency.entries())
        .sort((a, b) => b[1] - a[1]);
      
      console.log();
      console.log(`Most used ingredients:`);
      sorted.slice(0, 5).forEach(([ing, count]) => {
        console.log(`  - ${ing}: ${count} times (${((count / metrics.totalRecipes) * 100).toFixed(1)}%)`);
      });
      
      console.log();
      console.log(`Least used ingredients:`);
      sorted.slice(-5).reverse().forEach(([ing, count]) => {
        console.log(`  - ${ing}: ${count} times (${((count / metrics.totalRecipes) * 100).toFixed(1)}%)`);
      });
      
      console.log();
      
      totalScore += metrics.diversityScore;
      count++;
    }
    
    const avgScore = totalScore / count;
    
    console.log('='.repeat(80));
    console.log('OVERALL ASSESSMENT');
    console.log('='.repeat(80));
    console.log();
    console.log(`Average diversity score: ${avgScore.toFixed(1)}/100`);
    console.log();
    
    if (avgScore >= 80) {
      console.log('‚úÖ EXCELLENT - Recipes show high variety and good rotation');
    } else if (avgScore >= 60) {
      console.log('‚ö†Ô∏è  GOOD - Recipes have decent variety but could be improved');
    } else if (avgScore >= 40) {
      console.log('‚ö†Ô∏è  FAIR - Recipes show some repetition, needs improvement');
    } else {
      console.log('‚ùå POOR - Recipes are too repetitive, major improvements needed');
    }
    
    console.log();
    this.generateRecommendations(avgScore);
    
    // Save detailed report
    this.saveDetailedReport();
  }
  
  private generateRecommendations(avgScore: number): void {
    console.log('RECOMMENDATIONS:');
    console.log('-'.repeat(80));
    
    for (const [species, metrics] of this.results) {
      if (metrics.diversityScore < 60) {
        console.log(`\n${species}:`);
        
        if (metrics.uniqueRecipes / metrics.totalRecipes < 0.7) {
          console.log('  - Too many duplicate recipes - increase randomization');
        }
        
        if (metrics.uniqueIngredients.size < 15) {
          console.log('  - Limited ingredient pool - expand available ingredients');
        }
        
        if (metrics.ingredientRotation < 0.5) {
          console.log('  - Poor ingredient rotation - some ingredients overused');
          
          // Find overused ingredients
          const sorted = Array.from(metrics.ingredientFrequency.entries())
            .sort((a, b) => b[1] - a[1]);
          
          const overused = sorted.filter(([_, count]) => 
            count / metrics.totalRecipes > 0.5
          );
          
          if (overused.length > 0) {
            console.log(`    Overused: ${overused.map(([ing]) => ing).join(', ')}`);
          }
        }
      }
    }
    
    console.log();
  }
  
  private saveDetailedReport(): void {
    const report = {
      timestamp: new Date().toISOString(),
      results: Array.from(this.results.entries()).map(([species, metrics]) => ({
        species,
        totalRecipes: metrics.totalRecipes,
        uniqueRecipes: metrics.uniqueRecipes,
        duplicateRecipes: metrics.duplicateRecipes,
        uniqueIngredients: metrics.uniqueIngredients.size,
        averageIngredientsPerRecipe: metrics.averageIngredientsPerRecipe,
        ingredientRotation: metrics.ingredientRotation,
        diversityScore: metrics.diversityScore,
        ingredientFrequency: Array.from(metrics.ingredientFrequency.entries()),
      })),
    };
    
    const outputPath = path.join(process.cwd(), 'RECIPE_VARIETY_AUDIT.json');
    fs.writeFileSync(outputPath, JSON.stringify(report, null, 2), 'utf-8');
    
    console.log(`Detailed report saved to: ${outputPath}`);
  }
}

// Run the audit
const audit = new RecipeVarietyAudit();
audit.runAudit().catch(console.error);
</file>

<file path="lib/competitors/balanceit-analysis.ts">
// lib/competitors/balanceit-analysis.ts
// Competitive analysis of BalanceIT.com - our main competitor

export interface CompetitorAnalysis {
  strengths: string[];
  weaknesses: string[];
  gapsToExploit: string[];
  pricingStructure: {
    perRecipe?: number;
    annualSubscription?: number;
    supplementSales?: string;
  };
  userPainPoints: string[];
  marketPosition: string;
  targetUsers: string[];
}

export const BALANCEIT_ANALYSIS: CompetitorAnalysis = {
  strengths: [
    "UC Davis veterinary school backing - strong credibility",
    "Supplement-focused approach (easy for vets to understand)",
    "Established since 1999 - long market presence",
    "Simple interface for basic nutritional needs",
    "Good for veterinary practices and professional use"
  ],

  weaknesses: [
    "DOG/CAT ONLY - no exotic pet support (birds, reptiles, small mammals)",
    "$14.95 per recipe (expensive for regular users)",
    "No compatibility scoring or dynamic recommendations",
    "Manual calculations required - not automated",
    "No affiliate/shopping integration - users must source ingredients themselves",
    "Outdated UI (looks like early 2000s web design)",
    "Limited ingredient database compared to modern apps",
    "No meal planning features or weekly meal prep",
    "No user community or recipe sharing",
    "No mobile app - desktop only"
  ],

  gapsToExploit: [
    "Complete exotic pet support (birds, reptiles, pocket pets) - huge market gap",
    "Free tier with affiliate monetization - accessible to all pet owners",
    "Dynamic compatibility scoring with real-time feedback",
    "One-click shopping lists with Amazon affiliate links",
    "Fresh/whole food focus vs expensive supplement approach",
    "Modern, user-friendly interface with mobile-first design",
    "Comprehensive ingredient database with USDA nutritional data",
    "Automated meal planning and portion calculations",
    "Community features and user-generated recipes",
    "Multi-device support with responsive design",
    "Educational content and veterinary-backed resources",
    "Cost-effective alternative to expensive vet consultations"
  ],

  pricingStructure: {
    perRecipe: 14.95,
    annualSubscription: 149,
    supplementSales: "Primary revenue stream through affiliate marketing"
  },

  userPainPoints: [
    "Cost per recipe adds up quickly for multiple pets",
    "No support for exotic pets (birds, reptiles, etc.)",
    "Requires veterinary knowledge to interpret results",
    "No automated meal planning or shopping features",
    "Limited ingredient database forces manual entry",
    "Outdated interface feels unprofessional",
    "No mobile access for on-the-go pet parents",
    "Expensive subscription model vs one-time purchases",
    "No community support or user resources",
    "Time-consuming process for regular meal prep"
  ],

  marketPosition: "Veterinary-focused supplement recommendation tool",

  targetUsers: [
    "Veterinary practices and animal hospitals",
    "Professional animal nutritionists",
    "Pet owners willing to pay premium for vet-backed advice",
    "Dog and cat owners with specific health concerns",
    "Users who prefer supplement-based solutions"
  ]
};

// Key competitive advantages for Paw & Plate
export const PAW_PLATE_ADVANTAGES = {
  exoticSupport: {
    title: "Complete Exotic Pet Coverage",
    description: "While BalanceIT only supports dogs and cats, Paw & Plate covers birds, reptiles, and pocket pets with species-specific nutrition standards.",
    impact: "Captures entire exotic pet market (30% of pet owners)"
  },

  pricingModel: {
    title: "Free Core Features",
    description: "Free recipe generation and meal planning vs $14.95 per recipe.",
    impact: "10x more accessible to average pet owners"
  },

  userExperience: {
    title: "Modern Mobile-First Design",
    description: "Beautiful, responsive interface vs 20-year-old web design.",
    impact: "Higher user engagement and satisfaction"
  },

  automation: {
    title: "One-Click Shopping",
    description: "Automated shopping lists with affiliate links vs manual sourcing.",
    impact: "Saves users 30+ minutes per meal prep"
  },

  community: {
    title: "User Community",
    description: "Recipe sharing and community features vs isolated experience.",
    impact: "Builds user loyalty and engagement"
  }
};

// Market opportunity analysis
export const MARKET_OPPORTUNITY = {
  totalAddressableMarket: "Pet nutrition software market: $2.3B globally",
  balanceitMarketShare: "~5% of dog/cat nutrition market",
  exoticPetGap: "70% of exotic pet owners have no nutrition planning tools",
  pricingAdvantage: "90% cost reduction vs BalanceIT's premium pricing",
  userAcquisition: "Free tier enables viral growth and affiliate monetization",

  projectedMetrics: {
    year1Users: 50000,
    year2Users: 250000,
    revenueModel: "Affiliate commissions + premium features",
    competitiveMoat: "Exotic pet specialization + modern UX"
  }
};
</file>

<file path="lib/generator/AmazonLinkAudit.ts">
// Amazon Affiliate Link Audit
// Checks all asinLink values in vetted-products for issues

import { VETTED_PRODUCTS } from '../data/vetted-products';

interface LinkIssue {
  ingredient: string;
  issue: string;
  asinLink?: string;
  productName?: string;
}

const issues: LinkIssue[] = [];
const stats = {
  total: 0,
  withLinks: 0,
  withoutLinks: 0,
  invalidFormat: 0,
  missingAsin: 0,
  suspiciousLinks: 0,
  duplicateAsins: new Map<string, string[]>(),
};

console.log('='.repeat(80));
console.log('AMAZON AFFILIATE LINK AUDIT');
console.log('='.repeat(80));
console.log();

// Check each product
for (const [ingredientName, product] of Object.entries(VETTED_PRODUCTS)) {
  stats.total++;
  
  const asinLink = product.asinLink;
  
  // Issue 1: Missing asinLink
  if (!asinLink || asinLink === '') {
    stats.withoutLinks++;
    issues.push({
      ingredient: ingredientName,
      issue: 'Missing asinLink',
      productName: product.productName,
    });
    continue;
  }
  
  stats.withLinks++;
  
  // Issue 2: Invalid format (should be Amazon URL)
  if (!asinLink.includes('amazon.com')) {
    stats.invalidFormat++;
    issues.push({
      ingredient: ingredientName,
      issue: 'Not an Amazon link',
      asinLink,
      productName: product.productName,
    });
    continue;
  }
  
  // Issue 3: Missing ASIN in URL
  const asinMatch = asinLink.match(/\/dp\/([A-Z0-9]{10})/i);
  if (!asinMatch) {
    stats.missingAsin++;
    issues.push({
      ingredient: ingredientName,
      issue: 'No valid ASIN found in URL',
      asinLink,
      productName: product.productName,
    });
    continue;
  }
  
  const asin = asinMatch[1];
  
  // Issue 4: Missing affiliate tag
  if (!asinLink.includes('tag=robinfrench-20')) {
    stats.suspiciousLinks++;
    issues.push({
      ingredient: ingredientName,
      issue: 'Missing affiliate tag (tag=robinfrench-20)',
      asinLink,
      productName: product.productName,
    });
  }
  
  // Track duplicate ASINs
  if (!stats.duplicateAsins.has(asin)) {
    stats.duplicateAsins.set(asin, []);
  }
  stats.duplicateAsins.get(asin)!.push(ingredientName);
}

// Find actual duplicates (same ASIN used for multiple ingredients)
const duplicates = Array.from(stats.duplicateAsins.entries())
  .filter(([_, ingredients]) => ingredients.length > 1);

// Print Summary
console.log('SUMMARY');
console.log('-'.repeat(80));
console.log(`Total products: ${stats.total}`);
console.log(`With links: ${stats.withLinks} (${((stats.withLinks / stats.total) * 100).toFixed(1)}%)`);
console.log(`Without links: ${stats.withoutLinks} (${((stats.withoutLinks / stats.total) * 100).toFixed(1)}%)`);
console.log();
console.log(`Issues found: ${issues.length}`);
console.log(`  - Invalid format: ${stats.invalidFormat}`);
console.log(`  - Missing ASIN: ${stats.missingAsin}`);
console.log(`  - Missing affiliate tag: ${stats.suspiciousLinks}`);
console.log(`  - Duplicate ASINs: ${duplicates.length} ASINs used for multiple ingredients`);
console.log();

// Print Issues
if (issues.length > 0) {
  console.log('='.repeat(80));
  console.log('ISSUES FOUND');
  console.log('='.repeat(80));
  console.log();
  
  // Group by issue type
  const byType = issues.reduce((acc, issue) => {
    if (!acc[issue.issue]) acc[issue.issue] = [];
    acc[issue.issue].push(issue);
    return acc;
  }, {} as Record<string, LinkIssue[]>);
  
  for (const [issueType, issueList] of Object.entries(byType)) {
    console.log(`${issueType} (${issueList.length}):`);
    console.log('-'.repeat(80));
    
    issueList.slice(0, 10).forEach(issue => {
      console.log(`  Ingredient: ${issue.ingredient}`);
      if (issue.productName) console.log(`  Product: ${issue.productName}`);
      if (issue.asinLink) console.log(`  Link: ${issue.asinLink}`);
      console.log();
    });
    
    if (issueList.length > 10) {
      console.log(`  ... and ${issueList.length - 10} more`);
      console.log();
    }
  }
}

// Print Duplicate ASINs
if (duplicates.length > 0) {
  console.log('='.repeat(80));
  console.log('DUPLICATE ASINs');
  console.log('='.repeat(80));
  console.log();
  console.log('Same ASIN used for multiple ingredients (may indicate incorrect mappings):');
  console.log();
  
  duplicates.slice(0, 20).forEach(([asin, ingredients]) => {
    console.log(`ASIN ${asin} used for ${ingredients.length} ingredients:`);
    ingredients.forEach(ing => console.log(`  - ${ing}`));
    console.log();
  });
  
  if (duplicates.length > 20) {
    console.log(`... and ${duplicates.length - 20} more duplicate ASINs`);
  }
}

// Print recommendations
console.log('='.repeat(80));
console.log('RECOMMENDATIONS');
console.log('='.repeat(80));
console.log();

if (stats.withoutLinks > 0) {
  console.log(`1. Add asinLink for ${stats.withoutLinks} products without links`);
}

if (stats.invalidFormat > 0) {
  console.log(`2. Fix ${stats.invalidFormat} products with invalid link format`);
}

if (stats.missingAsin > 0) {
  console.log(`3. Fix ${stats.missingAsin} products with missing/invalid ASIN`);
}

if (stats.suspiciousLinks > 0) {
  console.log(`4. Add affiliate tag to ${stats.suspiciousLinks} products`);
}

if (duplicates.length > 0) {
  console.log(`5. Review ${duplicates.length} duplicate ASINs - may indicate wrong products`);
}

if (issues.length === 0 && duplicates.length === 0) {
  console.log('‚úÖ All links look good! No issues found.');
}

console.log();
console.log('='.repeat(80));
</file>

<file path="lib/generator/AutoClassifyLinks.ts">
// Auto-classify all 94 items using spec-based validation
// Reduces manual review from 94 ‚Üí ~15-20 items

import { VETTED_PRODUCTS } from '../data/vetted-products';
import { RETAIL_SPECS } from '../validation/retailSpecDefinitions';
import { RetailValidator } from '../validation/retailValidator';
import * as fs from 'fs';
import * as path from 'path';

interface ClassificationResult {
  ingredient: string;
  productName: string;
  asin: string;
  link: string;
  status: 'auto-valid' | 'auto-invalid' | 'needs-review' | 'no-spec';
  confidence: 'high' | 'medium' | 'low';
  issues: string[];
  notes: string;
}

const validator = new RetailValidator();
const results: ClassificationResult[] = [];

console.log('='.repeat(80));
console.log('AUTO-CLASSIFYING AMAZON LINKS');
console.log('='.repeat(80));
console.log();

// Track duplicate ASINs
const asinMap = new Map<string, string[]>();
for (const [ingredientName, product] of Object.entries(VETTED_PRODUCTS)) {
  const asinMatch = product.asinLink.match(/\/dp\/([A-Z0-9]{10})/i);
  if (asinMatch) {
    const asin = asinMatch[1];
    if (!asinMap.has(asin)) {
      asinMap.set(asin, []);
    }
    asinMap.get(asin)!.push(ingredientName);
  }
}

// Known dead links
const deadLinks = new Set(['B0082C00P8', 'B0006L2XNK']);

// Process each ingredient
for (const [ingredientName, product] of Object.entries(VETTED_PRODUCTS)) {
  const asinMatch = product.asinLink.match(/\/dp\/([A-Z0-9]{10})/i);
  if (!asinMatch) continue;
  
  const asin = asinMatch[1];
  const spec = RETAIL_SPECS[ingredientName];
  
  let status: ClassificationResult['status'];
  let confidence: ClassificationResult['confidence'];
  let issues: string[] = [];
  let notes = '';
  
  // Dead link check
  if (deadLinks.has(asin)) {
    status = 'auto-invalid';
    confidence = 'high';
    issues.push('Dead link (HTTP 405)');
    notes = 'NEEDS REPLACEMENT - Link is dead';
  }
  // Has spec - validate it
  else if (spec) {
    const validationResult = validator.validateProductTitle(
      product.productName,
      spec,
      asin
    );
    
    confidence = validationResult.confidence;
    issues = validationResult.issues.map(i => `${i.severity.toUpperCase()}: ${i.message}`);
    
    if (validationResult.status === 'valid') {
      status = 'auto-valid';
      notes = '‚úÖ Passes all validation checks';
    } else if (validationResult.status === 'invalid') {
      status = 'auto-invalid';
      notes = '‚ùå Failed validation - likely wrong product';
    } else {
      status = 'needs-review';
      notes = '‚ö†Ô∏è Ambiguous - manual review needed';
    }
  }
  // No spec - check if duplicate ASIN
  else {
    const duplicates = asinMap.get(asin) || [];
    if (duplicates.length > 1) {
      status = 'needs-review';
      confidence = 'medium';
      issues.push(`Duplicate ASIN shared with: ${duplicates.filter(d => d !== ingredientName).join(', ')}`);
      notes = '‚ö†Ô∏è Duplicate ASIN - verify if appropriate';
    } else {
      status = 'no-spec';
      confidence = 'medium';
      notes = 'No validation spec defined - assumed OK';
    }
  }
  
  results.push({
    ingredient: ingredientName,
    productName: product.productName,
    asin,
    link: product.asinLink,
    status,
    confidence,
    issues,
    notes,
  });
}

// Generate statistics
const stats = {
  total: results.length,
  autoValid: results.filter(r => r.status === 'auto-valid').length,
  autoInvalid: results.filter(r => r.status === 'auto-invalid').length,
  needsReview: results.filter(r => r.status === 'needs-review').length,
  noSpec: results.filter(r => r.status === 'no-spec').length,
};

console.log('CLASSIFICATION RESULTS');
console.log('-'.repeat(80));
console.log(`Total items: ${stats.total}`);
console.log(`‚úÖ Auto-valid: ${stats.autoValid} (${((stats.autoValid / stats.total) * 100).toFixed(1)}%)`);
console.log(`‚ùå Auto-invalid: ${stats.autoInvalid} (${((stats.autoInvalid / stats.total) * 100).toFixed(1)}%)`);
console.log(`‚ö†Ô∏è  Needs review: ${stats.needsReview} (${((stats.needsReview / stats.total) * 100).toFixed(1)}%)`);
console.log(`üìã No spec: ${stats.noSpec} (${((stats.noSpec / stats.total) * 100).toFixed(1)}%)`);
console.log();
console.log(`Manual review reduced from 94 ‚Üí ${stats.needsReview + stats.autoInvalid} items`);
console.log();

// Show items needing review
const reviewItems = results.filter(r => r.status === 'needs-review' || r.status === 'auto-invalid');

if (reviewItems.length > 0) {
  console.log('='.repeat(80));
  console.log(`ITEMS REQUIRING MANUAL REVIEW (${reviewItems.length})`);
  console.log('='.repeat(80));
  console.log();
  
  reviewItems.forEach((item, idx) => {
    console.log(`${idx + 1}. ${item.ingredient}`);
    console.log(`   Product: ${item.productName}`);
    console.log(`   ASIN: ${item.asin}`);
    console.log(`   Status: ${item.status.toUpperCase()}`);
    console.log(`   Confidence: ${item.confidence.toUpperCase()}`);
    if (item.issues.length > 0) {
      console.log(`   Issues:`);
      item.issues.forEach(issue => console.log(`     - ${issue}`));
    }
    console.log(`   Notes: ${item.notes}`);
    console.log(`   Link: ${item.link}`);
    console.log();
  });
}

// Generate CSV for manual review
const csvHeader = 'Status,Ingredient,Product Name,ASIN,Confidence,Issues,Notes,Action Needed,Link\n';
const csvRows = reviewItems.map(item => {
  const escapeCsv = (str: string) => `"${str.replace(/"/g, '""')}"`;
  return [
    item.status.toUpperCase(),
    escapeCsv(item.ingredient),
    escapeCsv(item.productName),
    item.asin,
    item.confidence.toUpperCase(),
    escapeCsv(item.issues.join('; ')),
    escapeCsv(item.notes),
    item.status === 'auto-invalid' ? 'FIND NEW ASIN' : 'VERIFY',
    item.link,
  ].join(',');
}).join('\n');

const csv = csvHeader + csvRows;
const outputPath = path.join(process.cwd(), 'MANUAL_REVIEW_REQUIRED.csv');
fs.writeFileSync(outputPath, csv, 'utf-8');

console.log('='.repeat(80));
console.log('NEXT STEPS');
console.log('='.repeat(80));
console.log();
console.log(`1. Open MANUAL_REVIEW_REQUIRED.csv (${reviewItems.length} items)`);
console.log('2. Click each link and verify product matches ingredient');
console.log('3. For AUTO-INVALID items: Find replacement ASIN');
console.log('4. For NEEDS-REVIEW items: Confirm if product is correct');
console.log();
console.log(`CSV saved to: ${outputPath}`);
console.log();

// Generate summary report
const report = `# Auto-Classification Report

## Summary

**Total items processed:** ${stats.total}

- ‚úÖ **Auto-valid:** ${stats.autoValid} (${((stats.autoValid / stats.total) * 100).toFixed(1)}%)
- ‚ùå **Auto-invalid:** ${stats.autoInvalid} (${((stats.autoInvalid / stats.total) * 100).toFixed(1)}%)
- ‚ö†Ô∏è **Needs review:** ${stats.needsReview} (${((stats.needsReview / stats.total) * 100).toFixed(1)}%)
- üìã **No spec:** ${stats.noSpec} (${((stats.noSpec / stats.total) * 100).toFixed(1)}%)

**Manual review reduced:** 94 ‚Üí ${stats.needsReview + stats.autoInvalid} items (${Math.round((1 - (stats.needsReview + stats.autoInvalid) / 94) * 100)}% reduction)

---

## Auto-Invalid Items (${stats.autoInvalid})

These items failed validation and need replacement ASINs:

${results.filter(r => r.status === 'auto-invalid').map(item => 
  `### ${item.ingredient}
- **Product:** ${item.productName}
- **ASIN:** ${item.asin}
- **Issues:** ${item.issues.join(', ')}
- **Action:** Find correct product on Amazon
- **Link:** ${item.link}
`).join('\n')}

---

## Needs Review (${stats.needsReview})

These items are ambiguous and need human verification:

${results.filter(r => r.status === 'needs-review').slice(0, 10).map(item =>
  `### ${item.ingredient}
- **Product:** ${item.productName}
- **ASIN:** ${item.asin}
- **Issues:** ${item.issues.join(', ')}
- **Action:** Verify if product is correct
- **Link:** ${item.link}
`).join('\n')}

${stats.needsReview > 10 ? `\n... and ${stats.needsReview - 10} more (see CSV)\n` : ''}

---

## Auto-Valid Items (${stats.autoValid})

These items passed all validation checks and are assumed correct.

---

## Next Steps

1. **Review the ${reviewItems.length} flagged items** in MANUAL_REVIEW_REQUIRED.csv
2. **Find replacement ASINs** for auto-invalid items
3. **Verify ambiguous items** by clicking links
4. **Update vetted-products.ts** with corrections

---

## Phase 2: PA-API Integration

After manual review is complete, we'll implement:
- Automated metadata fetching from Amazon PA-API
- Price and availability tracking
- Automatic re-validation of stale links
- Confidence scoring and caching
`;

const reportPath = path.join(process.cwd(), 'AUTO_CLASSIFICATION_REPORT.md');
fs.writeFileSync(reportPath, report, 'utf-8');

console.log(`Report saved to: ${reportPath}`);
console.log();
console.log('='.repeat(80));
</file>

<file path="lib/generator/BirdDebug.ts">
// Detailed debug for bird recipe generation
import { RecipeBuilder, type GenerationConstraints } from './RecipeBuilder';
import { getIngredientsForSpecies } from '../data/ingredients';

const constraints: GenerationConstraints = {
  species: 'birds',
  lifeStage: 'adult',
  petWeightKg: 0.5,
  healthConcerns: ['digestive_issues'],
  targetCalories: 100,
};

console.log('=== BIRD RECIPE DEBUG ===\n');

// Check available ingredients
const allBirdIngredients = getIngredientsForSpecies('birds');
console.log(`Total bird ingredients available: ${allBirdIngredients.length}`);

const seeds = allBirdIngredients.filter(ing => ing.category === 'seed');
const nuts = allBirdIngredients.filter(ing => ing.category === 'nut');
const insects = allBirdIngredients.filter(ing => ing.category === 'insect');
const fruits = allBirdIngredients.filter(ing => ing.category === 'fruit');
const vegetables = allBirdIngredients.filter(ing => ing.category === 'vegetable');

console.log(`\nBy category:`);
console.log(`  Seeds: ${seeds.length}`);
console.log(`  Nuts: ${nuts.length}`);
console.log(`  Insects: ${insects.length}`);
console.log(`  Fruits: ${fruits.length}`);
console.log(`  Vegetables: ${vegetables.length}`);

console.log(`\nSample seeds:`);
seeds.slice(0, 5).forEach(s => console.log(`  - ${s.name} (id: ${s.id})`));

console.log(`\nSample nuts:`);
nuts.slice(0, 5).forEach(n => console.log(`  - ${n.name} (id: ${n.id})`));

console.log(`\n${'='.repeat(80)}`);
console.log('Attempting recipe generation...\n');

// Attempt generation with internal logging
const builder = new RecipeBuilder(constraints, 'standard', 'medium');

// Access private method via any cast to see what's happening
const builderAny = builder as any;

// Try to generate and see what happens
try {
  const recipe = builder.generate();
  
  if (recipe) {
    console.log('‚úÖ Recipe generated successfully!');
    console.log(`\nIngredients (${recipe.ingredients.length}):`);
    recipe.ingredients.forEach(p => {
      console.log(`  - ${p.ingredient.name} (${p.ingredient.category}): ${p.grams}g`);
    });
  } else {
    console.log('‚ùå Recipe generation returned null');
  }
} catch (error: any) {
  console.log('‚ùå Error during generation:', error.message);
  console.log(error.stack);
}
</file>

<file path="lib/generator/BirdDetailedDebug.ts">
// Very detailed debug - manually walk through the RecipeBuilder process
import { getIngredientsForSpecies } from '../data/ingredients';
import type { Ingredient } from '../data/ingredients';

const species = 'birds';
const healthConcerns = ['digestive_issues'];

console.log('=== DETAILED BIRD INGREDIENT DEBUG ===\n');

// Step 1: Get all bird ingredients
const allBirdIngredients = getIngredientsForSpecies(species);
console.log(`Step 1: Total bird ingredients: ${allBirdIngredients.length}\n`);

// Step 2: Check categories
const byCategory: Record<string, Ingredient[]> = {};
allBirdIngredients.forEach(ing => {
  if (!byCategory[ing.category]) byCategory[ing.category] = [];
  byCategory[ing.category].push(ing);
});

console.log('Step 2: Ingredients by category:');
Object.entries(byCategory).forEach(([cat, ings]) => {
  console.log(`  ${cat}: ${ings.length} ingredients`);
});

// Step 3: Check quality scores for seeds/nuts
console.log('\nStep 3: Quality scores for seeds:');
const seeds = byCategory['seed'] || [];
seeds.slice(0, 10).forEach(s => {
  console.log(`  ${s.name}: quality=${s.qualityScore}, feedingRole=${s.feedingRole}`);
});

console.log('\nStep 3b: Quality scores for nuts:');
const nuts = byCategory['nut'] || [];
nuts.slice(0, 10).forEach(n => {
  console.log(`  ${n.name}: quality=${n.qualityScore}, feedingRole=${n.feedingRole}`);
});

// Step 4: Filter by quality tier (standard = qualityScore >= 5)
const qualityTier = 'standard';
const minQuality = qualityTier === 'premium' ? 7 : qualityTier === 'standard' ? 5 : 0;

console.log(`\nStep 4: Filtering by quality tier '${qualityTier}' (min quality: ${minQuality})`);
const afterQualityFilter = allBirdIngredients.filter(ing => ing.qualityScore >= minQuality);
console.log(`  Remaining after quality filter: ${afterQualityFilter.length}`);

const seedsAfterFilter = afterQualityFilter.filter(ing => ing.category === 'seed');
const nutsAfterFilter = afterQualityFilter.filter(ing => ing.category === 'nut');
const insectsAfterFilter = afterQualityFilter.filter(ing => ing.category === 'insect');

console.log(`  Seeds after filter: ${seedsAfterFilter.length}`);
console.log(`  Nuts after filter: ${nutsAfterFilter.length}`);
console.log(`  Insects after filter: ${insectsAfterFilter.length}`);

if (seedsAfterFilter.length === 0) {
  console.log('\n‚ö†Ô∏è  WARNING: No seeds passed quality filter!');
  console.log('Seeds that failed:');
  seeds.forEach(s => {
    if (s.qualityScore < minQuality) {
      console.log(`  ‚ùå ${s.name}: quality=${s.qualityScore} (needs ${minQuality})`);
    }
  });
}

if (nutsAfterFilter.length === 0) {
  console.log('\n‚ö†Ô∏è  WARNING: No nuts passed quality filter!');
  console.log('Nuts that failed:');
  nuts.forEach(n => {
    if (n.qualityScore < minQuality) {
      console.log(`  ‚ùå ${n.name}: quality=${n.qualityScore} (needs ${minQuality})`);
    }
  });
}

// Step 5: Check what would be selected
console.log('\n=== SELECTION SIMULATION ===');
const requiredCategories = ['seed', 'nut', 'fruit', 'vegetable'];
console.log(`Required categories for birds: ${requiredCategories.join(', ')}\n`);

for (const category of requiredCategories) {
  const inCategory = afterQualityFilter.filter(ing => ing.category === category);
  console.log(`${category}: ${inCategory.length} available`);
  if (inCategory.length > 0) {
    console.log(`  Top 3:`);
    inCategory.slice(0, 3).forEach(ing => {
      console.log(`    - ${ing.name} (quality: ${ing.qualityScore})`);
    });
  } else {
    console.log(`  ‚ö†Ô∏è  NONE AVAILABLE - THIS WILL CAUSE ISSUES`);
  }
}
</file>

<file path="lib/generator/BirdTest.ts">
// Quick test for bird recipe generation
import { RecipeBuilder, type GenerationConstraints } from './RecipeBuilder';

const constraints: GenerationConstraints = {
  species: 'birds',
  lifeStage: 'adult',
  petWeightKg: 0.5, // Small bird
  healthConcerns: ['digestive_issues'],
  targetCalories: 100,
};

console.log('Testing bird recipe generation...');
console.log('Constraints:', constraints);
console.log('='.repeat(80));

for (let attempt = 1; attempt <= 3; attempt++) {
  console.log(`\nAttempt ${attempt}:`);
  try {
    const builder = new RecipeBuilder(constraints, 'standard', 'medium');
    const recipe = builder.generate();
    
    if (recipe) {
      console.log('‚úÖ SUCCESS!');
      console.log(`Ingredients (${recipe.ingredients.length}):`);
      recipe.ingredients.forEach(p => {
        console.log(`  - ${p.ingredient.name} (${p.ingredient.category}): ${p.grams}g`);
      });
      console.log(`Total: ${recipe.ingredients.reduce((sum, p) => sum + p.grams, 0)}g`);
      break;
    } else {
      console.log('‚ùå No recipe generated');
    }
  } catch (error: any) {
    console.log('‚ùå Error:', error.message);
  }
}
</file>

<file path="lib/generator/CheckBirdIngredients.ts">
// Check what bird ingredients are available
import { getIngredientsForSpecies } from '../data/ingredients';

console.log('Checking bird ingredients...\n');

const birdIngredients = getIngredientsForSpecies('birds');
console.log(`Total bird ingredients: ${birdIngredients.length}\n`);

// Group by category
const byCategory: Record<string, number> = {};
birdIngredients.forEach(ing => {
  byCategory[ing.category] = (byCategory[ing.category] || 0) + 1;
});

console.log('By category:');
Object.entries(byCategory).sort((a, b) => b[1] - a[1]).forEach(([cat, count]) => {
  console.log(`  ${cat}: ${count}`);
});

console.log('\n=== Seeds ===');
birdIngredients.filter(ing => ing.category === 'seed').slice(0, 10).forEach(ing => {
  console.log(`  - ${ing.name} (${ing.id})`);
});

console.log('\n=== Nuts ===');
birdIngredients.filter(ing => ing.category === 'nut').slice(0, 10).forEach(ing => {
  console.log(`  - ${ing.name} (${ing.id})`);
});

console.log('\n=== Insects ===');
birdIngredients.filter(ing => ing.category === 'insect').slice(0, 10).forEach(ing => {
  console.log(`  - ${ing.name} (${ing.id})`);
});

console.log('\n=== Fruits ===');
birdIngredients.filter(ing => ing.category === 'fruit').slice(0, 10).forEach(ing => {
  console.log(`  - ${ing.name} (${ing.id})`);
});

console.log('\n=== Vegetables ===');
birdIngredients.filter(ing => ing.category === 'vegetable').slice(0, 10).forEach(ing => {
  console.log(`  - ${ing.name} (${ing.id})`);
});
</file>

<file path="lib/generator/CombinatoricsPruning.ts">
/**
 * COMBINATORICS PRUNING
 * Pre-validation filtering to prevent micronutrient-toxic pairings
 * 
 * This runs BEFORE validation, teaching the generator what NOT to produce
 * instead of just rejecting finished recipes.
 */

import type { Ingredient } from '@/lib/data/ingredients';

// ============================================================================
// TOXIC PAIRINGS (Disallow these combinations)
// ============================================================================

interface ToxicPairing {
  ingredients: string[]; // ingredient names (lowercase, partial match)
  reason: string;
  maxAllowed?: number; // max of this pairing allowed (0 = never)
}

const TOXIC_PAIRINGS: ToxicPairing[] = [
  // Liver + high-iodine fish = vitamin A + iodine overload
  {
    ingredients: ['liver', 'salmon'],
    reason: 'Liver + salmon = vitamin A + iodine spike',
    maxAllowed: 0,
  },
  {
    ingredients: ['liver', 'cod'],
    reason: 'Liver + cod = vitamin A + iodine overload',
    maxAllowed: 0,
  },
  {
    ingredients: ['liver', 'sardine'],
    reason: 'Liver + sardine = vitamin A + iodine spike',
    maxAllowed: 0,
  },
  {
    ingredients: ['liver', 'mackerel'],
    reason: 'Liver + mackerel = vitamin A + iodine overload',
    maxAllowed: 0,
  },
  {
    ingredients: ['liver', 'herring'],
    reason: 'Liver + herring = vitamin A + iodine spike',
    maxAllowed: 0,
  },

  // Liver + high-iodine supplements = iodine bomb
  {
    ingredients: ['liver', 'kelp'],
    reason: 'Liver + kelp = iodine bomb',
    maxAllowed: 0,
  },
  {
    ingredients: ['liver', 'seaweed'],
    reason: 'Liver + seaweed = iodine overload',
    maxAllowed: 0,
  },

  // Multiple organ meats = mineral overload
  {
    ingredients: ['liver', 'kidney'],
    reason: 'Multiple organ meats = copper/mineral toxicity',
    maxAllowed: 0,
  },
  {
    ingredients: ['liver', 'heart'],
    reason: 'Multiple organ meats = mineral imbalance',
    maxAllowed: 0,
  },

  // High-copper sources together
  {
    ingredients: ['liver', 'sunflower_seed'],
    reason: 'Liver + sunflower seeds = copper overload',
    maxAllowed: 0,
  },
  {
    ingredients: ['liver', 'pumpkin_seed'],
    reason: 'Liver + pumpkin seeds = copper spike',
    maxAllowed: 0,
  },

  // Oxalate + calcium = absorption issues
  {
    ingredients: ['spinach', 'eggshell_powder'],
    reason: 'Spinach oxalates + calcium supplement = poor absorption',
    maxAllowed: 0,
  },
];

// ============================================================================
// INGREDIENT MICRONUTRIENT DENSITY PROFILE
// ============================================================================

interface MicronutrientProfile {
  vitaminA?: 'high' | 'medium' | 'low';
  copper?: 'high' | 'medium' | 'low';
  iodine?: 'high' | 'medium' | 'low';
  oxalates?: 'high' | 'medium' | 'low';
}

const MICRONUTRIENT_PROFILES: Record<string, MicronutrientProfile> = {
  // Organ meats (high in multiple micronutrients)
  liver: { vitaminA: 'high', copper: 'high', iodine: 'medium' },
  kidney: { copper: 'high', iodine: 'medium' },
  heart: { copper: 'medium' },

  // Fish (iodine-rich)
  salmon: { iodine: 'high', vitaminA: 'medium' },
  cod: { iodine: 'high' },
  sardine: { iodine: 'high' },
  mackerel: { iodine: 'high' },
  herring: { iodine: 'high' },

  // Supplements (concentrated)
  kelp: { iodine: 'high' },
  seaweed: { iodine: 'high' },
  fish_oil: { vitaminA: 'high' },
  cod_liver_oil: { vitaminA: 'high', iodine: 'high' },

  // Seeds (copper-rich)
  sunflower_seed: { copper: 'high' },
  pumpkin_seed: { copper: 'high' },
  sesame_seed: { copper: 'high' },

  // Vegetables (oxalate-rich)
  spinach: { oxalates: 'high' },
  beet_greens: { oxalates: 'high' },
  chard: { oxalates: 'high' },
};

// ============================================================================
// PRUNING FUNCTIONS
// ============================================================================

/**
 * Check if a pairing violates toxic combination rules
 */
export function hasToxicPairing(ingredients: Ingredient[]): boolean {
  const names = ingredients.map(ing => ing.name.toLowerCase());

  for (const pairing of TOXIC_PAIRINGS) {
    const matches = pairing.ingredients.filter(required =>
      names.some(name => name.includes(required))
    );

    if (matches.length === pairing.ingredients.length) {
      // All ingredients in this toxic pairing are present
      if (pairing.maxAllowed === 0) {
        return true; // Disallowed
      }
    }
  }

  return false;
}

/**
 * Get micronutrient density profile for an ingredient
 */
export function getMicronutrientProfile(ingredient: Ingredient): MicronutrientProfile {
  const name = ingredient.name.toLowerCase();

  for (const [key, profile] of Object.entries(MICRONUTRIENT_PROFILES)) {
    if (name.includes(key)) {
      return profile;
    }
  }

  return {}; // Unknown ingredient, assume low density
}

/**
 * Calculate cumulative micronutrient risk for a recipe
 * Returns a risk score (0-100) where 100 = definitely toxic
 * 
 * NOTE: This is SOFT pruning. Only flag truly dangerous combos.
 * Fish + liver is OK. Fish + fish oil + liver is risky.
 */
export function calculateMicronutrientRisk(ingredients: Ingredient[]): number {
  let risk = 0;

  // Check for specific dangerous combos
  const vitaminAHighCount = ingredients.filter(ing => {
    const profile = getMicronutrientProfile(ing);
    return profile.vitaminA === 'high';
  }).length;

  const iodineHighCount = ingredients.filter(ing => {
    const profile = getMicronutrientProfile(ing);
    return profile.iodine === 'high';
  }).length;

  const copperHighCount = ingredients.filter(ing => {
    const profile = getMicronutrientProfile(ing);
    return profile.copper === 'high';
  }).length;

  // Only flag if we have MULTIPLE high sources of the SAME nutrient
  // (not just any high-density ingredient)
  
  // Multiple vitamin A sources (e.g., liver + fish oil)
  if (vitaminAHighCount >= 2) risk += 50;

  // Multiple iodine sources (e.g., kelp + fish + fish oil)
  if (iodineHighCount >= 3) risk += 50;
  else if (iodineHighCount >= 2) risk += 20; // Mild risk for 2 iodine sources

  // Multiple copper sources (e.g., liver + seeds)
  if (copperHighCount >= 2) risk += 40;

  return Math.min(100, risk);
}

/**
 * Prune candidates that are likely to fail T6 (nutrient ceiling)
 * Returns true if candidate should be rejected
 */
export function shouldPruneCandidateForMicronutrients(ingredients: Ingredient[]): boolean {
  // Hard reject: toxic pairings
  if (hasToxicPairing(ingredients)) {
    return true;
  }

  // Soft reject: high micronutrient risk
  const risk = calculateMicronutrientRisk(ingredients);
  if (risk > 70) {
    return true; // Likely to fail T6
  }

  return false;
}

/**
 * Get a human-readable reason why a candidate was pruned
 */
export function getPruningReason(ingredients: Ingredient[]): string {
  if (hasToxicPairing(ingredients)) {
    const names = ingredients.map(ing => ing.name.toLowerCase());
    for (const pairing of TOXIC_PAIRINGS) {
      const matches = pairing.ingredients.filter(required =>
        names.some(name => name.includes(required))
      );
      if (matches.length === pairing.ingredients.length) {
        return pairing.reason;
      }
    }
  }

  const risk = calculateMicronutrientRisk(ingredients);
  if (risk > 70) {
    return `High micronutrient risk (${Math.round(risk)}/100)`;
  }

  return 'Unknown';
}
</file>

<file path="lib/generator/CommercialPriorEnforcement.ts">
/**
 * COMMERCIAL PRIOR ENFORCEMENT
 * 
 * Enforces learned commercial pairing rules:
 * - hardBlockPairs: Filter out candidates that never co-occur with selected ingredients
 * - strongPenaltyPairs: Apply harsh penalty (0.05x) to rare negative pairings
 * - Positive PMI: Apply soft boost (1.05-1.15x) to common pairings
 */

import recipePriors from '../data/recipePriors.json';
import type { Species } from '../types';

interface CommercialPriors {
  ingredientCounts: Record<string, number>;
  ingredientFreq: Record<string, number>;
  pairCounts: Record<string, number>;
  pairPMI: Record<string, number>;
  hardBlockPairs: string[];
  strongPenaltyPairs: string[];
}

/**
 * Normalize pair key to sorted format (a|b)
 */
function normalizePairKey(ing1: string, ing2: string): string {
  return [ing1, ing2].sort().join('|');
}

/**
 * Get commercial priors for a species
 */
function getCommercialPriors(species: Species): CommercialPriors | null {
  const priors = (recipePriors as any).commercialPriors;
  if (!priors) return null;
  
  // Map species to commercial priors key
  const speciesKey = species === 'dogs' || species === 'cats' ? species : null;
  if (!speciesKey) return null;
  
  return priors[speciesKey] as CommercialPriors;
}

/**
 * Check if a candidate ingredient is hard-blocked by any selected ingredient
 * Returns the blocking pair if found, null otherwise
 */
export function checkHardBlock(
  candidateId: string,
  selectedIngredientIds: string[],
  species: Species
): string | null {
  const priors = getCommercialPriors(species);
  if (!priors || !priors.hardBlockPairs) return null;
  
  const hardBlockSet = new Set(priors.hardBlockPairs);
  
  for (const selectedId of selectedIngredientIds) {
    const pairKey = normalizePairKey(candidateId, selectedId);
    if (hardBlockSet.has(pairKey)) {
      return pairKey;
    }
  }
  
  return null;
}

/**
 * Check if a candidate ingredient has strong penalty pairs with selected ingredients
 * Returns array of penalty pairs
 */
export function checkStrongPenalty(
  candidateId: string,
  selectedIngredientIds: string[],
  species: Species
): string[] {
  const priors = getCommercialPriors(species);
  if (!priors || !priors.strongPenaltyPairs) return [];
  
  const penaltySet = new Set(priors.strongPenaltyPairs);
  const penaltyPairs: string[] = [];
  
  for (const selectedId of selectedIngredientIds) {
    const pairKey = normalizePairKey(candidateId, selectedId);
    if (penaltySet.has(pairKey)) {
      penaltyPairs.push(pairKey);
    }
  }
  
  return penaltyPairs;
}

/**
 * Get PMI boost for a candidate ingredient paired with selected ingredients
 * Returns multiplier (1.0 = no change, >1.0 = boost, <1.0 = penalty)
 */
export function getPMIBoost(
  candidateId: string,
  selectedIngredientIds: string[],
  species: Species
): number {
  const priors = getCommercialPriors(species);
  if (!priors || !priors.pairPMI) return 1.0;
  
  let totalPMI = 0;
  let pairCount = 0;
  
  for (const selectedId of selectedIngredientIds) {
    const pairKey = normalizePairKey(candidateId, selectedId);
    const pmi = priors.pairPMI[pairKey];
    
    if (pmi !== undefined && pmi > 0) {
      totalPMI += pmi;
      pairCount++;
    }
  }
  
  if (pairCount === 0) return 1.0;
  
  // Average PMI across pairs
  const avgPMI = totalPMI / pairCount;
  
  // Convert to multiplier: PMI of 1.0 -> 1.05x boost, PMI of 2.0 -> 1.10x boost
  // Cap at 1.15x to avoid over-boosting
  const boost = 1.0 + Math.min(avgPMI * 0.05, 0.15);
  
  return boost;
}

/**
 * Filter candidates by commercial priors
 * Removes hard-blocked candidates and logs reasons
 */
export function filterCandidatesByCommercialPriors<T extends { id: string }>(
  candidates: T[],
  selectedIngredientIds: string[],
  species: Species,
  logPrefix: string = ''
): T[] {
  const priors = getCommercialPriors(species);
  if (!priors) return candidates;
  
  return candidates.filter(candidate => {
    const blockingPair = checkHardBlock(candidate.id, selectedIngredientIds, species);
    
    if (blockingPair) {
      const [ing1, ing2] = blockingPair.split('|');
      console.log(`${logPrefix}[PAIR BLOCK] ${candidate.id}: Never co-occurs with ${ing1 === candidate.id ? ing2 : ing1} (commercial data)`);
      return false;
    }
    
    return true;
  });
}

/**
 * Apply commercial prior scoring to a candidate
 * Returns modified score and logs reasons
 */
export function applyCommercialPriorScoring(
  candidateId: string,
  baseScore: number,
  selectedIngredientIds: string[],
  species: Species,
  logPrefix: string = ''
): number {
  const priors = getCommercialPriors(species);
  if (!priors) return baseScore;
  
  let score = baseScore;
  
  // Check for strong penalty pairs
  const penaltyPairs = checkStrongPenalty(candidateId, selectedIngredientIds, species);
  if (penaltyPairs.length > 0) {
    score *= 0.05; // Harsh penalty
    penaltyPairs.forEach(pair => {
      const [ing1, ing2] = pair.split('|');
      const otherIng = ing1 === candidateId ? ing2 : ing1;
      console.log(`${logPrefix}[PAIR PENALTY] ${candidateId}: Rare pairing with ${otherIng} (commercial data, PMI<-1.5)`);
    });
  }
  
  // Apply PMI boost for positive pairings
  const pmiBoost = getPMIBoost(candidateId, selectedIngredientIds, species);
  if (pmiBoost > 1.0) {
    score *= pmiBoost;
    console.log(`${logPrefix}[PMI BOOST] ${candidateId}: ${pmiBoost.toFixed(2)}x boost from commercial pairings`);
  }
  
  return score;
}

/**
 * Check if commercial priors are available for a species
 */
export function hasCommercialPriors(species: Species): boolean {
  return getCommercialPriors(species) !== null;
}
</file>

<file path="lib/generator/ComprehensiveAudit.ts">
// Comprehensive Audit: All Species + Health Concerns
// Tests recipe generation for every species with single and paired health concerns

import { RecipeBuilder, type GenerationConstraints } from './RecipeBuilder';

type Species = 'dogs' | 'cats' | 'birds' | 'reptiles' | 'pocket-pets';

const SPECIES: Species[] = ['dogs', 'cats', 'birds', 'reptiles', 'pocket-pets'];

const HEALTH_CONCERNS = [
  'allergies',
  'digestive_issues',
  'joint_health',
  'skin_health',
  'weight_management',
  'dental_health',
  'immune_support',
];

interface AuditResult {
  species: Species;
  healthConcerns: string[];
  success: boolean;
  attempts: number;
  totalGrams?: number;
  primaryProteins?: number;
  error?: string;
}

const results: AuditResult[] = [];

console.log('='.repeat(80));
console.log('COMPREHENSIVE RECIPE GENERATION AUDIT');
console.log('='.repeat(80));
console.log(`Testing ${SPECIES.length} species √ó ${HEALTH_CONCERNS.length} concerns + pairs`);
console.log(`Total combinations: ~${SPECIES.length * (HEALTH_CONCERNS.length + (HEALTH_CONCERNS.length * (HEALTH_CONCERNS.length - 1)) / 2)}`);
console.log('='.repeat(80));

let totalTests = 0;
let passedTests = 0;
let failedTests = 0;

// Test 1: Single health concerns
console.log('\nüìã PHASE 1: Single Health Concerns');
console.log('-'.repeat(80));

for (const species of SPECIES) {
  for (const concern of HEALTH_CONCERNS) {
    totalTests++;
    const constraints: GenerationConstraints = {
      species,
      lifeStage: 'adult',
      petWeightKg: species === 'dogs' ? 20 : species === 'cats' ? 5 : 2,
      healthConcerns: [concern],
      targetCalories: 500,
    };

    let attempts = 0;
    let success = false;
    let totalGrams = 0;
    let primaryProteins = 0;

    for (let i = 0; i < 3; i++) {
      attempts++;
      try {
        const builder = new RecipeBuilder(constraints, 'standard', 'medium');
        const recipe = builder.generate();

        if (recipe && recipe.ingredients.length > 0) {
          success = true;
          totalGrams = recipe.ingredients.reduce((sum, p) => sum + p.grams, 0);
          primaryProteins = recipe.ingredients.filter(
            p => p.ingredient.category === 'protein' && p.ingredient.proteinRole === 'primary'
          ).length;
          break;
        }
      } catch (error) {
        // Continue to next attempt
      }
    }

    const result: AuditResult = {
      species,
      healthConcerns: [concern],
      success,
      attempts,
      totalGrams,
      primaryProteins,
    };

    results.push(result);

    if (success) {
      passedTests++;
      console.log(`‚úÖ ${species.padEnd(12)} + ${concern.padEnd(20)} | ${totalGrams}g | ${primaryProteins} primary protein`);
    } else {
      failedTests++;
      console.log(`‚ùå ${species.padEnd(12)} + ${concern.padEnd(20)} | Failed after ${attempts} attempts`);
    }
  }
}

// Test 2: Paired health concerns (sample combinations)
console.log('\nüìã PHASE 2: Paired Health Concerns (Sample)');
console.log('-'.repeat(80));

const pairCombos = [
  ['allergies', 'digestive_issues'],
  ['joint_health', 'weight_management'],
  ['skin_health', 'immune_support'],
  ['digestive_issues', 'dental_health'],
  ['weight_management', 'immune_support'],
];

for (const species of SPECIES) {
  for (const [concern1, concern2] of pairCombos) {
    totalTests++;
    const constraints: GenerationConstraints = {
      species,
      lifeStage: 'adult',
      petWeightKg: species === 'dogs' ? 20 : species === 'cats' ? 5 : 2,
      healthConcerns: [concern1, concern2],
      targetCalories: 500,
    };

    let attempts = 0;
    let success = false;
    let totalGrams = 0;
    let primaryProteins = 0;

    for (let i = 0; i < 3; i++) {
      attempts++;
      try {
        const builder = new RecipeBuilder(constraints, 'standard', 'medium');
        const recipe = builder.generate();

        if (recipe && recipe.ingredients.length > 0) {
          success = true;
          totalGrams = recipe.ingredients.reduce((sum, p) => sum + p.grams, 0);
          primaryProteins = recipe.ingredients.filter(
            p => p.ingredient.category === 'protein' && p.ingredient.proteinRole === 'primary'
          ).length;
          break;
        }
      } catch (error) {
        // Continue to next attempt
      }
    }

    const result: AuditResult = {
      species,
      healthConcerns: [concern1, concern2],
      success,
      attempts,
      totalGrams,
      primaryProteins,
    };

    results.push(result);

    if (success) {
      passedTests++;
      console.log(
        `‚úÖ ${species.padEnd(12)} + ${(concern1 + ' + ' + concern2).padEnd(35)} | ${totalGrams}g | ${primaryProteins} primary protein`
      );
    } else {
      failedTests++;
      console.log(
        `‚ùå ${species.padEnd(12)} + ${(concern1 + ' + ' + concern2).padEnd(35)} | Failed after ${attempts} attempts`
      );
    }
  }
}

// Summary
console.log('\n' + '='.repeat(80));
console.log('AUDIT SUMMARY');
console.log('='.repeat(80));
console.log(`Total Tests: ${totalTests}`);
console.log(`‚úÖ Passed: ${passedTests} (${((passedTests / totalTests) * 100).toFixed(1)}%)`);
console.log(`‚ùå Failed: ${failedTests} (${((failedTests / totalTests) * 100).toFixed(1)}%)`);

// Breakdown by species
console.log('\nüìä Results by Species:');
for (const species of SPECIES) {
  const speciesResults = results.filter(r => r.species === species);
  const speciesPassed = speciesResults.filter(r => r.success).length;
  const speciesTotal = speciesResults.length;
  console.log(
    `  ${species.padEnd(12)}: ${speciesPassed}/${speciesTotal} (${((speciesPassed / speciesTotal) * 100).toFixed(1)}%)`
  );
}

// Breakdown by health concern
console.log('\nüìä Results by Health Concern (Single):');
for (const concern of HEALTH_CONCERNS) {
  const concernResults = results.filter(r => r.healthConcerns.length === 1 && r.healthConcerns[0] === concern);
  const concernPassed = concernResults.filter(r => r.success).length;
  const concernTotal = concernResults.length;
  console.log(
    `  ${concern.padEnd(20)}: ${concernPassed}/${concernTotal} (${((concernPassed / concernTotal) * 100).toFixed(1)}%)`
  );
}

// Failed combinations
const failedResults = results.filter(r => !r.success);
if (failedResults.length > 0) {
  console.log('\n‚ö†Ô∏è  Failed Combinations:');
  for (const result of failedResults.slice(0, 10)) {
    console.log(`  ${result.species} + ${result.healthConcerns.join(', ')}`);
  }
  if (failedResults.length > 10) {
    console.log(`  ... and ${failedResults.length - 10} more`);
  }
}

console.log('\n' + '='.repeat(80));
</file>

<file path="lib/generator/DebugProteinRole.ts">
// Quick debug to check proteinRole population
import { getIngredientsForSpecies } from '../data/ingredients';

const dogs = getIngredientsForSpecies('dogs');
const proteins = dogs.filter(i => i.category === 'protein').slice(0, 10);

console.log('=== Dog Proteins ===');
proteins.forEach(p => {
  console.log(`${p.name}: proteinRole=${p.proteinRole || 'undefined'}`);
});
</file>

<file path="lib/generator/GenerateVerificationList.ts">
// Generate a verification list for manual Amazon link checking
// Outputs CSV format for easy tracking in Excel/Sheets

import { VETTED_PRODUCTS } from '../data/vetted-products';
import * as fs from 'fs';
import * as path from 'path';

interface VerificationItem {
  ingredient: string;
  productName: string;
  asin: string;
  link: string;
  issue: string;
  priority: 'high' | 'medium' | 'low';
  verified: 'pending' | 'correct' | 'wrong' | 'dead';
  notes: string;
}

const items: VerificationItem[] = [];

// Track duplicate ASINs
const asinMap = new Map<string, string[]>();

for (const [ingredientName, product] of Object.entries(VETTED_PRODUCTS)) {
  const asinLink = product.asinLink;
  const asinMatch = asinLink.match(/\/dp\/([A-Z0-9]{10})/i);
  
  if (asinMatch) {
    const asin = asinMatch[1];
    if (!asinMap.has(asin)) {
      asinMap.set(asin, []);
    }
    asinMap.get(asin)!.push(ingredientName);
  }
}

// Known dead links from HTTP check
const deadLinks = new Set(['B0082C00P8', 'B0006L2XNK']);

// Known suspicious mappings
const suspiciousMapping: Record<string, { ingredients: string[]; issue: string }> = {
  'B07VHR2WNZ': { ingredients: ['ground beef (lean)', 'venison'], issue: 'Beef and venison are different meats' },
  'B0082C00P8': { ingredients: ['ground lamb', 'rabbit meat'], issue: 'Lamb and rabbit are different meats (DEAD LINK)' },
  'B0BXZ3JJL9': { ingredients: ['chicken hearts', 'turkey giblets'], issue: 'Chicken and turkey are different poultry' },
  'B01FUWYO2M': { ingredients: ['sardines (canned in water)', 'herring (canned)', 'sardines (in water)'], issue: 'Sardines and herring are different fish' },
  'B00WM6CHFQ': { ingredients: ['mango', 'chia seed oil'], issue: 'Mango and chia oil are completely different' },
  'B0BWBNT8JX': { ingredients: ['egg (hard-boiled)', 'duck hearts'], issue: 'Eggs and duck hearts are different' },
  'B00027ZVG4': { ingredients: ['canary seed', 'flaxseeds', 'rapeseed', 'sunflower seeds (small amounts)', 'pumpkin seeds', 'cuttlebone'], issue: 'Multiple seed types - verify if seed mix is appropriate' },
  'B086211R4H': { ingredients: ['niger seed', 'oat groats', 'hemp seeds', 'sesame seeds', 'chia seeds', 'pellets (fortified)'], issue: 'Multiple seed types - verify if seed mix is appropriate' },
};

// Generate verification items
for (const [ingredientName, product] of Object.entries(VETTED_PRODUCTS)) {
  const asinLink = product.asinLink;
  const asinMatch = asinLink.match(/\/dp\/([A-Z0-9]{10})/i);
  
  if (!asinMatch) continue;
  
  const asin = asinMatch[1];
  
  // Check if this needs verification
  let needsVerification = false;
  let issue = '';
  let priority: 'high' | 'medium' | 'low' = 'low';
  
  // Dead link
  if (deadLinks.has(asin)) {
    needsVerification = true;
    issue = 'Dead link (HTTP 405) - needs replacement';
    priority = 'high';
  }
  // Suspicious mapping
  else if (suspiciousMapping[asin]) {
    needsVerification = true;
    issue = suspiciousMapping[asin].issue;
    priority = 'high';
  }
  // Duplicate ASIN (but not in suspicious list)
  else if (asinMap.get(asin)!.length > 1) {
    needsVerification = true;
    issue = `Shared with: ${asinMap.get(asin)!.filter(i => i !== ingredientName).join(', ')}`;
    priority = 'medium';
  }
  
  if (needsVerification) {
    items.push({
      ingredient: ingredientName,
      productName: product.productName,
      asin,
      link: asinLink,
      issue,
      priority,
      verified: deadLinks.has(asin) ? 'dead' : 'pending',
      notes: '',
    });
  }
}

// Sort by priority
items.sort((a, b) => {
  const priorityOrder = { high: 0, medium: 1, low: 2 };
  return priorityOrder[a.priority] - priorityOrder[b.priority];
});

// Generate CSV
const csvHeader = 'Priority,Ingredient,Product Name,ASIN,Issue,Verified,Notes,Link\n';
const csvRows = items.map(item => {
  const escapeCsv = (str: string) => `"${str.replace(/"/g, '""')}"`;
  return [
    item.priority.toUpperCase(),
    escapeCsv(item.ingredient),
    escapeCsv(item.productName),
    item.asin,
    escapeCsv(item.issue),
    item.verified.toUpperCase(),
    '', // Empty notes column for manual entry
    item.link,
  ].join(',');
}).join('\n');

const csv = csvHeader + csvRows;

// Save to file
const outputPath = path.join(process.cwd(), 'AMAZON_LINK_VERIFICATION.csv');
fs.writeFileSync(outputPath, csv, 'utf-8');

console.log('='.repeat(80));
console.log('VERIFICATION LIST GENERATED');
console.log('='.repeat(80));
console.log();
console.log(`Total items needing verification: ${items.length}`);
console.log(`  High priority: ${items.filter(i => i.priority === 'high').length}`);
console.log(`  Medium priority: ${items.filter(i => i.priority === 'medium').length}`);
console.log(`  Low priority: ${items.filter(i => i.priority === 'low').length}`);
console.log();
console.log(`CSV file saved to: ${outputPath}`);
console.log();
console.log('HOW TO USE:');
console.log('1. Open AMAZON_LINK_VERIFICATION.csv in Excel/Google Sheets');
console.log('2. Click each link in the "Link" column');
console.log('3. Verify if the Amazon product matches the ingredient');
console.log('4. Update "Verified" column: CORRECT, WRONG, or DEAD');
console.log('5. Add notes in "Notes" column if needed');
console.log('6. For WRONG/DEAD items, find correct ASIN and add to notes');
console.log();
console.log('='.repeat(80));

// Also generate a markdown table for easy viewing
const mdTable = `# Amazon Link Verification List

Total items: ${items.length}

## High Priority (${items.filter(i => i.priority === 'high').length})

| Ingredient | Product | ASIN | Issue | Link |
|------------|---------|------|-------|------|
${items.filter(i => i.priority === 'high').map(item => 
  `| ${item.ingredient} | ${item.productName} | ${item.asin} | ${item.issue} | [Verify](${item.link}) |`
).join('\n')}

## Medium Priority (${items.filter(i => i.priority === 'medium').length})

| Ingredient | Product | ASIN | Issue | Link |
|------------|---------|------|-------|------|
${items.filter(i => i.priority === 'medium').slice(0, 10).map(item => 
  `| ${item.ingredient} | ${item.productName} | ${item.asin} | ${item.issue} | [Verify](${item.link}) |`
).join('\n')}

${items.filter(i => i.priority === 'medium').length > 10 ? `\n... and ${items.filter(i => i.priority === 'medium').length - 10} more medium priority items (see CSV)\n` : ''}

## Instructions

1. Click each "Verify" link
2. Check if Amazon product matches ingredient name
3. Mark in CSV: CORRECT, WRONG, or DEAD
4. For WRONG/DEAD: Find correct product and note new ASIN
`;

const mdPath = path.join(process.cwd(), 'AMAZON_LINK_VERIFICATION.md');
fs.writeFileSync(mdPath, mdTable, 'utf-8');

console.log(`Markdown file saved to: ${mdPath}`);
console.log();
</file>

<file path="lib/generator/Phase1_5_AutoClassify.ts">
// Phase 1.5: Enhanced auto-classification with clustering and token equivalence
// Reduces manual review from ~90 items to ~20 items

import { VETTED_PRODUCTS } from '../data/vetted-products';
import { RETAIL_SPECS } from '../validation/retailSpecDefinitions';
import { EnhancedRetailValidator } from '../validation/enhancedRetailValidator';
import { ASINClusterer } from '../validation/asinClusterer';
import * as fs from 'fs';
import * as path from 'path';

interface EnhancedClassificationResult {
  ingredient: string;
  productName: string;
  asin: string;
  link: string;
  status: 'auto-valid' | 'auto-structurally-valid' | 'auto-invalid' | 'needs-review' | 'no-spec';
  confidence: 'high' | 'medium' | 'low';
  issues: string[];
  notes: string;
  aliasGroup?: string;
  reasoning?: string;
}

const validator = new EnhancedRetailValidator();
const clusterer = new ASINClusterer();
const results: EnhancedClassificationResult[] = [];

console.log('='.repeat(80));
console.log('PHASE 1.5: ENHANCED AUTO-CLASSIFICATION');
console.log('With ASIN clustering + token equivalence + 4-state validation');
console.log('='.repeat(80));
console.log();

// Known dead links
const deadLinks = new Set(['B0082C00P8', 'B0006L2XNK']);

// STEP 1: Cluster duplicate ASINs
console.log('Step 1: Clustering duplicate ASINs...');
const productMap = new Map(Object.entries(VETTED_PRODUCTS));
const { aliasGroups, conflicts, singles } = clusterer.clusterByASIN(productMap);

console.log(`  Found ${aliasGroups.length} alias groups`);
console.log(`  Found ${conflicts.length} conflicts (wrong products)`);
console.log(`  Found ${singles.length} single-ASIN ingredients`);
console.log();

// STEP 2: Validate alias groups (once per group)
console.log('Step 2: Validating alias groups...');
const groupValidations = new Map<string, any>();

for (const group of aliasGroups) {
  const product = VETTED_PRODUCTS[group.canonicalName];
  if (!product) continue;
  
  const spec = RETAIL_SPECS[group.canonicalName];
  if (!spec) {
    // No spec for this group - mark as structurally valid by default
    groupValidations.set(group.groupId, {
      status: 'structurally-valid',
      confidence: 'medium',
      notes: 'No spec defined - assumed OK (alias group)',
    });
    continue;
  }
  
  const validationResult = validator.validateProductTitle(
    product.productName,
    spec,
    group.sharedASIN,
    group.canonicalName
  );
  
  groupValidations.set(group.groupId, validationResult);
}

console.log(`  Validated ${groupValidations.size} alias groups`);
console.log();

// STEP 3: Process all ingredients
console.log('Step 3: Classifying all ingredients...');

// Create reverse lookup: ingredient -> alias group
const ingredientToGroup = new Map<string, string>();
for (const group of aliasGroups) {
  for (const alias of group.aliases) {
    ingredientToGroup.set(alias, group.groupId);
  }
}

for (const [ingredientName, product] of Object.entries(VETTED_PRODUCTS)) {
  const asinMatch = product.asinLink.match(/\/dp\/([A-Z0-9]{10})/i);
  if (!asinMatch) continue;
  
  const asin = asinMatch[1];
  const spec = RETAIL_SPECS[ingredientName];
  
  let status: EnhancedClassificationResult['status'];
  let confidence: EnhancedClassificationResult['confidence'];
  let issues: string[] = [];
  let notes = '';
  let reasoning = '';
  let aliasGroup: string | undefined;
  
  // Check if dead link
  if (deadLinks.has(asin)) {
    status = 'auto-invalid';
    confidence = 'high';
    issues.push('Dead link (HTTP 405)');
    notes = '‚ùå NEEDS REPLACEMENT - Link is dead';
  }
  // Check if part of alias group
  else if (ingredientToGroup.has(ingredientName)) {
    const groupId = ingredientToGroup.get(ingredientName)!;
    const groupValidation = groupValidations.get(groupId);
    aliasGroup = groupId;
    
    if (groupValidation) {
      // Inherit validation from group
      if (groupValidation.status === 'valid') {
        status = 'auto-valid';
        confidence = groupValidation.confidence;
        notes = `‚úÖ Valid (alias group: ${groupId})`;
      } else if (groupValidation.status === 'structurally-valid') {
        status = 'auto-structurally-valid';
        confidence = groupValidation.confidence;
        notes = `‚úÖ Structurally valid (alias group: ${groupId})`;
        if (groupValidation.reasoning?.equivalentTokensUsed?.length > 0) {
          reasoning = `Uses equivalent tokens: ${groupValidation.reasoning.equivalentTokensUsed.map((e: any) => `${e.token}‚âà${e.synonym}`).join(', ')}`;
        }
      } else if (groupValidation.status === 'ambiguous') {
        status = 'needs-review';
        confidence = groupValidation.confidence;
        notes = `‚ö†Ô∏è Ambiguous (alias group: ${groupId})`;
      } else {
        status = 'auto-invalid';
        confidence = groupValidation.confidence;
        notes = `‚ùå Invalid (alias group: ${groupId})`;
      }
      
      if (groupValidation.structuralIssues) {
        issues.push(...groupValidation.structuralIssues.map((i: any) => `STRUCTURAL: ${i.message}`));
      }
      if (groupValidation.semanticIssues) {
        issues.push(...groupValidation.semanticIssues.map((i: any) => `SEMANTIC: ${i.message}`));
      }
    } else {
      status = 'no-spec';
      confidence = 'medium';
      notes = `No spec (alias group: ${groupId})`;
    }
  }
  // Check if conflict
  else if (conflicts.some(c => c.ingredients.includes(ingredientName))) {
    const conflict = conflicts.find(c => c.ingredients.includes(ingredientName))!;
    status = 'needs-review';
    confidence = 'low';
    issues.push(`CONFLICT: ${conflict.reason}`);
    notes = `‚ö†Ô∏è Conflict detected - likely wrong product`;
  }
  // Has spec - validate individually
  else if (spec) {
    const validationResult = validator.validateProductTitle(
      product.productName,
      spec,
      asin,
      ingredientName
    );
    
    confidence = validationResult.confidence;
    
    if (validationResult.structuralIssues) {
      issues.push(...validationResult.structuralIssues.map(i => `STRUCTURAL: ${i.message}`));
    }
    if (validationResult.semanticIssues) {
      issues.push(...validationResult.semanticIssues.map(i => `SEMANTIC: ${i.message}`));
    }
    
    if (validationResult.reasoning?.equivalentTokensUsed?.length > 0) {
      reasoning = `Uses equivalent tokens: ${validationResult.reasoning.equivalentTokensUsed.map(e => `${e.token}‚âà${e.synonym}`).join(', ')}`;
    }
    
    if (validationResult.status === 'valid') {
      status = 'auto-valid';
      notes = '‚úÖ Passes all validation checks';
    } else if (validationResult.status === 'structurally-valid') {
      status = 'auto-structurally-valid';
      notes = '‚úÖ Structurally valid - safe to use';
    } else if (validationResult.status === 'invalid') {
      status = 'auto-invalid';
      notes = '‚ùå Failed validation - likely wrong product';
    } else {
      status = 'needs-review';
      notes = '‚ö†Ô∏è Ambiguous - manual review needed';
    }
  }
  // No spec - assume OK
  else {
    status = 'no-spec';
    confidence = 'medium';
    notes = 'No validation spec defined - assumed OK';
  }
  
  results.push({
    ingredient: ingredientName,
    productName: product.productName,
    asin,
    link: product.asinLink,
    status,
    confidence,
    issues,
    notes,
    aliasGroup,
    reasoning,
  });
}

// Generate statistics
const stats = {
  total: results.length,
  autoValid: results.filter(r => r.status === 'auto-valid').length,
  autoStructurallyValid: results.filter(r => r.status === 'auto-structurally-valid').length,
  autoInvalid: results.filter(r => r.status === 'auto-invalid').length,
  needsReview: results.filter(r => r.status === 'needs-review').length,
  noSpec: results.filter(r => r.status === 'no-spec').length,
  inAliasGroups: results.filter(r => r.aliasGroup).length,
};

console.log();
console.log('='.repeat(80));
console.log('PHASE 1.5 RESULTS');
console.log('='.repeat(80));
console.log();
console.log(`Total items: ${stats.total}`);
console.log(`‚úÖ Auto-valid: ${stats.autoValid} (${((stats.autoValid / stats.total) * 100).toFixed(1)}%)`);
console.log(`‚úÖ Auto-structurally-valid: ${stats.autoStructurallyValid} (${((stats.autoStructurallyValid / stats.total) * 100).toFixed(1)}%)`);
console.log(`‚ùå Auto-invalid: ${stats.autoInvalid} (${((stats.autoInvalid / stats.total) * 100).toFixed(1)}%)`);
console.log(`‚ö†Ô∏è  Needs review: ${stats.needsReview} (${((stats.needsReview / stats.total) * 100).toFixed(1)}%)`);
console.log(`üìã No spec: ${stats.noSpec} (${((stats.noSpec / stats.total) * 100).toFixed(1)}%)`);
console.log();
console.log(`üîó In alias groups: ${stats.inAliasGroups} (${((stats.inAliasGroups / stats.total) * 100).toFixed(1)}%)`);
console.log();

const totalAccepted = stats.autoValid + stats.autoStructurallyValid + stats.noSpec;
const manualReviewNeeded = stats.needsReview + stats.autoInvalid;

console.log(`üìä SUMMARY:`);
console.log(`   Automatically accepted: ${totalAccepted} (${((totalAccepted / stats.total) * 100).toFixed(1)}%)`);
console.log(`   Manual review required: ${manualReviewNeeded} (${((manualReviewNeeded / stats.total) * 100).toFixed(1)}%)`);
console.log();
console.log(`üéØ Manual review reduced from 94 ‚Üí ${manualReviewNeeded} items`);
console.log(`   (${Math.round((1 - manualReviewNeeded / 94) * 100)}% reduction)`);
console.log();

// Show items needing review
const reviewItems = results.filter(r => r.status === 'needs-review' || r.status === 'auto-invalid');

if (reviewItems.length > 0) {
  console.log('='.repeat(80));
  console.log(`ITEMS REQUIRING MANUAL REVIEW (${reviewItems.length})`);
  console.log('='.repeat(80));
  console.log();
  
  reviewItems.forEach((item, idx) => {
    console.log(`${idx + 1}. ${item.ingredient}`);
    console.log(`   Product: ${item.productName}`);
    console.log(`   ASIN: ${item.asin}`);
    console.log(`   Status: ${item.status.toUpperCase()}`);
    if (item.aliasGroup) console.log(`   Alias Group: ${item.aliasGroup}`);
    if (item.issues.length > 0) {
      console.log(`   Issues:`);
      item.issues.forEach(issue => console.log(`     - ${issue}`));
    }
    if (item.reasoning) console.log(`   Reasoning: ${item.reasoning}`);
    console.log(`   Notes: ${item.notes}`);
    console.log(`   Link: ${item.link}`);
    console.log();
  });
}

// Generate CSV for manual review
const csvHeader = 'Status,Ingredient,Product Name,ASIN,Confidence,Alias Group,Issues,Notes,Action Needed,Link\n';
const csvRows = reviewItems.map(item => {
  const escapeCsv = (str: string) => `"${str.replace(/"/g, '""')}"`;
  return [
    item.status.toUpperCase(),
    escapeCsv(item.ingredient),
    escapeCsv(item.productName),
    item.asin,
    item.confidence.toUpperCase(),
    item.aliasGroup || '',
    escapeCsv(item.issues.join('; ')),
    escapeCsv(item.notes),
    item.status === 'auto-invalid' ? 'FIND NEW ASIN' : 'VERIFY',
    item.link,
  ].join(',');
}).join('\n');

const csv = csvHeader + csvRows;
const outputPath = path.join(process.cwd(), 'PHASE_1_5_MANUAL_REVIEW.csv');
fs.writeFileSync(outputPath, csv, 'utf-8');

console.log('='.repeat(80));
console.log('FILES GENERATED');
console.log('='.repeat(80));
console.log();
console.log(`CSV saved to: ${outputPath}`);
console.log();
console.log('='.repeat(80));
</file>

<file path="lib/generator/QuickTest.ts">
/**
 * Phase 1 Smoke Test - Verify critical fixes
 * Tests: S1 (1 primary protein), portion calc (petWeightKg), T1/T2/T3 hard fails
 */

import { RecipeBuilder } from './RecipeBuilder';

console.log('\n=== PHASE 1 SMOKE TEST ===\n');

// Test 1: Dog recipe with actual pet weight
console.log('TEST 1: Dog recipe with petWeightKg (10kg dog)');
const dogConstraints = {
  species: 'dogs' as const,
  lifeStage: 'adult' as const,
  petWeightKg: 10, // PHASE 1.4: Actual pet weight
  healthConcerns: [],
  budgetPerMeal: 4.0,
  targetCalories: undefined,
  allergies: [],
  bannedIngredients: [],
};

let successCount = 0;
let failCount = 0;

for (let i = 0; i < 3; i++) {
  const builder = new RecipeBuilder(dogConstraints, 'standard', 'medium');
  const recipe = builder.generate();

  if (recipe) {
    successCount++;
    console.log(`\n‚úÖ Dog Recipe ${i + 1}:`);
    
    // PHASE 1.2: Verify exactly 1 primary protein (PHASE 1.7: use proteinRole)
    const primaryProteins = recipe.ingredients.filter(ing => ing.ingredient.proteinRole === 'primary');
    console.log(`   Primary proteins: ${primaryProteins.map(p => p.ingredient.name).join(', ')} (count: ${primaryProteins.length})`);
    if (primaryProteins.length !== 1) {
      console.log(`   ‚ùå FAIL: Expected 1 primary protein, got ${primaryProteins.length}`);
    } else {
      console.log(`   ‚úÖ PASS: Exactly 1 primary protein`);
    }
    
    // PHASE 1.4: Check portion calculation uses pet weight
    const totalGrams = recipe.totalGrams;
    console.log(`   Total grams: ${totalGrams} (for 10kg dog)`);
    if (totalGrams < 200 || totalGrams > 1000) {
      console.log(`   ‚ö†Ô∏è  Portion seems off for 10kg dog`);
    }
    
    // Check organ meat percentage
    const organMeatGrams = recipe.ingredients
      .filter(ing =>
        ing.ingredient.feedingRole === 'supplement' &&
        (ing.ingredient.name.toLowerCase().includes('liver') ||
         ing.ingredient.name.toLowerCase().includes('kidney') ||
         ing.ingredient.name.toLowerCase().includes('heart'))
      )
      .reduce((sum, ing) => sum + ing.grams, 0);
    
    const organPercent = (organMeatGrams / recipe.totalGrams) * 100;
    console.log(`   Organ meat: ${organPercent.toFixed(1)}%`);
    if (organPercent > 10) {
      console.log(`   ‚ùå FAIL: Organ meat exceeds 10%`);
    } else {
      console.log(`   ‚úÖ PASS: Organ meat within 10% cap`);
    }
    
    // Check for toxic pairings
    const hasLiver = recipe.ingredients.some(ing => ing.ingredient.name.toLowerCase().includes('liver'));
    const hasSalmon = recipe.ingredients.some(ing => ing.ingredient.name.toLowerCase().includes('salmon'));
    const hasCod = recipe.ingredients.some(ing => ing.ingredient.name.toLowerCase().includes('cod'));
    
    if (hasLiver && (hasSalmon || hasCod)) {
      console.log(`   ‚ùå FAIL: TOXIC PAIRING - Liver + ${hasSalmon ? 'salmon' : 'cod'}`);
    } else {
      console.log(`   ‚úÖ PASS: No toxic pairings`);
    }
  } else {
    failCount++;
    console.log(`\n‚ùå Dog Recipe ${i + 1}: Failed to generate`);
  }
}

// Test 2: Cat recipe (salmon_atlantic should be primary)
console.log('\n\nTEST 2: Cat recipe (salmon_atlantic as primary protein)');
const catConstraints = {
  species: 'cats' as const,
  lifeStage: 'adult' as const,
  petWeightKg: 4, // PHASE 1.4: Typical cat weight
  healthConcerns: [],
  budgetPerMeal: 3.0,
  targetCalories: undefined,
  allergies: [],
  bannedIngredients: [],
};

for (let i = 0; i < 2; i++) {
  const builder = new RecipeBuilder(catConstraints, 'standard', 'medium');
  const recipe = builder.generate();

  if (recipe) {
    successCount++;
    console.log(`\n‚úÖ Cat Recipe ${i + 1}:`);
    
    const primaryProteins = recipe.ingredients.filter(ing => ing.ingredient.feedingRole === 'staple');
    console.log(`   Primary protein: ${primaryProteins.map(p => p.ingredient.name).join(', ')}`);
    if (primaryProteins.length !== 1) {
      console.log(`   ‚ùå FAIL: Expected 1 primary protein, got ${primaryProteins.length}`);
    } else {
      console.log(`   ‚úÖ PASS: Exactly 1 primary protein`);
    }
    
    console.log(`   Total grams: ${recipe.totalGrams} (for 4kg cat)`);
  } else {
    failCount++;
    console.log(`\n‚ùå Cat Recipe ${i + 1}: Failed to generate`);
  }
}

console.log(`\n\n=== PHASE 1 SMOKE TEST RESULTS ===`);
console.log(`‚úÖ Passed: ${successCount}`);
console.log(`‚ùå Failed: ${failCount}`);
console.log(`Total: ${successCount + failCount}\n`);
</file>

<file path="lib/generator/RecipeBuilder.ts">
/**
 * ENHANCED RECIPE BUILDER
 * Adds health-aware ingredient selection + palatability
 * 
 * Key improvements:
 * 1. Health concerns drive ingredient selection (40% weight)
 * 2. Contraindications filtered as hard constraints
 * 3. Palatability built into scoring (30% weight)
 * 4. Species-specific taste preferences
 * 5. Debug info for transparency
 */

import type { Species } from '@/lib/data/ingredients';
import { INGREDIENTS, getIngredientsForSpecies, type Ingredient, type IngredientCategory } from '@/lib/data/ingredients';

/**
 * Normalize ingredient category strings to canonical values.
 * Handles variations like 'fish', 'seafood', 'meat', 'poultry' ‚Üí 'protein'
 */
function canonicalCategory(cat: any): IngredientCategory | 'unknown' {
  const c = String(cat ?? '').toLowerCase().trim();

  // PROTEIN family (fish, meat, poultry, seafood, eggs)
  if (
    c === 'protein' ||
    c.includes('protein') ||
    c.includes('meat') ||
    c.includes('poultry') ||
    c.includes('fish') ||
    c.includes('seafood') ||
    c.includes('egg')
  ) return 'protein';

  // VEGETABLE family
  if (c === 'vegetable' || c.includes('veg')) return 'vegetable';

  // FAT family (oils)
  if (c === 'fat' || c.includes('oil')) return 'fat';

  // CARB family (grains, starches)
  if (c === 'carb' || c.includes('grain') || c.includes('starch')) return 'carb';

  // Keep specialized categories as-is
  if (['seed', 'nut', 'fruit', 'insect', 'hay', 'pellet', 'supplement'].includes(c)) {
    return c as IngredientCategory;
  }

  return 'unknown';
}
import { getNutritionalStandard } from '@/lib/data/aafco-standards';
import { HEALTH_BENEFIT_MAP, HEALTH_CONTRAINDICATIONS } from '@/lib/data/healthBenefitMap';
import { validateRecipeComprehensive } from './RecipeConstraintRules';
import { shouldPruneCandidateForMicronutrients, getPruningReason } from './CombinatoricsPruning';
import { isFatCompatibleWithProteins, calculatePairingScore, logPairingDecision } from './RecipePMIScoring';
import { applyPriorScoring } from './RecipePriorScoring';
import { filterCandidatesByCommercialPriors, applyCommercialPriorScoring, hasCommercialPriors } from './CommercialPriorEnforcement';

export interface GenerationConstraints {
  species: Species;
  lifeStage: 'puppy' | 'adult' | 'senior';
  petWeightKg?: number; // PHASE 1.3: Actual pet weight for portion calculation
  healthConcerns?: string[];
  budgetPerMeal?: number;
  targetCalories?: number;
  allergies?: string[];
  bannedIngredients?: string[];
  recentIngredients?: string[]; // Track recently used ingredients for variety
}

export interface PortionedIngredient {
  ingredient: Ingredient;
  grams: number;
}

export interface GeneratedRecipeRaw {
  ingredients: PortionedIngredient[];
  totalGrams: number;
  estimatedCost: number;
  micronutrientDataIncomplete?: boolean; // Flag for exotic pets (no AAFCO standards)
  debugInfo?: {
    candidateCount: number;
    topScores: Array<{ name: string; score: number; breakdown: any }>;
    validation?: {
      isValid: boolean;
      failedRules: string[];
      softPenalties: Array<{ ruleId: string; penalty: number; message: string }>;
    };
  };
}

interface ScoredIngredient {
  ingredient: Ingredient;
  totalScore: number;
  breakdown: {
    health: number;
    quality: number;
    nutritional: number;
    diversity?: number;
  };
}

export type DiversityMode = 'high' | 'medium' | 'low' | 'none';

export class RecipeBuilder {
  private constraints: GenerationConstraints;
  private qualityTier: 'premium' | 'standard' | 'budget';
  private diversityMode: DiversityMode;

  // Scoring weights (reflects priority order)
  private weights = {
    health: 0.40,
    nutritional: 0.50,
    quality: 0.10,
  };

  constructor(
    constraints: GenerationConstraints,
    qualityTier: 'premium' | 'standard' | 'budget' = 'standard',
    diversityMode: DiversityMode = 'medium'
  ) {
    this.constraints = constraints;
    this.qualityTier = qualityTier;
    this.diversityMode = diversityMode;
  }

  /**
   * Main generation method
   */
  generate(): GeneratedRecipeRaw | null {
    try {
      console.log(`\n========== RECIPE GENERATION START (${this.constraints.species}) ==========`);
      const maxRetries = 3;
      let attempt = 0;
      const failedIngredients = new Set<string>(); // Track ingredients that failed hard gates

      while (attempt < maxRetries) {
        attempt++;
        console.log(`\n--- Attempt ${attempt}/${maxRetries} ---`);

        // 1. Get candidate ingredients (hard filters)
        let candidates = this.getCandidateIngredients();
        console.log(`[Step 1] Candidates after filters: ${candidates.length}`);
        
        // üî• CRITICAL GUARDRAIL: Block small candidate pools (vetted-only path)
        const MIN_POOL = 200;
        if (this.constraints.species === 'cats' && candidates.length < MIN_POOL) {
          throw new Error(
            `[RecipeBuilder] Candidate pool collapsed to ${candidates.length}. ` +
            `Refusing to generate recipes from small pool (likely vetted-only/products-only path). ` +
            `Minimum required: ${MIN_POOL}`
          );
        }
        
        if (candidates.length === 0) {
          console.warn(`No candidate ingredients found for ${this.constraints.species}`);
          return null;
        }

        // üî• NEW: Exclude ingredients that failed hard gates in previous attempts
        if (failedIngredients.size > 0) {
          candidates = candidates.filter(ing => !failedIngredients.has(ing.name));
          if (candidates.length === 0) {
            console.warn('All candidates excluded due to previous failures');
            return null;
          }
        }

        // 2. Score all candidates
        const scored = this.scoreIngredients(candidates);
        console.log(`[Step 2] Scored ingredients: ${scored.length}`);
        console.log(`[Step 2] Top 5 scores:`, scored.slice(0, 5).map(s => `${s.ingredient.name} (${s.totalScore.toFixed(1)})`));

        // 3. Select best ingredients by category
        const selected = this.selectIngredients(scored);
        console.log(`[Step 3] Selected ingredients: ${selected.length}`);
        console.log(`[Step 3] Ingredients:`, selected.map(i => `${i.name} (${i.category})`));
        if (selected.length === 0) {
          console.warn('No ingredients selected');
          return null;
        }

        // üî• NEW: Prune micronutrient-toxic candidates BEFORE validation
        if (shouldPruneCandidateForMicronutrients(selected)) {
          if (attempt < maxRetries) {
            console.warn(
              `Attempt ${attempt} pruned (micronutrient risk): ${getPruningReason(selected)}`
            );
            continue; // Retry with different random selections
          }
        }

        // 4. Calculate portions
        const portioned = this.calculatePortions(selected);
        console.log(`[Step 4] Portioned ingredients: ${portioned.length}`);
        console.log(`[Step 4] Portions:`, portioned.map(p => `${p.ingredient.name}: ${p.grams}g`));
        if (portioned.length === 0) {
          console.warn('Failed to calculate portions');
          return null;
        }

        // 5. Calculate cost
        const estimatedCost = this.calculateCost(portioned);
        console.log(`[Step 5] Estimated cost: $${estimatedCost.toFixed(2)}`);

        // üî• NEW: Validate recipe composition (comprehensive)
        const comprehensiveValidation = validateRecipeComprehensive(
          selected,
          this.constraints.species,
          this.constraints.lifeStage,
          estimatedCost,
          this.constraints.allergies
        );

        console.log(`[Step 6] Validation result: ${comprehensiveValidation.isValid ? 'PASS' : 'FAIL'}`);
        if (!comprehensiveValidation.isValid) {
          console.warn(`[Step 6] Failed hard gates:`, comprehensiveValidation.failedRules);
          
          // üî• NEW: Track which ingredients to exclude next time
          // If S2 (organ meat) failed, exclude organ meats
          if (comprehensiveValidation.failedRules.includes('S2')) {
            selected.forEach(ing => {
              if (ing.name.toLowerCase().includes('liver') ||
                  ing.name.toLowerCase().includes('kidney') ||
                  ing.name.toLowerCase().includes('heart')) {
                failedIngredients.add(ing.name);
              }
            });
          }
          
          if (attempt < maxRetries) {
            continue; // Retry with different random selections
          }
          // Last attempt failed - do NOT return recipe
          console.error('Could not generate valid recipe after', maxRetries, 'attempts');
          continue; // Skip to next retry (which will exit loop)
        } else {
          console.log(`[Step 6] ‚úÖ Validation passed!`);
          if (comprehensiveValidation.totalPenalty > 0) {
            console.warn(
              `[Step 6] Recipe quality penalties: ${comprehensiveValidation.totalPenalty}`,
              comprehensiveValidation.softGates.map(g => `${g.ruleId}: -${g.penalty}`)
            );
          }
        }

        // üî• PHASE 1: Only return if validation passed
        const species = this.constraints.species;
        const isExoticPet = species === 'birds' || species === 'reptiles' || species === 'pocket-pets';
        
        return {
          ingredients: portioned,
          totalGrams: portioned.reduce((sum, p) => sum + p.grams, 0),
          estimatedCost,
          // Flag exotic pets: micronutrient data incomplete (no AAFCO standards)
          micronutrientDataIncomplete: isExoticPet,
          debugInfo: {
            candidateCount: candidates.length,
            topScores: scored.slice(0, 10).map(s => ({
              name: s.ingredient.name,
              score: Math.round(s.totalScore),
              breakdown: {
                health: Math.round(s.breakdown.health),
                quality: Math.round(s.breakdown.quality),
                nutrition: Math.round(s.breakdown.nutritional),
              },
            })),
            validation: {
              isValid: comprehensiveValidation.isValid,
              failedRules: comprehensiveValidation.failedRules,
              softPenalties: comprehensiveValidation.softGates.map(g => ({
                ruleId: g.ruleId,
                penalty: g.penalty,
                message: g.message,
              })),
            },
          },
        };
      }

      return null;
    } catch (error) {
      console.error('RecipeBuilder.generate() error:', error);
      return null;
    }
  }


  /**
   * STEP 1: HARD FILTERS
   * Get candidate ingredients filtered by species and hard constraints
   */
  private getCandidateIngredients(): Ingredient[] {
    let candidates = getIngredientsForSpecies(this.constraints.species);
    
    // üî• STACK TRACE: Identify source of small pools
    console.log(`[PoolSource] Initial candidates: ${candidates.length}`, {
      species: this.constraints.species,
      source: 'getIngredientsForSpecies'
    });
    if (candidates.length < 200) {
      console.trace('[PoolSource] Small pool detected - trace:');
    }
    
    // üî• INVARIANT: Full pool must be large enough for cats
    if (this.constraints.species === 'cats' && candidates.length < 200) {
      throw new Error(
        `[Invariant] Full ingredient pool too small (${candidates.length}). ` +
        `Registry/provider is wrong. Expected 400+. ` +
        `This means getIngredientsForSpecies is returning a subset (vetted-only? priced-only?).`
      );
    }

    // Apply each filter individually with logging
    candidates = candidates.filter(ing => {
      // Filter 1: Allergies (HARD)
      if (
        this.constraints.allergies?.some(a =>
          ing.name.toLowerCase().includes(a.toLowerCase())
        )
      ) {
        return false;
      }

      // Filter 2: Banned ingredients (HARD)
      if (
        this.constraints.bannedIngredients?.some(b =>
          ing.name.toLowerCase().includes(b.toLowerCase())
        )
      ) {
        return false;
      }

      // Filter 3: Health contraindications (HARD)
      if (this.constraints.healthConcerns?.length) {
        for (const concern of this.constraints.healthConcerns) {
          const contraindicated = HEALTH_CONTRAINDICATIONS[concern] || [];
          const isContraindicated = contraindicated.some(
            contra =>
              ing.name.toLowerCase().includes(contra.toLowerCase()) ||
              ing.id.includes(contra.toLowerCase())
          );
          if (isContraindicated) {
            return false; // Hard exclude
          }
        }
      }

      // Filter 4: Exclude supplements from base recipes (HARD)
      // Supplements should only appear in supplements tab as add-ons
      if (ing.category === 'supplement') {
        return false;
      }

      // Filter 4b: Explicitly exclude fish oils (HARD)
      // Fish oils should only be supplements, not base ingredients
      const lowerName = ing.name.toLowerCase();
      const lowerId = ing.id.toLowerCase();
      if (lowerName.includes('fish oil') || 
          lowerName.includes('salmon oil') || 
          lowerName.includes('anchovy oil') ||
          lowerName.includes('mackerel oil') ||
          lowerName.includes('krill oil') ||
          lowerName.includes('cod liver oil') ||
          lowerName.includes('sardine oil') ||
          lowerName.includes('tuna oil') ||
          lowerName.includes('herring oil') ||
          lowerId.includes('fish_oil') ||
          lowerId.includes('salmon_oil') ||
          lowerId.includes('anchovy_oil') ||
          lowerId.includes('mackerel_oil') ||
          lowerId.includes('krill_oil') ||
          lowerId.includes('cod_liver_oil') ||
          lowerId.includes('sardine_oil') ||
          lowerId.includes('tuna_oil') ||
          lowerId.includes('herring_oil')) {
        console.log(`[FILTER] Excluding fish oil: ${ing.name} (id: ${ing.id})`);
        return false;
      }

      // Filter 5: Budget constraint (SOFT - allow some flex)
      if (this.constraints.budgetPerMeal && ing.pricePerLb) {
        const maxPrice = this.constraints.budgetPerMeal * 3; // Allow 3x for high-value ingredients
        if (ing.pricePerLb > maxPrice) return false;
      }

      return true;
    });
    
    console.log(`[Filters] After all filters: ${candidates.length} candidates`);
    
    // üî• INVARIANT: Check category pools for cats
    if (this.constraints.species === 'cats') {
      const veg = candidates.filter(x => canonicalCategory(x.category) === 'vegetable');
      const fat = candidates.filter(x => canonicalCategory(x.category) === 'fat');
      // Allow all proteins (exotic proteins already filtered out earlier)
      const proteinPool = candidates.filter(x => canonicalCategory(x.category) === 'protein');
      
      console.log(`[CategoryPools] protein=${proteinPool.length}, veg=${veg.length}, fat=${fat.length}`);
      
      if (veg.length < 2 || fat.length < 1 || proteinPool.length < 1) {
        throw new Error(
          `[Invariant] Missing required ingredient categories for cats: ` +
          `protein=${proteinPool.length} (need 1+), veg=${veg.length} (need 2+), fat=${fat.length} (need 1+). ` +
          `Cannot generate valid recipes. Pool size: ${candidates.length}`
        );
      }
    }

    return candidates;
  }

  /**
   * STEP 2: SCORE ALL CANDIDATES
   * Multi-factor scoring: health + quality + nutrition + diversity penalty
   * CRITICAL FIX: For protein category, heavily prioritize protein density
   */
  private scoreIngredients(candidates: Ingredient[]): ScoredIngredient[] {
    const recentIngredients = this.constraints.recentIngredients || [];
    
    return candidates
      .map(ing => {
        const breakdown = {
          health: this.scoreHealth(ing),
          quality: this.scoreQuality(ing),
          nutritional: this.scoreNutritional(ing),
        };

        // CRITICAL FIX: For protein category, use special weights
        // USER REQUIREMENT: Nutrition ALWAYS wins - protein density must dominate
        let weights = this.weights;
        if (canonicalCategory(ing.category) === 'protein') {
          weights = {
            health: 0.20,
            nutritional: 0.75,  // NUTRITION ALWAYS WINS - protein density dominates
            quality: 0.05,      // Minimal influence from quality
          };
        }

        let totalScore =
          breakdown.health * weights.health +
          breakdown.quality * weights.quality +
          breakdown.nutritional * weights.nutritional;

        // Apply diversity penalty for recently used ingredients
        const ingNameLower = ing.name.toLowerCase();
        const timesUsedRecently = recentIngredients.filter(r => r === ingNameLower).length;
        
        if (timesUsedRecently > 0) {
          // Heavy penalty: 50% reduction per recent use
          const diversityPenalty = Math.pow(0.5, timesUsedRecently);
          totalScore *= diversityPenalty;
          
          if (timesUsedRecently >= 2) {
            console.log(`[Diversity] Penalizing ${ing.name}: used ${timesUsedRecently}x recently, score ${totalScore.toFixed(1)} ‚Üí ${(totalScore * diversityPenalty).toFixed(1)}`);
          }
        }

        return { ingredient: ing, totalScore, breakdown };
      })
      .sort((a, b) => b.totalScore - a.totalScore); // Sort by total score descending
  }

  /**
   * HEALTH SCORE (0-100)
   * Does this ingredient help with pet's health concerns?
   */
  private scoreHealth(ing: Ingredient): number {
    if (!this.constraints.healthConcerns?.length) return 50; // Neutral if no concerns

    let score = 0;
    const ingName = ing.name.toLowerCase();

    for (const concern of this.constraints.healthConcerns) {
      const beneficialIngredients = HEALTH_BENEFIT_MAP[concern] || [];

      // Check if this ingredient is explicitly beneficial
      const isBeneficial = beneficialIngredients.some(
        beneficial =>
          ingName.includes(beneficial.toLowerCase()) ||
          beneficial.toLowerCase().includes(ingName)
      );

      if (isBeneficial) {
        score += 35; // +35 per matched health concern (can exceed 100)
      }
    }

    return Math.min(100, score);
  }

  /**
   * QUALITY SCORE (0-100)
   * Ingredient quality rating
   */
  private scoreQuality(ing: Ingredient): number {
    return ing.qualityScore * 10; // Convert 1-10 to 0-100
  }

  /**
   * NUTRITIONAL SCORE (0-100)
   * CRITICAL FIX: Heavily prioritize protein density to meet AAFCO standards
   * Protein is now 60% of nutritional score (was ~30%)
   */
  private scoreNutritional(ing: Ingredient): number {
    const comp = ing.composition;
    let score = 0;

    // PROTEIN DENSITY - Now 70 points max
    // Prioritize actual protein content over omega-3 for protein ingredients
    if (comp.protein) {
      if (comp.protein >= 30) score += 70;        // Chicken breast, turkey breast
      else if (comp.protein >= 25) score += 55;   // Ground turkey, ground chicken, tuna
      else if (comp.protein >= 20) score += 40;   // Salmon, duck
      else if (comp.protein >= 15) score += 25;   // Eggs, some fish
      else if (comp.protein >= 10) score += 12;   // Legumes
      else if (comp.protein >= 5) score += 6;     // Some vegetables
    }

    // Healthy fats (omega-3) - 10 points max (reduced from 20)
    // Omega-3 is good but shouldn't make canned fish dominate every recipe
    if (comp.omega3 && comp.omega3 > 1) score += 10;
    else if (comp.omega3 && comp.omega3 > 0.5) score += 5;

    // Fiber (good for digestion) - 10 points max
    if (comp.fiber && comp.fiber > 5) score += 10;
    else if (comp.fiber && comp.fiber > 2) score += 5;

    // Micronutrients - 10 points max
    if (comp.calcium && comp.calcium > 100) score += 5;
    if (comp.vitaminA && comp.vitaminA > 500) score += 5;

    return Math.min(100, score);
  }

  /**
   * Get required categories for a given species
   */
  private getRequiredCategoriesForSpecies(): IngredientCategory[] {
    const species = this.constraints.species;
    
    switch (species) {
      case 'dogs':
        return ['protein', 'carb', 'vegetable'];
      case 'cats':
        return ['protein', 'vegetable'];
      
      case 'birds':
        // Birds need seeds/nuts as protein, fruits/veggies for vitamins
        return ['seed', 'nut', 'fruit', 'vegetable'];
      
      case 'reptiles':
        // Reptiles need insects as protein, veggies for fiber
        return ['insect', 'vegetable', 'fruit'];
      
      case 'pocket-pets':
        // Pocket-pets need hay as staple, veggies/fruits for variety
        return ['hay', 'vegetable', 'fruit', 'seed'];
      
      default:
        return ['protein', 'carb', 'vegetable'];
    }
  }

  /**
   * Get how many ingredients to select from each category
   * Some categories are more important than others
   */
  private getIngredientCountForCategory(category: IngredientCategory): number {
    const species = this.constraints.species;
    
    // Dogs/Cats
    if (species === 'dogs' || species === 'cats') {
      if (category === 'protein') {
        return 1; // S1: Exactly 1 primary protein (hard gate)
      }
      if (category === 'carb') {
        return species === 'cats' ? 0 : 1; // Cats don't need carbs (obligate carnivores)
      }
      if (category === 'vegetable') {
        return species === 'cats' ? 2 : 1; // Cats get 2 veggies for variety (min 3 ingredients)
      }
      if (category === 'fat') {
        return 1; // 1 fat
      }
      return 1; // Default
    }
    
    // Birds
    if (species === 'birds') {
      if (category === 'seed' || category === 'nut') {
        return 2; // 2 seeds/nuts for variety
      }
      if (category === 'fruit') {
        return 1; // 1 fruit
      }
      if (category === 'vegetable') {
        return 1; // 1 veggie
      }
    }
    
    // Reptiles
    if (species === 'reptiles') {
      if (category === 'insect') {
        return 2; // 2 insects for variety
      }
      if (category === 'vegetable') {
        return 1; // 1 veggie
      }
      if (category === 'fruit') {
        return 1; // 1 fruit (optional)
      }
    }
    
    // Pocket-pets
    if (species === 'pocket-pets') {
      if (category === 'hay') {
        return 1; // 1 hay type (essential)
      }
      if (category === 'vegetable') {
        return 2; // 2 veggies for variety
      }
      if (category === 'fruit') {
        return 1; // 1 fruit (treat)
      }
      if (category === 'seed') {
        return 1; // 1 seed type (optional)
      }
    }
    
    return 1; // Default
  }

  // REMOVED: Hardcoded fat-protein pairing logic
  // Now using PMI-based pairing intelligence from recipePriors.json
  // See RecipePMIScoring.ts for learned pairing logic

  /**
   * STEP 3: SELECT BEST INGREDIENTS
   * Pick ingredients with weighted randomization to ensure diversity
   * üî• FIX: Species-aware ingredient selection
   */
  private selectIngredients(scored: ScoredIngredient[]): Ingredient[] {
    const selected: Ingredient[] = [];
    const categories = this.getRequiredCategoriesForSpecies();

    // üî• PRECONDITION CHECK: For cats, ensure we have all required categories
    if (this.constraints.species === 'cats') {
      const vegPool = scored.filter(s => canonicalCategory(s.ingredient.category) === 'vegetable');
      const fatPool = scored.filter(s => canonicalCategory(s.ingredient.category) === 'fat');
      // Allow all proteins (exotic proteins already filtered out earlier)
      const proteinPool = scored.filter(s => canonicalCategory(s.ingredient.category) === 'protein');
      
      if (vegPool.length < 2 || fatPool.length < 1 || proteinPool.length < 1) {
        throw new Error(
          `[RecipeBuilder] Insufficient pools for cats: ` +
          `protein=${proteinPool.length}, veg=${vegPool.length}, fat=${fatPool.length}. ` +
          `Cannot generate valid recipe without all required categories.`
        );
      }
    }

    // DEBUG: Log what we're looking for
    if (this.constraints.species === 'birds') {
      console.log(`[BIRD DEBUG] Looking for categories: ${categories.join(', ')}`);
      console.log(`[BIRD DEBUG] Total scored ingredients: ${scored.length}`);
    }

    for (const category of categories) {
      let inCategory = scored.filter(s => canonicalCategory(s.ingredient.category) === category);
      
      // CRITICAL: For dogs/cats protein category, all proteins allowed (exotic already filtered)
      // No additional filtering needed here
      
      // üî• COMMERCIAL PRIORS: Filter candidates using learned commercial pairing rules
      if (hasCommercialPriors(this.constraints.species) && selected.length > 0) {
        const selectedIds = selected.map(ing => ing.id);
        const beforeCommercialFilter = inCategory.length;
        
        // Filter out hardBlockPairs (never co-occur in commercial products)
        inCategory = filterCandidatesByCommercialPriors(
          inCategory.map(s => s.ingredient),
          selectedIds,
          this.constraints.species,
          '[Commercial] '
        ).map(ing => {
          // Find the scored ingredient back
          return inCategory.find(s => s.ingredient.id === ing.id)!;
        }).filter(Boolean);
        
        const afterCommercialFilter = inCategory.length;
        if (beforeCommercialFilter !== afterCommercialFilter) {
          console.log(`[Commercial Filter] Removed ${beforeCommercialFilter - afterCommercialFilter} hard-blocked ingredients`);
        }
      }
      
      // üî• PMI-BASED: Filter fats using learned pairing intelligence
      if (category === 'fat') {
        const selectedProteins = selected.filter(ing => canonicalCategory(ing.category) === 'protein');
        if (selectedProteins.length > 0) {
          const beforeFilter = inCategory.length;
          inCategory = inCategory.filter(s => {
            const compat = isFatCompatibleWithProteins(s.ingredient, selectedProteins, this.constraints.species);
            if (!compat.compatible) {
              console.log(`[PMI Filter] ${s.ingredient.name}: ${compat.reason}`);
            }
            return compat.compatible;
          });
          const afterFilter = inCategory.length;
          if (beforeFilter !== afterFilter) {
            console.log(`[PMI Filter] Removed ${beforeFilter - afterFilter} incompatible fats based on learned priors`);
          }
        }
      }
      
      // üî• DEBUG: Log protein pool details for cats
      if (this.constraints.species === 'cats' && category === 'protein') {
        console.log(`[ProteinPool] Total proteins in scored: ${inCategory.length}`);
        console.log(`[ProteinPool] Top 10 proteins:`, inCategory.slice(0, 10).map(s => 
          `${s.ingredient.name} (score: ${s.totalScore.toFixed(1)}, role: ${s.ingredient.proteinRole || 'none'})`
        ));
      }
      
      if (inCategory.length === 0) {
        console.warn(`No ingredients found for category: ${category} (species: ${this.constraints.species})`);
        continue;
      }

      const count = this.getIngredientCountForCategory(category);
      
      // DEBUG: Log selection details for birds
      if (this.constraints.species === 'birds') {
        console.log(`[BIRD DEBUG] Category '${category}': ${inCategory.length} available, selecting ${count}`);
        if (inCategory.length > 0) {
          console.log(`[BIRD DEBUG]   Top 3 in ${category}:`, inCategory.slice(0, 3).map(s => 
            `${s.ingredient.name} (score: ${s.totalScore.toFixed(1)})`
          ));
        }
      }
      
      // Skip if count is 0 (e.g., cats don't need grains)
      if (count === 0) continue;

      // Pick randomly from top N
      for (let i = 0; i < count && inCategory.length > 0; i++) {
        let poolSize: number;
        switch (this.diversityMode) {
          case 'high':
            poolSize = Math.min(8, inCategory.length);
            break;
          case 'medium':
            poolSize = Math.min(5, inCategory.length);
            break;
          case 'low':
            poolSize = Math.min(3, inCategory.length);
            break;
          case 'none':
            poolSize = 1;
            break;
        }

        const randomIndex = this.weightedRandomSelection(inCategory.slice(0, poolSize));
        const selectedIng = inCategory[randomIndex].ingredient;
        selected.push(selectedIng);
        
        // üî• DEBUG: Log what was selected
        if (this.constraints.species === 'cats' && category === 'protein') {
          console.log(`[Selection] Picked protein: ${selectedIng.name} (from pool of ${poolSize})`);
        }
        
        // Remove selected to avoid duplicates
        inCategory.splice(randomIndex, 1);
      }
    }

    if (selected.length === 0) {
      console.error('No ingredients selected for species:', this.constraints.species);
      console.error('Available categories:', categories);
      console.error('Scored ingredients count:', scored.length);
    }

    // CRITICAL: Enforce minimum 3 ingredients for proper meal prep
    // 2-ingredient meals are just "putting ingredients in a bowl", not meal prep
    const MIN_INGREDIENTS = 3;
    if (selected.length < MIN_INGREDIENTS) {
      console.warn(`Only ${selected.length} ingredients selected, need at least ${MIN_INGREDIENTS}`);
      
      // üî• NEVER pad with proteins when vegetables/fats are missing
      // Check what categories we're missing
      const selectedCategories = new Set(selected.map(ing => ing.category));
      const missingCategories = categories.filter(cat => !selectedCategories.has(cat));
      
      if (missingCategories.length > 0) {
        console.error(`Missing required categories: ${missingCategories.join(', ')}`);
        console.error('Cannot pad with random ingredients - aborting recipe generation');
        throw new Error(
          `Recipe generation failed: missing required categories [${missingCategories.join(', ')}]. ` +
          `This indicates the ingredient pool is too small or filtered incorrectly.`
        );
      }
      
      // Only pad if we have all required categories but just need more variety
      const remainingNeeded = MIN_INGREDIENTS - selected.length;
      const alreadySelectedIds = new Set(selected.map(ing => ing.id));
      
      // Get top-scoring ingredients from EXISTING categories only (no proteins if we already have one)
      const availableToAdd = scored
        .filter(s => {
          // Don't add if already selected
          if (alreadySelectedIds.has(s.ingredient.id)) return false;
          
          // For cats: don't add more proteins (we already have 1)
          if (this.constraints.species === 'cats' && canonicalCategory(s.ingredient.category) === 'protein') {
            return false;
          }
          
          // Only add from categories we already have
          return selectedCategories.has(s.ingredient.category);
        })
        .slice(0, remainingNeeded * 3); // Get 3x needed for variety
      
      for (let i = 0; i < remainingNeeded && availableToAdd.length > 0; i++) {
        const randomIndex = Math.floor(Math.random() * Math.min(5, availableToAdd.length));
        selected.push(availableToAdd[randomIndex].ingredient);
        availableToAdd.splice(randomIndex, 1);
      }
      
      console.log(`Added ${remainingNeeded} ingredients to reach minimum. Total: ${selected.length}`);
    }

    // DEBUG: Log final selection for birds
    if (this.constraints.species === 'birds') {
      console.log(`[BIRD DEBUG] Final selection: ${selected.length} ingredients`);
      selected.forEach(ing => console.log(`[BIRD DEBUG]   - ${ing.name} (${ing.category})`));
    }

    return selected;
  }

  /**
   * Weighted random selection
   * Higher-scoring ingredients have higher probability of being selected
   */
  private weightedRandomSelection(pool: ScoredIngredient[]): number {
    if (pool.length === 1) return 0;

    // Calculate weights (score^2 gives exponential preference to higher scores)
    const weights = pool.map(s => Math.pow(Math.max(0, s.totalScore), 2));
    const totalWeight = weights.reduce((sum, w) => sum + w, 0);

    if (totalWeight === 0) {
      // Fallback to uniform random if all scores are 0 or negative
      return Math.floor(Math.random() * pool.length);
    }

    // Pick random value in [0, totalWeight)
    let random = Math.random() * totalWeight;

    // Find which ingredient this corresponds to
    for (let i = 0; i < weights.length; i++) {
      random -= weights[i];
      if (random <= 0) return i;
    }

    return pool.length - 1; // Fallback
  }

  /**
   * Calculate portions based on NUTRIENT TARGETS (not category weights)
   * CRITICAL FIX: Calculate protein/fat needs UPFRONT, then allocate portions to meet targets
   * This ensures recipes meet AAFCO standards for all species
   */
  private calculatePortions(ingredients: Ingredient[]): PortionedIngredient[] {
    const petWeightKg = this.constraints.petWeightKg || 5;
    const species = this.constraints.species;
    
    // Step 1: Calculate total meal size
    const totalMealGrams = this.calculateTotalMealSize(petWeightKg, species);
    
    // Step 2: Get nutritional targets for this species
    const targets = this.getNutritionalTargets(species);
    
    // Step 3: Calculate required nutrient grams
    const targetProteinGrams = totalMealGrams * targets.proteinPercent;
    const targetFatGrams = totalMealGrams * targets.fatPercent;
    
    // Step 4: Allocate portions to meet nutrient targets
    return this.allocateNutrientTargetedPortions(
      ingredients,
      totalMealGrams,
      targetProteinGrams,
      targetFatGrams,
      petWeightKg
    );
  }
  
  /**
   * Calculate total meal size based on species and pet weight
   */
  private calculateTotalMealSize(petWeightKg: number, species: Species): number {
    if (species === 'dogs' || species === 'cats') {
      const mealMultiplier = this.qualityTier === 'premium' ? 80 : this.qualityTier === 'standard' ? 65 : 50;
      return petWeightKg * mealMultiplier;
    } else if (species === 'birds') {
      return petWeightKg * 40;
    } else if (species === 'reptiles') {
      return petWeightKg * 30;
    } else if (species === 'pocket-pets') {
      return petWeightKg * 100;
    }
    return petWeightKg * 65;
  }
  
  /**
   * Get nutritional targets (protein %, fat %) for each species
   * Based on AAFCO standards
   */
  private getNutritionalTargets(species: Species): { proteinPercent: number; fatPercent: number } {
    switch (species) {
      case 'dogs':
        return { proteinPercent: 0.20, fatPercent: 0.08 }; // 20% protein, 8% fat (above 18% minimum)
      case 'cats':
        return { proteinPercent: 0.23, fatPercent: 0.10 }; // 23% protein, 10% fat (allows diverse protein sources)
      case 'birds':
        // Target 15% but accept 13-17% range (natural fluctuation in seed diets)
        return { proteinPercent: 0.15, fatPercent: 0.08 };
      case 'reptiles':
        // Target 15% but accept 13-17% range (natural fluctuation in insect diets)
        return { proteinPercent: 0.15, fatPercent: 0.07 };
      case 'pocket-pets':
        // Target 14% but accept 12-16% range (natural fluctuation in hay diets)
        return { proteinPercent: 0.14, fatPercent: 0.06 };
      default:
        return { proteinPercent: 0.20, fatPercent: 0.08 };
    }
  }
  
  /**
   * Allocate portions to meet nutrient targets
   * Uses iterative approach: start with base allocation, then adjust to hit targets
   */
  private allocateNutrientTargetedPortions(
    ingredients: Ingredient[],
    totalMealGrams: number,
    targetProteinGrams: number,
    targetFatGrams: number,
    petWeightKg: number
  ): PortionedIngredient[] {
    const species = this.constraints.species;
    
    // Note: highProtein used later for boosting portions if needed
    const highProtein = ingredients.filter(ing => (ing.composition.protein || 0) >= 15);
    
    const portioned: PortionedIngredient[] = [];
    let allocatedGrams = 0;
    let allocatedProtein = 0;
    let allocatedFat = 0;
    
    // USER REQUIREMENT: Distribute portions across ALL selected ingredients
    // Don't allocate 90% to one ingredient - spread it out for variety
    
    // For dogs/cats: Use SELECTED protein (whatever was chosen by scoring)
    if (species === 'dogs' || species === 'cats') {
      // Get ANY protein that was selected (no primary/secondary distinction)
      const proteinIngredients = ingredients.filter(ing => canonicalCategory(ing.category) === 'protein');
      
      if (proteinIngredients.length === 0) {
        console.warn('No protein ingredients available for dogs/cats!');
        console.warn('Selected ingredients:', ingredients.map(i => `${i.name} (cat: ${i.category})`));
        return [];
      }
      
      // Use whichever protein was selected (chicken, sardines, mackerel, turkey, etc.)
      const primaryProtein = proteinIngredients[0];
      
      // Calculate portion needed to hit protein target with THIS protein
      const proteinDensity = (primaryProtein.composition.protein || 20) / 100;
      const requiredIngredientGrams = targetProteinGrams / proteinDensity;
      
      let proteinPortion = requiredIngredientGrams;
      
      // ARCHITECTURAL RULE: Hard upper bound to prevent crowding out micronutrients/fats
      // Cats: 90% max (obligate carnivores, need high protein even with diverse sources)
      // Dogs: 85% max (leaves 15% for variety & micronutrient carriers)
      const maxProteinPercent = species === 'cats' ? 0.90 : 0.85;
      proteinPortion = Math.min(proteinPortion, totalMealGrams * maxProteinPercent);
      
      // ARCHITECTURAL RULE: Never override max-inclusion constraints
      const maxGrams = petWeightKg * 1000 * primaryProtein.maxInclusionPercent[species];
      proteinPortion = Math.min(proteinPortion, maxGrams);
      
      proteinPortion = Math.round(proteinPortion);
      
      if (proteinPortion > 0) {
        portioned.push({ ingredient: primaryProtein, grams: proteinPortion });
        allocatedGrams += proteinPortion;
        allocatedProtein += (primaryProtein.composition.protein || 0) * proteinPortion / 100;
        allocatedFat += (primaryProtein.composition.fat || 0) * proteinPortion / 100;
      }
      
      // Allocate remaining grams to other ingredients
      const remainingGrams = totalMealGrams - allocatedGrams;
      const otherIngredients = ingredients.filter(ing => ing.id !== primaryProtein.id);
      
      if (remainingGrams > 0 && otherIngredients.length > 0) {
        const gramsPerIngredient = remainingGrams / otherIngredients.length;
        
        for (const ing of otherIngredients) {
          let grams = gramsPerIngredient;
          grams *= (0.85 + Math.random() * 0.3);
          
          const maxGrams = petWeightKg * 1000 * ing.maxInclusionPercent[species];
          grams = Math.min(grams, maxGrams);
          grams = Math.round(grams);
          
          if (grams > 0) {
            portioned.push({ ingredient: ing, grams });
            allocatedGrams += grams;
            allocatedProtein += (ing.composition.protein || 0) * grams / 100;
            allocatedFat += (ing.composition.fat || 0) * grams / 100;
          }
        }
      }
    } else {
      // For exotic pets: Distribute with bias toward higher-protein items
      // Equal grams ‚â† equal nutrition - bias toward protein-dense natural foods
      
      // Calculate protein density weights for each ingredient
      const totalProteinDensity = ingredients.reduce((sum, ing) => 
        sum + (ing.composition.protein || 0), 0);
      
      for (const ing of ingredients) {
        const proteinDensity = ing.composition.protein || 0;
        
        // Base allocation: equal distribution
        const baseGrams = totalMealGrams / ingredients.length;
        
        // Protein bias: allocate more to higher-protein ingredients
        // Weight = 70% equal + 30% protein-density-weighted
        const proteinWeight = totalProteinDensity > 0 
          ? proteinDensity / totalProteinDensity 
          : 1 / ingredients.length;
        
        let grams = (baseGrams * 0.70) + (totalMealGrams * proteinWeight * 0.30);
        
        // Add variation (¬±15%)
        grams *= (0.85 + Math.random() * 0.3);
        
        // ARCHITECTURAL RULE: Never override max-inclusion constraints
        const maxGrams = petWeightKg * 1000 * ing.maxInclusionPercent[species];
        grams = Math.min(grams, maxGrams);
        grams = Math.round(grams);
        
        if (grams > 0) {
          portioned.push({ ingredient: ing, grams });
          allocatedGrams += grams;
          allocatedProtein += (ing.composition.protein || 0) * grams / 100;
          allocatedFat += (ing.composition.fat || 0) * grams / 100;
        }
      }
    }
    
    // Step 4: Adjust if we're still below protein target
    const currentProteinPercent = allocatedGrams > 0 ? (allocatedProtein / allocatedGrams) : 0;
    const targetProteinPercent = targetProteinGrams / totalMealGrams;
    
    if (currentProteinPercent < targetProteinPercent * 0.95 && highProtein.length > 0) {
      // Boost high-protein portions by 20%
      for (const portioned_ing of portioned) {
        if ((portioned_ing.ingredient.composition.protein || 0) >= 15) {
          const boost = Math.round(portioned_ing.grams * 0.2);
          const maxGrams = petWeightKg * 1000 * portioned_ing.ingredient.maxInclusionPercent[species];
          portioned_ing.grams = Math.min(portioned_ing.grams + boost, maxGrams);
        }
      }
    }
    
    return portioned;
  }


  /**
   * Calculate estimated cost
   */
  private calculateCost(portioned: PortionedIngredient[]): number {
    return portioned.reduce((sum, p) => {
      if (!p.ingredient.pricePerLb) return sum;
      const lbs = p.grams / 453.592;
      return sum + lbs * p.ingredient.pricePerLb;
    }, 0);
  }
}
</file>

<file path="lib/generator/RecipeCompositionValidator.ts">
/**
 * RECIPE COMPOSITION VALIDATOR
 * Ensures recipes follow safe ingredient combination rules
 * Prevents unsafe combinations like multiple organ meats or unbalanced macros
 */

import type { Ingredient, Species } from '@/lib/data/ingredients';

// ============================================================================
// INGREDIENT ROLE DEFINITIONS
// ============================================================================

export const INGREDIENT_ROLES = {
  // Main proteins - can be primary ingredient (30-40% of recipe)
  mainProtein: [
    'chicken', 'turkey', 'beef', 'lamb', 'duck', 'venison',
    'salmon', 'whitefish', 'cod', 'sardine', 'tuna', 'egg'
  ],

  // Organ meats - MUST be limited to <10% of recipe
  organMeat: [
    'liver', 'kidney', 'heart', 'tripe', 'lung', 'spleen'
  ],

  // Carbohydrates - should be 30-40% of recipe
  carbs: [
    'rice', 'oats', 'quinoa', 'barley', 'potato', 'sweet potato',
    'pumpkin', 'squash', 'lentils', 'chickpeas', 'beans'
  ],

  // Vegetables - should be 10-20% of recipe
  vegetables: [
    'carrots', 'green beans', 'broccoli', 'spinach', 'kale',
    'zucchini', 'celery', 'peas', 'asparagus', 'lettuce'
  ],

  // Fats/oils - should be <5% of recipe
  fats: [
    'fish oil', 'coconut oil', 'olive oil', 'salmon oil', 'flaxseed', 'oil'
  ],
};

// ============================================================================
// UNSAFE COMBINATIONS
// ============================================================================

export const UNSAFE_COMBINATIONS = [
  {
    name: 'Multiple Organ Meats',
    ingredients: ['liver', 'kidney', 'heart'],
    maxCombined: 1, // Can only have 1 organ meat per recipe
    reason: 'Risk of vitamin A toxicity and mineral imbalance',
  },
  {
    name: 'High-Fat Proteins Together',
    ingredients: ['salmon', 'sardine', 'duck', 'lamb', 'mackerel'],
    maxCombined: 1, // Only 1 high-fat protein per recipe
    reason: 'Too much fat can cause pancreatitis',
  },
  {
    name: 'Multiple Fish Sources',
    ingredients: ['salmon', 'sardine', 'tuna', 'mackerel', 'whitefish', 'cod'],
    maxCombined: 1, // Only 1 fish per recipe
    reason: 'Risk of mercury accumulation and thiamine deficiency',
  },
];

// ============================================================================
// REQUIRED RECIPE STRUCTURE BY SPECIES
// ============================================================================

export const REQUIRED_RECIPE_STRUCTURE: Record<Species, {
  mustHave: string[];
  shouldHave: string[];
  optional: string[];
  minIngredients: number;
  maxIngredients: number;
}> = {
  dogs: {
    mustHave: ['mainProtein', 'carbs'], // REQUIRED
    shouldHave: ['vegetables'], // RECOMMENDED
    optional: ['fats', 'organMeat'], // OPTIONAL
    minIngredients: 3, // At least protein + carb + veggie
    maxIngredients: 6, // Don't overcomplicate
  },
  cats: {
    mustHave: ['mainProtein'], // Obligate carnivores - protein is essential
    shouldHave: ['fats'], // Cats need higher fat
    optional: ['carbs', 'vegetables'], // Cats don't need carbs, but tolerate some
    minIngredients: 2, // Can be simpler (protein + fat)
    maxIngredients: 5,
  },
  birds: {
    mustHave: ['vegetables', 'seed'], // Birds need seeds/veggies
    shouldHave: ['fruit'], // Birds love fruits
    optional: ['protein', 'carbs'],
    minIngredients: 2,
    maxIngredients: 5,
  },
  reptiles: {
    mustHave: ['protein'], // Carnivorous reptiles need protein
    shouldHave: ['vegetable'], // Some herbivorous/omnivorous reptiles
    optional: ['carbs', 'fruit'],
    minIngredients: 1,
    maxIngredients: 4,
  },
  'pocket-pets': {
    mustHave: ['hay', 'vegetable'], // Herbivores need hay and veggies
    shouldHave: ['fruit'], // Optional treats
    optional: ['carbs', 'seed'],
    minIngredients: 2,
    maxIngredients: 5,
  },
};

// ============================================================================
// VALIDATION RESULT
// ============================================================================

export interface ValidationResult {
  isValid: boolean;
  issues: string[];
  warnings: string[];
}

// ============================================================================
// MAIN VALIDATION FUNCTION
// ============================================================================

/**
 * Validate recipe composition for safety and balance
 */
export function validateRecipeComposition(
  selectedIngredients: Ingredient[],
  species: Species
): ValidationResult {
  const issues: string[] = [];
  const warnings: string[] = [];

  const ingredientNames = selectedIngredients.map(ing => ing.name.toLowerCase());

  // ========================================================================
  // CHECK 1: Required structure
  // ========================================================================
  const structure = REQUIRED_RECIPE_STRUCTURE[species];
  if (structure) {
    // Check mustHave categories
    for (const category of structure.mustHave) {
      const hasCategory = ingredientNames.some(name =>
        INGREDIENT_ROLES[category as keyof typeof INGREDIENT_ROLES]?.some(role =>
          name.includes(role)
        )
      );
      if (!hasCategory) {
        issues.push(`Missing required ingredient type: ${category}`);
      }
    }

    // Check shouldHave categories
    for (const category of structure.shouldHave) {
      const hasCategory = ingredientNames.some(name =>
        INGREDIENT_ROLES[category as keyof typeof INGREDIENT_ROLES]?.some(role =>
          name.includes(role)
        )
      );
      if (!hasCategory) {
        warnings.push(`Recommended ingredient type missing: ${category}`);
      }
    }

    // Check ingredient count
    if (selectedIngredients.length < structure.minIngredients) {
      issues.push(
        `Too few ingredients (${selectedIngredients.length}, need ${structure.minIngredients}+)`
      );
    }
    if (selectedIngredients.length > structure.maxIngredients) {
      warnings.push(
        `Too many ingredients (${selectedIngredients.length}, recommended max ${structure.maxIngredients})`
      );
    }
  }

  // ========================================================================
  // CHECK 2: Unsafe combinations
  // ========================================================================
  for (const combo of UNSAFE_COMBINATIONS) {
    const matchedIngredients = ingredientNames.filter(name =>
      combo.ingredients.some(unsafe => name.includes(unsafe))
    );

    if (matchedIngredients.length > combo.maxCombined) {
      issues.push(
        `Unsafe combination: ${matchedIngredients.join(' + ')}. ` +
        `${combo.reason}. Max ${combo.maxCombined} allowed.`
      );
    }
  }

  // ========================================================================
  // CHECK 3: Organ meat percentage (if present)
  // ========================================================================
  const hasOrganMeat = ingredientNames.some(name =>
    INGREDIENT_ROLES.organMeat.some(organ => name.includes(organ))
  );

  if (hasOrganMeat) {
    const organMeats = selectedIngredients.filter(ing =>
      INGREDIENT_ROLES.organMeat.some(organ => ing.name.toLowerCase().includes(organ))
    );

    // Check if organ meat has proper role
    const organMeatRole = organMeats[0]?.feedingRole;
    if (organMeatRole === 'staple') {
      issues.push(
        `${organMeats[0].name} is marked as staple but should be supplement. ` +
        `Organ meats must be limited to <10% of recipe.`
      );
    }

    // If multiple ingredients, warn if organ meat portion is too large
    if (selectedIngredients.length <= 2 && hasOrganMeat) {
      issues.push(
        `Recipe has too few ingredients with organ meat present. ` +
        `Add carbs/vegetables to dilute organ meat concentration.`
      );
    }
  }

  // ========================================================================
  // CHECK 4: No double proteins without carbs (for dogs)
  // ========================================================================
  if (species === 'dogs') {
    const proteinCount = ingredientNames.filter(name =>
      INGREDIENT_ROLES.mainProtein.some(p => name.includes(p)) ||
      INGREDIENT_ROLES.organMeat.some(o => name.includes(o))
    ).length;

    const hasCarbs = ingredientNames.some(name =>
      INGREDIENT_ROLES.carbs.some(c => name.includes(c))
    );

    if (proteinCount >= 2 && !hasCarbs) {
      issues.push(
        `Recipe has ${proteinCount} protein sources but no carbohydrates. ` +
        `This is unbalanced and too protein-heavy.`
      );
    }
  }

  return {
    isValid: issues.length === 0,
    issues,
    warnings,
  };
}

/**
 * Check if an ingredient should be categorized as a supplement (organ meat)
 */
export function isOrganMeat(ingredient: Ingredient): boolean {
  const name = ingredient.name.toLowerCase();
  return INGREDIENT_ROLES.organMeat.some(organ => name.includes(organ));
}

/**
 * Get ingredient category role
 */
export function getIngredientRole(ingredient: Ingredient): string {
  const name = ingredient.name.toLowerCase();

  if (INGREDIENT_ROLES.mainProtein.some(p => name.includes(p))) return 'mainProtein';
  if (INGREDIENT_ROLES.organMeat.some(o => name.includes(o))) return 'organMeat';
  if (INGREDIENT_ROLES.carbs.some(c => name.includes(c))) return 'carbs';
  if (INGREDIENT_ROLES.vegetables.some(v => name.includes(v))) return 'vegetables';
  if (INGREDIENT_ROLES.fats.some(f => name.includes(f))) return 'fats';

  return 'unknown';
}
</file>

<file path="lib/generator/RecipeConstraintRules.ts">
/**
 * RECIPE CONSTRAINT RULES
 * Pre-scoring validation gates that reject unsafe/invalid recipes before optimization
 * 
 * Pipeline:
 * 1. Constraint Gate (hard rejections)
 * 2. Composition Validator (structure + balance)
 * 3. Nutrient Ceiling Validator (micronutrient caps)
 * 4. Optimizer (cost + nutrition)
 * 5. Scorer (quality + fit)
 */

import type { Ingredient, Species } from '@/lib/data/ingredients';

// ============================================================================
// NUTRIENT CEILING TABLE (Species-Aware)
// Absolute caps per day equivalent, not scoring targets
// ============================================================================

export const NUTRIENT_CEILINGS: Record<Species, {
  vitaminA_IU: number;
  copper_mg: number;
  iodine_mcg: number;
  fat_percent: number;
  calcium_g: number;
  calcium_phosphorus_min: number;
  calcium_phosphorus_max: number;
}> = {
  dogs: {
    vitaminA_IU: 30000,       // PHASE 2: Per recipe (realistic with organs)
    copper_mg: 5.0,           // PHASE 2: Per recipe ceiling (realistic with organs)
    iodine_mcg: 1000,         // PHASE 2: Per recipe ceiling (realistic)
    fat_percent: 30,
    calcium_g: 2.5,
    calcium_phosphorus_min: 1.2,
    calcium_phosphorus_max: 2.0,
  },
  cats: {
    vitaminA_IU: 25000,       // PHASE 2: Per recipe (realistic with organs)
    copper_mg: 4.0,           // PHASE 2: Per recipe ceiling (realistic with organs)
    iodine_mcg: 800,          // PHASE 2: Per recipe ceiling (realistic)
    fat_percent: 45,
    calcium_g: 2.0,
    calcium_phosphorus_min: 1.1,
    calcium_phosphorus_max: 1.5,
  },
  birds: {
    vitaminA_IU: 4000, // Species-dependent, conservative estimate
    copper_mg: 0.3,
    iodine_mcg: 150,
    fat_percent: 15,
    calcium_g: 1.5,
    calcium_phosphorus_min: 1.0,
    calcium_phosphorus_max: 2.0,
  },
  reptiles: {
    vitaminA_IU: 3000, // Highly species-dependent
    copper_mg: 0.2,
    iodine_mcg: 100,
    fat_percent: 20,
    calcium_g: 2.0,
    calcium_phosphorus_min: 1.5,
    calcium_phosphorus_max: 2.5,
  },
  'pocket-pets': {
    vitaminA_IU: 4000,
    copper_mg: 0.3,
    iodine_mcg: 150,
    fat_percent: 20,
    calcium_g: 1.8,
    calcium_phosphorus_min: 1.0,
    calcium_phosphorus_max: 2.0,
  },
};

// ============================================================================
// INGREDIENT ROLE MATRIX
// Prevents "two mains in disguise" and organ stacking
// ============================================================================

export const INGREDIENT_ROLE_MATRIX = {
  'primary-protein': {
    allowedAsPrimary: true,
    percentCap: 0.60,
    maxPerRecipe: 1, // Exactly one primary protein
    examples: ['chicken_breast', 'beef', 'salmon', 'turkey_breast'],
  },
  'carb-base': {
    allowedAsPrimary: false,
    percentCap: 0.40,
    maxPerRecipe: 2,
    examples: ['rice', 'sweet_potato', 'oats', 'barley'],
  },
  'vegetable': {
    allowedAsPrimary: false,
    percentCap: 0.25,
    maxPerRecipe: 3,
    examples: ['carrots', 'green_beans', 'spinach', 'broccoli'],
  },
  'organ-meat': {
    allowedAsPrimary: false,
    percentCap: 0.10, // Hard cap for organ meats
    maxPerRecipe: 1, // Only one organ meat per recipe
    examples: ['chicken_liver', 'beef_liver', 'chicken_hearts'],
  },
  'fat-supplement': {
    allowedAsPrimary: false,
    percentCap: 0.05,
    maxPerRecipe: 1, // Only one added fat source
    examples: ['fish_oil', 'coconut_oil', 'olive_oil'],
  },
  'micronutrient': {
    allowedAsPrimary: false,
    percentCap: 0.01,
    maxPerRecipe: 1,
    examples: ['kelp', 'eggshell_powder', 'vitamin_premix'],
  },
};

// ============================================================================
// STRUCTURAL COMPOSITION RULES (Hard Gates)
// ============================================================================

export interface CompositionRuleResult {
  passed: boolean;
  ruleId: string;
  message: string;
}

export function validateStructuralComposition(
  ingredients: Ingredient[],
  species: Species,
  lifeStage: 'puppy' | 'adult' | 'senior'
): CompositionRuleResult[] {
  const results: CompositionRuleResult[] = [];

  // S1: Exactly 1 protein source (STRICT) - Species-aware
  // Dogs/cats: Must have 1 'protein' category (any protein, not just "primary")
  // Birds: Can have seeds/nuts as protein
  // Reptiles: Can have insects as protein
  // Pocket-pets: Can have hay/seeds as protein
  
  // Helper to normalize categories
  const canonicalCategory = (cat: any): string => {
    const c = String(cat ?? '').toLowerCase().trim();
    if (c === 'protein' || c.includes('protein') || c.includes('meat') || 
        c.includes('poultry') || c.includes('fish') || c.includes('seafood') || c.includes('egg')) {
      return 'protein';
    }
    return c;
  };
  
  let primaryProteins: Ingredient[];
  if (species === 'dogs' || species === 'cats') {
    // Accept ANY protein ingredient (chicken, turkey, sardines, mackerel, etc.)
    primaryProteins = ingredients.filter(ing => canonicalCategory(ing.category) === 'protein');
  } else if (species === 'birds') {
    // Birds: seeds/nuts/insects, but exclude oils (they're fats, not protein sources)
    primaryProteins = ingredients.filter(ing =>
      ['seed', 'nut', 'insect'].includes(ing.category) &&
      !ing.name.toLowerCase().includes('oil')
    );
  } else if (species === 'reptiles') {
    primaryProteins = ingredients.filter(ing =>
      ['insect', 'protein'].includes(ing.category)
    );
  } else if (species === 'pocket-pets') {
    primaryProteins = ingredients.filter(ing =>
      ['hay', 'seed'].includes(ing.category)
    );
  } else {
    // Default: accept any protein
    primaryProteins = ingredients.filter(ing => canonicalCategory(ing.category) === 'protein');
  }
  
  // Dogs/cats need exactly 1, exotic species can have 1-2 for variety
  const minRequired = (species === 'dogs' || species === 'cats') ? 1 : 1;
  const maxAllowed = (species === 'dogs' || species === 'cats') ? 1 : 3;
  
  results.push({
    passed: primaryProteins.length >= minRequired && primaryProteins.length <= maxAllowed,
    ruleId: 'S1',
    message: `Primary protein sources: ${primaryProteins.length} (species: ${species}, range: ${minRequired}-${maxAllowed})`,
  });

  // S2: Organ meats ‚â§ 1 per recipe (count-based, not weight)
  // NOTE: Weight-based cap moved to quality scoring as soft gate
  const organMeatNames = ['liver', 'kidney', 'heart'];
  const organMeats = ingredients.filter(ing => {
    const name = ing.name.toLowerCase();
    return ing.feedingRole === 'supplement' && organMeatNames.some(organ => name.includes(organ));
  });
  
  results.push({
    passed: organMeats.length <= 1,
    ruleId: 'S2',
    message: `Organ meats ‚â§ 1 per recipe (found ${organMeats.length})`,
  });

  // S3: Organ meats cannot be primary protein
  const organAsPrimary = ingredients.filter(ing =>
    ing.feedingRole === 'staple' &&
    (ing.name.toLowerCase().includes('liver') ||
      ing.name.toLowerCase().includes('kidney') ||
      ing.name.toLowerCase().includes('heart'))
  );
  results.push({
    passed: organAsPrimary.length === 0,
    ruleId: 'S3',
    message: `Organ meats cannot be primary protein (found ${organAsPrimary.length})`,
  });

  // S4: Must include carb/energy source (species-aware)
  // Dogs: need 'carb' (grains)
  // Birds: need 'seed' or 'nut' (energy-dense)
  // Pocket-pets: need 'hay' (fiber/energy)
  // Cats/reptiles: optional carbs
  let hasEnergySource = false;
  if (species === 'dogs') {
    hasEnergySource = ingredients.some(ing => ing.category === 'carb');
  } else if (species === 'birds') {
    hasEnergySource = ingredients.some(ing => ['seed', 'nut', 'carb'].includes(ing.category));
  } else if (species === 'pocket-pets') {
    hasEnergySource = ingredients.some(ing => ['hay', 'seed', 'carb'].includes(ing.category));
  } else {
    hasEnergySource = true; // Cats/reptiles don't require carbs
  }
  
  results.push({
    passed: hasEnergySource,
    ruleId: 'S4',
    message: `${species} energy source requirement met: ${hasEnergySource}`,
  });

  // S5: Carnivores may be carb-free (informational, not a gate)
  const isCarnivore = ['cats', 'reptiles'].includes(species);
  results.push({
    passed: true, // Always pass - this is permissive
    ruleId: 'S5',
    message: `${species} may be carb-free (allowed)`,
  });

  // S6: Minimum ingredient categories
  // All species need at least 2 different categories for nutritional balance
  const categories = new Set(ingredients.map(ing => ing.category));
  results.push({
    passed: categories.size >= 2,
    ruleId: 'S6',
    message: `Minimum 2 ingredient categories required (found ${categories.size})`,
  });

  // S7: Added fat sources ‚â§ 1
  const addedFats = ingredients.filter(ing => ing.category === 'fat');
  results.push({
    passed: addedFats.length <= 1,
    ruleId: 'S7',
    message: `Maximum 1 added fat source (found ${addedFats.length})`,
  });

  // S8: Ingredient diversity ‚â• 3 unique foods
  const uniqueIngredients = new Set(ingredients.map(ing => ing.id));
  results.push({
    passed: uniqueIngredients.size >= 3,
    ruleId: 'S8',
    message: `Minimum 3 unique ingredients required (found ${uniqueIngredients.size})`,
  });

  return results;
}

// ============================================================================
// SAFETY & TOXICITY RULES (Hard Gates)
// ============================================================================

export interface SafetyRuleResult {
  passed: boolean;
  ruleId: string;
  message: string;
  value?: number;
  ceiling?: number;
}

export function validateSafetyAndToxicity(
  ingredients: Ingredient[],
  species: Species,
  allergies?: string[]
): SafetyRuleResult[] {
  const results: SafetyRuleResult[] = [];
  const ceilings = NUTRIENT_CEILINGS[species];

  // T1: Vitamin A ceiling (HARD for dogs/cats, SOFT for exotic pets)
  const proteinAndOrganMeats = ingredients.filter(ing => 
    ing.category === 'protein' || 
    ing.name.toLowerCase().includes('liver') ||
    ing.name.toLowerCase().includes('kidney') ||
    ing.name.toLowerCase().includes('heart')
  );
  
  const totalVitaminA = ingredients.reduce((sum, ing) => sum + (ing.composition.vitaminA || 0), 0);
  const hasVitaminAData = proteinAndOrganMeats.every(ing => ing.composition.vitaminA !== undefined);
  
  // Only enforce for dogs/cats (AAFCO standards exist)
  const enforceT1 = species === 'dogs' || species === 'cats';
  results.push({
    passed: enforceT1 ? (hasVitaminAData && totalVitaminA <= ceilings.vitaminA_IU) : true,
    ruleId: 'T1',
    message: hasVitaminAData 
      ? `Vitamin A: ${totalVitaminA} IU (ceiling: ${ceilings.vitaminA_IU})`
      : enforceT1 
        ? `Vitamin A data incomplete for proteins/organs - cannot validate`
        : `Vitamin A data incomplete (soft warning for ${species})`,
    value: totalVitaminA,
    ceiling: ceilings.vitaminA_IU,
  });

  // T2: Copper ceiling (HARD for dogs/cats, SOFT for exotic pets)
  const totalCopper = ingredients.reduce((sum, ing) => sum + (ing.composition.copper_mg_per_100g || 0), 0);
  const hasAllCopperData = ingredients.every(ing => ing.composition.copper_mg_per_100g !== undefined);
  
  // Only enforce for dogs/cats
  const enforceT2 = species === 'dogs' || species === 'cats';
  results.push({
    passed: enforceT2 ? (hasAllCopperData && totalCopper <= ceilings.copper_mg) : true,
    ruleId: 'T2',
    message: hasAllCopperData 
      ? `Copper: ${totalCopper.toFixed(2)} mg (ceiling: ${ceilings.copper_mg})`
      : enforceT2
        ? `Copper data incomplete - cannot validate`
        : `Copper data incomplete (soft warning for ${species})`,
    value: totalCopper,
    ceiling: ceilings.copper_mg,
  });

  // T3: Iodine ceiling (PHASE 2: Now using class-based defaults + measured overrides)
  const totalIodine = ingredients.reduce((sum, ing) => sum + (ing.composition.iodine_mcg_per_100g || 0), 0);
  const hasAllIodineData = ingredients.every(ing => ing.composition.iodine_mcg_per_100g !== undefined);
  results.push({
    passed: hasAllIodineData && totalIodine <= ceilings.iodine_mcg,
    ruleId: 'T3',
    message: hasAllIodineData 
      ? `Iodine: ${totalIodine.toFixed(1)} mcg (ceiling: ${ceilings.iodine_mcg})`
      : `Iodine data incomplete - cannot validate`,
    value: totalIodine,
    ceiling: ceilings.iodine_mcg,
  });

  // T4: Known toxic ingredient present
  const toxicIngredients = ['grape', 'raisin', 'onion', 'garlic', 'chocolate', 'xylitol'];
  const hasToxic = ingredients.some(ing =>
    toxicIngredients.some(toxic => ing.name.toLowerCase().includes(toxic))
  );
  results.push({
    passed: !hasToxic,
    ruleId: 'T4',
    message: `No known toxic ingredients (found: ${hasToxic})`,
  });

  // T5: Allergen or derivative present
  const hasAllergen =
    allergies && allergies.length > 0
      ? ingredients.some(ing =>
          allergies.some(allergen =>
            ing.name.toLowerCase().includes(allergen.toLowerCase()) ||
            ing.id.includes(allergen.toLowerCase())
          )
        )
      : false;
  results.push({
    passed: !hasAllergen,
    ruleId: 'T5',
    message: `No allergens present (found: ${hasAllergen})`,
  });

  // T6: Ca:P ratio (SOFT WARNING - hard gate disabled until supplements available)
  // Phase 1: Just track it. Phase 2: Apply soft penalties if out of range.
  // Real fix: Add calcium supplement ingredients (eggshell powder, bone meal, etc.)
  const totalCalcium = ingredients.reduce((sum, ing) => sum + (ing.composition.calcium || 0), 0);
  const totalPhosphorus = ingredients.reduce((sum, ing) => sum + (ing.composition.phosphorus || 0), 0);
  const caPRatio = totalPhosphorus > 0 ? totalCalcium / totalPhosphorus : 1;
  const hasCalciumSupplement = ingredients.some(ing =>
    ing.name.toLowerCase().includes('eggshell') ||
    ing.name.toLowerCase().includes('bone meal') ||
    ing.name.toLowerCase().includes('calcium')
  );
  
  // Pass if: naturally in range OR has calcium supplement
  const caPValid = (caPRatio >= 1.0 && caPRatio <= 2.0) || hasCalciumSupplement;
  
  results.push({
    passed: true, // Always pass - this is now a soft warning, not hard gate
    ruleId: 'T6',
    message: `Ca:P ratio: ${Math.round(caPRatio * 100) / 100} ${hasCalciumSupplement ? '(supplement present)' : '(natural)'}`,
    value: Math.round(caPRatio * 100) / 100,
    ceiling: 2.0,
  });

  return results;
}

// ============================================================================
// LIFE STAGE RULES (Hard Gates)
// ============================================================================

export interface LifeStageRuleResult {
  passed: boolean;
  ruleId: string;
  message: string;
}

export function validateLifeStage(
  ingredients: Ingredient[],
  species: Species,
  lifeStage: 'puppy' | 'adult' | 'senior'
): LifeStageRuleResult[] {
  const results: LifeStageRuleResult[] = [];

  if (lifeStage === 'puppy') {
    // L1: Puppy calcium upper limit (prevent skeletal issues)
    const totalCalcium = ingredients.reduce((sum, ing) => sum + (ing.composition.calcium || 0), 0);
    const puppyCalciumMax = 2.0; // g per day
    results.push({
      passed: totalCalcium <= puppyCalciumMax,
      ruleId: 'L1',
      message: `Puppy calcium ‚â§ ${puppyCalciumMax}g (found ${totalCalcium}g)`,
    });

    // L4: Growth diets require higher protein
    const totalProtein = ingredients.reduce((sum, ing) => sum + (ing.composition.protein || 0), 0);
    const puppyProteinMin = 18; // % of calories
    results.push({
      passed: totalProtein >= puppyProteinMin,
      ruleId: 'L4',
      message: `Puppy protein ‚â• ${puppyProteinMin}% (found ${totalProtein}%)`,
    });
  }

  if (lifeStage === 'senior' && species === 'dogs') {
    // L3: Senior kidney load (reduce phosphorus)
    const totalPhosphorus = ingredients.reduce((sum, ing) => sum + (ing.composition.phosphorus || 0), 0);
    const seniorPhosphorusMax = 1.0; // g per day
    results.push({
      passed: totalPhosphorus <= seniorPhosphorusMax,
      ruleId: 'L3',
      message: `Senior phosphorus ‚â§ ${seniorPhosphorusMax}g (found ${totalPhosphorus}g)`,
    });
  }

  return results;
}

// ============================================================================
// QUALITY / PLAUSIBILITY RULES (Soft Gates ‚Üí Penalty)
// ============================================================================

export interface QualityRuleResult {
  passed: boolean;
  ruleId: string;
  message: string;
  penalty: number; // 0-100, applied to score
}

export function validateQualityAndPlausibility(
  ingredients: Ingredient[],
  estimatedCost: number
): QualityRuleResult[] {
  const results: QualityRuleResult[] = [];

  // Q1: "Two mains in disguise" (multiple high-protein ingredients)
  const highProteinCount = ingredients.filter(ing =>
    ing.composition.protein && ing.composition.protein > 20
  ).length;
  const twoMainsPenalty = highProteinCount > 1 ? 30 : 0;
  results.push({
    passed: highProteinCount <= 1,
    ruleId: 'Q1',
    message: `Multiple high-protein ingredients detected (${highProteinCount})`,
    penalty: twoMainsPenalty,
  });

  // Q2: Excessive powders / oils (low ingredient diversity)
  const powderOilCount = ingredients.filter(ing =>
    ing.name.toLowerCase().includes('oil') ||
    ing.name.toLowerCase().includes('powder') ||
    ing.name.toLowerCase().includes('premix')
  ).length;
  const excessivePowderPenalty = powderOilCount > 2 ? 25 : 0;
  results.push({
    passed: powderOilCount <= 2,
    ruleId: 'Q2',
    message: `Excessive powders/oils (${powderOilCount})`,
    penalty: excessivePowderPenalty,
  });

  // Q3: Human implausibility heuristic
  // Recipes that are technically complete but no one would actually make
  const implausiblePatterns = [
    ingredients.length === 2, // Too simple
    estimatedCost < 0.50, // Suspiciously cheap
    ingredients.every(ing => ing.category === 'supplement'), // All supplements
  ];
  const implausiblePenalty = implausiblePatterns.filter(p => p).length > 0 ? 20 : 0;
  results.push({
    passed: implausiblePenalty === 0,
    ruleId: 'Q3',
    message: `Recipe may be implausible (${implausiblePatterns.filter(p => p).length} flags)`,
    penalty: implausiblePenalty,
  });

  // Q4: Repetitive cheap filler pattern
  const cheapFillers = ingredients.filter(ing =>
    (ing.name.toLowerCase().includes('rice') ||
      ing.name.toLowerCase().includes('corn') ||
      ing.name.toLowerCase().includes('wheat')) &&
    (ing.pricePerLb || 1) < 0.50
  ).length;
  const fillerPenalty = cheapFillers >= 2 ? 15 : 0;
  results.push({
    passed: cheapFillers < 2,
    ruleId: 'Q4',
    message: `Repetitive cheap filler pattern (${cheapFillers})`,
    penalty: fillerPenalty,
  });

  // Q5: Organ meat weight cap (soft gate - penalize if >10%)
  const organMeatNames = ['liver', 'kidney', 'heart'];
  const organMeats = ingredients.filter(ing => {
    const name = ing.name.toLowerCase();
    return ing.feedingRole === 'supplement' && organMeatNames.some(organ => name.includes(organ));
  });
  
  const totalWeight = ingredients.reduce((sum, ing) => sum + (ing.composition.protein || 1), 0);
  const organMeatWeight = organMeats.reduce((sum, ing) => sum + (ing.composition.protein || 1), 0);
  const organMeatPercent = totalWeight > 0 ? (organMeatWeight / totalWeight) * 100 : 0;
  
  let organMeatPenalty = 0;
  if (organMeatPercent > 15) organMeatPenalty = 30; // Way over
  else if (organMeatPercent > 10) organMeatPenalty = 15; // Slightly over
  
  results.push({
    passed: organMeatPercent <= 10,
    ruleId: 'Q5',
    message: `Organ meat weight: ${organMeatPercent.toFixed(1)}% (soft cap 10%)`,
    penalty: organMeatPenalty,
  });

  return results;
}

// ============================================================================
// MASTER VALIDATION FUNCTION
// ============================================================================

export interface RecipeValidationResult {
  isValid: boolean;
  hardGates: {
    structural: CompositionRuleResult[];
    safety: SafetyRuleResult[];
    lifeStage: LifeStageRuleResult[];
  };
  softGates: QualityRuleResult[];
  totalPenalty: number;
  failedRules: string[];
}

export function validateRecipeComprehensive(
  ingredients: Ingredient[],
  species: Species,
  lifeStage: 'puppy' | 'adult' | 'senior',
  estimatedCost: number,
  allergies?: string[]
): RecipeValidationResult {
  const structural = validateStructuralComposition(ingredients, species, lifeStage);
  const safety = validateSafetyAndToxicity(ingredients, species, allergies);
  const lifeStageRules = validateLifeStage(ingredients, species, lifeStage);
  const quality = validateQualityAndPlausibility(ingredients, estimatedCost);

  const hardGateFailed = [
    ...structural,
    ...safety,
    ...lifeStageRules,
  ].filter(r => !r.passed);

  const totalPenalty = quality.reduce((sum, q) => sum + q.penalty, 0);

  return {
    isValid: hardGateFailed.length === 0,
    hardGates: {
      structural,
      safety,
      lifeStage: lifeStageRules,
    },
    softGates: quality,
    totalPenalty,
    failedRules: hardGateFailed.map(r => r.ruleId),
  };
}
</file>

<file path="lib/generator/RecipePMIScoring.ts">
/**
 * PMI-BASED PAIRING INTELLIGENCE
 * Uses learned statistical priors from BOTH recipe scraping AND commercial products
 * NOT hardcoded rules - behavior changes when recipePriors.json changes
 */

import type { Ingredient } from '@/lib/data/ingredients';
import priors from '@/lib/data/recipePriors.json';

interface PairingScore {
  score: number;
  reason: string;
  pmiValue?: number;
  source?: 'recipe' | 'commercial' | 'both';
}

/**
 * Calculate PMI-based pairing score for an ingredient given already-selected ingredients
 * Combines recipe priors AND commercial priors for stronger signal
 * Returns both the score and an explanation
 */
export function calculatePairingScore(
  ingredient: Ingredient,
  selectedIngredients: Ingredient[],
  species: string
): PairingScore {
  if (selectedIngredients.length === 0) {
    return { score: 0, reason: 'No selected ingredients' };
  }

  const ingName = ingredient.name;
  let totalPMI = 0;
  let pairCount = 0;
  let negativePenalty = 0;
  const reasons: string[] = [];
  let hasRecipePriors = false;
  let hasCommercialPriors = false;

  // Check recipe priors (homemade recipes)
  const recipePriors = priors.coOccurrence?.[species];
  if (recipePriors) {
    for (const selected of selectedIngredients) {
      const selName = selected.name;
      const pair = [ingName, selName].sort().join('+');
      
      const pmi = recipePriors.pairPMI?.[pair];
      if (pmi !== undefined && pmi > 0) {
        totalPMI += pmi;
        pairCount++;
        hasRecipePriors = true;
        reasons.push(`+${pmi.toFixed(2)} recipe PMI with ${selName}`);
      }
      
      const negativePMI = recipePriors.negativePairs?.[pair];
      if (negativePMI !== undefined) {
        negativePenalty += Math.abs(negativePMI) * 10;
        hasRecipePriors = true;
        reasons.push(`-${Math.abs(negativePMI).toFixed(2)} NEGATIVE recipe pair with ${selName}`);
      }
    }
  }

  // Check commercial priors (pet food products)
  const commercialPriors = (priors as any).commercial?.[species];
  if (commercialPriors) {
    for (const selected of selectedIngredients) {
      const selName = selected.name;
      const pair = [ingName, selName].sort().join('|'); // Commercial uses | separator
      
      const pmi = commercialPriors.pairPMI?.[pair];
      if (pmi !== undefined && pmi > 0) {
        totalPMI += pmi * 1.2; // Boost commercial data slightly (more products = stronger signal)
        pairCount++;
        hasCommercialPriors = true;
        reasons.push(`+${pmi.toFixed(2)} commercial PMI with ${selName}`);
      }
      
      const rarePMI = commercialPriors.rarePairs?.[pair];
      if (rarePMI !== undefined) {
        negativePenalty += Math.abs(rarePMI) * 15; // Strong penalty for commercial rare pairs
        hasCommercialPriors = true;
        reasons.push(`-${Math.abs(rarePMI).toFixed(2)} RARE commercial pair with ${selName}`);
      }
    }
  }

  // Average PMI across all pairs
  const avgPMI = pairCount > 0 ? totalPMI / pairCount : 0;
  const finalScore = avgPMI - negativePenalty;

  const source = hasRecipePriors && hasCommercialPriors ? 'both' 
    : hasCommercialPriors ? 'commercial' 
    : hasRecipePriors ? 'recipe' 
    : undefined;

  const reason = reasons.length > 0 
    ? reasons.join(', ')
    : 'No learned pairings';

  return {
    score: finalScore,
    reason,
    pmiValue: avgPMI,
    source
  };
}

/**
 * Check if a fat is compatible with selected proteins based on PMI
 * Checks BOTH recipe and commercial priors for hard blocks
 * Returns true if fat should be ALLOWED
 */
export function isFatCompatibleWithProteins(
  fat: Ingredient,
  proteins: Ingredient[],
  species: string
): { compatible: boolean; reason: string; pmiScore?: number } {
  if (proteins.length === 0) {
    return { compatible: true, reason: 'No proteins selected yet' };
  }

  const fatName = fat.name;
  let totalPMI = 0;
  let pmiCount = 0;
  let hasNegativePair = false;
  let negativePairWith = '';
  let negativeSource = '';

  // Check recipe priors
  const recipePriors = priors.coOccurrence?.[species];
  if (recipePriors) {
    for (const protein of proteins) {
      const proteinName = protein.name;
      const pair = [fatName, proteinName].sort().join('+');
      
      const negativePMI = recipePriors.negativePairs?.[pair];
      if (negativePMI !== undefined && negativePMI < -1.0) {
        hasNegativePair = true;
        negativePairWith = proteinName;
        negativeSource = 'recipes';
        break;
      }
      
      const pmi = recipePriors.pairPMI?.[pair];
      if (pmi !== undefined) {
        totalPMI += pmi;
        pmiCount++;
      }
    }
  }

  // Check commercial priors (stronger signal)
  const commercialPriors = (priors as any).commercial?.[species];
  if (commercialPriors && !hasNegativePair) {
    for (const protein of proteins) {
      const proteinName = protein.name;
      const pair = [fatName, proteinName].sort().join('|');
      
      const rarePMI = commercialPriors.rarePairs?.[pair];
      if (rarePMI !== undefined && rarePMI < -1.5) {
        hasNegativePair = true;
        negativePairWith = proteinName;
        negativeSource = 'commercial products';
        break;
      }
      
      const pmi = commercialPriors.pairPMI?.[pair];
      if (pmi !== undefined) {
        totalPMI += pmi * 1.2; // Weight commercial data higher
        pmiCount++;
      }
    }
  }

  // Hard block if negative pairing detected
  if (hasNegativePair) {
    return {
      compatible: false,
      reason: `Negative pairing with ${negativePairWith} (learned from ${negativeSource})`,
      pmiScore: undefined
    };
  }

  // Allow if positive PMI or no learned relationship
  const avgPMI = pmiCount > 0 ? totalPMI / pmiCount : 0;
  
  if (avgPMI > 0.3) {
    return {
      compatible: true,
      reason: `Strong positive pairing (PMI: ${avgPMI.toFixed(2)})`,
      pmiScore: avgPMI
    };
  } else if (avgPMI > 0) {
    return {
      compatible: true,
      reason: `Weak positive pairing (PMI: ${avgPMI.toFixed(2)})`,
      pmiScore: avgPMI
    };
  } else {
    // No learned relationship - allow by default (species-appropriate fats)
    return {
      compatible: true,
      reason: 'No learned pairing (species-default allowed)',
      pmiScore: 0
    };
  }
}

/**
 * Get top-N fats that pair well with selected proteins
 * Uses PMI to rank fats, not hardcoded rules
 */
export function getTopPairedFats(
  availableFats: Ingredient[],
  proteins: Ingredient[],
  species: string,
  topN: number = 5
): Array<{ fat: Ingredient; pmiScore: number; reason: string }> {
  const scored = availableFats.map(fat => {
    const compat = isFatCompatibleWithProteins(fat, proteins, species);
    return {
      fat,
      pmiScore: compat.pmiScore || 0,
      reason: compat.reason,
      compatible: compat.compatible
    };
  });

  // Filter to compatible only, then sort by PMI
  return scored
    .filter(s => s.compatible)
    .sort((a, b) => b.pmiScore - a.pmiScore)
    .slice(0, topN);
}

/**
 * Log pairing decision for debugging
 */
export function logPairingDecision(
  ingredient: Ingredient,
  selectedIngredients: Ingredient[],
  species: string,
  action: 'selected' | 'rejected'
): void {
  const pairingScore = calculatePairingScore(ingredient, selectedIngredients, species);
  const prefix = action === 'selected' ? '‚úì' : '‚úó';
  console.log(
    `[PMI ${prefix}] ${ingredient.name}: score=${pairingScore.score.toFixed(2)} | ${pairingScore.reason}`
  );
}
</file>

<file path="lib/generator/RecipePriorScoring.ts">
/**
 * RECIPE PRIOR SCORING
 * Soft scoring boosts based on learned patterns from scraped recipes
 * Integrates with RecipeBuilder to improve realism and variety
 */

import recipePriors from '../data/recipePriors.json';
import { Ingredient } from '../data/ingredients';

interface RecipePriors {
  coOccurrence: {
    [species: string]: {
      pairs: Record<string, number>;
      triples: Record<string, number>;
    };
  };
  categoryRatios: {
    [species: string]: {
      protein: { mean: number; stdDev: number };
      vegetable: { mean: number; stdDev: number };
      fat: { mean: number; stdDev: number };
      carbohydrate: { mean: number; stdDev: number };
    };
  };
  ingredientCounts: {
    [species: string]: {
      mean: number;
      median: number;
      min: number;
      max: number;
    };
  };
}

const priors = recipePriors as RecipePriors;

/**
 * Calculate co-occurrence boost for an ingredient based on already-selected ingredients
 * Returns a score boost (0-1) based on how often this ingredient appears with the selected ones
 */
export function calculateCoOccurrenceBoost(
  candidateIngredient: Ingredient,
  selectedIngredients: Ingredient[],
  species: string
): number {
  if (selectedIngredients.length === 0) return 0;
  
  const speciesPriors = priors.coOccurrence[species];
  if (!speciesPriors) return 0;

  let totalBoost = 0;
  let pairCount = 0;

  // Check pairs with each selected ingredient
  for (const selected of selectedIngredients) {
    const pair1 = `${candidateIngredient.name}+${selected.name}`;
    const pair2 = `${selected.name}+${candidateIngredient.name}`;
    
    const count = speciesPriors.pairs[pair1] || speciesPriors.pairs[pair2] || 0;
    if (count > 0) {
      totalBoost += Math.log(count + 1) / 10; // Logarithmic scaling
      pairCount++;
    }
  }

  // Check triples if we have 2+ selected ingredients
  if (selectedIngredients.length >= 2) {
    for (let i = 0; i < selectedIngredients.length - 1; i++) {
      for (let j = i + 1; j < selectedIngredients.length; j++) {
        const ingredients = [
          candidateIngredient.name,
          selectedIngredients[i].name,
          selectedIngredients[j].name,
        ].sort();
        
        const triple = ingredients.join('+');
        const count = speciesPriors.triples[triple] || 0;
        
        if (count > 0) {
          totalBoost += Math.log(count + 1) / 5; // Higher weight for triples
        }
      }
    }
  }

  // Normalize to 0-1 range
  return Math.min(totalBoost, 1.0);
}

/**
 * Calculate category ratio penalty based on deviation from learned distributions
 * Returns a penalty (0-1) where 0 = perfect match, 1 = very far from typical
 */
export function calculateCategoryRatioPenalty(
  categoryRatios: Record<string, number>,
  species: string
): number {
  const speciesPriors = priors.categoryRatios[species];
  if (!speciesPriors) return 0;

  let totalDeviation = 0;
  let categoryCount = 0;

  for (const [category, ratio] of Object.entries(categoryRatios)) {
    const prior = speciesPriors[category as keyof typeof speciesPriors];
    if (!prior) continue;

    // Calculate z-score (how many standard deviations away)
    const zScore = Math.abs(ratio - prior.mean) / prior.stdDev;
    
    // Convert to penalty (0-1)
    // z-score of 0 = 0 penalty, z-score of 3+ = 1 penalty
    const penalty = Math.min(zScore / 3, 1.0);
    
    totalDeviation += penalty;
    categoryCount++;
  }

  return categoryCount > 0 ? totalDeviation / categoryCount : 0;
}

/**
 * Calculate ingredient count penalty based on deviation from typical recipe sizes
 * Returns a penalty (0-1) where 0 = typical count, 1 = very unusual count
 */
export function calculateIngredientCountPenalty(
  ingredientCount: number,
  species: string
): number {
  const speciesPriors = priors.ingredientCounts[species];
  if (!speciesPriors) return 0;

  const { mean, min, max } = speciesPriors;

  // Within typical range = no penalty
  if (ingredientCount >= min && ingredientCount <= max) {
    // Small penalty for being far from mean
    const deviation = Math.abs(ingredientCount - mean);
    return Math.min(deviation / (max - min), 0.3);
  }

  // Outside typical range = higher penalty
  if (ingredientCount < min) {
    const deficit = min - ingredientCount;
    return Math.min(0.5 + (deficit / min) * 0.5, 1.0);
  }

  // Too many ingredients
  const excess = ingredientCount - max;
  return Math.min(0.5 + (excess / max) * 0.5, 1.0);
}

/**
 * Get typical ingredient count range for a species
 */
export function getTypicalIngredientCount(species: string): { min: number; max: number; median: number } {
  const speciesPriors = priors.ingredientCounts[species];
  if (!speciesPriors) {
    return { min: 3, max: 10, median: 6 };
  }
  return {
    min: speciesPriors.min,
    max: speciesPriors.max,
    median: speciesPriors.median,
  };
}

/**
 * Check if an ingredient is commonly paired with a protein for this species
 * Used to boost vegetables/fats that commonly appear with the selected protein
 */
export function isCommonProteinPairing(
  ingredient: Ingredient,
  protein: Ingredient,
  species: string,
  pairingType: 'fat' | 'vegetable'
): boolean {
  const speciesPriors = priors.categoryPairs?.[species];
  if (!speciesPriors) return false;

  const pairings = pairingType === 'fat' 
    ? speciesPriors.proteinWithFat 
    : speciesPriors.proteinWithVeg;

  const commonPairs = pairings?.[protein.name] || [];
  return commonPairs.includes(ingredient.name);
}

/**
 * Apply all prior-based scoring adjustments to a base score
 * This is the main integration point for RecipeBuilder
 */
export function applyPriorScoring(
  ingredient: Ingredient,
  baseScore: number,
  selectedIngredients: Ingredient[],
  species: string,
  options: {
    coOccurrenceWeight?: number;
    proteinPairingWeight?: number;
  } = {}
): number {
  const {
    coOccurrenceWeight = 0.15,
    proteinPairingWeight = 0.1,
  } = options;

  let adjustedScore = baseScore;

  // 1. Co-occurrence boost
  const coOccurrenceBoost = calculateCoOccurrenceBoost(
    ingredient,
    selectedIngredients,
    species
  );
  adjustedScore += coOccurrenceBoost * coOccurrenceWeight;

  // 2. Protein pairing boost
  const selectedProtein = selectedIngredients.find(i => i.category === 'protein');
  if (selectedProtein) {
    if (ingredient.category === 'fat') {
      const isCommon = isCommonProteinPairing(ingredient, selectedProtein, species, 'fat');
      if (isCommon) {
        adjustedScore += proteinPairingWeight;
      }
    } else if (ingredient.category === 'vegetable') {
      const isCommon = isCommonProteinPairing(ingredient, selectedProtein, species, 'vegetable');
      if (isCommon) {
        adjustedScore += proteinPairingWeight;
      }
    }
  }

  return adjustedScore;
}
</file>

<file path="lib/generator/VerifyAmazonLinks.ts">
// Verify Amazon Links - Check if links are live and accessible
// Note: This checks HTTP status, but can't verify product details without scraping

import { VETTED_PRODUCTS } from '../data/vetted-products';

interface VerificationResult {
  ingredient: string;
  productName: string;
  asinLink: string;
  asin: string;
  status: 'checking' | 'live' | 'dead' | 'redirect' | 'error';
  httpStatus?: number;
  error?: string;
}

const results: VerificationResult[] = [];

console.log('='.repeat(80));
console.log('AMAZON LINK VERIFICATION - HTTP Status Check');
console.log('='.repeat(80));
console.log();
console.log('‚ö†Ô∏è  Note: This checks if links are accessible, but cannot verify');
console.log('    if the product matches the ingredient without manual review.');
console.log();
console.log('Checking links...');
console.log();

// Sample a subset of links to check (checking all 292 would take too long)
const entries = Object.entries(VETTED_PRODUCTS);
const sampleSize = 50; // Check first 50 products
const sampled = entries.slice(0, sampleSize);

async function checkLink(url: string): Promise<{ status: number; ok: boolean }> {
  try {
    const response = await fetch(url, {
      method: 'HEAD', // Just check headers, don't download content
      redirect: 'follow',
    });
    return { status: response.status, ok: response.ok };
  } catch (error: any) {
    throw new Error(error.message);
  }
}

async function verifyLinks() {
  let checked = 0;
  let live = 0;
  let dead = 0;
  let errors = 0;

  for (const [ingredientName, product] of sampled) {
    const asinLink = product.asinLink;
    const asinMatch = asinLink.match(/\/dp\/([A-Z0-9]{10})/i);
    const asin = asinMatch ? asinMatch[1] : 'unknown';

    const result: VerificationResult = {
      ingredient: ingredientName,
      productName: product.productName,
      asinLink,
      asin,
      status: 'checking',
    };

    try {
      const { status, ok } = await checkLink(asinLink);
      result.httpStatus = status;
      
      if (ok && status === 200) {
        result.status = 'live';
        live++;
      } else if (status >= 300 && status < 400) {
        result.status = 'redirect';
        live++; // Redirects are usually fine
      } else {
        result.status = 'dead';
        dead++;
      }
    } catch (error: any) {
      result.status = 'error';
      result.error = error.message;
      errors++;
    }

    results.push(result);
    checked++;

    // Progress indicator
    if (checked % 10 === 0) {
      console.log(`Checked ${checked}/${sampleSize}...`);
    }
  }

  console.log();
  console.log('='.repeat(80));
  console.log('VERIFICATION RESULTS');
  console.log('='.repeat(80));
  console.log();
  console.log(`Sample size: ${sampleSize} products (out of ${entries.length} total)`);
  console.log(`Live links: ${live} (${((live / checked) * 100).toFixed(1)}%)`);
  console.log(`Dead links: ${dead} (${((dead / checked) * 100).toFixed(1)}%)`);
  console.log(`Errors: ${errors} (${((errors / checked) * 100).toFixed(1)}%)`);
  console.log();

  // Show dead links
  const deadLinks = results.filter(r => r.status === 'dead');
  if (deadLinks.length > 0) {
    console.log('DEAD LINKS FOUND:');
    console.log('-'.repeat(80));
    deadLinks.forEach(r => {
      console.log(`‚ùå ${r.ingredient}`);
      console.log(`   Product: ${r.productName}`);
      console.log(`   ASIN: ${r.asin}`);
      console.log(`   Status: ${r.httpStatus}`);
      console.log(`   Link: ${r.asinLink}`);
      console.log();
    });
  }

  // Show errors
  const errorLinks = results.filter(r => r.status === 'error');
  if (errorLinks.length > 0) {
    console.log('ERRORS ENCOUNTERED:');
    console.log('-'.repeat(80));
    errorLinks.forEach(r => {
      console.log(`‚ö†Ô∏è  ${r.ingredient}`);
      console.log(`   Product: ${r.productName}`);
      console.log(`   Error: ${r.error}`);
      console.log(`   Link: ${r.asinLink}`);
      console.log();
    });
  }

  console.log('='.repeat(80));
  console.log('IMPORTANT NOTES');
  console.log('='.repeat(80));
  console.log();
  console.log('1. This script only checks if links are accessible (HTTP 200)');
  console.log('2. It CANNOT verify if the product actually matches the ingredient');
  console.log('3. Manual review is needed to confirm product accuracy');
  console.log();
  console.log('RECOMMENDED MANUAL CHECKS:');
  console.log('- Verify "venison" ASIN actually links to venison (not beef)');
  console.log('- Verify "rabbit meat" ASIN actually links to rabbit (not lamb)');
  console.log('- Verify "turkey giblets" ASIN actually links to turkey (not chicken)');
  console.log('- Verify seed products link to correct seed types');
  console.log();
  console.log('To manually verify, visit the links and check product titles/descriptions.');
  console.log('='.repeat(80));
}

// Run verification
verifyLinks().catch(console.error);
</file>

<file path="lib/hooks/useChunkedRecipeScoring.ts">
// lib/hooks/useChunkedRecipeScoring.ts
// Chunked recipe scoring hook for non-blocking UI performance

import { useState, useEffect, useRef, useMemo } from 'react';
import type { Recipe, ModifiedRecipeResult } from '@/lib/types';
import { calculateEnhancedCompatibility, calibrateScoresForPet, type Pet as EnhancedPet } from '@/lib/utils/enhancedCompatibilityScoring';

interface ScoredMeal {
  meal: ModifiedRecipeResult | { recipe: Recipe; explanation: string };
  score: number;
  recipeId: string;
}

interface CacheEntry {
  scores: ScoredMeal[];
  timestamp: number;
  recipeIds: string[];
  petProfileHash: string;
  version?: string;
}

interface IndividualCacheEntry {
  score: number;
  timestamp: number;
  recipeId: string;
  petProfileHash: string;
  version?: string;
}

const SCORING_VERSION = 'v3';
const CACHE_KEY_PREFIX = `recipe_scores_${SCORING_VERSION}_`;
const INDIVIDUAL_CACHE_KEY_PREFIX = `recipe_score_${SCORING_VERSION}_`;
const CACHE_DURATION_MS = 30 * 60 * 1000; // 30 minutes
const CHUNK_SIZE = 20; // Recipes per frame
const MAX_CACHE_SIZE_MB = 5; // Maximum cache size in MB
const MAX_CACHE_ENTRIES = 50; // Maximum number of cache entries before LRU eviction

/**
 * Simple string hash function for stable hashing
 * Produces consistent hash regardless of object property order
 */
function simpleHash(str: string): string {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32-bit integer
  }
  return Math.abs(hash).toString(36);
}

/**
 * Generate a stable hash from pet profile for caching
 * Uses sorted arrays to ensure consistent hash regardless of property order
 */
function generatePetProfileHash(
  pet: null, // Deprecated - using enhancedPet only
  enhancedPet: EnhancedPet | null
): string {
  if (!enhancedPet) return 'no-pet';
  
  const petData = enhancedPet;
  
  // Create stable string representation with sorted arrays
  const healthConcerns = (petData.healthConcerns || []).slice().sort().join(',');
  const allergies = ((petData.allergies || petData.dietaryRestrictions || [])).slice().sort().join(',');
  
  const stableString = [
    petData.id || '',
    petData.type || '',
    petData.breed || '',
    typeof petData.age === 'string' ? parseFloat(petData.age) || 0 : petData.age || 0,
    petData.weight || petData.weightKg || 0,
    petData.activityLevel || 'moderate',
    healthConcerns,
    allergies,
  ].join('|');
  
  return simpleHash(stableString);
}

/**
 * Get individual recipe score from cache
 */
function getCachedRecipeScore(
  recipeId: string,
  petProfileHash: string
): number | null {
  if (typeof window === 'undefined') return null;

  try {
    const cacheKey = `${INDIVIDUAL_CACHE_KEY_PREFIX}${recipeId}_${petProfileHash}`;
    const cached = localStorage.getItem(cacheKey);
    
    if (!cached) return null;

    const entry: IndividualCacheEntry = JSON.parse(cached);
    
    // Validate cache
    const now = Date.now();
    const isExpired = now - entry.timestamp > CACHE_DURATION_MS;
    const versionMatch = entry.version === SCORING_VERSION;
    const hashMatch = entry.petProfileHash === petProfileHash;
    const recipeMatch = entry.recipeId === recipeId;

    if (!isExpired && versionMatch && hashMatch && recipeMatch) {
      return entry.score;
    }
  } catch (error) {
    // Silently fail for individual cache misses
  }

  return null;
}

/**
 * Cache individual recipe score
 */
function cacheRecipeScore(
  recipeId: string,
  score: number,
  petProfileHash: string
): void {
  if (typeof window === 'undefined') return;

  const cacheKey = `${INDIVIDUAL_CACHE_KEY_PREFIX}${recipeId}_${petProfileHash}`;
  const entry: IndividualCacheEntry = {
    score,
    timestamp: Date.now(),
    recipeId,
    petProfileHash,
    version: SCORING_VERSION,
  };

  try {
    localStorage.setItem(cacheKey, JSON.stringify(entry));
  } catch (error) {
    // Silently fail for individual cache writes (batch cache will handle quota)
  }
}

/**
 * Get cached scores if available and valid
 */
function getCachedScores(
  meals: (ModifiedRecipeResult | { recipe: Recipe; explanation: string })[],
  petProfileHash: string
): ScoredMeal[] | null {
  if (typeof window === 'undefined') return null;

  try {
    const cacheKey = `${CACHE_KEY_PREFIX}${petProfileHash}`;
    const cached = localStorage.getItem(cacheKey);
    
    if (!cached) return null;

    const entry: CacheEntry = JSON.parse(cached);
    
    // Validate cache
    const now = Date.now();
    const isExpired = now - entry.timestamp > CACHE_DURATION_MS;
    const versionMatch = (entry.version || 'v1') === SCORING_VERSION; // Default to v1 for old caches
    const recipeIdsMatch = 
      entry.recipeIds.length === meals.length &&
      entry.recipeIds.every((id, i) => id === (meals[i]?.recipe?.id || ''));
    const hashMatch = entry.petProfileHash === petProfileHash;

    if (!isExpired && versionMatch && recipeIdsMatch && hashMatch) {
      console.log('Using cached recipe scores');
      return entry.scores;
    }
  } catch (error) {
    console.warn('Failed to read score cache:', error);
  }

  return null;
}

/**
 * Get cache size in bytes (approximate)
 */
function getCacheSize(): number {
  if (typeof window === 'undefined') return 0;
  
  let size = 0;
  for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    if (key && (key.startsWith(CACHE_KEY_PREFIX) || key.startsWith(INDIVIDUAL_CACHE_KEY_PREFIX))) {
      const value = localStorage.getItem(key);
      if (value) {
        size += key.length + value.length;
      }
    }
  }
  return size;
}

/**
 * Get all cache entries with timestamps for LRU eviction
 */
function getCacheEntriesWithTimestamps(): Array<{ key: string; timestamp: number; size: number }> {
  if (typeof window === 'undefined') return [];
  
  const entries: Array<{ key: string; timestamp: number; size: number }> = [];
  
  for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    if (key && (key.startsWith(CACHE_KEY_PREFIX) || key.startsWith(INDIVIDUAL_CACHE_KEY_PREFIX))) {
      try {
        const value = localStorage.getItem(key);
        if (value) {
          const parsed = JSON.parse(value);
          entries.push({
            key,
            timestamp: parsed.timestamp || 0,
            size: key.length + value.length,
          });
        }
      } catch {
        // Skip invalid entries
      }
    }
  }
  
  return entries.sort((a, b) => a.timestamp - b.timestamp); // Oldest first
}

/**
 * Evict old cache entries using LRU strategy
 */
function evictOldCacheEntries(): void {
  if (typeof window === 'undefined') return;
  
  const maxSizeBytes = MAX_CACHE_SIZE_MB * 1024 * 1024;
  const currentSize = getCacheSize();
  
  if (currentSize <= maxSizeBytes) return;
  
  // Get entries sorted by timestamp (oldest first)
  const entries = getCacheEntriesWithTimestamps();
  
  // Remove oldest entries until we're under the limit
  let sizeToRemove = currentSize - maxSizeBytes;
  for (const entry of entries) {
    if (sizeToRemove <= 0) break;
    
    try {
      localStorage.removeItem(entry.key);
      sizeToRemove -= entry.size;
    } catch {
      // Continue if removal fails
    }
  }
  
  // Also limit by entry count
  const remainingEntries = getCacheEntriesWithTimestamps();
  if (remainingEntries.length > MAX_CACHE_ENTRIES) {
    const toRemove = remainingEntries.slice(0, remainingEntries.length - MAX_CACHE_ENTRIES);
    for (const entry of toRemove) {
      try {
        localStorage.removeItem(entry.key);
      } catch {
        // Continue if removal fails
      }
    }
  }
}

/**
 * Clear all caches for a specific version (useful when version changes)
 */
export function clearCacheForVersion(version: string): void {
  if (typeof window === 'undefined') return;
  
  const keysToRemove: string[] = [];
  for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    if (key && (key.includes(`_${version}_`) || key.startsWith(`recipe_scores_${version}_`) || key.startsWith(`recipe_score_${version}_`))) {
      keysToRemove.push(key);
    }
  }
  
  keysToRemove.forEach(key => {
    try {
      localStorage.removeItem(key);
    } catch {
      // Continue if removal fails
    }
  });
}

/**
 * Cache scored results
 */
function cacheScores(
  scores: ScoredMeal[],
  meals: (ModifiedRecipeResult | { recipe: Recipe; explanation: string })[],
  petProfileHash: string
): void {
  if (typeof window === 'undefined') return;

  // Evict old entries before caching new ones
  evictOldCacheEntries();

  const cacheKey = `${CACHE_KEY_PREFIX}${petProfileHash}`;
  const entry: CacheEntry = {
    scores,
    timestamp: Date.now(),
    recipeIds: meals.map(m => m.recipe?.id || ''),
    petProfileHash,
    version: SCORING_VERSION,
  };

  try {
    localStorage.setItem(cacheKey, JSON.stringify(entry));
    
    // Also cache individual scores for future use
    scores.forEach(scored => {
      cacheRecipeScore(scored.recipeId, scored.score, petProfileHash);
    });
  } catch (error) {
    console.warn('Failed to cache scores:', error);
    // Handle quota exceeded errors gracefully
    if (error instanceof Error && error.name === 'QuotaExceededError') {
      // Evict more aggressively
      evictOldCacheEntries();
      try {
        // Retry caching
        localStorage.setItem(cacheKey, JSON.stringify(entry));
      } catch (retryError) {
        console.warn('Failed to cache scores after cleanup:', retryError);
      }
    }
  }
}

/**
 * Compute score for a single meal
 * Checks individual recipe cache before computing
 */
function computeMealScore(
  meal: ModifiedRecipeResult | { recipe: Recipe; explanation: string },
  ratingPet: null, // Deprecated - kept for type compatibility but always null
  enhancedPet: EnhancedPet | null,
  petProfileHash: string
): number {
  // If meal already has a score, use it
  if ('score' in meal && typeof (meal as ModifiedRecipeResult).score === 'number') {
    return Number((meal as ModifiedRecipeResult).score);
  }
  
  const recipeId = meal.recipe?.id || '';
  
  // Check individual recipe cache first
  if (recipeId) {
    const cachedScore = getCachedRecipeScore(recipeId, petProfileHash);
    if (cachedScore !== null) {
      return cachedScore;
    }
  }
  
  if (!enhancedPet) return 0;
  
  let score = 0;
  
  try {
    // Use enhanced compatibility scoring
    const enhanced = calculateEnhancedCompatibility(meal.recipe, enhancedPet);
    score = Number(enhanced.overallScore);
  } catch (error) {
    console.warn('Error scoring meal:', error);
    score = 0;
  }
  
  // Cache the computed score for future use
  if (recipeId && score > 0) {
    cacheRecipeScore(recipeId, score, petProfileHash);
  }
  
  return score;
}

/**
 * Hook for chunked recipe scoring
 * 
 * Processes meals in chunks using requestAnimationFrame to keep UI responsive
 */
export function useChunkedRecipeScoring(
  meals: (ModifiedRecipeResult | { recipe: Recipe; explanation: string })[],
  ratingPet: null, // Deprecated - using enhancedPet only
  enhancedPet: EnhancedPet | null
) {
  const [scoredMeals, setScoredMeals] = useState<ScoredMeal[]>([]);
  const [calibratedMeals, setCalibratedMeals] = useState<ScoredMeal[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [progress, setProgress] = useState(0);
  
  const chunkIndexRef = useRef(0);
  const frameIdRef = useRef<number | null>(null);
  const isMountedRef = useRef(true);

  // Generate pet profile hash for caching
  const petProfileHash = generatePetProfileHash(ratingPet, enhancedPet);

  // Check cache first
  useEffect(() => {
    if (meals.length === 0) {
      setScoredMeals([]);
      setIsLoading(false);
      setProgress(100);
      return;
    }

    const cached = getCachedScores(meals, petProfileHash);
    if (cached) {
      setScoredMeals(cached);
      setIsLoading(false);
      setProgress(100);
      return;
    }

    // Start chunked scoring
    setIsLoading(true);
    setProgress(0);
    setScoredMeals([]);
    chunkIndexRef.current = 0;
    isMountedRef.current = true;

    const processChunk = () => {
      if (!isMountedRef.current) return;

      const startIndex = chunkIndexRef.current;
      const endIndex = Math.min(startIndex + CHUNK_SIZE, meals.length);

      if (startIndex >= meals.length) {
        // All done - apply calibration before marking as complete
        setIsLoading(false);
        setProgress(100);
        return;
      }

      // Process current chunk
      const chunk = meals.slice(startIndex, endIndex);
      const newScores: ScoredMeal[] = chunk.map((meal, idx) => {
        const recipeId = meal.recipe?.id || `unknown-${startIndex + idx}`;
        const score = computeMealScore(meal, ratingPet, enhancedPet, petProfileHash);
        return {
          meal,
          score,
          recipeId,
        };
      });

      // Update state with new scores
      setScoredMeals(prev => {
        const updated = [...prev, ...newScores];
        // Sort as we go (optional - can defer to final sort)
        return updated;
      });

      // Update progress
      const newProgress = Math.floor((endIndex / meals.length) * 100);
      setProgress(newProgress);

      // Move to next chunk
      chunkIndexRef.current = endIndex;

      // Schedule next chunk
      frameIdRef.current = requestAnimationFrame(processChunk);
    };

    // Start processing
    frameIdRef.current = requestAnimationFrame(processChunk);

    return () => {
      isMountedRef.current = false;
      if (frameIdRef.current !== null) {
        cancelAnimationFrame(frameIdRef.current);
      }
    };
  }, [meals, petProfileHash, enhancedPet]);

  // Apply per-pet calibration when all scoring is complete
  useEffect(() => {
    if (!isLoading && scoredMeals.length > 0 && scoredMeals.length === meals.length && enhancedPet) {
      // Extract recipes from meals
      const recipes = meals.map(meal => meal.recipe).filter((r): r is Recipe => r !== undefined);
      
      if (recipes.length > 0) {
        // Apply calibration
        const calibratedScores = calibrateScoresForPet(recipes, enhancedPet);
        
        // Update scores with calibrated values
        const calibrated = scoredMeals.map(item => {
          const recipeId = item.recipeId;
          const calibratedScore = calibratedScores.get(recipeId);
          if (calibratedScore !== undefined) {
            return {
              ...item,
              score: calibratedScore,
            };
          }
          return item;
        });
        
        setCalibratedMeals(calibrated);
      } else {
        setCalibratedMeals(scoredMeals);
      }
    } else if (!isLoading && scoredMeals.length > 0 && scoredMeals.length === meals.length && !enhancedPet) {
      // No enhanced pet, skip calibration
      setCalibratedMeals(scoredMeals);
    }
  }, [isLoading, scoredMeals, meals, enhancedPet]);

  // Cache results when scoring completes (use calibrated scores)
  useEffect(() => {
    if (!isLoading && calibratedMeals.length > 0 && calibratedMeals.length === meals.length) {
      cacheScores(calibratedMeals, meals, petProfileHash);
    }
  }, [isLoading, calibratedMeals, meals, petProfileHash]);

  // Sort final results by score (descending) and format for rendering
  const scoredMealsToRender = useMemo(() => {
    const mealsToSort = calibratedMeals.length > 0 ? calibratedMeals : scoredMeals;
    const sorted = [...mealsToSort].sort((a, b) => {
      const scoreDiff = b.score - a.score;
      if (Math.abs(scoreDiff) > 0.001) {
        return scoreDiff;
      }
      // Tiebreaker: recipe ID
      return a.recipeId.localeCompare(b.recipeId);
    });

    return sorted.map(item => {
      if ('score' in item.meal && typeof (item.meal as ModifiedRecipeResult).score === 'number') {
        return { ...(item.meal as ModifiedRecipeResult), score: item.score };
      }
      return { ...item.meal, score: item.score };
    });
  }, [scoredMeals, calibratedMeals]);

  return {
    scoredMeals: scoredMealsToRender,
    isLoading,
    progress,
    totalMeals: meals.length,
    scoredCount: scoredMeals.length,
  };
}
</file>

<file path="lib/meal-plan-generator.ts">
// lib/meal-plan-generator.ts

// CORRECTED IMPORTS: Using absolute paths from the root ('@/')
import { Recipe, PetCategory, NutritionalRequirement } from '@/lib/types';
import { nutritionalGuidelines } from '@/lib/data/nutritional-guidelines';

/**
 * Defines the complete set of filtering criteria for a pet's profile.
 * Exported so it can be used in page.tsx.
 */
export interface PetProfile {
  category: PetCategory;
  ageGroup: string; // e.g., 'adult', 'puppy'
  breed: string | null; // e.g., 'labrador' or null
  healthConcern: string | null; // e.g., 'weight-management' or null
}

import { normalizeToSubtype } from '@/lib/utils/ingredientWhitelists';

/**
 * Check if recipe matches species/subtype (for meal plan generation)
 */
function matchesSpeciesForPlan(recipe: Recipe, profile: PetProfile): boolean {
  // Exact match
  if (recipe.category === profile.category) return true;
  
  // Subtype matching for exotics
  const subtype = normalizeToSubtype(profile.category as any, profile.breed || undefined);
  
  if (profile.category === 'birds') {
    // Allow generic bird recipes
    if (recipe.category === 'birds' || recipe.category === 'bird') return true;
    // Allow subtype-specific
    if (recipe.category === subtype) return true;
  }
  
  if (profile.category === 'reptiles') {    
    if (recipe.category === 'reptiles' || recipe.category === 'reptile') return true;
    if (recipe.category === subtype) return true;
  }
  
  if (profile.category === 'pocket-pets') {
    if (recipe.category === 'pocket-pets' || recipe.category === 'pocket-pet') return true;
    if (recipe.category === subtype) return true;
  }
  
  return false;
}

/**
 * Filters the master recipe list based on the pet's profile metadata.
 * Now supports subtype matching for exotic species.
 */
const filterRecipes = (profile: PetProfile): Recipe[] => {
  return recipes.filter(recipe => {
    // 1. Category/Subtype Match (Required)
    if (!matchesSpeciesForPlan(recipe, profile)) {
      return false;
    }

    // 2. Age Group Match (Required)
    // The recipe's ageGroup array must include the pet's ageGroup.
    if (!recipe.ageGroup.includes(profile.ageGroup)) {
      return false;
    }

    // 3. Breed Match (Optional - only applied if a breed is selected)
    // The recipe must either explicitly support the breed, or the recipe breed array is empty/null.
    if (profile.breed && recipe.breed && recipe.breed.length > 0) {
        if (!recipe.breed.includes(profile.breed)) {
            return false;
        }
    }
    
    // 4. Health Concern Match (Optional - only applied if a concern is selected)
    // The recipe's healthConcerns array must include the pet's health concern.
    if (profile.healthConcern && !recipe.healthConcerns.includes(profile.healthConcern)) {
      return false;
    }

    // If all checks pass, the recipe is suitable for the pet's profile.
    return true;
  });
};

/**
 * Generates a full weekly meal plan (14 meals total) from a pool of filtered recipes,
 * prioritizing variety and repeating recipes only if necessary.
 * Exported so it can be used in page.tsx.
 */
export const generateWeeklyMealPlan = (profile: PetProfile): Recipe[] => {
  const filteredRecipes = filterRecipes(profile);
  const mealPlan: Recipe[] = [];
  const requiredMeals = 14; // 7 days * 2 meals per day

  if (filteredRecipes.length === 0) {
    console.warn(`No recipes found for the selected profile: ${profile.category} - ${profile.ageGroup}. Returning placeholders.`);
    // Return a plan of placeholders if no recipes are found
    const placeholderRecipe: Recipe = {
        id: 'none',
        name: 'No Recipe Found',
        category: profile.category,
        ageGroup: ['adult'],
        healthConcerns: [],
        description: '',
        ingredients: [],
        instructions: [],
        tags: ['error'],
        rating: 0,
        reviews: 0,
        prepTime: '0 min',
        cookTime: '0 min',
        servings: 1
    };
    // Fill the 14-meal plan with the placeholder to prevent the UI from being empty
    return Array(requiredMeals).fill(placeholderRecipe);
  }

  // Use a temporary list to track recipes for variety
  let availableRecipes = [...filteredRecipes];

  // Loop to fill the 14-meal plan
  for (let i = 0; i < requiredMeals; i++) {
    // If we run out of unique recipes, refill the available list to allow repeats
    if (availableRecipes.length === 0) {
      availableRecipes = [...filteredRecipes];
    }

    // Randomly select a recipe from the current available list
    const randomIndex = Math.floor(Math.random() * availableRecipes.length);
    const selectedRecipe = availableRecipes[randomIndex];
    
    // Add the selected recipe to the plan
    mealPlan.push(selectedRecipe);

    // Remove the selected recipe from the available list to prevent immediate repetition
    availableRecipes.splice(randomIndex, 1);
  }

  return mealPlan;
};

/**
 * A utility function to retrieve the correct nutritional requirements.
 */
export const getRequiredGuidelines = (category: PetCategory, ageGroup: string): NutritionalRequirement | undefined => {
  const categoryGuidelines = nutritionalGuidelines[category];
  return categoryGuidelines[ageGroup as keyof typeof categoryGuidelines];
};
</file>

<file path="lib/modifierRules.ts">
import { IngredientOption, ModifierRule, Species } from '@/lib/types';

export const ingredientAlternatives: Record<string, string[]> = {
  chicken: ['turkey', 'duck', 'rabbit'],
  beef: ['venison', 'bison', 'lamb'],
  wheat: ['oats', 'quinoa', 'buckwheat'],
  rice: ['sweet potato', 'pumpkin', 'butternut squash'],
  dairy: ['goat milk kefir', 'bone broth'],
  salmon: ['sardine', 'mackerel', 'anchovy'],
};

export const healthConcernGuidelines: Record<
  string,
  {
    focus: string;
    avoid?: string[];
    preferredIngredients?: string[];
    supplementIdeas?: string[];
  }
> = {
  allergies: {
    focus: 'Novel proteins + anti-inflammatory omegas',
    avoid: ['chicken', 'beef', 'wheat'],
    preferredIngredients: ['duck', 'rabbit', 'pumpkin'],
    supplementIdeas: ['fish oil', 'quercetin'],
  },
  'weight-management': {
    focus: 'Lower calorie density, higher fiber for satiety',
    avoid: ['rendered fats', 'simple carbs'],
    preferredIngredients: ['green beans', 'lean turkey', 'cauliflower rice'],
    supplementIdeas: ['L-carnitine'],
  },
  'joint-health': {
    focus: 'Anti-inflammatory fats + joint supplements',
    preferredIngredients: ['wild salmon', 'turmeric', 'bone broth'],
    supplementIdeas: ['glucosamine', 'fish oil'],
  },
  digestive: {
    focus: 'Gentle proteins + prebiotic fiber + probiotics',
    avoid: ['dairy', 'fried fats', 'spices'],
    preferredIngredients: ['pumpkin', 'bone broth', 'cooked rice'],
    supplementIdeas: ['probiotics'],
  },
  kidney: {
    focus: 'Controlled phosphorus, moderate protein, high moisture',
    avoid: ['organ meats high in phosphorus'],
    preferredIngredients: ['white fish', 'egg whites', 'low-sodium broth'],
    supplementIdeas: ['omega-3 fish oil'],
  },
  'urinary-health': {
    focus: 'Moisture + urinary acidifiers',
    preferredIngredients: ['bone broth', 'cranberry', 'DL-methionine'],
  },
  diabetes: {
    focus: 'High protein, very low carbs, consistent calories',
    avoid: ['high-sugar', 'simple-carbs', 'corn-syrup', 'white-rice'],
    preferredIngredients: ['lean-protein', 'complex-carbs', 'high-fiber-vegetables'],
    supplementIdeas: ['chromium', 'alpha-lipoic-acid'],
  },
  hyperthyroidism: {
    focus: 'Controlled iodine + higher calories to offset metabolism',
  },
  pancreatitis: {
    focus: 'Ultra low fat, easily digestible proteins, MCT support',
    avoid: ['high-fat', 'pork', 'lamb', 'duck', 'fried', 'greasy', 'fatty-cuts'],
    preferredIngredients: ['lean-turkey', 'white-fish', 'chicken-breast', 'pumpkin'],
    supplementIdeas: ['digestive-enzymes', 'probiotics'],
  },
  'heart-disease': {
    focus: 'Low sodium, taurine-rich, omega-3 support, controlled calories',
    avoid: ['high-sodium', 'processed', 'excessive-fat'],
    preferredIngredients: ['lean-protein', 'omega-3-rich-fish', 'taurine-sources'],
    supplementIdeas: ['taurine', 'omega-3', 'coenzyme-q10'],
  },
  'heart disease': {
    focus: 'Low sodium, taurine-rich, omega-3 support, controlled calories',
    avoid: ['high-sodium', 'processed', 'excessive-fat'],
    preferredIngredients: ['lean-protein', 'omega-3-rich-fish', 'taurine-sources'],
    supplementIdeas: ['taurine', 'omega-3', 'coenzyme-q10'],
  },
  'skin-conditions': {
    focus: 'Omega-3 rich, quality protein, vitamin E, anti-inflammatory',
    avoid: ['artificial-colors', 'preservatives', 'low-quality-protein'],
    preferredIngredients: ['salmon', 'sardines', 'sweet-potato', 'pumpkin'],
    supplementIdeas: ['omega-3', 'vitamin-e', 'zinc', 'biotin'],
  },
  'skin conditions': {
    focus: 'Omega-3 rich, quality protein, vitamin E, anti-inflammatory',
    avoid: ['artificial-colors', 'preservatives', 'low-quality-protein'],
    preferredIngredients: ['salmon', 'sardines', 'sweet-potato', 'pumpkin'],
    supplementIdeas: ['omega-3', 'vitamin-e', 'zinc', 'biotin'],
  },
  hairball: {
    focus: 'Insoluble & soluble fiber blend + omega oils',
  },
};

export const breedPredispositions: Record<
  string,
  {
    concerns: string[];
    notes: string;
  }
> = {
  labrador: {
    concerns: ['weight-management', 'joint-health'],
    notes: 'Prone to obesity and hip dysplasia; monitor calories and joints.',
  },
  'german-shepherd': {
    concerns: ['joint-health', 'digestive'],
    notes: 'Hip issues and sensitive gut benefit from joint + probiotic support.',
  },
  'golden-retriever': {
    concerns: ['joint-health', 'allergies'],
    notes: 'Seasonal allergies and hips respond to omega-3s.',
  },
  beagle: {
    concerns: ['weight-management'],
    notes: 'Small frame with big appetite ‚Äì portion discipline is critical.',
  },
  mainecoon: {
    concerns: ['joint-health', 'heart'],
    notes: 'Large frame cats need taurine and joint support.',
  },
  siamese: {
    concerns: ['hyperthyroidism'],
    notes: 'Breed predisposition for thyroid imbalance.',
  },
  persian: {
    concerns: ['hairball', 'urinary-health'],
    notes: 'Long coats and kidney sensitivities.',
  },
};

export const healthConcernCalorieAdjustments: Record<string, number> = {
  'weight-management': -20,
  obesity: -20,
  allergies: 0,
  'joint-health': -5,
  digestive: -5,
  kidney: -10,
  'urinary-health': -5,
  diabetes: -15,
  hyperthyroidism: +10,
  pancreatitis: -15,
  hairball: 0,
};

const addIngredient = (
  options: IngredientOption[],
  weightKg: number
): IngredientOption[] =>
  options.map((opt) => {
    if (!opt.amountPer10kg) {
      return opt;
    }
    const numeric = parseFloat(opt.amountPer10kg);
    if (Number.isNaN(numeric)) {
      return { ...opt, amount: opt.amountPer10kg };
    }
    const amountValue = ((weightKg / 10) * numeric).toFixed(0);
    const unit = opt.amountPer10kg.replace(/[0-9.]/g, '').trim() || 'g';
    return {
      ...opt,
      amount: `${amountValue}${unit}`,
    };
  });

export const modifierRules: ModifierRule[] = [
  {
    id: 'mod-allergies-01',
    appliesTo: {
      species: ['dogs'],
      healthConcerns: ['allergies'],
    },
    ingredientChanges: {
      remove: ['chicken', 'beef', 'wheat'],
      substitute: [
        { from: 'chicken', to: 'turkey breast' },
        { from: 'beef', to: 'venison' },
      ],
      add: [
        {
          name: 'Pumpkin Puree',
          amountPer10kg: '50g',
          amazonLink: 'https://www.amazon.com/s?k=organic+pumpkin+puree+dog',
          notes: 'Adds fiber & beta carotene for gut healing.',
        },
        {
          name: 'Fish Oil Supplement',
          amountPer10kg: '250mg',
          amazonLink: 'https://www.amazon.com/s?k=dog+fish+oil',
          notes: 'Provides EPA/DHA for anti-inflammatory support.',
        },
      ],
    },
    nutritionalTargets: {
      fatMax: 15,
    },
    rationale:
      'Removes common allergens and boosts anti-inflammatory omega-3 intake.',
    ruleWeight: 12,
  },
  {
    id: 'mod-weight-01',
    appliesTo: {
      species: ['dogs'],
      healthConcerns: ['weight-management', 'obesity'],
    },
    ingredientChanges: {
      add: [
        {
          name: 'Green Bean Fiber Boost',
          amountPer10kg: '80g',
          amazonLink: 'https://www.amazon.com/s?k=freeze+dried+green+beans+dog',
          notes: 'Adds bulk without calories.',
        },
      ],
      substitute: [{ from: 'white rice', to: 'steamed cauliflower rice' }],
    },
    nutritionalTargets: {
      fatMax: 12,
      caloriesAdjust: -20,
    },
    rationale:
      'Increases fiber and swaps starches to support caloric deficit safely.',
    ruleWeight: 15,
  },
  {
    id: 'mod-joints-01',
    appliesTo: {
      species: ['dogs'],
      healthConcerns: ['joint-health', 'arthritis'],
      ageGroups: ['senior'],
    },
    ingredientChanges: {
      add: [
        {
          name: 'Fish Oil Supplement',
          amountPer10kg: '250mg',
          amazonLink: 'https://www.amazon.com/s?k=fish+oil+for+dogs',
          notes: 'EPA/DHA for inflammation control.',
        },
        {
          name: 'Golden Paste (Turmeric + Black Pepper)',
          amountPer10kg: '10g',
          amazonLink: 'https://www.amazon.com/s?k=turmeric+paste+dog',
          notes: 'Natural COX-2 inhibitor to ease joint pain.',
        },
      ],
    },
    nutritionalTargets: {
      fatMax: 15,
    },
    rationale: 'Supports anti-inflammatory pathways in senior joints.',
    ruleWeight: 14,
  },
  {
    id: 'mod-digest-01',
    appliesTo: {
      species: ['dogs'],
      healthConcerns: ['digestive'],
    },
    ingredientChanges: {
      remove: ['dairy'],
      add: [
        {
          name: 'Bone Broth',
          amountPer10kg: '120ml',
          amazonLink: 'https://www.amazon.com/s?k=dog+bone+broth',
          notes: 'Adds collagen + hydration for gut lining.',
        },
        {
          name: 'Probiotic Powder',
          amountPer10kg: '1g',
          amazonLink: 'https://www.amazon.com/s?k=dog+probiotic+powder',
          notes: 'Rebalances microbiome after GI upset.',
        },
      ],
    },
    nutritionalTargets: {
      fatMax: 14,
    },
    rationale:
      'Removes irritants, increases moisture, and replenishes beneficial bacteria.',
    ruleWeight: 11,
  },
  {
    id: 'mod-kidney-01',
    appliesTo: {
      species: ['dogs'],
      healthConcerns: ['kidney'],
    },
    ingredientChanges: {
      remove: ['organ meat'],
      substitute: [{ from: 'bone meal', to: 'egg shell powder' }],
      add: [
        {
          name: 'Low-Sodium Bone Broth',
          amountPer10kg: '150ml',
          notes: 'Boosts hydration without excess sodium.',
        },
        {
          name: 'Omega-3 Fish Oil',
          amountPer10kg: '200mg',
          amazonLink: 'https://www.amazon.com/s?k=renal+support+fish+oil+dog',
          notes: 'Slows kidney inflammation.',
        },
      ],
    },
    nutritionalTargets: {
      proteinMin: 18,
      phosphorusMax: 0.6,
      fatMax: 14,
    },
    rationale: 'Controls phosphorus and supports renal hydration.',
    ruleWeight: 16,
  },
  {
    id: 'mod-urinary-01',
    appliesTo: {
      species: ['cats'],
      healthConcerns: ['urinary-health'],
    },
    ingredientChanges: {
      add: [
        {
          name: 'Unsalted Bone Broth',
          amountPer10kg: '120ml',
          notes: 'Raises moisture intake to dilute urine.',
        },
        {
          name: 'Cranberry Powder',
          amountPer10kg: '500mg',
          amazonLink: 'https://www.amazon.com/s?k=cranberry+cat+urinary',
          notes: 'Helps acidify urine to reduce crystals.',
        },
      ],
    },
    nutritionalTargets: {
      phosphorusMax: 0.7,
    },
    rationale:
      'Increases moisture and adds mild acidifiers for urinary tract protection.',
    ruleWeight: 15,
  },
  {
    id: 'mod-diabetes-01',
    appliesTo: {
      species: ['cats'],
      healthConcerns: ['diabetes'],
    },
    ingredientChanges: {
      remove: ['white rice', 'peas'],
      substitute: [{ from: 'sweet potato', to: 'steamed zucchini' }],
      add: [
        {
          name: 'Chromium + Cinnamon Blend',
          amountPer10kg: '250mg',
          notes: 'Helps insulin sensitivity (vet-approved doses).',
        },
      ],
    },
    nutritionalTargets: {
      proteinMin: 40,
      fatMax: 18,
      caloriesAdjust: -10,
    },
    rationale: 'Cuts starches and supports glycemic control.',
    ruleWeight: 16,
  },
  {
    id: 'mod-hyperthyroid-01',
    appliesTo: {
      species: ['cats'],
      healthConcerns: ['hyperthyroidism'],
    },
    ingredientChanges: {
      add: [
        {
          name: 'L-Carnitine Supplement',
          amountPer10kg: '200mg',
          amazonLink: 'https://www.amazon.com/s?k=l-carnitine+for+cats',
          notes: 'Supports muscle mass during hypermetabolic states.',
        },
      ],
      substitute: [{ from: 'kelp', to: 'dulse (low iodine)' }],
    },
    nutritionalTargets: {
      proteinMin: 42,
      caloriesAdjust: +10,
    },
    rationale:
      'Maintains lean mass and avoids iodine spikes that can worsen thyroid storms.',
    ruleWeight: 12,
  },
  {
    id: 'mod-pancreatitis-01',
    appliesTo: {
      species: ['cats'],
      healthConcerns: ['pancreatitis'],
    },
    ingredientChanges: {
      remove: ['salmon skin', 'added oils'],
      add: [
        {
          name: 'Skinless White Fish',
          amountPer10kg: '120g',
          notes: 'Ultra-lean protein swap to rest pancreas.',
        },
        {
          name: 'MCT Oil (Caprylic/Capric)',
          amountPer10kg: '3ml',
          notes: 'Easy energy source without pancreatic enzymes.',
        },
      ],
    },
    nutritionalTargets: {
      fatMax: 10,
    },
    rationale: 'Removes fats requiring pancreatic lipase and adds safe energy.',
    ruleWeight: 17,
  },
  {
    id: 'mod-hairball-01',
    appliesTo: {
      species: ['cats'],
      healthConcerns: ['hairball'],
    },
    ingredientChanges: {
      add: [
        {
          name: 'Psyllium Husk',
          amountPer10kg: '1g',
          notes: 'Adds soluble fiber to move ingested hair.',
        },
        {
          name: 'Sardine Oil',
          amountPer10kg: '150mg',
          amazonLink: 'https://www.amazon.com/s?k=sardine+oil+for+cats',
          notes: 'Lubricates GI tract and boosts omegas for coat.',
        },
      ],
    },
    nutritionalTargets: {},
    rationale: 'Fibers plus omegas reduce shedding and lubricate transit.',
    ruleWeight: 10,
  },
  {
    id: 'mod-heart-disease-dog-01',
    appliesTo: {
      species: ['dogs'],
      healthConcerns: ['heart-disease', 'heart disease'],
    },
    ingredientChanges: {
      remove: ['high-sodium', 'processed'],
      add: [
        {
          name: 'Taurine Supplement',
          amountPer10kg: '500mg',
          amazonLink: 'https://www.amazon.com/s?k=taurine+supplement+dog',
          notes: 'Essential amino acid for heart muscle function.',
        },
        {
          name: 'Omega-3 Fish Oil',
          amountPer10kg: '300mg',
          amazonLink: 'https://www.amazon.com/s?k=omega-3+fish+oil+dog',
          notes: 'EPA/DHA support cardiovascular health.',
        },
        {
          name: 'Coenzyme Q10',
          amountPer10kg: '30mg',
          amazonLink: 'https://www.amazon.com/s?k=coq10+for+dogs',
          notes: 'Supports heart muscle energy production.',
        },
      ],
    },
    nutritionalTargets: {
      fatMax: 15,
      sodiumMax: 0.3,
    },
    rationale: 'Low sodium, taurine-rich diet with omega-3 support for cardiac function.',
    ruleWeight: 18,
  },
  {
    id: 'mod-heart-disease-cat-01',
    appliesTo: {
      species: ['cats'],
      healthConcerns: ['heart-disease', 'heart disease'],
    },
    ingredientChanges: {
      remove: ['high-sodium', 'processed'],
      add: [
        {
          name: 'Taurine Supplement',
          amountPer10kg: '250mg',
          amazonLink: 'https://www.amazon.com/s?k=taurine+supplement+cat',
          notes: 'Critical for feline heart health - cats cannot synthesize taurine.',
        },
        {
          name: 'Omega-3 Fish Oil',
          amountPer10kg: '200mg',
          amazonLink: 'https://www.amazon.com/s?k=omega-3+fish+oil+cat',
          notes: 'EPA/DHA for cardiovascular support.',
        },
        {
          name: 'L-Carnitine',
          amountPer10kg: '250mg',
          amazonLink: 'https://www.amazon.com/s?k=l-carnitine+for+cats',
          notes: 'Supports heart muscle metabolism.',
        },
      ],
    },
    nutritionalTargets: {
      fatMax: 15,
      sodiumMax: 0.25,
      proteinMin: 40,
    },
    rationale: 'Taurine-rich, low-sodium diet essential for feline cardiac health.',
    ruleWeight: 20,
  },
  {
    id: 'mod-skin-conditions-dog-01',
    appliesTo: {
      species: ['dogs'],
      healthConcerns: ['skin-conditions', 'skin conditions'],
    },
    ingredientChanges: {
      remove: ['artificial-colors', 'preservatives'],
      add: [
        {
          name: 'Omega-3 Fish Oil',
          amountPer10kg: '400mg',
          amazonLink: 'https://www.amazon.com/s?k=omega-3+fish+oil+dog',
          notes: 'Anti-inflammatory omega-3s for skin health.',
        },
        {
          name: 'Vitamin E Supplement',
          amountPer10kg: '100IU',
          amazonLink: 'https://www.amazon.com/s?k=vitamin+e+for+dogs',
          notes: 'Antioxidant support for skin barrier function.',
        },
        {
          name: 'Zinc Supplement',
          amountPer10kg: '15mg',
          amazonLink: 'https://www.amazon.com/s?k=zinc+supplement+dog',
          notes: 'Essential for skin healing and immune function.',
        },
      ],
    },
    nutritionalTargets: {
      fatMin: 10,
    },
    rationale: 'Omega-3s, vitamin E, and zinc support healthy skin barrier and reduce inflammation.',
    ruleWeight: 14,
  },
  {
    id: 'mod-skin-conditions-cat-01',
    appliesTo: {
      species: ['cats'],
      healthConcerns: ['skin-conditions', 'skin conditions'],
    },
    ingredientChanges: {
      remove: ['artificial-colors', 'preservatives'],
      add: [
        {
          name: 'Omega-3 Fish Oil',
          amountPer10kg: '300mg',
          amazonLink: 'https://www.amazon.com/s?k=omega-3+fish+oil+cat',
          notes: 'EPA/DHA for skin health and anti-inflammatory support.',
        },
        {
          name: 'Biotin Supplement',
          amountPer10kg: '250mcg',
          amazonLink: 'https://www.amazon.com/s?k=biotin+for+cats',
          notes: 'B-vitamin essential for healthy skin and coat.',
        },
        {
          name: 'Vitamin E',
          amountPer10kg: '50IU',
          amazonLink: 'https://www.amazon.com/s?k=vitamin+e+for+cats',
          notes: 'Antioxidant for skin barrier protection.',
        },
      ],
    },
    nutritionalTargets: {
      fatMin: 12,
      proteinMin: 38,
    },
    rationale: 'Quality protein, omega-3s, and skin-supporting vitamins for healthy coat.',
    ruleWeight: 15,
  },
  {
    id: 'mod-diabetes-dog-01',
    appliesTo: {
      species: ['dogs'],
      healthConcerns: ['diabetes'],
    },
    ingredientChanges: {
      remove: ['high-sugar', 'simple-carbs', 'corn-syrup', 'white-rice'],
      substitute: [
        { from: 'white rice', to: 'steamed cauliflower rice' },
        { from: 'sweet potato', to: 'green beans' },
      ],
      add: [
        {
          name: 'Chromium Supplement',
          amountPer10kg: '50mcg',
          amazonLink: 'https://www.amazon.com/s?k=chromium+supplement+dog',
          notes: 'Helps improve insulin sensitivity.',
        },
        {
          name: 'Alpha-Lipoic Acid',
          amountPer10kg: '25mg',
          amazonLink: 'https://www.amazon.com/s?k=alpha-lipoic-acid+dog',
          notes: 'Antioxidant that may help with glucose metabolism.',
        },
      ],
    },
    nutritionalTargets: {
      proteinMin: 25,
      fatMax: 15,
      caloriesAdjust: -10,
    },
    rationale: 'Low-glycemic, high-protein diet with consistent calories for blood sugar control.',
    ruleWeight: 17,
  },
  {
    id: 'mod-diabetes-cat-01',
    appliesTo: {
      species: ['cats'],
      healthConcerns: ['diabetes'],
    },
    ingredientChanges: {
      remove: ['high-sugar', 'simple-carbs', 'corn-syrup', 'white-rice'],
      substitute: [
        { from: 'white rice', to: 'steamed cauliflower rice' },
        { from: 'sweet potato', to: 'green beans' },
      ],
      add: [
        {
          name: 'Chromium Supplement',
          amountPer10kg: '25mcg',
          amazonLink: 'https://www.amazon.com/s?k=chromium+supplement+cat',
          notes: 'Helps improve insulin sensitivity in cats.',
        },
        {
          name: 'Alpha-Lipoic Acid',
          amountPer10kg: '15mg',
          amazonLink: 'https://www.amazon.com/s?k=alpha-lipoic-acid+cat',
          notes: 'Antioxidant support for glucose metabolism.',
        },
      ],
    },
    nutritionalTargets: {
      proteinMin: 40,
      fatMax: 15,
      caloriesAdjust: -10,
    },
    rationale: 'High-protein, low-carb diet with consistent calories for feline diabetes management.',
    ruleWeight: 18,
  },
  {
    id: 'mod-pancreatitis-dog-01',
    appliesTo: {
      species: ['dogs'],
      healthConcerns: ['pancreatitis'],
    },
    ingredientChanges: {
      remove: ['high-fat', 'pork', 'lamb', 'duck', 'fried', 'greasy'],
      substitute: [
        { from: 'ground beef', to: 'lean turkey breast' },
        { from: 'salmon', to: 'white fish (cod/tilapia)' },
      ],
      add: [
        {
          name: 'MCT Oil',
          amountPer10kg: '5ml',
          amazonLink: 'https://www.amazon.com/s?k=mct+oil+for+dogs',
          notes: 'Easy energy source that bypasses pancreatic enzymes.',
        },
        {
          name: 'Digestive Enzymes',
          amountPer10kg: '1 capsule',
          amazonLink: 'https://www.amazon.com/s?k=digestive+enzymes+dog',
          notes: 'Supports digestion during pancreatic recovery.',
        },
        {
          name: 'Probiotics',
          amountPer10kg: '1g',
          amazonLink: 'https://www.amazon.com/s?k=probiotics+for+dogs',
          notes: 'Supports gut health during low-fat diet.',
        },
      ],
    },
    nutritionalTargets: {
      fatMax: 10,
    },
    rationale: 'Ultra-low fat diet with easily digestible proteins to rest the pancreas.',
    ruleWeight: 19,
  },
];

/**
 * Utility helper to inject weight-aware additions inline.
 * Exported for tests and future dynamic adjustments.
 */
export const expandWeightAwareIngredients = (
  additions: IngredientOption[] | undefined,
  weightKg: number
): IngredientOption[] => {
  if (!additions?.length) return [];
  return addIngredient(additions, weightKg);
};
</file>

<file path="lib/nutrition/nutritionHistory.ts">
import type { Recipe } from '@/lib/types';

export interface DailyNutrition {
  day: string;
  calories: number;
  protein: number;
  fat: number;
  carbs: number;
  fiber?: number;
}

export interface NutritionTargets {
  calories?: number;
  proteinRange?: [number, number];
  fatRange?: [number, number];
  carbsRange?: [number, number];
  fiberRange?: [number, number];
}

const safeNumber = (value: any, fallback = 0) => {
  const n = Number(value);
  return Number.isFinite(n) ? n : fallback;
};

const extractRecipeNutrition = (recipe: Recipe) => {
  // Prefer nutritionalCalculation if present (for custom meals)
  const calc = (recipe as any).nutritionalCalculation || (recipe as any).nutrition;
  if (calc) {
    return {
      calories: safeNumber(calc.calories),
      protein: safeNumber(calc.protein),
      fat: safeNumber(calc.fat),
      carbs: safeNumber(calc.carbs),
      fiber: safeNumber(calc.fiber),
    };
  }

  // Extract from nutritionalInfo (recipes-complete.ts format)
  const info = recipe.nutritionalInfo || {};
  
  // Calories are stored as absolute kcal values
  const calories = safeNumber(
    info.calories?.min || info.calories?.max || 
    parseFloat((recipe.nutritionInfo?.calories || '').replace(/[^0-9.]/g, '')) || 
    300
  );

  // Protein, fat, carbs, fiber are stored as percentages
  // Estimate serving size from calories (rough: ~4 kcal per gram average)
  // Then convert percentages to grams
  const estimatedServingGrams = calories / 3.5; // ~3.5 kcal/g average for pet food
  
  const proteinPercent = safeNumber(info.protein?.min || info.protein?.max || 0);
  const fatPercent = safeNumber(info.fat?.min || info.fat?.max || 0);
  const fiberPercent = safeNumber(info.fiber?.min || info.fiber?.max || 0);
  
  // Estimate carbs as remainder (100% - protein% - fat% - fiber% - water/ash ~70%)
  // Or use a conservative estimate
  const carbsPercent = Math.max(0, 100 - proteinPercent - fatPercent - fiberPercent - 70);
  
  return {
    calories,
    protein: (proteinPercent / 100) * estimatedServingGrams,
    fat: (fatPercent / 100) * estimatedServingGrams,
    carbs: (carbsPercent / 100) * estimatedServingGrams,
    fiber: (fiberPercent / 100) * estimatedServingGrams,
  };
};

export function calculateDailyNutrition(plan: { day: string; meals: Recipe[] }[]): DailyNutrition[] {
  return plan.map(({ day, meals }) => {
    const totals = meals.reduce(
      (acc, meal) => {
        const n = extractRecipeNutrition(meal);
        acc.calories += n.calories;
        acc.protein += n.protein;
        acc.fat += n.fat;
        acc.carbs += n.carbs;
        acc.fiber += n.fiber || 0;
        return acc;
      },
      { calories: 0, protein: 0, fat: 0, carbs: 0, fiber: 0 }
    );
    return {
      day,
      calories: Math.round(totals.calories),
      protein: Number(totals.protein.toFixed(1)),
      fat: Number(totals.fat.toFixed(1)),
      carbs: Number(totals.carbs.toFixed(1)),
      fiber: Number(totals.fiber.toFixed(1)),
    };
  });
}

export function getNutritionTargets(species?: string): NutritionTargets {
  const key = (species || '').toLowerCase();
  if (key.includes('cat')) {
    return { proteinRange: [28, 45], fatRange: [9, 20], calories: undefined };
  }
  if (key.includes('bird')) {
    return { proteinRange: [12, 22], fatRange: [4, 12] };
  }
  if (key.includes('reptile')) {
    return { proteinRange: [15, 28], fatRange: [4, 12] };
  }
  if (key.includes('pocket')) {
    return { proteinRange: [12, 20], fatRange: [2, 8], fiberRange: [15, 30] };
  }
  // Default dog
  return { proteinRange: [18, 35], fatRange: [8, 22] };
}
</file>

<file path="lib/portionCalc.ts">
import { PortionPlan, Recipe, Species, PetNutritionProfile } from '@/lib/types';
import { healthConcernCalorieAdjustments } from './modifierRules';

const DEFAULT_CALORIES_PER_KG: Record<Species, number> = {
  dogs: 95,
  cats: 75,
};

const AGE_ADJUSTMENTS: Record<string, number> = {
  baby: +15,
  young: +5,
  adult: 0,
  senior: -10,
};

const clamp = (value: number, min: number, max: number) =>
  Math.min(Math.max(value, min), max);

const UNIT_TO_GRAMS: Record<string, number> = {
  g: 1,
  gram: 1,
  grams: 1,
  kg: 1000,
  mg: 0.001,
  oz: 28.35,
  ounce: 28.35,
  ounces: 28.35,
  lb: 453.59,
  lbs: 453.59,
  cup: 120,
  cups: 120,
  tbsp: 15,
  tablespoon: 15,
  tablespoons: 15,
  tsp: 5,
  teaspoon: 5,
  teaspoons: 5,
  ml: 1,
  liter: 1000,
};

const parseAmountToGrams = (amount: string | undefined): number => {
  if (!amount) return 0;
  const numericMatch = amount.match(/[\d.]+/);
  if (!numericMatch) return 0;
  const quantity = parseFloat(numericMatch[0]);
  const unit = amount
    .replace(numericMatch[0], '')
    .trim()
    .toLowerCase()
    .replace(/[^a-z]/g, '');
  if (!unit) return quantity;
  const conversion = UNIT_TO_GRAMS[unit];
  return conversion ? quantity * conversion : quantity;
};

const parseCalories = (calorieString: string | undefined): number | null => {
  if (!calorieString) return null;
  const numericMatch = calorieString.match(/[\d.]+/);
  if (!numericMatch) return null;
  return parseFloat(numericMatch[0]);
};

export const calculateDailyPortion = (
  weightKg: number,
  caloriesPerKg: number
): number => Math.round(weightKg * caloriesPerKg);

export const getCaloriesPerKg = (
  profile: PetNutritionProfile
): { caloriesPerKg: number; notes: string[] } => {
  if (profile.caloriesPerKgOverride) {
    return {
      caloriesPerKg: profile.caloriesPerKgOverride,
      notes: ['User override applied'],
    };
  }

  const base = DEFAULT_CALORIES_PER_KG[profile.species];
  let caloriesPerKg = base;
  const notes: string[] = [`Base MER ${base} kcal/kg for ${profile.species}`];

  const ageAdj = AGE_ADJUSTMENTS[profile.ageGroup];
  if (typeof ageAdj === 'number' && ageAdj !== 0) {
    caloriesPerKg += ageAdj;
    notes.push(
      `Age adjustment (${profile.ageGroup}): ${
        ageAdj > 0 ? '+' : ''
      }${ageAdj} kcal/kg`
    );
  }

  (profile.healthConcerns || []).forEach((concern) => {
    const adj =
      healthConcernCalorieAdjustments[concern] ??
      healthConcernCalorieAdjustments[concern.replace(/\s+/g, '-').toLowerCase()];
    if (typeof adj === 'number' && adj !== 0) {
      caloriesPerKg += adj;
      notes.push(
        `Health adjustment (${concern}): ${adj > 0 ? '+' : ''}${adj} kcal/kg`
      );
    }
  });

  const clamped = clamp(caloriesPerKg, 55, 140);
  if (clamped !== caloriesPerKg) {
    notes.push('Calorie target clamped to safe bounds (55-140 kcal/kg).');
  }

  return {
    caloriesPerKg: clamped,
    notes,
  };
};

export const getPortionPlan = (
  recipe: Recipe,
  profile: PetNutritionProfile
): PortionPlan => {
  const { caloriesPerKg, notes } = getCaloriesPerKg(profile);
  const dailyCalories = calculateDailyPortion(profile.weightKg, caloriesPerKg);

  const recipeCalories =
    recipe.nutritionalInfo?.calories?.min ||
    recipe.nutritionalInfo?.calories?.max ||
    parseCalories(recipe.nutritionInfo?.calories) ||
    350;

  const baseIngredientWeight = recipe.ingredients.reduce(
    (sum, ingredient) => sum + parseAmountToGrams(ingredient.amount),
    0
  );

  const multiplier = recipeCalories
    ? clamp(dailyCalories / recipeCalories, 0.3, 3)
    : 1;

  const dailyPortionGrams = Math.round(baseIngredientWeight * multiplier);
  const weeklyCalories = dailyCalories * 7;
  const weeklyPortionGrams = dailyPortionGrams * 7;

  return {
    dailyGrams: dailyPortionGrams,
    mealsPerDay: 2, // Default to 2 meals per day
    multiplier,
    caloriesPerKg,
    dailyCalories,
    weeklyCalories,
    dailyPortionGrams,
    weeklyPortionGrams,
    notes,
  };
};

export const scaleAmount = (
  amount: string | undefined,
  multiplier: number
): string | undefined => {
  if (!amount) return amount;
  const numericMatch = amount.match(/[\d.]+/);
  if (!numericMatch) return amount;
  const quantity = parseFloat(numericMatch[0]);
  if (Number.isNaN(quantity)) return amount;
  const scaled = (quantity * multiplier).toFixed(1).replace(/\.0$/, '');
  return amount.replace(numericMatch[0], scaled);
};
</file>

<file path="lib/quoteGenerator.ts">
// lib/quoteGenerator.ts
import type { Recipe } from './types';

/**
 * Deterministic quote generator for recipes.
 * - Always returns the same quote for the same recipe.id
 * - Generates a celebrity-pet author name based on category
 * - Ensures the quote text is unique per recipe by incorporating a
 *   deterministic short adjective/phrase derived from the recipe id/hash.
 *
 * This avoids storing a separate map of 175 entries while guaranteeing
 * each recipe has a permanent, non-reused quote style.
 */

const CELEB_POOLS: Record<string, string[]> = {
  dogs: [
    'Bark Obama','Mutt Damon','Chew-barka','Salvador Dogi','Hairy Styles',
    'Droolius Caesar','Sherlock Bones','Bark Twain','Jimmy Chew','Snoop Doggy Dog'
  ],
  cats: [
    'Catrick Swayze','Leonardo DiCatrio','Meowly Cyrus','Purr-ince','Cat Damon',
    'William Shakespaw','Clawdia Schiffer','Fur-dinand Magellan','Meowrio Andretti','Kitty Purry'
  ],
  birds: [
    'Tweety Mercury','Squawkstin Bieber','Chirp Cobain','Feather Locklear','Beaky Blinders',
    'Wing Crosby','Tweetie Poppins','Beak Affleck','Fluffy Gaga','Plume Hathaway'
  ],
  reptiles: [
    'Scale-y Cyrus','Lizard of Oz','Geck-o Washington','Rango Stallone','Sir Hissington',
    'Gila Clooney','Scaley Cooper','Rex Sauron','Iggy Pop','Cold-Blooded Coleman'
  ],
  'pocket-pets': [
    'Ham Solo','Bun Jovi','Whisker Nelson','Gerbil Gates','Puff Daddy',
    'Fuzz Aldrin','Pipsqueak Jordan','Squeakers O\'Neal','Nibble Newton','Buckminster Fuzz'
  ],
};

// Adjective/phrases to make each quote unique; deterministic selection via recipe id
const TAGS = [
  'a tail-wagging triumph',
  'a purrfect bite',
  'a feather-ruffling delight',
  'a scales-approved staple',
  'a hop-and-nibble favorite',
  'a culinary comfort',
  'an epic chew-fest',
  'a snooze-and-savor meal',
  'a barkworthy banquet',
  'a whisker-twitching wonder',
  'a chirp-causing classic',
  'a slippery-sweet supper',
  'an anxious-belly soother',
  'a crunchy, chewy celebration',
  'a slow-cooked nostalgia'
];

function hashStringToNumber(s: string) {
  // simple deterministic hash to number
  let h = 2166136261 >>> 0;
  for (let i = 0; i < s.length; i++) {
    h = Math.imul(h ^ s.charCodeAt(i), 16777619);
  }
  return Math.abs(h);
}

export function getQuoteForRecipe(recipe: Recipe) {
  const cat = recipe.category ?? 'dogs';
  const pool = CELEB_POOLS[cat] ?? CELEB_POOLS.dogs;
  const idHash = hashStringToNumber(recipe.id || recipe.name || JSON.stringify(recipe)).toString();
  const celebIndex = Number(idHash.slice(-2)) % pool.length;
  const tagIndex = Number(idHash.slice(0, 2)) % TAGS.length;

  const author = pool[celebIndex];
  const tag = TAGS[tagIndex];

  // Build a short, persona-appropriate quote (in the voice of the celeb-pet)
  // We add the recipe name to make the quote unique and clearly tied to this dish.
  const shortRecipeName = recipe.name?.split(':')[0] ?? recipe.name ?? 'this dish';

  // Tone templates per animal type to add variety
  const templates: Record<string, string[]> = {
    dogs: [
      `As I always say, ${shortRecipeName} is ${tag}.`,
      `My fellow canines, try ${shortRecipeName} ‚Äî ${tag}.`,
      `If you enjoy bones, you'll adore ${shortRecipeName}; truly ${tag}.`
    ],
    cats: [
      `I declare ${shortRecipeName} to be absolutely ${tag}.`,
      `In my refined opinion, ${shortRecipeName} is ${tag}.`,
      `Paws down ‚Äî ${shortRecipeName} is ${tag}.`
    ],
    birds: [
      `${shortRecipeName} made me chirp ‚Äî ${tag}.`,
      `Squawk: ${shortRecipeName} equals ${tag}.`,
      `If it makes me preen, it's ${shortRecipeName} ‚Äî truly ${tag}.`
    ],
    reptiles: [
      `${shortRecipeName} is slow-cooked and ${tag}.`,
      `Cold-bloodedly, ${shortRecipeName} is ${tag}.`,
      `Scale-tested: ${shortRecipeName} is ${tag}.`
    ],
    'pocket-pets': [
      `${shortRecipeName} is tiny but ${tag}.`,
      `Nibble-approved: ${shortRecipeName} is ${tag}.`,
      `Small meal, big joy ‚Äî ${shortRecipeName} is ${tag}.`
    ],
  };

  const templatesForCat = templates[cat] ?? templates.dogs;
  const template = templatesForCat[Number(idHash.slice(-1)) % templatesForCat.length];

  const text = template;

  return {
    author,
    text,
  };
}

export default getQuoteForRecipe;
</file>

<file path="lib/recipe-generator-legacy.ts">
/**
 * LEGACY RECIPE GENERATOR - DEPRECATED
 * 
 * This file contains the old recipe generation system.
 * It has been replaced by the refactored system in lib/recipe-generator-v2.ts
 * 
 * DO NOT USE - For reference/archival only
 * 
 * Old files that have been removed:
 * - lib/utils/constraintRecipeGenerator.ts (replaced by lib/generator/RecipeBuilder.ts)
 * - lib/utils/completeRecipeSystem.ts (replaced by lib/generator/nutrition.ts)
 * 
 * Migration: Use lib/recipe-generator-v2.ts instead
 */

// This file is kept for reference only. All functionality has been migrated to the new system.
// See REFACTOR_MIGRATION_GUIDE.md for migration instructions.
</file>

<file path="lib/recipe-generator-v3.ts">
/**
 * PRAGMATIC RECIPE GENERATOR V3
 * Enhanced with health-aware ingredient selection
 * 
 * Flow:
 * 1. RecipeBuilder filters hard constraints (species, allergies, contraindications)
 * 2. RecipeBuilder scores ingredients (health 40%, nutrition 50%, quality 10%)
 * 3. RecipeBuilder selects top ingredients by category
 * 4. RecipeBuilder calculates portions and costs
 */

import type { Pet } from '@/lib/types';
import { RecipeBuilder, type GenerationConstraints, type GeneratedRecipeRaw, type DiversityMode } from '@/lib/generator/RecipeBuilder';
import type { IngredientCategory } from '@/lib/data/ingredients';

/**
 * Normalize ingredient category strings to canonical values.
 * Handles variations like 'fish', 'seafood', 'meat', 'poultry' ‚Üí 'protein'
 */
function canonicalCategory(cat: any): IngredientCategory | 'unknown' {
  const c = String(cat ?? '').toLowerCase().trim();

  // PROTEIN family (fish, meat, poultry, seafood, eggs)
  if (
    c === 'protein' ||
    c.includes('protein') ||
    c.includes('meat') ||
    c.includes('poultry') ||
    c.includes('fish') ||
    c.includes('seafood') ||
    c.includes('egg')
  ) return 'protein';

  // VEGETABLE family
  if (c === 'vegetable' || c.includes('veg')) return 'vegetable';

  // FAT family (oils)
  if (c === 'fat' || c.includes('oil')) return 'fat';

  // CARB family (grains, starches)
  if (c === 'carb' || c.includes('grain') || c.includes('starch')) return 'carb';

  // Keep specialized categories as-is
  if (['seed', 'nut', 'fruit', 'insect', 'hay', 'pellet', 'supplement'].includes(c)) {
    return c as IngredientCategory;
  }

  return 'unknown';
}

export interface GenerateRecipeOptions {
  pet: Pet;
  budgetPerMeal?: number;
  targetCalories?: number;
  diversityMode?: DiversityMode;
  recentIngredients?: string[]; // Track recently used ingredients for variety
}

export interface GeneratedRecipe {
  id: string;
  name: string;
  ingredients: Array<{ name: string; amount: string }>;
  nutrition: {
    protein: number;
    fat: number;
    fiber: number;
    kcal: number;
  };
  scores: {
    health: number;
    nutrition: number;
    cost: number;
    quality: number;
    overall: number;
  };
  debugInfo?: {
    candidateCount: number;
    topScores: Array<{ name: string; score: number; breakdown: any }>;
  };
}

/**
 * Generate a recipe for a pet using enhanced pragmatic approach
 */
export function generateRecipeForPet(options: GenerateRecipeOptions): GeneratedRecipe | null {
  const { pet, budgetPerMeal = 4.0, targetCalories = 500, diversityMode = 'medium', recentIngredients = [] } = options;

  console.log(`\nüîß Generating recipe for ${pet.name}...`);

  try {
    // Build constraints from pet profile
    const constraints: GenerationConstraints = {
      species: pet.type as any,
      lifeStage: 'adult', // TODO: derive from pet.age
      healthConcerns: pet.healthConcerns,
      budgetPerMeal,
      targetCalories,
      allergies: pet.allergies?.map(a => a.toLowerCase()),
      bannedIngredients: pet.bannedIngredients?.map(b => b.toLowerCase()),
      recentIngredients, // Pass to builder for diversity penalties
    };

    // Generate with different quality tiers
    const candidates: GeneratedRecipe[] = [];

    for (let tier = 0; tier < 3; tier++) {
      const tierName = ['premium', 'standard', 'budget'][tier] as 'premium' | 'standard' | 'budget';
      const builder = new RecipeBuilder(constraints, tierName, diversityMode);
      const raw = builder.generate();

      if (!raw) continue;

      // Convert to GeneratedRecipe
      const recipe = assembleRecipe(raw, pet);
      if (recipe) {
        candidates.push(recipe);
      }
    }

    if (candidates.length === 0) {
      console.warn(`Failed to generate any recipes for ${pet.name}`);
      return null;
    }

    // Return highest scoring recipe
    const best = candidates.sort((a, b) => b.scores.overall - a.scores.overall)[0];

    console.log(`‚ú® Generated: ${best.name}`);
    console.log(
      `   Scores: Health=${best.scores.health} Quality=${best.scores.quality} Overall=${best.scores.overall}`
    );

    return best;
  } catch (error) {
    console.error(`Error generating recipe for ${pet.name}:`, error);
    return null;
  }
}

/**
 * Generate multiple recipes for a pet with ingredient tracking for variety
 */
export function generateRecipesForPet(
  options: GenerateRecipeOptions,
  count: number = 3
): GeneratedRecipe[] {
  const recipes: GeneratedRecipe[] = [];
  const recentIngredients: string[] = []; // Track last 10 ingredients used
  const TRACKING_WINDOW = 10; // Remember last 10 ingredients

  for (let i = 0; i < count; i++) {
    try {
      // Pass recent ingredients to enforce variety
      const recipe = generateRecipeForPet({
        ...options,
        recentIngredients: [...recentIngredients], // Pass copy
      });
      
      if (recipe) {
        recipes.push(recipe);
        
        // Track ingredients from this recipe
        recipe.ingredients.forEach(ing => {
          recentIngredients.push(ing.name.toLowerCase());
        });
        
        // Keep only last N ingredients
        if (recentIngredients.length > TRACKING_WINDOW) {
          recentIngredients.splice(0, recentIngredients.length - TRACKING_WINDOW);
        }
        
        if ((i + 1) % 10 === 0) {
          console.log(`Generated ${i + 1}/${count} recipes. Recent ingredients: ${recentIngredients.slice(-5).join(', ')}`);
        }
      }
    } catch (error) {
      console.error(`Failed to generate recipe ${i + 1}:`, error);
    }
  }

  return recipes;
}

/**
 * Assemble GeneratedRecipe from raw builder output
 */
function assembleRecipe(raw: GeneratedRecipeRaw, pet: Pet): GeneratedRecipe | null {
  if (!raw.ingredients || raw.ingredients.length === 0) {
    return null;
  }

  // Calculate nutrition totals
  let totalProtein = 0,
    totalFat = 0,
    totalFiber = 0,
    totalKcal = 0;

  for (const p of raw.ingredients) {
    const comp = p.ingredient.composition;
    const ratio = p.grams / 100;
    totalProtein += (comp.protein || 0) * ratio;
    totalFat += (comp.fat || 0) * ratio;
    totalFiber += (comp.fiber || 0) * ratio;
    totalKcal += (comp.kcal || 100) * ratio;
  }

  // Generate recipe name using canonicalCategory
  const proteinNames = raw.ingredients
    .filter(p => canonicalCategory(p.ingredient.category) === 'protein')
    .map(p => p.ingredient.name);
  const name = proteinNames.length > 0 
    ? `${pet.name}'s ${proteinNames.join(' & ')} Bowl`
    : `${pet.name}'s Custom Bowl`;

  // Calculate average scores from debug info
  let avgHealth = 50,
    avgPalatability = 50,
    avgQuality = 50,
    avgNutrition = 50;

  if (raw.debugInfo?.topScores && raw.debugInfo.topScores.length > 0) {
    const topBreakdowns = raw.debugInfo.topScores.slice(0, raw.ingredients.length);
    avgHealth =
      topBreakdowns.reduce((sum, s) => sum + s.breakdown.health, 0) / topBreakdowns.length;
    avgPalatability =
      topBreakdowns.reduce((sum, s) => sum + s.breakdown.taste, 0) / topBreakdowns.length;
    avgQuality =
      topBreakdowns.reduce((sum, s) => sum + s.breakdown.quality, 0) / topBreakdowns.length;
    avgNutrition =
      topBreakdowns.reduce((sum, s) => sum + s.breakdown.nutrition, 0) / topBreakdowns.length;
  }

  const costScore = raw.estimatedCost < 4.0 ? 90 : raw.estimatedCost < 6.0 ? 70 : 50;
  const overall = Math.round(
    (avgHealth * 0.4 + avgPalatability * 0.3 + avgQuality * 0.2 + avgNutrition * 0.1) * 0.7 +
      costScore * 0.3
  );

  return {
    id: `generated-${Date.now()}`,
    name,
    ingredients: raw.ingredients.map(p => ({
      name: p.ingredient.name,
      amount: `${p.grams}g`,
    })),
    nutrition: {
      protein: Math.round(totalProtein * 10) / 10,
      fat: Math.round(totalFat * 10) / 10,
      fiber: Math.round(totalFiber * 10) / 10,
      kcal: Math.round(totalKcal),
    },
    scores: {
      health: Math.round(avgHealth),
      nutrition: Math.round(avgNutrition),
      cost: costScore,
      quality: Math.round(avgQuality),
      overall,
    },
    debugInfo: raw.debugInfo,
  };
}

export type { GeneratedRecipe };
</file>

<file path="lib/recipe-generator.ts">
/**
 * Scalable Recipe Generation System for Pet Meal-Prep Website
 *
 * Core generation + scoring that is pet-aware, condition-aware, and diversity-aware.
 */

import type { Recipe, Ingredient, RecipeNutritionInfo, Pet } from './types';
import { VETTED_PRODUCTS_RESEARCH, getResearchBackedProduct } from './data/vetted-products-new';
import { scoreRecipeImproved } from './scoreRecipe';
import { HEALTH_BENEFIT_MAP, HEALTH_CONTRAINDICATIONS, normalizeConcernKey } from './data/healthBenefitMap';
import { CONDITION_TEMPLATES, type ConditionTemplate } from './data/conditionTemplates';
import { calculateDiversityPenalty, getRecentIngredients, normalizeIngredientNames } from './utils/diversityTracker';
import { generateMealName } from './utils/mealNameGenerator';
import { getProductByIngredient, getProductPrice, getProductQualityScore, getProductOptions } from './data/product-prices';
import { GoalOrientedGenerator } from './utils/constraintRecipeGenerator';

// ============================================================================
// SCRAPED DATA INTEGRATION (lightweight stubs used by test scripts)
// ============================================================================

export interface ScrapedResearchData {
  ingredients: string[];
  nutritionalInfo: any[];
  healthRecommendations: Array<{
    text: string;
    category: string;
    source: string;
  }>;
  veterinaryInsights: Array<{
    text: string;
    type: string;
    credibility: number;
  }>;
  researchFindings: any[];
  source: string;
  type: string;
  category: string;
  credibility: number;
}

export interface ScrapedInsights {
  commonIngredients: Record<string, number>;
  healthFocusAreas: Record<string, number>;
  ingredientHealthMap: Record<string, string[]>;
}

export function integrateScrapedIngredients(scrapedData: ScrapedResearchData[], category: PetCategory): IngredientTemplate[] {
  const existingIngredients = INGREDIENT_TEMPLATES[category] || [];
  const scrapedIngredients = new Set<string>();
  scrapedData.forEach(data => {
    data.ingredients?.forEach(ing => scrapedIngredients.add(ing.toLowerCase()));
  });

  const newIngredients: IngredientTemplate[] = [];
  scrapedIngredients.forEach(name => {
    const exists = existingIngredients.some(i => i.name.toLowerCase() === name);
    if (!exists) {
      newIngredients.push({
        id: name.replace(/\s+/g, '-'),
        name: name.charAt(0).toUpperCase() + name.slice(1),
        category: 'supplement',
        nutritionalProfile: { protein: 5, fat: 2, fiber: 1, calories: 100 },
        safeFor: [category],
        notes: 'Auto-added from scraped data'
      });
    }
  });
  return [...existingIngredients, ...newIngredients];
}

export function enhanceHealthConcernsWithScrapedData(scrapedData: ScrapedResearchData[]): Record<string, HealthConcern[]> {
  const map: Record<string, HealthConcern[]> = {};
  scrapedData.forEach(data => {
    data.healthRecommendations?.forEach(rec => {
      const text = rec.text.toLowerCase();
      data.ingredients?.forEach(ing => {
        if (text.includes(ing.toLowerCase())) {
          map[ing] = map[ing] || [];
          const c = rec.category as HealthConcern;
          if (!map[ing].includes(c)) map[ing].push(c);
        }
      });
    });
  });
  return map;
}

export function validateRecipeWithScrapedData(
  recipe: GeneratedRecipe,
  scrapedInsights: ScrapedInsights,
  healthInsights: Record<string, HealthConcern[]>,
  category: PetCategory
): { score: number; recommendations: string[] } {
  let score = 5;
  const recs: string[] = [];
  const recipeIngredients = recipe.ingredients.map(i => i.name.toLowerCase());
  const common = Object.keys(scrapedInsights.commonIngredients || {});
  const commonCount = recipeIngredients.filter(ing => common.some(c => ing.includes(c) || c.includes(ing))).length;
  if (commonCount > 0) {
    score += 2;
    recs.push(`Uses ${commonCount} ingredients commonly recommended by veterinarians`);
  }
  const healthMatches = recipe.healthConcerns.filter(c => scrapedInsights.healthFocusAreas?.[c] > 0);
  if (healthMatches.length) {
    score += 2;
    recs.push(`Addresses ${healthMatches.length} research-backed health concerns`);
  }
  recipeIngredients.forEach(ing => {
    const benefits = healthInsights[ing];
    if (benefits?.length) recs.push(`${ing} is associated with: ${benefits.join(', ')}`);
  });
  return { score: Math.min(10, score), recommendations: recs };
}

// ============================================================================
// CORE TYPES
// ============================================================================

export type PetCategory = 'dogs' | 'cats' | 'birds' | 'reptiles' | 'pocket-pets';
export type AgeGroup = 'baby' | 'young' | 'adult' | 'senior';

export type HealthConcern =
  | 'allergy-support'
  | 'joint-health'
  | 'digestive-issues'
  | 'weight-management'
  | 'kidney-disease'
  | 'urinary-health'
  | 'dental-issues'
  | 'heart-disease'
  | 'diabetes'
  | 'respiratory'
  | 'pancreatitis'
  | 'skin-coat'
  | 'senior-support'
  | 'hairball'
  | 'dental-health'
  | 'immune-support';

export type RecipeStyle =
  | 'cooked'
  | 'raw'
  | 'dehydrated'
  | 'freeze-dried'
  | 'kibble-topper'
  | 'treat'
  | 'supplement'
  | 'seed-mix'
  | 'hay-based'
  | 'insect-based';

export interface IngredientTemplate {
  id: string;
  name: string;
  category: 'protein' | 'vegetable' | 'fruit' | 'grain' | 'dairy' | 'supplement' | 'fat' | 'seed' | 'hay' | 'insect';
  nutritionalProfile: {
    protein?: number;
    fat?: number;
    fiber?: number;
    moisture?: number;
    calories?: number;
    calcium?: number;
    phosphorus?: number;
  };
  safeFor: PetCategory[];
  avoidFor?: HealthConcern[];
  asinLink?: string;
  notes?: string;
}

export interface RecipeTemplate {
  id: string;
  name: string;
  category: PetCategory;
  style: RecipeStyle;
  baseIngredients: IngredientTemplate[];
  optionalIngredients: IngredientTemplate[];
  healthBenefits: HealthConcern[];
  ageGroups: AgeGroup[];
  breeds?: string[];
  defaultPrepTime: number;
  defaultCookTime?: number;
  servingSize: { min: number; max: number };
  nutritionalTargets: {
    protein: { min: number; max: number };
    fat: { min: number; max: number };
    fiber: { min: number; max: number };
  };
}

export interface RecipeGenerationOptions {
  template: RecipeTemplate;
  variations?: {
    ingredientSubstitutions?: IngredientTemplate[][];
    portionAdjustments?: number[];
    healthFocus?: HealthConcern[];
  };
  customizations?: {
    name?: string;
    additionalIngredients?: IngredientTemplate[];
    excludedIngredients?: string[];
    prepTimeMultiplier?: number;
  };
  pet?: Pet;
}

export interface GeneratedRecipe extends Omit<Recipe, 'id'> {
  templateId: string;
  generationTimestamp: Date;
  nutritionalCalculation: RecipeNutritionInfo;
  researchValidation?: {
    score: number;
    recommendations: string[];
  };
  ingredientBreakdown: {
    ingredient: Ingredient;
    contribution: {
      protein: number;
      fat: number;
      calories: number;
    };
  }[];
  _unsafeIngredients?: string[];
}

// Minimal curated templates to keep generator functional
export const INGREDIENT_TEMPLATES: Record<PetCategory, IngredientTemplate[]> = {
  dogs: [
    // Proteins (5 options for variety)
    { id: 'ground-chicken', name: 'ground chicken', category: 'protein', nutritionalProfile: { protein: 26, fat: 9 }, safeFor: ['dogs'] },
    { id: 'ground-beef', name: 'ground beef (lean)', category: 'protein', nutritionalProfile: { protein: 26, fat: 15 }, safeFor: ['dogs'] },
    { id: 'ground-turkey', name: 'ground turkey', category: 'protein', nutritionalProfile: { protein: 29, fat: 1 }, safeFor: ['dogs'] },
    { id: 'chicken', name: 'Chicken Breast', category: 'protein', nutritionalProfile: { protein: 31, fat: 3 }, safeFor: ['dogs'] },
    { id: 'salmon', name: 'Salmon', category: 'protein', nutritionalProfile: { protein: 25, fat: 14 }, safeFor: ['dogs'] },
    // Grains (4 options for variety)
    { id: 'brown-rice', name: 'Brown Rice', category: 'grain', nutritionalProfile: { protein: 2.6, fiber: 1.8 }, safeFor: ['dogs'] },
    { id: 'white-rice', name: 'White Rice', category: 'grain', nutritionalProfile: { protein: 2.7, fiber: 0.4 }, safeFor: ['dogs'] },
    { id: 'oats', name: 'Oats', category: 'grain', nutritionalProfile: { protein: 10, fiber: 10 }, safeFor: ['dogs'] },
    { id: 'sweet-potato', name: 'Sweet Potato', category: 'grain', nutritionalProfile: { fiber: 3, calories: 86 }, safeFor: ['dogs'] },
    // Vegetables (5 options for variety)
    { id: 'pumpkin', name: 'Pumpkin', category: 'vegetable', nutritionalProfile: { fiber: 2 }, safeFor: ['dogs'] },
    { id: 'spinach', name: 'Spinach', category: 'vegetable', nutritionalProfile: { protein: 3 }, safeFor: ['dogs'] },
    { id: 'carrots', name: 'Carrots', category: 'vegetable', nutritionalProfile: { fiber: 2.8 }, safeFor: ['dogs'] },
    { id: 'broccoli', name: 'Broccoli', category: 'vegetable', nutritionalProfile: { protein: 3.7, fiber: 2.4 }, safeFor: ['dogs'] },
    { id: 'green-beans', name: 'Green Beans', category: 'vegetable', nutritionalProfile: { fiber: 2.7 }, safeFor: ['dogs'] },
    // Fats (3 options)
    { id: 'fish-oil', name: 'Fish Oil', category: 'fat', nutritionalProfile: { fat: 99 }, safeFor: ['dogs'] },
    { id: 'coconut-oil', name: 'Coconut Oil', category: 'fat', nutritionalProfile: { fat: 99 }, safeFor: ['dogs'] },
    { id: 'olive-oil', name: 'Olive Oil', category: 'fat', nutritionalProfile: { fat: 99 }, safeFor: ['dogs'] },
  ],
  cats: [
    { id: 'chicken', name: 'Chicken Breast', category: 'protein', nutritionalProfile: { protein: 31, fat: 3 }, safeFor: ['cats'] },
    { id: 'salmon', name: 'Salmon', category: 'protein', nutritionalProfile: { protein: 25, fat: 14 }, safeFor: ['cats'] },
    { id: 'pumpkin', name: 'Pumpkin', category: 'vegetable', nutritionalProfile: { fiber: 2 }, safeFor: ['cats'] },
  ],
  birds: [
    { id: 'millet', name: 'Millet', category: 'seed', nutritionalProfile: { protein: 11, fat: 4 }, safeFor: ['birds'] },
    { id: 'sunflower', name: 'Sunflower Seed', category: 'seed', nutritionalProfile: { protein: 21, fat: 49 }, safeFor: ['birds'] },
    { id: 'walnuts', name: 'Walnuts', category: 'supplement', nutritionalProfile: { protein: 15, fat: 65 }, safeFor: ['birds'] }, // For Macaws/Greys
    { id: 'kale', name: 'Kale', category: 'vegetable', nutritionalProfile: { protein: 3 }, safeFor: ['birds'] },
    { id: 'apple', name: 'Apple', category: 'fruit', nutritionalProfile: { fiber: 2.4, calories: 52 }, safeFor: ['birds'] },
  ],
  reptiles: [
    { id: 'cricket', name: 'Crickets', category: 'insect', nutritionalProfile: { protein: 20, fat: 6 }, safeFor: ['reptiles'] },
    { id: 'mealworm', name: 'Mealworms', category: 'insect', nutritionalProfile: { protein: 19, fat: 13 }, safeFor: ['reptiles'] },
    { id: 'mouse', name: 'Frozen Mouse', category: 'protein', nutritionalProfile: { protein: 50, fat: 20 }, safeFor: ['reptiles'] }, // For Snakes
    { id: 'collard', name: 'Collard Greens', category: 'vegetable', nutritionalProfile: { fiber: 4 }, safeFor: ['reptiles'] },
    { id: 'squash', name: 'Butternut Squash', category: 'vegetable', nutritionalProfile: { fiber: 2 }, safeFor: ['reptiles'] },
    { id: 'mango', name: 'Mango', category: 'fruit', nutritionalProfile: { fiber: 1.6, calories: 60 }, safeFor: ['reptiles'] }, // For Geckos
  ],
  'pocket-pets': [
    { id: 'timothy-hay', name: 'Timothy Hay', category: 'hay', nutritionalProfile: { fiber: 30 }, safeFor: ['pocket-pets'] },
    { id: 'pellets', name: 'Fortified Pellets', category: 'grain', nutritionalProfile: { protein: 14 }, safeFor: ['pocket-pets'] },
    { id: 'parsley', name: 'Parsley', category: 'vegetable', nutritionalProfile: { fiber: 3 }, safeFor: ['pocket-pets'] },
    { id: 'apple', name: 'Apple', category: 'fruit', nutritionalProfile: { fiber: 2.4, calories: 52 }, safeFor: ['pocket-pets'] },
    { id: 'mealworm', name: 'Mealworms (Treat)', category: 'insect', nutritionalProfile: { protein: 19, fat: 13 }, safeFor: ['pocket-pets'] }, // For Sugar Gliders/Hamsters
  ],
};

// Simple template set
export const TEMPLATE_LIBRARY: RecipeTemplate[] = [
  {
    id: 'dog-budget',
    name: 'Budget Ground Chicken Mix',
    category: 'dogs',
    style: 'cooked',
    baseIngredients: [
      INGREDIENT_TEMPLATES.dogs[0], // ground chicken (cheap)
      INGREDIENT_TEMPLATES.dogs[7], // white rice (cheap)
      INGREDIENT_TEMPLATES.dogs[9], // spinach (cheap)
    ],
    optionalIngredients: [INGREDIENT_TEMPLATES.dogs[12], INGREDIENT_TEMPLATES.dogs[10]], // coconut oil, carrots
    healthBenefits: ['digestive-issues', 'weight-management'],
    ageGroups: ['adult'],
    defaultPrepTime: 10,
    defaultCookTime: 20,
    servingSize: { min: 180, max: 240 },
    nutritionalTargets: { protein: { min: 20, max: 35 }, fat: { min: 8, max: 18 }, fiber: { min: 2, max: 6 } },
  },
  {
    id: 'dog-balanced',
    name: 'Balanced Ground Beef Mix',
    category: 'dogs',
    style: 'cooked',
    baseIngredients: [
      INGREDIENT_TEMPLATES.dogs[1], // ground beef (cheap)
      INGREDIENT_TEMPLATES.dogs[6], // brown rice
      INGREDIENT_TEMPLATES.dogs[8], // pumpkin
    ],
    optionalIngredients: [INGREDIENT_TEMPLATES.dogs[10], INGREDIENT_TEMPLATES.dogs[12]], // carrots, coconut oil
    healthBenefits: ['digestive-issues', 'weight-management'],
    ageGroups: ['adult'],
    defaultPrepTime: 10,
    defaultCookTime: 20,
    servingSize: { min: 180, max: 240 },
    nutritionalTargets: { protein: { min: 20, max: 35 }, fat: { min: 8, max: 18 }, fiber: { min: 2, max: 6 } },
  },
  {
    id: 'cat-salmon',
    name: 'Omega Salmon Delight',
    category: 'cats',
    style: 'cooked',
    baseIngredients: [INGREDIENT_TEMPLATES.cats[1], INGREDIENT_TEMPLATES.cats[2]],
    optionalIngredients: [INGREDIENT_TEMPLATES.cats[0]],
    healthBenefits: ['skin-coat', 'kidney-disease'],
    ageGroups: ['adult'],
    defaultPrepTime: 8,
    defaultCookTime: 15,
    servingSize: { min: 120, max: 180 },
    nutritionalTargets: { protein: { min: 30, max: 45 }, fat: { min: 10, max: 20 }, fiber: { min: 1, max: 4 } },
  },
  {
    id: 'bird-parrot-mix',
    name: 'Tropical Nut & Veggie Mix',
    category: 'birds',
    style: 'seed-mix',
    baseIngredients: [INGREDIENT_TEMPLATES.birds[1], INGREDIENT_TEMPLATES.birds[2], INGREDIENT_TEMPLATES.birds[3]], // Sunflower, Walnut, Kale
    optionalIngredients: [INGREDIENT_TEMPLATES.birds[4]], // Apple
    healthBenefits: ['skin-coat', 'immune-support'],
    ageGroups: ['adult'],
    defaultPrepTime: 5,
    servingSize: { min: 30, max: 60 },
    nutritionalTargets: { protein: { min: 12, max: 18 }, fat: { min: 15, max: 30 }, fiber: { min: 5, max: 12 } },
  },
  {
    id: 'reptile-carnivore',
    name: 'Whole Prey Feast',
    category: 'reptiles',
    style: 'raw',
    baseIngredients: [INGREDIENT_TEMPLATES.reptiles[2]], // Mouse
    optionalIngredients: [],
    healthBenefits: ['weight-management'],
    ageGroups: ['adult'],
    defaultPrepTime: 2,
    servingSize: { min: 50, max: 150 },
    nutritionalTargets: { protein: { min: 40, max: 60 }, fat: { min: 15, max: 25 }, fiber: { min: 0, max: 2 } },
  },
  {
    id: 'reptile-omnivore',
    name: 'Dragon Salad & Bugs',
    category: 'reptiles',
    style: 'cooked', // Mixed
    baseIngredients: [INGREDIENT_TEMPLATES.reptiles[3], INGREDIENT_TEMPLATES.reptiles[4], INGREDIENT_TEMPLATES.reptiles[0]], // Collard, Squash, Cricket
    optionalIngredients: [INGREDIENT_TEMPLATES.reptiles[5]], // Mango
    healthBenefits: ['digestive-issues'],
    ageGroups: ['adult'],
    defaultPrepTime: 10,
    servingSize: { min: 40, max: 80 },
    nutritionalTargets: { protein: { min: 20, max: 30 }, fat: { min: 4, max: 8 }, fiber: { min: 5, max: 10 } },
  },
  {
    id: 'sugar-glider-fresh',
    name: 'Nectar & Fruit Bowl',
    category: 'pocket-pets',
    style: 'raw',
    baseIngredients: [INGREDIENT_TEMPLATES['pocket-pets'][3], INGREDIENT_TEMPLATES['pocket-pets'][4]], // Apple, Mealworm
    optionalIngredients: [INGREDIENT_TEMPLATES['pocket-pets'][1]], // Pellets
    healthBenefits: ['energy'],
    ageGroups: ['adult'],
    defaultPrepTime: 5,
    servingSize: { min: 20, max: 40 },
    nutritionalTargets: { protein: { min: 15, max: 25 }, fat: { min: 5, max: 10 }, fiber: { min: 2, max: 5 } },
  },
  {
    id: 'pocket-fresh',
    name: 'Greens & Hay Medley',
    category: 'pocket-pets',
    style: 'hay-based',
    baseIngredients: [INGREDIENT_TEMPLATES['pocket-pets'][0], INGREDIENT_TEMPLATES['pocket-pets'][2]],
    optionalIngredients: [INGREDIENT_TEMPLATES['pocket-pets'][1]],
    healthBenefits: ['dental-health', 'digestive-issues'],
    ageGroups: ['adult'],
    defaultPrepTime: 2,
    servingSize: { min: 50, max: 80 },
    nutritionalTargets: { protein: { min: 10, max: 18 }, fat: { min: 2, max: 6 }, fiber: { min: 15, max: 30 } },
  },
];

// ============================================================================
// HELPERS
// ============================================================================

const SYNERGY_MAP: Record<string, string[]> = {
  turmeric: ['black pepper', 'fish oil', 'salmon'],
  'fish oil': ['salmon', 'sardines', 'mackerel'],
  salmon: ['sweet potato', 'pumpkin', 'spinach'],
  'white fish': ['pumpkin', 'sweet potato', 'rice'],
};

function clamp(num: number, min: number, max: number) {
  return Math.min(Math.max(num, min), max);
}

function computeMacroTotals(recipe: GeneratedRecipe) {
  const parseAmount = (amt?: string) => {
    if (!amt) return 0;
    const match = amt.match(/([\d.]+)/);
    return match ? parseFloat(match[1]) : 0;
  };
  const totalWeight = (recipe.ingredients || []).reduce((sum, ing) => sum + parseAmount(ing.amount), 0);
  const protein = recipe.ingredientBreakdown?.reduce((sum, b) => sum + b.contribution.protein, 0) ?? 0;
  const fat = recipe.ingredientBreakdown?.reduce((sum, b) => sum + b.contribution.fat, 0) ?? 0;
  return { totalWeight, protein, fat };
}

function applyNutrientTargets(recipe: GeneratedRecipe, pet?: Pet): number {
  if (!pet) return 0;
  const { protein, fat } = computeMacroTotals(recipe);
  const weight = recipe.ingredients.length ? computeMacroTotals(recipe).totalWeight || 1 : 1;
  const proteinPct = weight ? (protein / weight) * 100 : 0;
  const fatPct = weight ? (fat / weight) * 100 : 0;

  const speciesTargets: Record<string, { protein: [number, number]; fat: [number, number] }> = {
    dog: { protein: [18, 35], fat: [8, 22] },
    cat: { protein: [28, 45], fat: [9, 25] },
    bird: { protein: [12, 22], fat: [4, 12] },
    reptile: { protein: [15, 28], fat: [4, 12] },
    'pocket-pet': { protein: [12, 20], fat: [2, 8] },
  };

  const key = normalizeSpecies(pet.species);
  const t = speciesTargets[key] || speciesTargets.dog;
  let bonus = 0;
  if (proteinPct >= t.protein[0] && proteinPct <= t.protein[1]) bonus += 6;
  else bonus -= 4;
  if (fatPct >= t.fat[0] && fatPct <= t.fat[1]) bonus += 4;
  else bonus -= 3;
  return bonus;
}

function applyConditionTemplateBias(recipe: GeneratedRecipe, pet?: Pet): number {
  if (!pet?.healthConcerns?.length) return 0;
  const template = CONDITION_TEMPLATES.find(t => t.concerns.some(c => pet.healthConcerns?.includes(c)));
  if (!template) return 0;
  const ingNames = recipe.ingredients.map(i => i.name.toLowerCase());
  let delta = 0;
  template.preferredIngredients?.forEach(pref => {
    if (ingNames.includes(pref.toLowerCase())) delta += 3;
  });
  template.avoidedIngredients?.forEach(avoid => {
    if (ingNames.includes(avoid.toLowerCase())) delta -= 5;
  });
  return delta;
}

function applySynergyBonus(recipe: GeneratedRecipe): number {
  const ingNames = recipe.ingredients.map(i => i.name.toLowerCase());
  let bonus = 0;
  Object.entries(SYNERGY_MAP).forEach(([a, partners]) => {
    if (ingNames.includes(a)) {
      partners.forEach(p => {
        if (ingNames.includes(p)) bonus += 2;
      });
    }
  });
  return bonus;
}

/**
 * Apply quality score bonus for using high-quality, research-backed products
 */
function applyQualityBonus(recipe: GeneratedRecipe): number {
  let qualityBonus = 0;
  const avgQualityScore = recipe.ingredients.reduce((sum, ing) => {
    const score = getProductQualityScore(ing.name);
    return sum + score;
  }, 0) / (recipe.ingredients.length || 1);
  
  // Normalize quality score (0-10) to bonus points (0-8)
  // High quality (8+) = +8 bonus, Medium (5-7) = +3 bonus, Low (<5) = 0 bonus
  if (avgQualityScore >= 8) qualityBonus = 8;
  else if (avgQualityScore >= 6) qualityBonus = 4;
  else if (avgQualityScore >= 5) qualityBonus = 2;
  
  return qualityBonus;
}

function normalizeSpecies(species?: string): string {
  const s = (species || '').toLowerCase();
  if (['hamster', 'guinea pig', 'pocket', 'pocket-pet', 'pocket pet'].includes(s)) return 'pocket-pet';
  if (s.includes('cat')) return 'cat';
  if (s.includes('bird')) return 'bird';
  if (s.includes('reptile') || s.includes('dragon') || s.includes('gecko')) return 'reptile';
  return 'dog';
}

function quickPrecheckFails(recipe: GeneratedRecipe, pet?: Pet): string[] {
  if (!pet) return [];
  const allergens = (pet.allergies || []).map(a => a.toLowerCase());
  const ingNames = recipe.ingredients.map(i => i.name.toLowerCase());
  return ingNames.filter(n => allergens.includes(n));
}

export function computeFinalGenerationScore(
  recipe: GeneratedRecipe, 
  pet?: Pet, 
  recentIngredients?: string[]
): { score: number; explain: string[]; estimatedCostPerMeal?: number } {
  const explain: string[] = [];
  
  // Base compatibility score from improved system (0-100)
  // Convert GeneratedRecipe to Recipe format for scoring (add temporary id if missing)
  const recipeForScoring: Recipe = {
    ...recipe,
    id: recipe.templateId || 'generated-recipe',
  } as unknown as Recipe;
  
  const improvedScore = pet 
    ? (scoreRecipeImproved(recipeForScoring, pet).compatibilityScore || scoreRecipeImproved(recipeForScoring, pet).matchScore)
    : 60; // Default if no pet
  
  // Generator-specific modifiers (normalized to small adjustments)
  const synergyBonus = applySynergyBonus(recipe);
  const qualityBonus = applyQualityBonus(recipe);
  const conditionBias = applyConditionTemplateBias(recipe, pet);
  const nutrientAdjustment = applyNutrientTargets(recipe, pet);
  const diversityPenalty = calculateDiversityPenalty(
    normalizeIngredientNames(recipe.ingredients.map(i => i.name.toLowerCase())),
    recentIngredients || []
  );
  
  // NEW: Cost optimization bonus/penalty (matched to commercial pet food pricing)
  const estimatedCost = estimateRecipeCost(recipe.ingredients);
  const MAX_TARGET_COST = 4.00; // Allow up to $4/meal for better ingredient variety and quality
  let costAdjustment = 0;
  
  if (estimatedCost <= MAX_TARGET_COST) {
    // Bonus for being under budget
    const costSavings = MAX_TARGET_COST - estimatedCost;
    costAdjustment = Math.min(10, costSavings * 2); // Up to +10 bonus
    explain.push(`‚úì Cost-competitive: $${estimatedCost.toFixed(2)}/meal (target: $${MAX_TARGET_COST})`);
  } else {
    // Penalty for exceeding budget
    const costOverage = estimatedCost - MAX_TARGET_COST;
    costAdjustment = -Math.min(15, costOverage * 1.5); // Up to -15 penalty
    explain.push(`‚ö†Ô∏è Cost premium: $${estimatedCost.toFixed(2)}/meal (target: $${MAX_TARGET_COST})`);
  }
  
  // Normalize legacy modifiers to ¬±10 range so they don't dominate
  const normalizedSynergy = clamp(synergyBonus * 0.5, 0, 5); // Max +5
  const normalizedQuality = clamp(qualityBonus * 0.5, 0, 5); // Max +5 for quality
  const normalizedCondition = clamp(conditionBias * 0.3, -5, 5); // ¬±5 max
  const normalizedNutrient = clamp(nutrientAdjustment * 0.5, -5, 5); // ¬±5 max
  const normalizedDiversity = clamp(diversityPenalty.penalty, 0, 10); // Max -10
  
  // Combine: improved score (base) + small generator adjustments + quality + cost optimization
  let finalScore = improvedScore 
    + normalizedSynergy 
    + normalizedQuality
    + normalizedCondition 
    + normalizedNutrient 
    + costAdjustment
    - normalizedDiversity;
  
  // Safety floor: if improved score is high but we have diversity issues, don't tank completely
  if (improvedScore >= 80 && normalizedDiversity > 0) {
    finalScore = Math.max(finalScore, improvedScore - 8); // Cap diversity penalty
  }
  
  // Explain array for debugging
  if (normalizedSynergy > 0) explain.push(`Synergy bonus: +${normalizedSynergy.toFixed(1)}`);
  if (normalizedCondition !== 0) explain.push(`Condition bias: ${normalizedCondition > 0 ? '+' : ''}${normalizedCondition.toFixed(1)}`);
  if (normalizedNutrient !== 0) explain.push(`Nutrient adjustment: ${normalizedNutrient > 0 ? '+' : ''}${normalizedNutrient.toFixed(1)}`);
  if (normalizedDiversity > 0) explain.push(`Diversity overlap: -${normalizedDiversity.toFixed(1)}`);
  
  return { 
    score: clamp(finalScore, 0, 100), 
    explain,
    estimatedCostPerMeal: estimatedCost
  };
}

// ============================================================================
// GENERATION
// ============================================================================

/**
 * Calculate estimated cost per meal for a recipe
 * Uses product-prices.json data when available
 * Converts amount to grams and calculates proportional cost
 */
function estimateRecipeCost(ingredients: Array<{ name: string; amount: string }>): number {
  let totalCost = 0;
  
  for (const ing of ingredients) {
    const pricePerPound = getProductPrice(ing.name.toLowerCase());
    if (typeof pricePerPound === 'number' && pricePerPound > 0) {
      // Parse amount to grams
      let grams = 0;
      const amountStr = ing.amount.toLowerCase();
      
      // Try to extract numeric value and unit
      const match = amountStr.match(/(\d+(?:\.\d+)?)\s*([a-z]+)?/);
      if (match) {
        const value = parseFloat(match[1]);
        const unit = match[2] || 'g';
        
        // Convert to grams
        if (unit === 'g' || unit === 'gram' || unit === 'grams') grams = value;
        else if (unit === 'kg' || unit === 'kilogram') grams = value * 1000;
        else if (unit === 'lb' || unit === 'lbs' || unit === 'pound') grams = value * 453.592;
        else if (unit === 'oz' || unit === 'ounce') grams = value * 28.3495;
        else grams = value; // Default to grams
      }
      
      // Calculate cost: (grams / grams_per_pound) * price_per_pound
      if (grams > 0) {
        const cost = (grams / 453.592) * pricePerPound;
        totalCost += cost;
      }
    }
  }
  
  return totalCost;
}

/**
 * Pick ingredients with cost optimization
 * Prefers cheaper options when multiple ingredients can serve the same role
 */
function pickIngredients(template: RecipeTemplate, pet?: Pet, excluded: string[] = [], optimizeForCost: boolean = true) {
  const safeList = [...template.baseIngredients, ...template.optionalIngredients].filter(
    ing => ing.safeFor.includes(template.category) && !excluded.includes(ing.id) && !excluded.includes(ing.name)
  );
  const chosen: IngredientTemplate[] = [];
  
  // Always include base ingredients (required for nutrition)
  template.baseIngredients.forEach(ing => {
    if (!excluded.includes(ing.id)) chosen.push(ing);
  });
  
  // Add optional ingredients, preferring cheaper ones if optimizing for cost
  if (safeList.length > chosen.length && optimizeForCost) {
    const optionals = safeList.filter(i => !chosen.includes(i) && template.optionalIngredients.includes(i));
    
    if (optionals.length > 0) {
      // Sort by price (cheapest first)
      const optionalsWithPrice = optionals.map(opt => ({
        ingredient: opt,
        price: getProductPrice(opt.name.toLowerCase()) || 999, // High default for missing prices
      })).sort((a, b) => a.price - b.price);
      
      // Pick the cheapest optional
      if (optionalsWithPrice[0]) {
        chosen.push(optionalsWithPrice[0].ingredient);
      }
    }
  } else if (safeList.length > chosen.length) {
    // Original behavior: just add first available optional
    const optional = safeList.find(i => !chosen.includes(i));
    if (optional) chosen.push(optional);
  }

  return chosen.map(ing => ({
    id: ing.id,
    name: ing.name,
    amount: ing.category === 'protein' ? '120g' : ing.category === 'fat' ? '5g' : '60g',
    amazonLink: getResearchBackedProduct ? getResearchBackedProduct(ing.id)?.amazonLink : undefined,
  }));
}

export function generateRecipe(options: RecipeGenerationOptions): GeneratedRecipe {
  const { template, customizations, pet } = options;
  const excluded = customizations?.excludedIngredients || [];
  const ingredients = pickIngredients(template, pet, excluded);

  const ingredientBreakdown = ingredients.map((ing) => ({
    ingredient: ing as unknown as Ingredient,
    contribution: {
      protein: ing.name.toLowerCase().includes('chicken') || ing.name.toLowerCase().includes('salmon') ? 20 : 2,
      fat: ing.name.toLowerCase().includes('oil') || ing.name.toLowerCase().includes('salmon') ? 8 : 1,
      calories: 50,
    },
  }));

  // Generate recipe name using enhanced naming system
  const ingredientKeys = ingredients.map(ing => ing.name || ing.id);
  const totalCalories = ingredientBreakdown.reduce((s, b) => s + b.contribution.calories, 0);
  const totalProtein = ingredientBreakdown.reduce((s, b) => s + b.contribution.protein, 0);
  const totalFat = ingredientBreakdown.reduce((s, b) => s + b.contribution.fat, 0);
  
  const nutritionalProfile = totalCalories > 0 ? {
    protein: (totalProtein / totalCalories) * 100,
    fat: (totalFat / totalCalories) * 100,
  } : undefined;
  
  const recipeForNaming: Recipe = {
    id: `generated-${template.id}-${Date.now()}`,
    name: template.name,
    category: template.category,
    ingredients: ingredients.map(ing => ({ id: ing.id, name: ing.name, amount: ing.amount })),
    instructions: ['Combine ingredients', 'Cook as needed', 'Cool and serve'],
    healthConcerns: [...template.healthBenefits, ...(pet?.healthConcerns || [])],
    ageGroup: template.ageGroups,
  };
  
  const nameResult = customizations?.name 
    ? { fullName: customizations.name, shortName: customizations.name }
    : generateMealName(ingredientKeys, {
        petName: pet?.name || undefined,
        petBreed: pet?.breed || undefined,
        petSpecies: pet?.type || undefined,
        healthConcerns: recipeForNaming.healthConcerns,
        nutritionalProfile,
        mealType: 'complete',
        recipeId: recipeForNaming.id,
        recipe: recipeForNaming,
        isCustomMeal: false,
      });

  const recipe: GeneratedRecipe = {
    templateId: template.id,
    generationTimestamp: new Date(),
    name: nameResult.fullName,
    description: `${nameResult.fullName} tailored for ${pet?.name || 'your pet'}`,
    category: template.category,
    healthConcerns: [...template.healthBenefits, ...(pet?.healthConcerns || [])],
    ageGroup: template.ageGroups,
    ingredients,
    instructions: ['Combine ingredients', 'Cook as needed', 'Cool and serve'],
    prepTime: `${template.defaultPrepTime} min`,
    cookTime: template.defaultCookTime ? `${template.defaultCookTime} min` : 'No cook',
    servings: 1,
    tags: template.healthBenefits,
    imageUrl: `/images/generated/${template.category}-${template.id}.png`,
    nutritionalCalculation: {
      calories: totalCalories,
      protein: totalProtein,
      fat: totalFat,
      carbs: 0,
      fiber: 0,
      moisture: 0,
    },
    ingredientBreakdown,
  };

  const recent = pet?.id ? getRecentIngredients(pet.id, 7) : [];
  const { score } = computeFinalGenerationScore(recipe, pet, recent);
  recipe.score = score;
  recipe._unsafeIngredients = quickPrecheckFails(recipe, pet);

  return recipe;
}

/**
 * Generate a recipe dynamically based on pet profile
 * Ignores templates - builds recipe from scratch based on pet needs
 */
export function generateBestRecipeForPet(templates: RecipeTemplate[] = TEMPLATE_LIBRARY, pet?: Pet, seed?: number) {
  if (!pet) {
    // Fallback to template-based if no pet provided
    const template = templates[seed ? seed % templates.length : 0];
    return generateRecipe({ template, pet });
  }

  // Build recipe from scratch based on pet profile
  const recipe = generateDynamicRecipe(pet, seed);
  const recent = pet.id ? getRecentIngredients(pet.id, 7) : [];
  const { score } = computeFinalGenerationScore(recipe, pet, recent);
  recipe.score = score;
  return recipe;
}

/**
 * Generate a recipe dynamically based on pet's specific needs
 * Uses constraint-based generation with AAFCO standards and quality scoring
 */
function generateDynamicRecipe(pet: Pet, seed?: number): GeneratedRecipe {
  try {
    const petType = pet.type || 'dogs';
    const lifeStage = 'adult';
    const healthConcerns = pet.healthConcerns || [];
    const targetCalories = 500;
    const budgetPerMeal = 4.00;
    
    console.log(`Generating recipe for ${pet.name} (${petType}), budget=$${budgetPerMeal}`);
    
    const generator = new GoalOrientedGenerator(
      petType,
      lifeStage,
      healthConcerns,
      targetCalories,
      budgetPerMeal
    );
    
    const result = generator.generate();
    
    if (!result) {
      console.warn(`Constraint generator failed for ${pet.name}, using fallback`);
      return createFallbackRecipe(pet, seed);
    }
    
    const ingredients: Ingredient[] = result.ingredients.map(ing => ({
      id: ing.name.replace(/\s+/g, '-').toLowerCase(),
      name: ing.name,
      amount: `${ing.amount}g`,
    }));
    
    const recipe: GeneratedRecipe = {
      templateId: 'constraint-generated',
      generationTimestamp: new Date(),
      name: `${pet.name}'s Balanced Meal`,
      description: result.description,
      category: petType as PetCategory,
      healthConcerns: healthConcerns,
      ageGroup: ['adult'],
      ingredients,
      instructions: result.instructions,
      prepTime: '10 min',
      cookTime: '15 min',
      servings: 1,
      tags: healthConcerns,
      imageUrl: `/images/generated/${petType}-meal.png`,
      nutritionalCalculation: {
        calories: result.nutritionalInfo.totalCalories,
        protein: result.nutritionalInfo.protein,
        fat: result.nutritionalInfo.fat,
        carbs: result.nutritionalInfo.carbs,
        fiber: result.nutritionalInfo.fiber,
        moisture: 0,
      },
      ingredientBreakdown: ingredients.map(ing => ({
        ingredient: ing,
        contribution: {
          protein: 0,
          fat: 0,
          calories: 0,
        },
      })),
    };
    
    const recent = pet.id ? getRecentIngredients(pet.id, 7) : [];
    const { score } = computeFinalGenerationScore(recipe, pet, recent);
    recipe.score = score;
    recipe._unsafeIngredients = quickPrecheckFails(recipe, pet);
    
    console.log(`Generated recipe: ${recipe.name} with score ${score.toFixed(1)}`);
    
    return recipe;
  } catch (error) {
    console.error(`Error generating dynamic recipe for ${pet.name}:`, error);
    return createFallbackRecipe(pet, seed);
  }
}

/**
 * Infer ingredient category from ID and composition data
 */
function inferCategory(id: string, composition?: any): string {
  const lower = id.toLowerCase();
  
  // Check composition data first for more accurate categorization
  if (composition) {
    // High protein = protein source
    if (composition.protein && composition.protein > 15) return 'protein';
    // High fat, low protein = fat/oil
    if (composition.fat && composition.fat > 50) return 'fat';
    // Fiber-rich = vegetable/hay
    if (composition.fiber && composition.fiber > 5) return composition.fiber > 15 ? 'hay' : 'vegetable';
  }
  
  // Fallback to ID-based categorization
  if (lower.includes('protein') || lower.includes('meat') || lower.includes('fish') || lower.includes('chicken') || lower.includes('beef') || lower.includes('turkey') || lower.includes('lamb') || lower.includes('mouse') || lower.includes('rat') || lower.includes('chick') || lower.includes('liver') || lower.includes('heart') || lower.includes('kidney')) return 'protein';
  if (lower.includes('rice') || lower.includes('grain') || lower.includes('oat') || lower.includes('barley') || lower.includes('millet') || lower.includes('quinoa') || lower.includes('pasta') || lower.includes('bread')) return 'grain';
  if (lower.includes('vegetable') || lower.includes('carrot') || lower.includes('spinach') || lower.includes('broccoli') || lower.includes('pumpkin') || lower.includes('sweet_potato') || lower.includes('squash') || lower.includes('greens') || lower.includes('lettuce') || lower.includes('kale') || lower.includes('celery') || lower.includes('zucchini')) return 'vegetable';
  if (lower.includes('fruit') || lower.includes('apple') || lower.includes('berry') || lower.includes('banana') || lower.includes('papaya') || lower.includes('mango') || lower.includes('blueberry')) return 'fruit';
  if (lower.includes('oil') || lower.includes('fat') || lower.includes('coconut') || lower.includes('salmon_oil') || lower.includes('fish_oil')) return 'fat';
  if (lower.includes('seed') || lower.includes('nut') || lower.includes('flax') || lower.includes('hemp') || lower.includes('chia') || lower.includes('sunflower')) return 'seed';
  if (lower.includes('hay') || lower.includes('timothy') || lower.includes('alfalfa')) return 'hay';
  if (lower.includes('insect') || lower.includes('cricket') || lower.includes('mealworm') || lower.includes('roach') || lower.includes('dubia')) return 'insect';
  return 'other';
}

/**
 * Build a nutritionally sound recipe using comprehensive ingredient data
 * REFACTORED: Constraint-first approach (health + cost drive selection, not scoring)
 */
function buildNutritionallySoundRecipe(ingredients: any[], pet: Pet, seed: number): GeneratedRecipe {
  const petType = pet.type as string;
  const isCarnivore = petType === 'cats' || petType === 'birds' || petType === 'reptiles';
  
  // STEP 1: CONSTRAINT FILTER - Remove ingredients that violate hard rules
  let constrainedIngredients = ingredients;
  
  // Filter out health contraindications (hard exclusions, not soft penalties)
  if (pet.healthConcerns && pet.healthConcerns.length > 0) {
    constrainedIngredients = constrainedIngredients.filter(ing => {
      // Exclude ingredients that are contraindicated for this health concern
      // (This would use HEALTH_CONTRAINDICATIONS if available)
      return true; // Placeholder - would check contraindications
    });
  }
  
  console.log(`After constraint filter: ${constrainedIngredients.length} ingredients remain`);
  
  // STEP 2: CATEGORIZE INTO FUNCTIONAL POOLS (not just ingredient type)
  const pools = {
    primaryProtein: constrainedIngredients.filter(i => 
      i.category === 'protein' && (i.composition.protein || 0) > 20
    ),
    secondaryProtein: constrainedIngredients.filter(i => 
      i.category === 'protein' && (i.composition.protein || 0) > 10 && (i.composition.protein || 0) <= 20
    ),
    carb: constrainedIngredients.filter(i => i.category === 'grain'),
    fiberVeg: constrainedIngredients.filter(i => i.category === 'vegetable'),
    fat: constrainedIngredients.filter(i => i.category === 'fat'),
    fruit: constrainedIngredients.filter(i => i.category === 'fruit'),
    seed: constrainedIngredients.filter(i => i.category === 'seed'),
    insect: constrainedIngredients.filter(i => i.category === 'insect'),
    hay: constrainedIngredients.filter(i => i.category === 'hay'),
  };
  
  // STEP 3: INGREDIENT OPTIMIZER - Score each ingredient by fitness (not final score)
  const ingredientFitness = (ing: any): number => {
    let fitness = 0;
    
    // Species safety (0-1)
    const speciesSafety = ing.composition.speciesCompatibility?.[petType === 'pocket-pets' ? 'pocket-pet' : petType];
    if (speciesSafety === 'ok') fitness += 1.0;
    else if (speciesSafety === 'limit') fitness += 0.5;
    else if (speciesSafety === 'caution') fitness += 0.2;
    
    // Health alignment (0-2)
    if (pet.healthConcerns && pet.healthConcerns.length > 0) {
      // Bonus for ingredients that support health concerns
      if (ing.composition.protein && pet.healthConcerns.includes('muscle-loss')) fitness += 0.5;
      if (ing.composition.omega3 && pet.healthConcerns.includes('joint-health')) fitness += 0.5;
      if (ing.composition.fiber && pet.healthConcerns.includes('digestion')) fitness += 0.5;
    }
    
    // Cost penalty (0-2, lower is better)
    const price = getProductPrice(ing.name);
    if (price !== null) {
      if (price < 2) fitness += 1.5;
      else if (price < 5) fitness += 1.0;
      else if (price < 10) fitness += 0.5;
      else fitness -= 1.0;
    }
    
    // Overuse penalty (0-1)
    const recentIngredients = getRecentIngredients(ing.id) || [];
    if (Array.isArray(recentIngredients) && recentIngredients.length > 3) fitness -= 0.5;
    
    return fitness;
  };
  
  // STEP 4: SELECT TOP INGREDIENTS FROM EACH POOL
  const selectTopFromPool = (pool: any[], count: number = 1): any[] => {
    return pool
      .map(ing => ({ ing, fitness: ingredientFitness(ing) }))
      .sort((a, b) => b.fitness - a.fitness)
      .slice(0, count)
      .map(x => x.ing);
  };
  
  const selected: any[] = [];
  
  // MANDATORY: Primary protein for carnivores/omnivores only
  // Herbivores (rabbits, guinea pigs, some reptiles) should NOT get meat
  const isHerbivore = petType === 'pocket-pets' && (pet.breed?.toLowerCase().includes('rabbit') || pet.breed?.toLowerCase().includes('guinea'));
  const isOmnivore = !isCarnivore && !isHerbivore;
  
  if (isCarnivore || isOmnivore) {
    const selectedProtein = selectTopFromPool(pools.primaryProtein, 1);
    if (selectedProtein.length > 0) {
      selected.push(selectedProtein[0]);
    } else if (pools.secondaryProtein.length > 0) {
      const secondary = selectTopFromPool(pools.secondaryProtein, 1);
      if (secondary.length > 0) selected.push(secondary[0]);
    } else if (isCarnivore) {
      console.warn(`No suitable protein found for carnivorous pet ${pet.name}`);
    }
    
    // OPTIONAL: Secondary protein (variety)
    if (seed % 2 === 0 && pools.secondaryProtein.length > 0) {
      const secondary = selectTopFromPool(pools.secondaryProtein, 1);
      if (secondary.length > 0 && secondary[0].id !== selected[0]?.id) {
        selected.push(secondary[0]);
      }
    }
  }
  
  // CARB: Choose based on health concerns
  if (pools.carb.length > 0) {
    const carbs = selectTopFromPool(pools.carb, 1);
    if (carbs.length > 0) selected.push(carbs[0]);
  }
  
  // FIBER/VEG: Always include for herbivores, optional for carnivores
  if (pools.fiberVeg.length > 0) {
    const isHerbivore = petType === 'pocket-pets' || petType === 'reptiles';
    if (isHerbivore || seed % 2 === 0) {
      const veg = selectTopFromPool(pools.fiberVeg, 1);
      if (veg.length > 0) selected.push(veg[0]);
    }
  }
  
  // FAT: Include for omega-3 and energy
  if (pools.fat.length > 0 && seed % 3 !== 0) {
    const fat = selectTopFromPool(pools.fat, 1);
    if (fat.length > 0) selected.push(fat[0]);
  }
  
  // FRUIT: Optional, low priority
  if (pools.fruit.length > 0 && seed % 4 === 0) {
    const fruit = selectTopFromPool(pools.fruit, 1);
    if (fruit.length > 0) selected.push(fruit[0]);
  }
  
  // Calculate portions to meet nutritional targets
  const weightKg = pet.weightKg || parseFloat(pet.weight || '10');
  const portionedIngredients = selected.map((ing) => {
    let amount = 100; // grams
    
    if (ing.category === 'protein') {
      amount = Math.round(weightKg * 8);
    } else if (ing.category === 'grain') {
      amount = Math.round(weightKg * 6);
    } else if (ing.category === 'vegetable') {
      amount = Math.round(weightKg * 3);
    } else if (ing.category === 'fruit') {
      amount = Math.round(weightKg * 2);
    } else if (ing.category === 'fat') {
      amount = Math.round(weightKg * 0.5);
    } else if (ing.category === 'seed') {
      amount = Math.round(weightKg * 1);
    } else if (ing.category === 'insect') {
      amount = Math.round(weightKg * 4);
    } else if (ing.category === 'hay') {
      amount = Math.round(weightKg * 5);
    }
    
    return { ingredient: ing, amount };
  });
  
  // Build recipe
  const recipeIngredients = portionedIngredients.map(p => ({
    id: p.ingredient.id,
    name: p.ingredient.name,
    amount: `${p.amount}g`,
  }));
  
  const ingredientNames = recipeIngredients.map(i => i.name).join(' & ');
  const recipeName = `${pet.name || 'Pet'}'s ${ingredientNames}`;
  
  // Calculate nutrition from composition data
  let totalProtein = 0;
  let totalFat = 0;
  let totalCalories = 0;
  let totalFiber = 0;
  
  for (const p of portionedIngredients) {
    const comp = p.ingredient.composition;
    const grams = p.amount;
    
    totalProtein += ((comp.protein || 0) * grams) / 100;
    totalFat += ((comp.fat || 0) * grams) / 100;
    totalCalories += ((comp.kcal || 50) * grams) / 100;
    totalFiber += ((comp.fiber || 0) * grams) / 100;
  }
  
  const ingredientBreakdown = portionedIngredients.map(p => ({
    ingredient: p.ingredient as unknown as Ingredient,
    contribution: {
      protein: ((p.ingredient.composition.protein || 0) * p.amount) / 100,
      fat: ((p.ingredient.composition.fat || 0) * p.amount) / 100,
      calories: ((p.ingredient.composition.kcal || 50) * p.amount) / 100,
    },
  }));
  
  return {
    templateId: 'dynamic',
    generationTimestamp: new Date(),
    name: recipeName,
    description: `Nutritionally balanced recipe for ${pet.name} using ${recipeIngredients.length} ingredients`,
    category: pet.type as PetCategory,
    healthConcerns: pet.healthConcerns || [],
    ageGroup: [pet.age || 'adult'],
    ingredients: recipeIngredients,
    instructions: [
      'Combine all ingredients',
      'Cook protein thoroughly if needed',
      'Mix with other ingredients',
      'Cool to room temperature before serving',
    ],
    prepTime: '10 min',
    cookTime: '20 min',
    servings: 1,
    tags: pet.healthConcerns || [],
    imageUrl: `/images/generated/${pet.type}-custom.png`,
    nutritionalCalculation: {
      calories: totalCalories,
      protein: totalProtein,
      fat: totalFat,
      fiber: totalFiber,
    },
    ingredientBreakdown,
  } as any;
}

/**
 * Infer ingredient category from ID or composition
 */
function getIngredientCategory(id: string, comp: any): string {
  if (comp.category) return comp.category;
  if (id.includes('protein') || id.includes('meat') || id.includes('fish') || id.includes('chicken') || id.includes('beef')) return 'protein';
  if (id.includes('rice') || id.includes('grain') || id.includes('oat') || id.includes('barley')) return 'grain';
  if (id.includes('vegetable') || id.includes('carrot') || id.includes('spinach') || id.includes('broccoli')) return 'vegetable';
  if (id.includes('fruit') || id.includes('apple') || id.includes('berry')) return 'fruit';
  if (id.includes('oil') || id.includes('fat')) return 'fat';
  return 'other';
}

/**
 * Prioritize ingredients based on health concerns
 */
function prioritizeIngredientsForHealth(ingredients: any[], pet: Pet): any[] {
  const concerns = pet.healthConcerns || [];
  if (concerns.length === 0) return ingredients;
  
  // Score each ingredient based on health benefits
  return ingredients.sort((a, b) => {
    const aScore = scoreIngredientForHealth(a, concerns);
    const bScore = scoreIngredientForHealth(b, concerns);
    return bScore - aScore;
  });
}

/**
 * Score ingredient for health benefits
 */
function scoreIngredientForHealth(ingredient: any, concerns: string[]): number {
  let score = 0;
  const comp = ingredient.composition;
  
  for (const concern of concerns) {
    if (concern.includes('digestive') && (comp.fiber || 0) > 2) score += 2;
    if (concern.includes('joint') && (comp.omega3 || 0) > 0.5) score += 2;
    if (concern.includes('weight') && (comp.protein || 0) > 20) score += 2;
    if (concern.includes('skin') && (comp.omega3 || 0) > 0.5) score += 2;
    if (concern.includes('allergy') && ingredient.category === 'protein') score += 1;
  }
  
  return score;
}

/**
 * Select diverse ingredients from the full pool
 */
function selectDiverseIngredientsFromPool(ingredients: any[], seed?: number): any[] {
  const categories = {
    protein: ingredients.filter(i => i.category === 'protein'),
    grain: ingredients.filter(i => i.category === 'grain'),
    vegetable: ingredients.filter(i => i.category === 'vegetable'),
    fruit: ingredients.filter(i => i.category === 'fruit'),
    fat: ingredients.filter(i => i.category === 'fat'),
  };
  
  const selected: any[] = [];
  const s = seed || 0;
  
  // Pick one from each category, cycling through all available
  if (categories.protein.length > 0) {
    selected.push(categories.protein[s % categories.protein.length]);
  }
  if (categories.grain.length > 0) {
    selected.push(categories.grain[(s + 1) % categories.grain.length]);
  }
  if (categories.vegetable.length > 0) {
    selected.push(categories.vegetable[(s + 2) % categories.vegetable.length]);
  }
  if (categories.fruit.length > 0 && s % 3 !== 0) {
    selected.push(categories.fruit[(s + 3) % categories.fruit.length]);
  }
  if (categories.fat.length > 0 && s % 2 === 0) {
    selected.push(categories.fat[(s + 4) % categories.fat.length]);
  }
  
  return selected;
}

/**
 * Calculate portions based on composition data
 */
function calculatePortionsFromComposition(ingredients: any[], pet: Pet): any[] {
  const weightKg = pet.weightKg || parseFloat(pet.weight || '10');
  
  return ingredients.map(ing => {
    let amount = '100g';
    const comp = ing.composition;
    
    if (ing.category === 'protein') {
      amount = `${Math.round(weightKg * 8)}g`;
    } else if (ing.category === 'grain') {
      amount = `${Math.round(weightKg * 6)}g`;
    } else if (ing.category === 'vegetable') {
      amount = `${Math.round(weightKg * 3)}g`;
    } else if (ing.category === 'fruit') {
      amount = `${Math.round(weightKg * 2)}g`;
    } else if (ing.category === 'fat') {
      amount = `${Math.round(weightKg * 0.5)}g`;
    }
    
    return { ingredient: ing, amount };
  });
}

/**
 * Build recipe from composition data
 */
function buildRecipeFromCompositions(portionedIngredients: any[], pet: Pet, seed?: number): GeneratedRecipe {
  const ingredients = portionedIngredients.map(p => ({
    id: p.ingredient.id,
    name: p.ingredient.name,
    amount: p.amount,
  }));
  
  const ingredientBreakdown = portionedIngredients.map(p => {
    const comp = p.ingredient.composition;
    const grams = parseFloat(p.amount);
    return {
      ingredient: p.ingredient as unknown as Ingredient,
      contribution: {
        protein: ((comp.protein || 0) * grams) / 100,
        fat: ((comp.fat || 0) * grams) / 100,
        calories: ((comp.kcal || 50) * grams) / 100,
      },
    };
  });
  
  const totalProtein = ingredientBreakdown.reduce((s, b) => s + b.contribution.protein, 0);
  const totalFat = ingredientBreakdown.reduce((s, b) => s + b.contribution.fat, 0);
  const totalCalories = ingredientBreakdown.reduce((s, b) => s + b.contribution.calories, 0);
  
  const ingredientNames = ingredients.map(i => i.name).join(' & ');
  const recipeName = `${pet.name || 'Pet'}'s ${ingredientNames}`;
  
  return {
    templateId: 'dynamic',
    generationTimestamp: new Date(),
    id: `generated-${Date.now()}-${seed || Math.random()}`,
    name: recipeName,
    description: `Customized recipe for ${pet.name} using real ingredient data`,
    category: pet.type as PetCategory,
    healthConcerns: pet.healthConcerns || [],
    ageGroup: [pet.age || 'adult'],
    ingredients,
    instructions: [
      'Combine all ingredients',
      'Cook protein thoroughly if needed',
      'Mix with other ingredients',
      'Cool to room temperature before serving',
    ],
    prepTime: '10 min',
    cookTime: '20 min',
    servings: 1,
    tags: pet.healthConcerns || [],
    imageUrl: `/images/generated/${pet.type}-custom.png`,
    nutritionalCalculation: {
      calories: totalCalories,
      protein: totalProtein,
      fat: totalFat,
      fiber: ingredientBreakdown.reduce((s, b) => s + ((b.ingredient.composition?.fiber || 0) * parseFloat(ingredients[ingredientBreakdown.indexOf(b)].amount)) / 100, 0),
    },
    ingredientBreakdown,
  };
}

/**
 * Create a fallback recipe when dynamic generation fails
 */
function createFallbackRecipe(pet: Pet, seed?: number): GeneratedRecipe {
  const petType = pet.type as PetCategory;
  const allIngredients = INGREDIENT_TEMPLATES[petType] || [];
  
  // Pick first 3 ingredients as fallback
  const ingredients = allIngredients.slice(0, 3);
  
  if (ingredients.length === 0) {
    // Ultimate fallback - create a minimal recipe
    return {
      templateId: 'fallback',
      generationTimestamp: new Date(),
      id: `fallback-${Date.now()}-${seed || 0}`,
      name: `${pet.name || 'Pet'}'s Basic Meal`,
      description: 'Basic meal recipe',
      category: petType,
      healthConcerns: [],
      ageGroup: ['adult'],
      ingredients: [
        { id: 'protein', name: 'Protein', amount: '100g' },
        { id: 'carbs', name: 'Carbohydrates', amount: '100g' },
        { id: 'veggies', name: 'Vegetables', amount: '50g' },
      ],
      instructions: ['Mix ingredients', 'Cook if needed', 'Serve'],
      prepTime: '10 min',
      cookTime: '20 min',
      servings: 1,
      tags: [],
      imageUrl: `/images/generated/${petType}-basic.png`,
      nutritionalCalculation: {
        calories: 300,
        protein: 30,
        fat: 10,
        fiber: 3,
      },
      ingredientBreakdown: [],
    };
  }
  
  const portionedIngredients = calculatePortions(ingredients, pet);
  return buildRecipeFromIngredients(portionedIngredients, pet, seed);
}

/**
 * Get all safe ingredients for a pet (exclude allergies)
 */
function getSafeIngredientsForPet(pet: Pet): IngredientTemplate[] {
  const allergies = (pet.allergies || []).map(a => a.toLowerCase());
  const petType = pet.type as PetCategory;
  const templates = INGREDIENT_TEMPLATES[petType] || [];
  
  return templates.filter((ing: any) => {
    const ingName = ing.name.toLowerCase();
    const ingId = ing.id.toLowerCase();
    return !allergies.some(allergy => 
      ingName.includes(allergy) || ingId.includes(allergy)
    );
  });
}

/**
 * Prioritize ingredients based on health concerns
 */
function prioritizeForHealthConcerns(ingredients: IngredientTemplate[], pet: Pet): IngredientTemplate[] {
  const concerns = pet.healthConcerns || [];
  if (concerns.length === 0) return ingredients;
  
  // Map health concerns to beneficial ingredients
  const healthBenefits: Record<string, string[]> = {
    'digestive-issues': ['pumpkin', 'sweet potato', 'brown rice', 'chicken'],
    'joint-health': ['salmon', 'fish oil', 'sweet potato'],
    'weight-management': ['chicken', 'turkey', 'lean beef', 'spinach', 'carrots'],
    'skin-coat': ['salmon', 'fish oil', 'sweet potato'],
    'allergy-support': ['chicken', 'turkey', 'sweet potato', 'pumpkin'],
    'kidney-disease': ['chicken', 'white fish', 'white rice'],
  };
  
  // Sort ingredients: beneficial ones first
  return ingredients.sort((a, b) => {
    const aIsBeneficial = concerns.some(c => 
      healthBenefits[c]?.some(benefit => a.name.toLowerCase().includes(benefit))
    );
    const bIsBeneficial = concerns.some(c => 
      healthBenefits[c]?.some(benefit => b.name.toLowerCase().includes(benefit))
    );
    return aIsBeneficial === bIsBeneficial ? 0 : aIsBeneficial ? -1 : 1;
  });
}

/**
 * Select diverse ingredients (protein, carbs, veggies, fats)
 * Uses seed to create deterministic but varied selections
 * Ensures all ingredients are used across 50 recipes
 */
function selectDiverseIngredients(ingredients: IngredientTemplate[], pet: Pet, seed: number): IngredientTemplate[] {
  const categories = {
    protein: ingredients.filter(i => i.category === 'protein'),
    carbs: ingredients.filter(i => i.category === 'grain'),
    veggies: ingredients.filter(i => i.category === 'vegetable'),
    fats: ingredients.filter(i => i.category === 'fat'),
  };
  
  const selected: IngredientTemplate[] = [];
  
  // Use seed to cycle through ALL ingredients deterministically
  // With 50 seeds, we'll use each ingredient multiple times in different combinations
  
  // Pick a protein - cycle through all proteins
  if (categories.protein.length > 0) {
    const idx = seed % categories.protein.length;
    selected.push(categories.protein[idx]);
  }
  
  // Pick a carb - offset seed so it doesn't match protein selection
  if (categories.carbs.length > 0) {
    const idx = (seed + Math.floor(seed / categories.protein.length)) % categories.carbs.length;
    selected.push(categories.carbs[idx]);
  }
  
  // Pick a veggie - different offset
  if (categories.veggies.length > 0) {
    const idx = (seed + Math.floor(seed / (categories.protein.length * categories.carbs.length))) % categories.veggies.length;
    selected.push(categories.veggies[idx]);
  }
  
  // Pick a fat - different offset, optional
  if (categories.fats.length > 0) {
    const idx = (seed * 2) % categories.fats.length;
    // Include fat ~60% of the time
    if (seed % 5 !== 0) {
      selected.push(categories.fats[idx]);
    }
  }
  
  return selected;
}

/**
 * Calculate portions based on pet weight and ingredient type
 */
function calculatePortions(ingredients: IngredientTemplate[], pet: Pet): Array<{ ingredient: IngredientTemplate; amount: string }> {
  const weightKg = pet.weightKg || parseFloat(pet.weight || '10');
  const dailyCalories = weightKg < 5 ? 200 : weightKg < 15 ? 400 : weightKg < 30 ? 800 : 1200;
  
  return ingredients.map(ing => {
    let amount = '100g'; // default
    
    if (ing.category === 'protein') {
      // ~40% of calories from protein
      amount = `${Math.round(weightKg * 8)}g`;
    } else if (ing.category === 'grain') {
      // ~40% of calories from carbs
      amount = `${Math.round(weightKg * 6)}g`;
    } else if (ing.category === 'vegetable') {
      // ~15% of calories from veggies
      amount = `${Math.round(weightKg * 3)}g`;
    } else if (ing.category === 'fat') {
      // ~5% of calories from fats
      amount = `${Math.round(weightKg * 0.5)}g`;
    }
    
    return { ingredient: ing, amount };
  });
}

/**
 * Build a complete recipe from selected ingredients
 */
function buildRecipeFromIngredients(
  portionedIngredients: Array<{ ingredient: IngredientTemplate; amount: string }>,
  pet: Pet,
  seed?: number
): GeneratedRecipe {
  const ingredients = portionedIngredients.map(p => ({
    id: p.ingredient.id,
    name: p.ingredient.name,
    amount: p.amount,
  }));
  
  const ingredientBreakdown = portionedIngredients.map(p => ({
    ingredient: p.ingredient as unknown as Ingredient,
    contribution: {
      protein: (p.ingredient.nutritionalProfile.protein || 0) * (parseFloat(p.amount) / 100),
      fat: (p.ingredient.nutritionalProfile.fat || 0) * (parseFloat(p.amount) / 100),
      calories: (p.ingredient.nutritionalProfile.calories || 50) * (parseFloat(p.amount) / 100),
    },
  }));
  
  const totalProtein = ingredientBreakdown.reduce((s, b) => s + b.contribution.protein, 0);
  const totalFat = ingredientBreakdown.reduce((s, b) => s + b.contribution.fat, 0);
  const totalCalories = ingredientBreakdown.reduce((s, b) => s + b.contribution.calories, 0);
  
  const ingredientNames = ingredients.map(i => i.name).join(' & ');
  const recipeName = `${pet.name || 'Pet'}'s Custom ${ingredientNames}`;
  
  return {
    templateId: 'dynamic',
    generationTimestamp: new Date(),
    id: `generated-${Date.now()}-${seed || Math.random()}`,
    name: recipeName,
    description: `Customized recipe for ${pet.name} based on their allergies, health concerns, and weight`,
    category: pet.type,
    healthConcerns: pet.healthConcerns || [],
    ageGroup: [pet.age || 'adult'],
    ingredients,
    instructions: [
      'Combine all ingredients',
      'Cook protein thoroughly',
      'Mix with vegetables and grains',
      'Cool to room temperature before serving',
      `Serve ${Math.round(totalCalories / 100)}g portions daily`,
    ],
    prepTime: '10 min',
    cookTime: '20 min',
    servings: 1,
    tags: pet.healthConcerns || [],
    imageUrl: `/images/generated/${pet.type}-custom.png`,
    nutritionalCalculation: {
      calories: totalCalories,
      protein: totalProtein,
      fat: totalFat,
      fiber: ingredientBreakdown.reduce((s, b) => s + ((b.ingredient as any).nutritionalProfile.fiber || 0), 0),
    },
    ingredientBreakdown,
  };
}

export function getRecipeTemplates(category?: PetCategory, style?: RecipeStyle): RecipeTemplate[] {
  return TEMPLATE_LIBRARY.filter(t => (!category || t.category === category) && (!style || t.style === style));
}

export async function loadAndIntegrateScrapedData() {
  // Stubbed: in real use we would fetch and merge scraped veterinary data.
  const insights: ScrapedInsights = { commonIngredients: {}, healthFocusAreas: {}, ingredientHealthMap: {} };
  const enhancedIngredients = TEMPLATE_LIBRARY.flatMap(t => t.baseIngredients);
  const healthInsights = enhanceHealthConcernsWithScrapedData([]);
  return { enhancedIngredients, healthInsights, insights };
}
</file>

<file path="lib/scoreRecipe.ts">
import type { Recipe } from './types';
import { dogModifiers } from './data/nutrition-dog-modifiers';
import { catModifiers } from './data/nutrition-cat-modifiers';
import { matchesSpecies } from './utils/recipeRecommendations';
import {
  calculateEnhancedCompatibility,
  type Pet as EnhancedPet,
} from './utils/enhancedCompatibilityScoring';

export interface ScoreReasoning {
  goodMatches: string[];
  conflicts: string[];
}

export interface ScoreResult {
  compatibilityScore: number; // 0-100 (formerly matchScore)
  matchScore: number; // 0-100 (deprecated - use compatibilityScore)
  stars: number; // 1-5
  reasoning: ScoreReasoning;
  conflictCount: number; // number of avoid rule conflicts
  hasHydrationSupport: boolean; // for kidney/urinary
  summaryReasoning?: string;
  recommendations?: string[];
}

const commonAllergens = [
  'chicken',
  'beef',
  'pork',
  'fish',
  'soy',
  'dairy',
  'egg',
  'wheat',
  'peanut',
  'lamb',
];

function toLower(s?: string) {
  return (s || '').toLowerCase();
}

function containsAllergen(recipe: Recipe, allergies: string[] = []) {
  const ingredientText = (recipe.ingredients || []).map((i) => toLower(i.name)).join(' ');
  // if user specified allergies explicitly, check those first
  for (const a of allergies) {
    const aLow = toLower(a);
    if (!aLow) continue;
    if (ingredientText.includes(aLow)) return aLow;
    // check substring matches for common names
  }
  // fallback: check against commonAllergens
  for (const allergen of commonAllergens) {
    if (ingredientText.includes(allergen)) return allergen;
  }
  return null;
}

function mapScoreToStars(score: number) {
  if (score >= 90) return 5;
  if (score >= 75) return 4;
  if (score >= 55) return 3;
  if (score >= 30) return 2;
  return 1;
}

// Helper function to get related keywords for health concerns
function getRelatedKeywords(concern: string): string[] {
  const keywordMap: Record<string, string[]> = {
    'allergies': ['skin', 'itch', 'immune', 'inflammatory'],
    'joint-health': ['arthritis', 'mobility', 'inflammatory', 'bone', 'cartilage'],
    'digestive-issues': ['gi', 'stomach', 'gut', 'inflammatory', 'sensitive'],
    'weight-management': ['low-calorie', 'lean', 'obesity', 'weight', 'calorie'],
    'kidney-disease': ['kidney', 'renal', 'phosphorus', 'hydration'],
    'urinary-health': ['urinary', 'uti', 'hydration', 'bladder'],
    'dental-issues': ['dental', 'teeth', 'tartar', 'oral'],
    'heart-disease': ['heart', 'cardiac', 'taurine', 'omega-3'],
    'diabetes': ['diabetes', 'sugar', 'glucose', 'insulin'],
    'respiratory': ['respiratory', 'breathing', 'lungs', 'airway'],
  };
  
  return keywordMap[concern] || [];
}

// Normalize human-readable health concerns to recipe format (kebab-case)
function normalizeHealthConcernForMatching(concern: string): string {
  const normalized = concern.toLowerCase().trim();
  
  // Map human-readable concerns to recipe format
  const mapping: Record<string, string> = {
    // Dogs
    'allergies/skin issues': 'allergies',
    'allergies': 'allergies',
    'allergy': 'allergies',
    'skin issues': 'allergies',
    'arthritis/joint pain': 'joint-health',
    'joint pain': 'joint-health',
    'arthritis': 'joint-health',
    'dental problems': 'dental-issues',
    'dental disease': 'dental-issues',
    'dental issues': 'dental-issues',
    'digestive issues': 'digestive-issues',
    'digestive': 'digestive-issues',
    'ear infections': 'ear-infections',
    'obesity/weight management': 'weight-management',
    'obesity': 'weight-management',
    'weight management': 'weight-management',
    'kidney disease': 'kidney-disease',
    'kidney': 'kidney-disease',
    'heart disease': 'heart-disease',
    'heart': 'heart-disease',
    'pancreatitis': 'pancreatitis',
    'pancreatic': 'pancreatitis',
    'diabetes': 'diabetes',
    'diabetic': 'diabetes',
    'skin conditions': 'skin-conditions',
    'skin condition': 'skin-conditions',
    'urinary problems': 'urinary-health',
    'urinary': 'urinary-health',
    'thyroid issues': 'thyroid',
    'thyroid': 'thyroid',
    
    // Cats
    'urinary tract issues': 'urinary-health',
    'hyperthyroidism': 'hyperthyroidism',
    'inflammatory bowel disease': 'digestive-issues',
    'ibd': 'digestive-issues',
    'hairballs': 'hairball',
    'hairball': 'hairball',
    'respiratory issues': 'respiratory',
    'skin allergies': 'allergies',
    
    // Birds
    'feather plucking': 'feather-plucking',
    'respiratory infection': 'respiratory',
    'beak overgrowth': 'beak-overgrowth',
    'vitamin deficiencies': 'vitamin-deficiency',
    'heavy metal exposure': 'heavy-metal',
    'egg binding': 'egg-binding',
    'fatty liver disease': 'fatty-liver',
    'nutritional imbalances': 'nutritional-deficiency',
    
    // Reptiles
    'metabolic bone disease': 'metabolic-bone-disease',
    'mbd': 'metabolic-bone-disease',
    'parasites': 'parasites',
    'stuck shed': 'stuck-shed',
    'impaction': 'impaction',
    'mouth rot': 'mouth-rot',
    'thermal burns': 'thermal-burns',
    'nutritional deficiencies': 'nutritional-deficiency',
    
    // Pocket pets (removed duplicates - already defined above)
    'skin/fur issues': 'skin-conditions',
  };
  
  // Try exact match first
  if (mapping[normalized]) {
    return mapping[normalized];
  }
  
  // Try partial matches (e.g., "obesity/weight management" contains "weight management")
  for (const [key, value] of Object.entries(mapping)) {
    if (normalized.includes(key) || key.includes(normalized)) {
      return value;
    }
  }
  
  // Fallback: convert to kebab-case
  return normalized.replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
}

const concernToModifierKey: Record<string, string> = {
  allergies: 'allergies',
  'joint-health': 'joint_issues',
  'weight-management': 'weight_management',
  digestive: 'gi_issues',
  'digestive-issues': 'gi_issues',
  'gi-issues': 'gi_issues',
  'kidney': 'kidney_support',
  'kidney-disease': 'kidney_support',
  'kidney/urinary-support': 'kidney_support',
  'urinary-health': 'urinary_health',
  diabetes: 'diabetes',
  'pancreatitis': 'pancreatitis',
  'heart-disease': 'heart_disease',
  'heart disease': 'heart_disease',
  'skin-conditions': 'skin_conditions',
  'skin conditions': 'skin_conditions',
  'skin-coat': 'skin_conditions',
  'dental-issues': 'dental_issues',
  'dental': 'dental_issues',
};

export function scoreRecipe(recipe: Recipe, pet: any): ScoreResult {
  const reasoning: ScoreReasoning = { goodMatches: [], conflicts: [] };
  let conflictCount = 0;
  let hasHydrationSupport = false;

  // Species gate: use matchesSpecies to support subtype matching for exotics
  if (!matchesSpecies(recipe, pet)) {
    reasoning.conflicts.push('Different species - not suitable');
    return { compatibilityScore: 0, matchScore: 0, stars: 1, reasoning, conflictCount: 1, hasHydrationSupport };
  }

  // Debug logging (only in development)
  if (process.env.NODE_ENV === 'development' && Math.random() < 0.1) { // Log 10% of calls
    // Debug logging removed - use logger if needed
  }

  // Base score components - start with higher base
  let score = 50; // Base score for species/age match
  let possible = 100; // total possible when nutrition present

  // Age match +15
  if (recipe.ageGroup && pet.age && recipe.ageGroup.includes(pet.age)) {
    score += 15;
    reasoning.goodMatches.push('Age group match');
  }
  // NO ELSE STATEMENT - no penalty for missing

  // Breed relevance +10
  if (recipe.breed && pet.breed && recipe.breed.includes(pet.breed)) {
    score += 10;
    reasoning.goodMatches.push('Breed-specific match');
  }

  // Health concerns: Use as modifiers, not blockers
  // Bonus if aligned, small penalty if not (but don't block)
  // Normalize pet concerns to recipe format for matching
  const petConcernsNormalized: string[] = (pet.healthConcerns || []).map((c: string) => 
    normalizeHealthConcernForMatching(String(c).toLowerCase())
  );
  const recipeConcernsNormalized: string[] = (recipe.healthConcerns || []).map((c: string) => 
    String(c).toLowerCase().trim()
  );
  
  let healthMatches = 0;
  let healthMismatches = 0;
  
  if (petConcernsNormalized.length > 0) {
    if (recipeConcernsNormalized.length > 0) {
      // Check for matches (exact or partial)
      for (const petConcern of petConcernsNormalized) {
        const matched = recipeConcernsNormalized.some(rc => 
          rc === petConcern || 
          rc.includes(petConcern) || 
          petConcern.includes(rc)
        );
        if (matched) {
          healthMatches += 1;
          const originalConcern = (pet.healthConcerns || [])[petConcernsNormalized.indexOf(petConcern)];
          reasoning.goodMatches.push(`Supports ${originalConcern}`);
          if (healthMatches >= 4) break;
        } else {
          healthMismatches += 1;
        }
      }
    } else {
      // Recipe has no health concern tags - small penalty but don't block
      healthMismatches = petConcernsNormalized.length;
      reasoning.conflicts.push('Not optimized for health concerns (but still safe)');
    }
  }
  
  // Bonus for matches: +15 each up to +60
  score += Math.min(4, healthMatches) * 15;
  
  // Small penalty for mismatches: -5 each, but don't go below base score
  score -= Math.min(healthMismatches * 5, 20); // Max -20 penalty
  score = Math.max(score, 30); // Never go below 30 if species matches

  // Weight control fit: +10 if pet overweight and recipe flags low-calorie
  const weightFlag = ((recipe.tags || []).map((t) => t.toLowerCase()).includes('low-calorie')) || false;
  if (pet.weightKg && (pet as any).weightStatus === 'overweight') {
    if (weightFlag) {
      score += 10;
      reasoning.goodMatches.push('Low-calorie fit for weight control');
    }
  }

  // Allergy detection: if pet has 'allergy' in concerns or explicit allergies, penalize heavily
  const normalizedPetConcernsForAllergy = petConcernsNormalized.filter((c: string) => c.includes('allerg') || c.includes('allergy'));
  const explicitAllergies: string[] = (pet && pet.allergies) || [];
  const allergyTrigger = containsAllergen(recipe, explicitAllergies.length ? explicitAllergies : normalizedPetConcernsForAllergy);
  if (allergyTrigger) {
    reasoning.conflicts.push(`Contains potential allergen: ${allergyTrigger}`);
    conflictCount += 1;
    // allergy override: near-zero
    return { compatibilityScore: 0, matchScore: 0, stars: 1, reasoning, conflictCount, hasHydrationSupport };
  }

  // Nutrient fit: +15 if nutritional info present and assumed within AAFCO range
  const hasNutrition = !!recipe.nutritionalInfo || !!recipe.nutritionInfo;
  if (hasNutrition) {
    // Simple heuristic: if nutritionalInfo exists, grant full nutrient fit
    score += 15;
    reasoning.goodMatches.push('Nutritional profile fits AAFCO ranges');
  } else {
    // If nutrition missing, lower max possible to 80
    possible = 80;
  }

  // Apply modifiers if applicable
  const modifiers = pet.type === 'dogs' ? dogModifiers : pet.type === 'cats' ? catModifiers : null;
  if (modifiers) {
    // Use normalized concerns for modifier matching
    for (let i = 0; i < petConcernsNormalized.length; i++) {
      const petConcernNormalized = petConcernsNormalized[i];
      const modKey = concernToModifierKey[petConcernNormalized];
      if (modKey && (modifiers as any)[modKey]) {
        const modifier = (modifiers as any)[modKey];
        // If recipe supports the concern, add boost
        if (recipeConcernsNormalized.some((rc: string) => rc.includes(petConcernNormalized) || petConcernNormalized.includes(rc))) {
          score += modifier.scoreBoost;
          const originalConcern = (pet.healthConcerns || [])[i];
          reasoning.goodMatches.push(`+${modifier.scoreBoost} for ${originalConcern} support`);
        }
        // Check for avoid ingredients
        const ingredientText = (recipe.ingredients || []).map((i) => toLower(i.name)).join(' ');
        for (const avoid of modifier.avoid) {
          if (ingredientText.includes(avoid.toLowerCase())) {
            score -= 5;
            conflictCount += 1;
            reasoning.conflicts.push(`-5 for containing ${avoid} (${petConcernNormalized})`);
          }
        }
        // Check if this modifier provides hydration support
        if (petConcernNormalized === 'kidney-disease' || petConcernNormalized === 'kidney' || petConcernNormalized === 'urinary-health') {
          hasHydrationSupport = true;
        }
      }
    }
  }

  // Normalize final score to 0..100 given 'possible'
  // But first, ensure negative conflicts do not drop below 0 (we handled allergies above)

  // Cap score to possible (shouldn't exceed)
  if (score > possible) score = possible;
  if (score < 0) score = 0;

  // Map into 0..100 proportionally
  const compatibilityScore = Math.round((score / possible) * 100);
  const stars = mapScoreToStars(compatibilityScore);

  return { compatibilityScore, matchScore: compatibilityScore, stars, reasoning, conflictCount, hasHydrationSupport };
}

/**
 * Improved scoring wrapper using the enhanced algorithm from improvedCompatibilityScoring.
 * Keeps the original ScoreResult shape for drop-in use.
 */
export function scoreRecipeImproved(recipe: Recipe, pet: any): ScoreResult {
  const enhancedPet: EnhancedPet = {
    id: pet.id,
    name: pet.name,
    type: pet.type as 'dog' | 'cat' | 'bird' | 'reptile' | 'pocket-pet',
    breed: pet.breed,
    age: typeof pet.age === 'string' ? parseFloat(pet.age) || 1 : pet.age || 1,
    weight: pet.weight || pet.weightKg || 10,
    activityLevel: pet.activityLevel,
    healthConcerns: pet.healthConcerns || [],
    dietaryRestrictions: pet.dietaryRestrictions || [],
    allergies: pet.allergies || [],
  };

  const result = calculateEnhancedCompatibility(recipe, enhancedPet);
  const stars = Math.round(result.overallScore / 20);
  return {
    compatibilityScore: result.overallScore,
    matchScore: result.overallScore, // Keep for backward compatibility
    stars: stars,
    reasoning: {
      goodMatches: result.detailedBreakdown.healthBenefits,
      conflicts: result.detailedBreakdown.warnings,
    },
    conflictCount: result.detailedBreakdown.warnings.length,
    hasHydrationSupport: false,
    summaryReasoning: `Compatibility score: ${result.overallScore}% (${result.grade})`,
    recommendations: result.detailedBreakdown.recommendations,
  };
}
</file>

<file path="lib/seo/metadata.ts">
// SEO Metadata Configurations for Key Pages
import { Metadata } from 'next';

const baseUrl = 'https://petplatesmealplatform-ldvstwjsy-plateandpaw.vercel.app';

// Helper to generate structured data for recipes
export function generateRecipeStructuredData(recipe: any) {
  return {
    "@context": "https://schema.org",
    "@type": "Recipe",
    "name": recipe.name,
    "description": recipe.description,
    "image": recipe.imageUrl ? `${baseUrl}${recipe.imageUrl}` : undefined,
    "prepTime": recipe.prepTime,
    "cookTime": recipe.cookTime,
    "recipeYield": `${recipe.servings} servings`,
    "recipeCategory": "Pet Food",
    "recipeCuisine": "Pet Nutrition",
    "keywords": `${recipe.category} food, homemade pet food, ${recipe.name}`,
    "recipeIngredient": recipe.ingredients?.map((i: any) => i.name) || [],
    "recipeInstructions": recipe.instructions?.map((step: string, idx: number) => ({
      "@type": "HowToStep",
      "position": idx + 1,
      "text": step
    })) || [],
    "author": {
      "@type": "Organization",
      "name": "Paw & Plate"
    },
    "aggregateRating": {
      "@type": "AggregateRating",
      "ratingValue": "4.8",
      "reviewCount": "127"
    }
  };
}

// Page-specific metadata configurations
export const pageMetadata: Record<string, Metadata> = {
  home: {
    title: 'Paw & Plate - Fresh Meal Prep for Dogs, Cats, Birds, Reptiles & Small Pets',
    description: 'Free vet-approved meal plans for ALL your pets. Custom recipes for dogs, cats, birds, reptiles, and pocket pets with one-click Amazon ingredient ordering. AAFCO & WSAVA compliant.',
    keywords: ['homemade dog food', 'homemade cat food', 'DIY pet meals', 'pet meal prep', 'fresh pet food recipes'],
    openGraph: {
      title: 'Paw & Plate - Fresh Meal Prep for All Pets',
      description: 'Free vet-approved meal plans with one-click Amazon ordering',
    },
  },
  
  dogs: {
    title: 'Homemade Dog Food Recipes - Vet-Approved & AAFCO Compliant',
    description: 'Free custom dog food recipes for all breeds, ages, and health needs. AAFCO compliant nutrition with Amazon ingredient links. Puppy, adult, and senior meal plans.',
    keywords: ['homemade dog food', 'dog food recipes', 'puppy food recipes', 'senior dog food', 'healthy dog meals'],
    openGraph: {
      title: 'Homemade Dog Food Recipes - Vet-Approved',
      description: 'AAFCO compliant dog food recipes for all breeds and ages',
    },
  },
  
  cats: {
    title: 'Homemade Cat Food Recipes - Vet-Approved & Balanced',
    description: 'Free custom cat food recipes for all breeds and ages. AAFCO compliant nutrition with Amazon ingredient links. Kitten, adult, and senior meal plans.',
    keywords: ['homemade cat food', 'cat food recipes', 'kitten food recipes', 'senior cat food', 'healthy cat meals'],
    openGraph: {
      title: 'Homemade Cat Food Recipes - Vet-Approved',
      description: 'AAFCO compliant cat food recipes for all breeds and ages',
    },
  },
  
  birds: {
    title: 'Bird Food Recipes & Diet Plans - Parrot, Parakeet, Cockatiel Nutrition',
    description: 'Custom bird diet plans for parrots, parakeets, cockatiels, and more. Evidence-based avian nutrition with ingredient shopping links.',
    keywords: ['bird food recipes', 'parrot diet', 'parakeet food', 'cockatiel nutrition', 'homemade bird food'],
    openGraph: {
      title: 'Bird Food Recipes - Avian Nutrition Plans',
      description: 'Evidence-based diet plans for parrots, parakeets, and more',
    },
  },
  
  reptiles: {
    title: 'Reptile Diet Plans - Bearded Dragon, Gecko, Snake Nutrition',
    description: 'Custom reptile diet plans for bearded dragons, geckos, snakes, and more. Species-specific nutrition with ingredient links.',
    keywords: ['reptile diet', 'bearded dragon food', 'gecko diet', 'snake feeding', 'reptile nutrition'],
    openGraph: {
      title: 'Reptile Diet Plans - Species-Specific Nutrition',
      description: 'Custom diet plans for bearded dragons, geckos, snakes, and more',
    },
  },
  
  'pocket-pets': {
    title: 'Small Pet Food Recipes - Hamster, Rabbit, Guinea Pig Nutrition',
    description: 'Custom diet plans for rabbits, hamsters, guinea pigs, ferrets, and more. Small pet nutrition with ingredient shopping links.',
    keywords: ['rabbit food', 'hamster diet', 'guinea pig nutrition', 'ferret food', 'small pet recipes'],
    openGraph: {
      title: 'Small Pet Food Recipes - Hamster, Rabbit, Guinea Pig',
      description: 'Custom diet plans for rabbits, hamsters, guinea pigs, and more',
    },
  },
  
  blog: {
    title: 'Pet Nutrition Blog - Meal Prep Tips & Recipes',
    description: 'Expert pet nutrition advice, homemade food recipes, and meal prep tips for dogs, cats, birds, reptiles, and small pets.',
    keywords: ['pet nutrition blog', 'pet food tips', 'homemade pet food advice', 'pet meal prep'],
    openGraph: {
      title: 'Pet Nutrition Blog - Expert Advice & Recipes',
      description: 'Expert pet nutrition advice and homemade food recipes',
    },
  },
  
  faq: {
    title: 'FAQ - Common Questions About Pet Meal Prep',
    description: 'Frequently asked questions about homemade pet food, nutrition guidelines, AAFCO compliance, and meal prep for dogs, cats, birds, reptiles, and small pets.',
    keywords: ['pet food FAQ', 'homemade pet food questions', 'AAFCO guidelines', 'pet nutrition FAQ'],
    openGraph: {
      title: 'FAQ - Pet Meal Prep Questions Answered',
      description: 'Common questions about homemade pet food and nutrition',
    },
  },
  
  contact: {
    title: 'Contact Us - Paw & Plate Support',
    description: 'Get in touch with the Paw & Plate team. Questions about pet nutrition, meal plans, or account support.',
    keywords: ['contact pet nutrition', 'Paw & Plate support', 'pet food questions'],
    openGraph: {
      title: 'Contact Paw & Plate',
      description: 'Get in touch with our pet nutrition team',
    },
  },
};

// Generate organization structured data
export const organizationStructuredData = {
  "@context": "https://schema.org",
  "@type": "Organization",
  "name": "Paw & Plate",
  "description": "Free vet-approved meal plans for dogs, cats, birds, reptiles, and pocket pets",
  "url": baseUrl,
  "logo": `${baseUrl}/images/emojis/Mascots/HeroPics/HeroBanner-v3.png`,
  "contactPoint": {
    "@type": "ContactPoint",
    "contactType": "Customer Support",
    "email": "support@pawandplate.com"
  },
  "sameAs": [
    // Add your social media profiles here when you have them
    // "https://facebook.com/pawandplate",
    // "https://twitter.com/pawandplate",
    // "https://instagram.com/pawandplate",
  ]
};

// Generate FAQ structured data for FAQ page
export function generateFAQStructuredData(faqs: { question: string; answer: string }[]) {
  return {
    "@context": "https://schema.org",
    "@type": "FAQPage",
    "mainEntity": faqs.map(faq => ({
      "@type": "Question",
      "name": faq.question,
      "acceptedAnswer": {
        "@type": "Answer",
        "text": faq.answer
      }
    }))
  };
}

// Generate breadcrumb structured data
export function generateBreadcrumbStructuredData(items: { name: string; url: string }[]) {
  return {
    "@context": "https://schema.org",
    "@type": "BreadcrumbList",
    "itemListElement": items.map((item, index) => ({
      "@type": "ListItem",
      "position": index + 1,
      "name": item.name,
      "item": `${baseUrl}${item.url}`
    }))
  };
}
</file>

<file path="lib/services/amazonPurchaseTracker.ts">
/**
 * Amazon Associates API integration for purchase confirmation
 * 
 * This service handles:
 * - Receiving purchase confirmations from Amazon
 * - Validating purchase data
 * - Updating purchase tracking
 * - Triggering village level updates
 * 
 * Note: This is a placeholder implementation.
 * In production, this would integrate with Amazon Associates API
 * to automatically confirm purchases when orders are completed.
 */

export interface AmazonPurchaseConfirmation {
  orderId: string;
  userId: string;
  items: Array<{
    asin: string;
    ingredientId: string;
    ingredientName: string;
    quantity: number;
    price: number;
  }>;
  orderDate: string;
  signature?: string; // For webhook verification
}

/**
 * Process Amazon purchase confirmation
 * This would be called by the webhook endpoint
 */
export async function processAmazonPurchaseConfirmation(
  confirmation: AmazonPurchaseConfirmation
): Promise<{
  success: boolean;
  confirmedCount: number;
  villageLevelUpdated: boolean;
}> {
  // TODO: Implement actual purchase confirmation logic
  // 1. Validate confirmation data
  // 2. Update purchase records in database
  // 3. Check if village level should be updated
  // 4. Return results

  return {
    success: true,
    confirmedCount: confirmation.items.length,
    villageLevelUpdated: false
  };
}

/**
 * Verify Amazon webhook signature
 */
export function verifyAmazonWebhookSignature(
  signature: string,
  payload: string,
  secret: string
): boolean {
  // TODO: Implement Amazon webhook signature verification
  // This would use HMAC-SHA256 to verify the signature
  return true; // Placeholder
}

/**
 * Get purchase confirmation URL for webhook
 */
export function getPurchaseConfirmationWebhookUrl(): string {
  // In production, this would return the actual webhook URL
  // registered with Amazon Associates API
  return '/api/amazon/purchase-confirmation';
}
</file>

<file path="lib/services/brandBasedVetter.ts">
// lib/services/brandBasedVetter.ts
// Brand-based product suggestions using analyze-brands.js data

import fs from 'fs';
import path from 'path';

interface BrandMatch {
  ingredient: string;
  brand: string;
  qualityScore: number;
  productName: string;
  confidence: number;
  category: string;
  specialties: string[];
  priceRange: string;
}

interface BrandData {
  category: string;
  qualityScore: number;
  vetRecommended: boolean;
  specialties: string[];
  priceRange: string;
  affiliateLink?: string;
}

// Brand database from analyze-brands.js
const BRAND_DATABASE: Record<string, BrandData> = {
  'Fresh Is Best': {
    category: 'freeze-dried',
    qualityScore: 9.2,
    vetRecommended: true,
    specialties: ['single-ingredient', 'human-grade', 'raw alternative'],
    priceRange: '$$',
    affiliateLink: 'https://www.freshisbest.com/'
  },
  'Vital Essentials': {
    category: 'freeze-dried',
    qualityScore: 9.0,
    vetRecommended: true,
    specialties: ['organ meats', 'grain-free', 'natural supplements'],
    priceRange: '$$',
    affiliateLink: 'https://www.vitalessentialsraw.com/'
  },
  'US Wellness Meats': {
    category: 'raw',
    qualityScore: 9.1,
    vetRecommended: true,
    specialties: ['grass-fed', 'organic', 'human-grade'],
    priceRange: '$$',
    affiliateLink: 'https://grasslandbeef.com/'
  },
  'Raw Paws': {
    category: 'raw',
    qualityScore: 8.9,
    vetRecommended: true,
    specialties: ['novel proteins', 'limited ingredients', 'digestive health'],
    priceRange: '$$',
    affiliateLink: 'https://www.rawpaws.pet/'
  },
  'Grizzly Salmon Oil': {
    category: 'supplement',
    qualityScore: 9.3,
    vetRecommended: true,
    specialties: ['wild-caught salmon', 'omega-3 concentrate', 'skin/coat health'],
    priceRange: '$',
    affiliateLink: 'https://www.grizzlys.com/'
  },
  'Primal': {
    category: 'raw',
    qualityScore: 8.7,
    vetRecommended: true,
    specialties: ['freeze-dried', 'complete nutrition', 'grain-free'],
    priceRange: '$$',
    affiliateLink: 'https://www.primalpetfoods.com/'
  },
  'Stella & Chewy\'s': {
    category: 'freeze-dried',
    qualityScore: 8.8,
    vetRecommended: true,
    specialties: ['raw-coated', 'grain-free', 'probiotics'],
    priceRange: '$$',
    affiliateLink: 'https://www.stellaandchewys.com/'
  },
  'Northwest Naturals': {
    category: 'freeze-dried',
    qualityScore: 8.8,
    vetRecommended: true,
    specialties: ['regional ingredients', 'sustainable', 'limited ingredients'],
    priceRange: '$$',
    affiliateLink: 'https://www.nwnaturals.com/'
  }
};

// Ingredient to brand mapping based on specialties
const INGREDIENT_BRAND_MAP: Record<string, string[]> = {
  // Proteins
  'chicken': ['Fresh Is Best', 'US Wellness Meats', 'Vital Essentials'],
  'chicken breast': ['Fresh Is Best', 'US Wellness Meats'],
  'ground chicken': ['US Wellness Meats', 'Raw Paws'],
  'turkey': ['US Wellness Meats', 'Raw Paws'],
  'ground turkey': ['US Wellness Meats', 'Raw Paws'],
  'beef': ['US Wellness Meats', 'Primal'],
  'ground beef': ['US Wellness Meats', 'Primal'],
  'lamb': ['Raw Paws', 'US Wellness Meats'],
  'ground lamb': ['Raw Paws', 'US Wellness Meats'],
  'duck': ['Raw Paws', 'Vital Essentials'],
  'venison': ['US Wellness Meats', 'Primal'],
  'rabbit': ['Raw Paws', 'US Wellness Meats'],
  'salmon': ['Vital Essentials', 'Fresh Is Best'],
  'fish': ['Vital Essentials', 'Fresh Is Best'],
  
  // Organs
  'heart': ['Vital Essentials', 'US Wellness Meats', 'Raw Paws'],
  'duck hearts': ['Vital Essentials', 'Raw Paws'],
  'chicken hearts': ['Vital Essentials', 'US Wellness Meats'],
  'liver': ['Vital Essentials', 'US Wellness Meats', 'Raw Paws'],
  'chicken liver': ['Vital Essentials', 'US Wellness Meats'],
  'lamb liver': ['Raw Paws', 'US Wellness Meats'],
  'kidney': ['Vital Essentials', 'US Wellness Meats'],
  'organ': ['Vital Essentials', 'US Wellness Meats'],
  
  // Oils & Supplements
  'salmon oil': ['Grizzly Salmon Oil'],
  'fish oil': ['Grizzly Salmon Oil'],
  'omega-3': ['Grizzly Salmon Oil'],
  'coconut oil': ['US Wellness Meats'],
  'flaxseed oil': ['US Wellness Meats'],
  'kelp powder': ['Vital Essentials', 'Northwest Naturals'],
  'supplement': ['Vital Essentials', 'Northwest Naturals']
};

export class BrandBasedVetter {
  findBrandMatches(ingredient: string): BrandMatch[] {
    const matches: BrandMatch[] = [];
    const normalizedIngredient = this.normalizeIngredientName(ingredient);
    
    // Check direct ingredient mapping
    const mappedBrands = INGREDIENT_BRAND_MAP[normalizedIngredient] || 
                        this.findBrandsByKeyword(normalizedIngredient);
    
    if (mappedBrands.length > 0) {
      mappedBrands.forEach(brandName => {
        const brandData = BRAND_DATABASE[brandName];
        if (brandData) {
          matches.push({
            ingredient,
            brand: brandName,
            qualityScore: brandData.qualityScore,
            productName: this.generateProductName(brandName, ingredient),
            confidence: this.calculateConfidence(ingredient, brandData, normalizedIngredient),
            category: brandData.category,
            specialties: brandData.specialties,
            priceRange: brandData.priceRange
          });
        }
      });
    }
    
    return matches.sort((a, b) => b.confidence - a.confidence);
  }
  
  private findBrandsByKeyword(ingredient: string): string[] {
    const brands: string[] = [];
    const keywords = ingredient.split(' ');
    
    Object.entries(BRAND_DATABASE).forEach(([brandName, brandData]) => {
      // Check if brand specialties match ingredient
      const matchesSpecialty = brandData.specialties.some(specialty =>
        keywords.some(keyword => specialty.toLowerCase().includes(keyword.toLowerCase()))
      );
      
      if (matchesSpecialty) {
        brands.push(brandName);
      }
    });
    
    return brands;
  }
  
  private generateProductName(brand: string, ingredient: string): string {
    // Clean ingredient name
    const cleanIngredient = ingredient
      .replace(/\(.*?\)/g, '')
      .trim();
    
    return `${brand} ${cleanIngredient}`;
  }
  
  private calculateConfidence(ingredient: string, brandData: BrandData, normalizedIngredient: string): number {
    let confidence = 0.5;
    
    // Higher confidence for higher quality scores
    if (brandData.qualityScore >= 9.0) confidence += 0.2;
    if (brandData.qualityScore >= 8.5) confidence += 0.1;
    
    // Higher confidence for vet recommended
    if (brandData.vetRecommended) confidence += 0.1;
    
    // Higher confidence for direct ingredient matches
    if (INGREDIENT_BRAND_MAP[normalizedIngredient]) {
      confidence += 0.1;
    }
    
    // Higher confidence for organ meats (brand-specific)
    if (normalizedIngredient.includes('heart') || 
        normalizedIngredient.includes('liver') || 
        normalizedIngredient.includes('kidney')) {
      confidence += 0.1;
    }
    
    // Higher confidence if brand specialty matches ingredient
    const ingredientKeywords = normalizedIngredient.split(' ');
    const specialtyMatch = brandData.specialties.some(specialty =>
      ingredientKeywords.some(keyword => 
        specialty.toLowerCase().includes(keyword.toLowerCase())
      )
    );
    if (specialtyMatch) confidence += 0.1;
    
    return Math.min(0.95, confidence);
  }
  
  private normalizeIngredientName(name: string): string {
    return name
      .toLowerCase()
      .replace(/\(.*?\)/g, '') // Remove parentheses
      .replace(/\s+/g, ' ')
      .trim();
  }
  
  generateVettedProduct(ingredient: string, brandMatch: BrandMatch): any {
    const amazonLink = brandMatch.brand === 'Grizzly Salmon Oil'
      ? 'https://www.amazon.com/s?k=Grizzly+Salmon+Plus+Omega-3+Oil&tag=robinfrench-20'
      : `https://www.amazon.com/s?k=${encodeURIComponent(brandMatch.productName)}&tag=robinfrench-20`;
    
    return {
      productName: brandMatch.productName,
      amazonLink,
      vetNote: `${brandMatch.brand} (${brandMatch.qualityScore}/10 quality score). ${brandMatch.specialties.slice(0, 2).join(', ')}. Veterinary recommended brand.`,
      category: this.getCategory(ingredient),
      commissionRate: 0.03,
      confidence: brandMatch.confidence,
      source: 'brand_analysis'
    };
  }
  
  private getCategory(ingredient: string): 'Meat' | 'Supplement' | 'Carb' | 'Vegetable' | 'Oil' | 'Seed' | 'Fruit' | 'Insect' | 'Hay' | 'Pellet' {
    const normalized = ingredient.toLowerCase();
    
    if (normalized.includes('heart') || normalized.includes('liver') || normalized.includes('kidney') || normalized.includes('organ')) {
      return 'Meat';
    }
    if (normalized.includes('oil') || normalized.includes('fat')) {
      return 'Oil';
    }
    if (normalized.includes('supplement') || normalized.includes('powder') || normalized.includes('capsule') || normalized.includes('kelp')) {
      return 'Supplement';
    }
    if (normalized.includes('seed') || normalized.includes('grain') || normalized.includes('flour') || normalized.includes('buckwheat') || normalized.includes('quinoa')) {
      return 'Carb';
    }
    
    return 'Meat'; // Default for proteins
  }
}
</file>

<file path="lib/services/firestoreService.ts">
import { 
  collection, 
  doc, 
  getDocs, 
  getDoc, 
  setDoc, 
  deleteDoc, 
  updateDoc, 
  query, 
  where,
  Timestamp 
} from 'firebase/firestore';
import { getFirebaseServices, getAppId } from '@/lib/utils/firebaseConfig';
import { Pet, CustomMeal } from '@/lib/types';
import { DatabaseError, ValidationError } from '@/lib/utils/errorHandler';
import { validatePet, validateCustomMeal } from '@/lib/validation/petSchema';

// Helper to get collection ref
const getCollection = (userId: string, collectionName: string) => {
  const services = getFirebaseServices();
  if (!services || !services.db) {
    throw new DatabaseError('Firebase not initialized');
  }
  const appId = getAppId();
  return collection(services.db, `artifacts/${appId}/users/${userId}/${collectionName}`);
};

// --- Pet Operations ---

export async function getPets(userId: string): Promise<Pet[]> {
  if (!userId) {
    throw new ValidationError('User ID is required');
  }

  try {
    const petsRef = getCollection(userId, 'pets');
    const snapshot = await getDocs(petsRef);
    
    const pets = snapshot.docs.map(doc => ({
      ...doc.data(),
      id: doc.id,
    })) as Pet[];
    
    // Validate each pet
    return pets.map(pet => {
      try {
        return validatePet(pet);
      } catch (e) {
        console.warn('Invalid pet data, skipping:', e);
        return null;
      }
    }).filter(Boolean) as Pet[];
  } catch (error) {
    if (error instanceof ValidationError || error instanceof DatabaseError) {
      throw error;
    }
    throw new DatabaseError('Failed to fetch pets', error as Error);
  }
}

export async function savePet(userId: string, pet: Pet): Promise<void> {
  if (!userId) {
    throw new ValidationError('User ID is required');
  }

  try {
    // Validate pet data
    const validatedPet = validatePet(pet);
    
    const petsRef = getCollection(userId, 'pets');
    const petDoc = doc(petsRef, validatedPet.id);
    
    // Convert undefined to null (Firestore doesn't accept undefined)
    const safePet = JSON.parse(JSON.stringify(validatedPet));
    
    await setDoc(petDoc, {
      ...safePet,
      updatedAt: Timestamp.now(),
    }, { merge: true });
  } catch (error) {
    if (error instanceof ValidationError || error instanceof DatabaseError) {
      throw error;
    }
    throw new DatabaseError('Failed to save pet', error as Error);
  }
}

export async function deletePet(userId: string, petId: string): Promise<void> {
  const { db } = getFirebaseServices() || {};
  if (!db) return;

  try {
    const petsRef = getCollection(userId, 'pets');
    await deleteDoc(doc(petsRef, petId));
  } catch (error) {
    console.error('Error deleting pet:', error);
    throw error;
  }
}

// --- Custom Meal Operations ---

export async function getCustomMeals(userId: string, petId: string): Promise<CustomMeal[]> {
  if (!userId || !petId) {
    throw new ValidationError('User ID and Pet ID are required');
  }

  try {
    const mealsRef = getCollection(userId, 'custom_meals');
    const q = query(mealsRef, where('petId', '==', petId));
    const snapshot = await getDocs(q);
    
    const meals = snapshot.docs.map(doc => ({
      ...doc.data(),
      id: doc.id,
    })) as CustomMeal[];
    
    // Validate each meal
    return meals.map(meal => {
      try {
        return validateCustomMeal(meal);
      } catch (e) {
        console.warn('Invalid meal data, skipping:', e);
        return null;
      }
    }).filter(Boolean) as CustomMeal[];
  } catch (error) {
    if (error instanceof ValidationError || error instanceof DatabaseError) {
      throw error;
    }
    throw new DatabaseError('Failed to fetch custom meals', error as Error);
  }
}

export async function saveCustomMeal(userId: string, meal: CustomMeal): Promise<void> {
  if (!userId) {
    throw new ValidationError('User ID is required');
  }

  try {
    // Validate meal data
    const validatedMeal = validateCustomMeal(meal);
    
    const mealsRef = getCollection(userId, 'custom_meals');
    const mealDoc = doc(mealsRef, validatedMeal.id);
    
    // Convert undefined to null
    const safeMeal = JSON.parse(JSON.stringify(validatedMeal));

    await setDoc(mealDoc, {
      ...safeMeal,
      updatedAt: Timestamp.now(),
    }, { merge: true });
  } catch (error) {
    if (error instanceof ValidationError || error instanceof DatabaseError) {
      throw error;
    }
    throw new DatabaseError('Failed to save custom meal', error as Error);
  }
}

export async function deleteCustomMeal(userId: string, mealId: string): Promise<void> {
  const { db } = getFirebaseServices() || {};
  if (!db) return;

  try {
    const mealsRef = getCollection(userId, 'custom_meals');
    await deleteDoc(doc(mealsRef, mealId));
  } catch (error) {
    console.error('Error deleting custom meal:', error);
    throw error;
  }
}
</file>

<file path="lib/services/unifiedVettingService.ts">
// lib/services/unifiedVettingService.ts
// Unified vetting service combining brand analysis + Amazon scraping

import { BrandBasedVetter } from './brandBasedVetter';
import { getVettedProduct } from '../data/vetted-products';
import fs from 'fs';
import path from 'path';

interface VettingResult {
  ingredient: string;
  status: 'vetted' | 'needs_vetting' | 'generic';
  vettedProduct?: any;
  brandMatches?: any[];
  amazonMatches?: any[];
  confidence?: number;
  recommendation?: string;
}

export class UnifiedVettingService {
  private brandVetter: BrandBasedVetter;
  
  constructor() {
    this.brandVetter = new BrandBasedVetter();
  }
  
  async getIngredientStatus(ingredientName: string): Promise<VettingResult> {
    // Check if already vetted
    const vetted = getVettedProduct(ingredientName);
    if (vetted) {
      return {
        ingredient: ingredientName,
        status: 'vetted',
        vettedProduct: vetted,
        confidence: 1.0
      };
    }
    
    // Check if generic
    if (this.isGenericIngredient(ingredientName)) {
      return {
        ingredient: ingredientName,
        status: 'generic',
        confidence: 1.0
      };
    }
    
    // Get brand matches
    const brandMatches = this.brandVetter.findBrandMatches(ingredientName);
    
    // Get Amazon matches (if available)
    const amazonMatches = await this.getAmazonMatches(ingredientName);
    
    // Calculate overall confidence
    const confidence = this.calculateOverallConfidence(brandMatches, amazonMatches);
    
    // Generate recommendation
    let recommendation = '';
    if (amazonMatches.length > 0 && amazonMatches[0].score >= 0.8) {
      recommendation = `Use Amazon product: ${amazonMatches[0].name} (${(amazonMatches[0].score * 100).toFixed(0)}% match)`;
    } else if (brandMatches.length > 0 && brandMatches[0].confidence >= 0.7) {
      recommendation = `Use brand: ${brandMatches[0].productName} (${(brandMatches[0].confidence * 100).toFixed(0)}% confidence)`;
    } else {
      recommendation = 'Manual review needed';
    }
    
    return {
      ingredient: ingredientName,
      status: 'needs_vetting',
      brandMatches: brandMatches.slice(0, 3),
      amazonMatches: amazonMatches.slice(0, 3),
      confidence,
      recommendation
    };
  }
  
  async getAllIngredientsStatus(ingredients: string[]): Promise<VettingResult[]> {
    const statuses: VettingResult[] = [];
    
    for (const ingredient of ingredients) {
      const status = await this.getIngredientStatus(ingredient);
      statuses.push(status);
    }
    
    return statuses;
  }
  
  generateVettedProductFromBrand(ingredient: string, brandMatch: any): any {
    return this.brandVetter.generateVettedProduct(ingredient, brandMatch);
  }
  
  generateVettedProductFromAmazon(ingredient: string, amazonProduct: any): any {
    return {
      productName: amazonProduct.name,
      amazonLink: amazonProduct.url,
      vetNote: `Amazon-discovered product. Rating: ${amazonProduct.rating}‚≠ê (${amazonProduct.reviewCount} reviews). Score: ${((amazonProduct.score || 0) * 100).toFixed(0)}%.`,
      category: this.determineCategory(ingredient),
      commissionRate: 0.03,
      confidence: amazonProduct.score || 0.7,
      source: 'amazon_scraper',
      asin: amazonProduct.asin
    };
  }
  
  private async getAmazonMatches(ingredientName: string): Promise<any[]> {
    try {
      // Check for cached Amazon results
      const resultsDir = path.join(__dirname, '../../pet-ingredient-scraper/results');
      const files = fs.readdirSync(resultsDir)
        .filter(f => f.startsWith('amazon-products-') && f.endsWith('.json'))
        .sort()
        .reverse();
      
      if (files.length > 0) {
        const latestFile = path.join(resultsDir, files[0]);
        const results = JSON.parse(fs.readFileSync(latestFile, 'utf-8'));
        return results[ingredientName] || [];
      }
    } catch (error) {
      // No Amazon results available
    }
    
    return [];
  }
  
  private calculateOverallConfidence(brandMatches: any[], amazonMatches: any[]): number {
    if (amazonMatches.length > 0) {
      return Math.max(...amazonMatches.map(m => m.score || 0));
    }
    
    if (brandMatches.length > 0) {
      return Math.max(...brandMatches.map(m => m.confidence || 0));
    }
    
    return 0;
  }
  
  private isGenericIngredient(name: string): boolean {
    const generics = [
      'water', 'salt', 'eggs', 'carrots', 'celery', 'spinach', 'kale',
      'blueberries', 'apples', 'sweet potato', 'pumpkin', 'broccoli',
      'cauliflower', 'green beans', 'peas', 'rice', 'oats', 'quinoa',
      'brown rice', 'white rice', 'bananas', 'strawberries', 'egg'
    ];
    
    const normalized = name.toLowerCase();
    return generics.some(generic => normalized.includes(generic));
  }
  
  private determineCategory(ingredient: string): 'Meat' | 'Supplement' | 'Carb' | 'Vegetable' | 'Oil' | 'Seed' | 'Fruit' | 'Insect' | 'Hay' | 'Pellet' {
    const normalized = ingredient.toLowerCase();
    
    if (normalized.includes('heart') || normalized.includes('liver') || normalized.includes('kidney')) {
      return 'Meat';
    }
    if (normalized.includes('oil')) {
      return 'Oil';
    }
    if (normalized.includes('powder') || normalized.includes('supplement') || normalized.includes('kelp')) {
      return 'Supplement';
    }
    if (normalized.includes('seed') || normalized.includes('grain') || normalized.includes('buckwheat') || normalized.includes('quinoa')) {
      return 'Carb';
    }
    
    return 'Meat';
  }
}
</file>

<file path="lib/state/villageStore.ts">
// lib/state/villageStore.ts
// Zustand store for village state management
// Provides reactive state for village level, purchase count, and mascot activities

import { create } from 'zustand';
import type { VillageLevel } from '../data/villageLevels';
import { VILLAGE_LEVELS, getVillageLevelData } from '../data/villageLevels';
import { getConfirmedCount } from '../utils/purchaseTracking';
import { logger } from '../utils/logger';

type VillageState = {
  userId: string | null;
  count: number;
  level: VillageLevel;
  isLoading: boolean;
  
  // Actions
  setUserId: (id: string) => void;
  refreshFromLocal: () => void;
  setCount: (n: number) => void;
  incrementCount: () => void;
  reset: () => void;
};

/**
 * Village store using Zustand
 * Provides reactive state management for village evolution
 */
export const useVillageStore = create<VillageState>((set, get) => ({
  userId: null,
  count: 0,
  level: VILLAGE_LEVELS[0],
  isLoading: false,

  /**
   * Set user ID and automatically refresh from localStorage
   */
  setUserId: (id: string) => {
    if (!id) {
      set({ userId: null, count: 0, level: VILLAGE_LEVELS[0] });
      return;
    }
    
    set({ userId: id, isLoading: true });
    get().refreshFromLocal();
  },

  /**
   * Refresh village state from localStorage
   * Called automatically when userId changes or after purchases
   */
  refreshFromLocal: () => {
    const { userId } = get();
    if (!userId) {
      set({ count: 0, level: VILLAGE_LEVELS[0], isLoading: false });
      return;
    }

    try {
      const count = getConfirmedCount(userId);
      const level = getVillageLevelData(count);
      set({ count, level, isLoading: false });
    } catch (error) {
      // Handle error gracefully
      logger.error('Failed to refresh village state', error as Error, { userId });
      set({ count: 0, level: VILLAGE_LEVELS[0], isLoading: false });
    }
  },

  /**
   * Set purchase count directly (for testing or manual updates)
   */
  setCount: (n: number) => {
    const count = Math.max(0, n);
    const level = getVillageLevelData(count);
    set({ count, level });
  },

  /**
   * Increment purchase count by 1
   * Useful for testing or manual increments
   */
  incrementCount: () => {
    const { count } = get();
    get().setCount(count + 1);
  },

  /**
   * Reset village state to initial values
   */
  reset: () => {
    set({
      userId: null,
      count: 0,
      level: VILLAGE_LEVELS[0],
      isLoading: false
    });
  }
}));

/**
 * Hook to get current village level
 * Convenience hook for components that only need the level
 */
export function useVillageLevel(): VillageLevel {
  return useVillageStore(state => state.level);
}

/**
 * Hook to get purchase count
 * Convenience hook for components that only need the count
 */
export function usePurchaseCount(): number {
  return useVillageStore(state => state.count);
}

/**
 * Hook to get village progress info
 * Returns count, level, and progress to next level
 */
export function useVillageProgress() {
  const count = useVillageStore(state => state.count);
  const level = useVillageStore(state => state.level);
  const progress = count % 10;
  const nextLevelThreshold = (level.id + 1) * 10;
  const ingredientsRemaining = nextLevelThreshold - count;
  
  return {
    count,
    level,
    progress,
    nextLevelThreshold,
    ingredientsRemaining,
    progressPercent: (progress / 10) * 100
  };
}
</file>

<file path="lib/types.ts">
// lib/types.ts
// Core TypeScript type definitions for PetPlates

export type PetCategory = 'dogs' | 'cats' | 'birds' | 'reptiles' | 'pocket-pets';
export type AgeGroupValue = 'baby' | 'young' | 'adult' | 'senior';

export interface Breed {
  id: string;
  name: string;
  category: PetCategory;
}

export interface AgeGroup {
  value: AgeGroupValue;
  label: string;
}

export interface HealthConcern {
  id: string;
  name: string;
  description: string;
  dietaryAdjustments: string[];
}

export type Species = 'dog' | 'cat' | 'bird' | 'reptile' | 'pocket-pet' | string;

export interface Ingredient {
  id: string;
  name: string;
  amount: string;
  asinLink?: string; // ASIN-based direct product link
  amazonLink?: string; // Legacy Amazon affiliate link
  productName?: string; // Vetted product name
  vetNote?: string; // Veterinary note about the product
  isVetted?: boolean; // Whether this ingredient has been vetted
  isGeneric?: boolean; // Whether this is a generic ingredient (produce/staples)
  asin?: string; // Amazon ASIN for cart operations
}

export interface RecipeNutritionInfo {
  protein?: { min: number; max: number; unit: string };
  fat?: { min: number; max: number; unit: string };
  fiber?: { min: number; max: number; unit: string };
  calories?: { min: number; max: number; unit: string };
  phosphorus?: { min: number; max: number; unit: string };
  calcium?: { min: number; max: number; unit: string };
}

export interface Recipe {
  id: string;
  name: string;
  shortName?: string;
  category: string;
  breed?: string | string[] | null;
  ageGroup: string[];
  healthConcerns: string[];
  notSuitableFor?: string[]; // Health concerns this recipe is NOT suitable for
  description?: string;
  tags?: string[];
  imageUrl?: string;
  prepTime?: string;
  cookTime?: string;
  servings?: number;
  ingredients: Ingredient[];
  instructions: string[];
  supplements?: Ingredient[]; // Optional supplements for the recipe
  nutritionalInfo?: RecipeNutritionInfo;
  nutritionInfo?: {
    protein?: string;
    fat?: string;
    fiber?: string;
    calories?: string;
    calcium?: string;
  };
  rating?: number;
  reviews?: number;
  score?: number;
  celebrityName?: string; // For celebrity pet recipes
  celebrityQuote?: string; // Quote from celebrity about the recipe
  // Enhanced fields (all optional for backward compatibility)
  needsReview?: boolean; // Flag if recipe uses estimated nutrition data or needs manual review
  validation?: {
    status: 'validated' | 'needs_review' | 'invalid';
    validatedAt?: string;
    method?: 'dry_matter' | 'as_fed' | 'estimated';
    standards?: string[];
    warnings?: string[];
    errors?: string[];
    missingIngredients?: string[];
    estimatedNutritionPercent?: number;
  };
  generationInfo?: {
    version: string;
    attempts?: number;
    confidence?: number;
  };
}

export interface Pet {
  id: string;
  name?: string;
  names?: string[];
  type: string | PetCategory;
  bannedIngredients?: string[]; // Ingredients user never wants to see for this pet
  breed?: string | null;
  age?: string;
  weight?: string;
  weightKg?: number;
  activityLevel?: 'sedentary' | 'moderate' | 'active' | 'very-active';
  mealPlan?: string[];
  savedRecipes?: string[];
  // Wellness and preference fields
  healthConcerns?: string[];
  dietaryRestrictions?: string[];
  allergies?: string[];
  allergiesSeverity?: Record<string, 'low' | 'medium' | 'high'>;
  dislikes?: string[];
  notes?: string;
  createdAt?: string;
  updatedAt?: string;
  customMeals?: CustomMeal[];
  userId?: string;
  image?: string;
  completedMealPlans?: number; // Number of completed meal plans for Planning Volume badge
}

export interface ModifiedRecipeResult {
  recipe: Recipe;
  adjustedIngredients?: Ingredient[];
  appliedRules?: AppliedModifierSummary[];
  modifications?: string[];
  nutritionalChanges?: Record<string, { before: number; after: number }> | Record<string, any>;
  portionPlan?: PortionPlan;
  portionSize?: { grams: number; calories: number };
  shoppingList?: ShoppingListItem[] | Array<{ name: string; amount: string; asinLink?: string }>;
  explanation: string;
  weeklyPlan?: WeeklyPlanEntry[];
  score?: number;
  _tierLabel?: string;
  _warning?: string;
  _healthMatch?: string;
}

// Custom meal created by user
export interface CustomMeal {
  id: string;
  petId: string;
  userId: string;
  name: string;
  createdAt: string;
  updatedAt: string;
  ingredients: Array<{
    key: string;
    grams: number;
  }>;
  analysis: {
    score: number;
    nutrients: Record<string, number>;
    totalRecipeGrams: number;
    recommendedServingGrams: number;
    breakdown: {
      nutrientCoverageScore: number;
      toxicityPenalty: number;
      balanceVarietyScore: number;
    };
    toxicityWarnings: Array<{
      message: string;
      severity: 'low' | 'medium' | 'high' | 'critical';
      ingredientKey?: string;
      ingredientName?: string;
    }>;
    allergyWarnings: Array<{
      message: string;
      severity: 'low' | 'medium' | 'high' | 'critical';
    }>;
    nutrientWarnings: Array<{
      message: string;
      severity: 'low' | 'medium' | 'high' | 'critical';
    }>;
    suggestions: Array<{
      message: string;
      action?: string;
      confidence?: 'low' | 'medium' | 'high';
    }>;
  };
}

// Pet nutrition profile for recommendation engine
export interface PetNutritionProfile {
  species: string;
  ageGroup: string;
  weightKg: number;
  breed?: string | null;
  healthConcerns?: string[];
  allergies?: string[];
  caloriesPerKgOverride?: number;
  petName?: string;
}

// Portion plan for meal recommendations
export interface PortionPlan {
  dailyGrams: number;
  multiplier: number;
  mealsPerDay: number;
  notes: string[];
  caloriesPerKg?: number;
  dailyCalories?: number;
  weeklyCalories?: number;
  dailyPortionGrams?: number;
  weeklyPortionGrams?: number;
}

// Shopping list item
export interface ShoppingListItem {
  name: string;
  amount: string;
  asinLink?: string; // ASIN-based direct product link
  notes?: string;
  category?: string;
}

// Weekly plan entry
export interface WeeklyPlanEntry {
  day: string;
  meal: string;
  recipeId: string;
}

// Applied modifier summary
export interface AppliedModifierSummary {
  ruleId: string;
  description: string;
  changes: string[];
}

// Image data for recipe images
export interface ImageData {
  url?: string;
  width?: number;
  height?: number;
  alt?: string;
  hero?: string;
  card?: {
    url: string;
    width: number;
    height: number;
    alt: string;
  };
}

// Nutritional requirement for pets
export interface NutritionalRequirement {
  protein: { min: number; max: number; unit: string };
  fat: { min: number; max: number; unit: string };
  fiber?: { min: number; max: number; unit: string };
  calcium?: { min: number; max: number; unit: string };
  phosphorus?: { min: number; max: number; unit: string };
  taurine?: { min: number; max: number; unit: string };
  calories?: { min: number; max: number; unit: string };
  vitamins?: string[];
}

// Modifier rule system
export interface IngredientOption {
  name: string;
  reason?: string;
  amount?: string;
  amountPer10kg?: string;
  amazonLink?: string;
  notes?: string;
}

export interface ModifierRule {
  id: string;
  name?: string;
  species?: Species[];
  healthConcerns?: string[];
  description?: string;
  rationale?: string;
  ruleWeight?: number;
  appliesTo?: {
    species?: Species[];
    healthConcerns?: string[];
    ageGroups?: string[];
  };
  ingredientChanges?: {
    add?: IngredientOption[];
    remove?: string[];
    substitute?: Record<string, string> | Array<{ from: string; to: string }>;
  };
  nutritionalAdjustments?: {
    protein?: { min?: number; max?: number };
    fat?: { min?: number; max?: number };
    phosphorus?: { min?: number; max?: number };
    calories?: { min?: number; max?: number };
  };
  nutritionalTargets?: Record<string, { min?: number; max?: number } | number>;
  portionAdjustments?: {
    multiplier?: number;
    notes?: string[];
  };
}
</file>

<file path="lib/types/aliasGroups.ts">
// Ingredient alias groups - handles one ASIN serving multiple ingredient concepts
// Separates retail identity (one product) from ingredient semantics (multiple names)

export interface IngredientAliasGroup {
  groupId: string;                    // e.g., "green_peas_fresh"
  canonicalName: string;              // Primary ingredient name
  aliases: string[];                  // All ingredient names sharing this ASIN
  sharedASIN: string;                 // The Amazon ASIN they all use
  
  // Validation happens once per group, not per ingredient
  validationStatus: 'valid' | 'structurally-valid' | 'ambiguous' | 'invalid';
  confidence: 'high' | 'medium' | 'low';
  lastVerified: Date;
  
  // Why these are grouped together
  groupingReason: 'same-base-ingredient' | 'known-synonyms' | 'manual-override';
  
  // Optional: differences between aliases handled in recipe logic
  preparationVariants?: Map<string, string>; // e.g., "peas (mashed)" -> "mashed"
  
  // Audit trail
  notes?: string;
}

export interface AliasGroupValidationResult {
  group: IngredientAliasGroup;
  validationResult: any; // Will use ValidationResult from retailValidation.ts
  appliesTo: string[];   // Which ingredients inherit this result
}

// Known synonym patterns for alias detection
export const KNOWN_SYNONYM_PAIRS: Array<[string, string]> = [
  // Rice variants
  ['brown rice', 'rice (hulled)'],
  
  // Fish - same product, different descriptions
  ['sardines (canned in water)', 'sardines (in water)'],
  
  // Supplements - naming variations
  ['b-complex', 'vitamin b complex'],
  ['hairball paste', 'hairball control paste'],
  
  // Broths - same product line
  ['chicken broth', 'bone broth (low sodium)'],
  ['fish broth (no salt)', 'turkey broth (no salt)'],
  
  // Oils - same oil, different names
  ['salmon oil', 'omega-3 oil'],
  ['fish oil', 'herring oil'],
  
  // Calcium sources
  ['calcium carbonate', 'eggshells (crushed)'],
  
  // Lettuce variants
  ['lettuce (romaine)', 'romaine lettuce'],
  
  // Watercress
  ['watercress', 'watercress (small amounts)'],
  
  // Peas - preparation variants
  ['peas', 'peas (mashed)'],
  ['peas', 'peas (cooked)'],
  ['green beans', 'green beans (cooked)'],
  
  // Prebiotic supplements - same family
  ['chicory root', 'inulin (prebiotic)'],
  ['chicory root', 'fructooligosaccharides (fos)'],
  ['inulin (prebiotic)', 'fructooligosaccharides (fos)'],
  
  // Joint supplements - same product line
  ['joint supplement', 'joint health supplement'],
  ['glucosamine sulfate', 'chondroitin sulfate'],
  ['joint supplement', 'glucosamine sulfate'],
  ['joint supplement', 'chondroitin sulfate'],
  
  // Bok choy variants
  ['bok choi', 'bok choy (small amounts)'],
  
  // Dubia roaches
  ['dubia roaches', 'small dubia roaches'],
  
  // Hay variants
  ['timothy hay', 'bluegrass hay'],
];

// Known conflict patterns - these should NOT be grouped
export const KNOWN_CONFLICT_PATTERNS: Array<[string, string]> = [
  // Different meats
  ['venison', 'beef'],
  ['rabbit', 'lamb'],
  ['turkey', 'chicken'],
  ['duck', 'chicken'],
  
  // Different fish
  ['herring', 'sardines'],
  
  // Completely different products
  ['mango', 'chia'],
  ['egg', 'duck'],
];
</file>

<file path="lib/types/badges.ts">
// lib/types/badges.ts
// Badge type definitions for pet achievement system

/**
 * Badge types - one-time and progressive badges
 */
export enum BadgeType {
  // Category 1: The Quality Match (Single Tier)
  NUTRIENT_NAVIGATOR = 'nutrient_navigator',
  
  // Category 2: Plan Variety & Engagement (Single Tier)
  MASTER_MEAL_PLANNER = 'master_meal_planner',
  
  // Category 3: Planning Volume (Tiered)
  PLANNING_VOLUME = 'planning_volume',
  
  // Category 4: Purchase Commitment (Tiered)
  PURCHASE_COMMITMENT = 'purchase_commitment',
}

/**
 * Badge tiers for progressive badges
 */
export type BadgeTier = 
  | 'bronze'
  | 'silver'
  | 'gold'
  | 'platinum'
  | 'diamond'
  | 'sultan'; // For Subscription Sultan

/**
 * Individual badge data
 */
export interface PetBadge {
  type: BadgeType;
  tier?: BadgeTier; // For progressive badges only
  unlockedAt: string; // ISO timestamp
  progress?: number; // Current progress count for progressive badges
  nextTierThreshold?: number; // Next tier threshold for progress display
}

/**
 * All badges for a pet
 */
export interface PetBadges {
  badges: PetBadge[];
  lastChecked?: string; // ISO timestamp of last badge check
}

/**
 * Badge unlock context for checking eligibility
 */
export interface BadgeCheckContext {
  action: 'meal_created' | 'recipe_viewed' | 'meal_plan_created' | 'recipe_saved' | 'recipe_removed' | 'meal_plan_completed' | 'purchase_confirmed';
  compatibilityScore?: number; // For Nutrient Navigator
  mealPlanCount?: number; // Unique meals in plan
  savedRecipesCount?: number; // Number of saved recipes
  weeklyPlanCompleted?: boolean; // Whether weekly plan is completed
  completionCount?: number; // Number of completed meal plans
  purchaseCount?: number; // Number of purchases
}
</file>

<file path="lib/types/index.ts">
// lib/types/index.ts
// Centralized type definitions - Single source of truth

export type PetCategory = 'dogs' | 'cats' | 'birds' | 'reptiles' | 'pocket-pets';
export type AgeGroup = 'baby' | 'young' | 'adult' | 'senior';
export type ActivityLevel = 'sedentary' | 'moderate' | 'active' | 'very-active';

/**
 * Core Pet interface
 */
export interface Pet {
  id: string;
  names: string[];
  type: PetCategory;
  breed: string;
  age: AgeGroup;
  weight?: string;
  weightKg?: number;
  activityLevel?: ActivityLevel;
  healthConcerns?: string[];
  dietaryRestrictions?: string[];
  allergies?: string[];
  dislikes?: string[];
  savedRecipes?: string[];
  image?: string;
}

/**
 * Ingredient in a recipe or custom meal
 */
export interface Ingredient {
  id?: string;
  key: string;
  name: string;
  amount?: string;
  grams?: number;
  asinLink?: string;
  purchaseLink?: string;
}

/**
 * Ingredient selection for custom meals
 */
export interface IngredientSelection {
  key: string;
  grams: number;
}

/**
 * Meal analysis result
 */
export interface MealAnalysis {
  score: number;
  nutrients: Record<string, number>;
  totalRecipeGrams: number;
  recommendedServingGrams: number;
  caToPratio?: number;
  breakdown: {
    nutrientCoverageScore: number;
    toxicityPenalty: number;
    balanceVarietyScore: number;
  };
  toxicityWarnings: Array<{
    message: string;
    severity: string;
    ingredientKey?: string;
    ingredientName?: string;
  }>;
  allergyWarnings: Array<{
    message: string;
    severity: string;
  } | string>;
  nutrientWarnings: Array<{
    message: string;
    severity: string;
  }>;
  suggestions: Array<{
    message: string;
    action?: string;
    confidence?: string;
  } | string>;
}

/**
 * Custom meal created by user
 */
export interface CustomMeal {
  id: string;
  petId: string;
  userId: string;
  name: string;
  createdAt: string;
  updatedAt: string;
  ingredients: IngredientSelection[];
  analysis: MealAnalysis;
}

/**
 * Recipe from the database
 */
export interface Recipe {
  id: string;
  name: string;
  shortName?: string;
  category: string;
  ageGroup: string[];
  healthConcerns?: string[];
  description: string;
  ingredients: Ingredient[];
  instructions: string[];
  nutritionalInfo: {
    protein: { min: number; max: number; unit: string };
    fat: { min: number; max: number; unit: string };
    calories: { min: number; max: number; unit: string };
  };
  rating: number;
  reviews: number;
  tags?: string[];
  image?: string;
  mealImage?: string;
}

/**
 * Modified recipe result from recommendation engine
 */
export interface ModifiedRecipeResult {
  recipe: Recipe;
  explanation: string;
  score?: number;
  adjustedIngredients?: Ingredient[];
}

/**
 * Breed information
 */
export interface Breed {
  id: string;
  name: string;
  category: PetCategory;
  traits?: string[];
  commonHealthConcerns?: string[];
}

/**
 * Nutritional requirement
 */
export interface NutritionalRequirement {
  nutrient: string;
  min?: number;
  max?: number;
  unit: string;
  critical?: boolean;
}

/**
 * API Error response
 */
export interface ApiError {
  code: string;
  message: string;
  statusCode: number;
  fields?: Record<string, string>;
}

/**
 * Loading state
 */
export interface LoadingState {
  loading: boolean;
  error: string | null;
}
</file>

<file path="lib/types/retailValidation.ts">
// Retail validation types for ingredient sourcing
// Separates biological truth (ingredient specs) from retail convenience (ASINs)

export interface IngredientRetailSpec {
  // Core identity validation
  requiredTokens: string[];           // Must appear in product title (e.g., ['chicken', 'breast'])
  forbiddenTokens: string[];          // Cannot appear in title (e.g., ['seasoned', 'cooked', 'breaded'])
  
  // Acceptable product forms
  acceptableForms?: string[];         // e.g., ['raw', 'frozen', 'fresh', 'canned in water']
  
  // Size constraints (optional)
  minPackageSize?: {
    amount: number;
    unit: 'g' | 'kg' | 'oz' | 'lb' | 'ml' | 'l' | 'count';
  };
  
  // Validation behavior
  validationRules: {
    titleMatch: 'strict' | 'flexible';  // strict = all tokens required, flexible = most tokens
    allowGenericBrand: boolean;         // true = store brands OK, false = name brands only
    caseSensitive: boolean;             // usually false
  };
}

export interface ProductMetadata {
  asin: string;
  title: string;
  brand?: string;
  packageSize?: {
    amount: number;
    unit: string;
    raw: string;  // Original text from title
  };
  price?: {
    amount: number;
    currency: string;
  };
  availability: 'in-stock' | 'out-of-stock' | 'unknown';
  lastFetched: Date;
}

export interface ValidationResult {
  status: 'valid' | 'structurally-valid' | 'ambiguous' | 'invalid' | 'error';
  confidence: 'high' | 'medium' | 'low';
  
  // Separate structural (safety) from semantic (naming) issues
  structuralIssues: ValidationIssue[];  // Forbidden tokens, safety violations
  semanticIssues: ValidationIssue[];    // Missing preferred tokens, naming mismatches
  
  // Explain the decision
  reasoning: {
    requiredTokensMatched: string[];
    equivalentTokensUsed: Array<{ token: string; synonym: string }>;
    forbiddenTokensFound: string[];
    structurallySound: boolean;
  };
  
  metadata?: ProductMetadata;
}

export interface ValidationIssue {
  type: 'missing-required' | 'has-forbidden' | 'size-mismatch' | 'form-mismatch' | 'dead-link' | 'ambiguous-title';
  severity: 'critical' | 'warning' | 'info';
  message: string;
  details?: any;
}

export interface VettedProductEnhanced {
  // Existing fields
  productName: string;
  asinLink: string;
  
  // New validation fields
  retailSpec?: IngredientRetailSpec;
  validationStatus?: 'validated' | 'pending' | 'flagged' | 'failed';
  confidence?: 'high' | 'medium' | 'low';
  lastVerified?: Date;
  validationNotes?: string;
}
</file>

<file path="lib/utils/abTesting.ts">
// A/B Testing Utilities for Button Copy Optimization
// Tracks which button text drives more affiliate clicks

export type ButtonVariant = 'shop-now' | 'buy-amazon' | 'get-ingredients';

export interface ButtonCopyVariant {
  id: ButtonVariant;
  text: string;
  icon?: string;
}

export const BUTTON_VARIANTS: ButtonCopyVariant[] = [
  { id: 'shop-now', text: 'Buy', icon: 'üõí' },
  { id: 'buy-amazon', text: 'Buy', icon: 'üì¶' },
  { id: 'get-ingredients', text: 'Buy', icon: '‚ú®' }
];

export const BUY_ALL_VARIANTS: ButtonCopyVariant[] = [
  { id: 'shop-now', text: 'Buy All', icon: 'üõí' },
  { id: 'buy-amazon', text: 'Buy All', icon: 'üì¶' },
  { id: 'get-ingredients', text: 'Buy All', icon: '‚ú®' }
];

// Assign user to a variant (sticky - stays same across session)
export function getAssignedVariant(): ButtonVariant {
  if (typeof window === 'undefined') return 'shop-now';
  
  // Check if user already has assigned variant
  const stored = localStorage.getItem('ab_button_variant');
  if (stored && ['shop-now', 'buy-amazon', 'get-ingredients'].includes(stored)) {
    return stored as ButtonVariant;
  }
  
  // Randomly assign new user to a variant (33/33/33 split)
  const variants: ButtonVariant[] = ['shop-now', 'buy-amazon', 'get-ingredients'];
  const random = Math.floor(Math.random() * 3);
  const assigned = variants[random];
  
  localStorage.setItem('ab_button_variant', assigned);
  return assigned;
}

// Get button text for assigned variant
export function getButtonCopy(isBuyAll: boolean = false): ButtonCopyVariant {
  const variant = getAssignedVariant();
  const variants = isBuyAll ? BUY_ALL_VARIANTS : BUTTON_VARIANTS;
  return variants.find(v => v.id === variant) || variants[0];
}

// Track button click (for conversion analysis)
export function trackButtonClick(
  variant: ButtonVariant,
  context: 'individual' | 'buy-all' | 'preview',
  ingredientName?: string
) {
  if (typeof window === 'undefined') return;
  
  const clicks = JSON.parse(localStorage.getItem('ab_button_clicks') || '[]');
  
  clicks.push({
    variant,
    context,
    ingredientName,
    timestamp: new Date().toISOString()
  });
  
  // Keep only last 1000 clicks
  if (clicks.length > 1000) {
    clicks.splice(0, clicks.length - 1000);
  }
  
  localStorage.setItem('ab_button_clicks', JSON.stringify(clicks));
}

// Get conversion stats for analysis
export function getConversionStats() {
  if (typeof window === 'undefined') return null;
  
  const clicks = JSON.parse(localStorage.getItem('ab_button_clicks') || '[]');
  
  const stats: Record<ButtonVariant, { total: number; byContext: Record<string, number> }> = {
    'shop-now': { total: 0, byContext: {} },
    'buy-amazon': { total: 0, byContext: {} },
    'get-ingredients': { total: 0, byContext: {} }
  };
  
  clicks.forEach((click: any) => {
    const variant = click.variant as ButtonVariant;
    if (stats[variant]) {
      stats[variant].total++;
      stats[variant].byContext[click.context] = (stats[variant].byContext[click.context] || 0) + 1;
    }
  });
  
  return stats;
}

// Console command to see results
export function logABTestResults() {
  const stats = getConversionStats();
  if (!stats) {
    console.log('No A/B test data available');
    return;
  }
  
  console.log('üß™ A/B Test Results - Button Copy Optimization\n');
  console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
  
  Object.entries(stats).forEach(([variant, data]) => {
    console.log(`${variant.toUpperCase()}:`);
    console.log(`  Total clicks: ${data.total}`);
    console.log(`  By context:`, data.byContext);
    console.log('');
  });
  
  // Calculate winner
  const sorted = Object.entries(stats).sort((a, b) => b[1].total - a[1].total);
  const winner = sorted[0];
  
  console.log(`üèÜ WINNER: "${winner[0]}" with ${winner[1].total} clicks`);
  console.log('\nTo reset test: localStorage.removeItem("ab_button_clicks")');
  console.log('To change your variant: localStorage.removeItem("ab_button_variant")');
}

// Make available globally for easy console access
if (typeof window !== 'undefined') {
  (window as any).logABTestResults = logABTestResults;
  (window as any).getConversionStats = getConversionStats;
}
</file>

<file path="lib/utils/affiliateLinks.ts">
// lib/utils/affiliateLinks.ts
// Utility functions to ensure all affiliate links have seller ID

const SELLER_ID = 'robinfrench-20';

/**
 * Ensures an Amazon product link has the seller ID affiliate tag.
 * If the link already has a tag, it replaces it with ours.
 * If the link doesn't have a tag, it adds ours.
 * 
 * @param url The Amazon product URL to ensure has seller ID (format: /dp/ASIN or /gp/product/ASIN)
 * @returns The URL with seller ID guaranteed
 * 
 * @example
 * ensureSellerId('https://www.amazon.com/dp/B01234567') 
 * // Returns: 'https://www.amazon.com/dp/B01234567?tag=robinfrench-20'
 */
export function ensureSellerId(url: string | undefined | null): string {
  if (!url) return '';
  
  try {
    // Remove any existing tag parameters
    const urlObj = new URL(url);
    urlObj.searchParams.delete('tag');
    urlObj.searchParams.delete('AssociateTag');
    
    // Add our seller ID
    urlObj.searchParams.set('tag', SELLER_ID);
    
    return urlObj.toString();
  } catch (e) {
    // If URL parsing fails, try simple string manipulation as fallback
    if (url.includes('?')) {
      return `${url}&tag=${SELLER_ID}`;
    }
    return `${url}?tag=${SELLER_ID}`;
  }
}

/**
 * Ensures an Amazon cart URL has the seller ID affiliate tag.
 * Cart URLs use AssociateTag parameter instead of tag parameter.
 * 
 * @param cartUrl The Amazon cart URL (format: /gp/aws/cart/add.html?ASIN.1=...)
 * @returns The cart URL with AssociateTag parameter added
 * 
 * @example
 * ensureCartUrlSellerId('https://www.amazon.com/gp/aws/cart/add.html?ASIN.1=B01234567&Quantity.1=1')
 * // Returns: 'https://www.amazon.com/gp/aws/cart/add.html?ASIN.1=B01234567&Quantity.1=1&AssociateTag=robinfrench-20'
 */
export function ensureCartUrlSellerId(cartUrl: string | undefined | null): string {
  if (!cartUrl) return '';
  
  // If it already has AssociateTag, replace it with ours
  if (cartUrl.includes('AssociateTag=')) {
    return cartUrl.replace(/AssociateTag=[^&]+/, `AssociateTag=${SELLER_ID}`);
  }
  
  // If it has tag parameter, replace with AssociateTag
  if (cartUrl.includes('tag=')) {
    return cartUrl.replace(/tag=[^&]+/, `AssociateTag=${SELLER_ID}`);
  }
  
  // Add AssociateTag parameter
  const separator = cartUrl.includes('?') ? '&' : '?';
  return `${cartUrl}${separator}AssociateTag=${SELLER_ID}`;
}

/**
 * Adds seller ID to a link only if it doesn't already have one.
 * @param url The URL to potentially add seller ID to
 * @returns The URL with seller ID if it was missing
 */
export function addSellerIdIfMissing(url: string | undefined | null): string {
  if (!url) return '';
  
  if (url.includes('tag=') || url.includes('AssociateTag=')) {
    // Already has a tag, ensure it's ours
    return ensureSellerId(url);
  }
  
  // Add our seller ID
  const separator = url.includes('?') ? '&' : '?';
  return `${url}${separator}tag=${SELLER_ID}`;
}

/**
 * Extracts ASIN from an Amazon URL.
 * Supports multiple URL formats: /dp/ASIN, /gp/product/ASIN, /product/ASIN
 * 
 * @param url The Amazon URL containing an ASIN
 * @returns The ASIN (10-character alphanumeric code) or null if not found
 * 
 * @example
 * extractASIN('https://www.amazon.com/dp/B01234567?tag=robinfrench-20')
 * // Returns: 'B01234567'
 */
export function extractASIN(url: string | undefined | null): string | null {
  if (!url) return null;
  
  // Try /dp/ASIN pattern (most common) - ASIN is 10 characters, stop at / or ? or end
  const dpMatch = url.match(/\/dp\/([A-Z0-9]{10})(?:\/|$|\?)/);
  if (dpMatch) return dpMatch[1];
  
  // Try /gp/product/ASIN pattern
  const gpMatch = url.match(/\/gp\/product\/([A-Z0-9]{10})(?:\/|$|\?)/);
  if (gpMatch) return gpMatch[1];
  
  // Try /product/ASIN pattern
  const productMatch = url.match(/\/product\/([A-Z0-9]{10})(?:\/|$|\?)/);
  if (productMatch) return productMatch[1];
  
  // Try ASIN parameter
  try {
    const urlObj = new URL(url);
    const asinParam = urlObj.searchParams.get('ASIN');
    if (asinParam && /^[A-Z0-9]{10}$/.test(asinParam)) {
      return asinParam;
    }
  } catch (e) {
    // Invalid URL, continue
  }
  
  return null;
}

/**
 * Checks if a URL has our seller ID.
 * Works with both product links (tag=) and cart links (AssociateTag=).
 * 
 * @param url The URL to check
 * @returns True if the URL has our seller ID
 * 
 * @example
 * hasSellerId('https://www.amazon.com/dp/B01234567?tag=robinfrench-20')
 * // Returns: true
 */
export function hasSellerId(url: string | undefined | null): boolean {
  if (!url) return false;
  return url.includes(`tag=${SELLER_ID}`) || url.includes(`AssociateTag=${SELLER_ID}`);
}

/**
 * Validates that a URL is a valid Amazon URL.
 * 
 * @param url The URL to validate
 * @returns True if the URL is a valid Amazon URL
 */
export function isValidAmazonUrl(url: string | undefined | null): boolean {
  if (!url) return false;
  
  try {
    const urlObj = new URL(url);
    return urlObj.hostname.includes('amazon.com') || urlObj.hostname.includes('amzn.');
  } catch (e) {
    return false;
  }
}

/**
 * Validates that a URL is an Amazon cart URL.
 * 
 * @param url The URL to validate
 * @returns True if the URL is an Amazon cart URL
 */
export function isCartUrl(url: string | undefined | null): boolean {
  if (!url) return false;
  return url.includes('/gp/aws/cart/add.html') || url.includes('/gp/cart/view.html');
}
</file>

<file path="lib/utils/allIngredients.ts">
// lib/utils/allIngredients.ts
// Extract all ingredients from generate-recipes.js INGREDIENTS object
// This contains all the scraped AAFCO and research-based ingredients
// Also includes auto-generated ingredients from scraped data

import { GENERATED_INGREDIENTS } from '@/lib/data/generatedIngredients';

export interface SpeciesIngredients {
  [category: string]: string[];
}

export interface AllIngredients {
  dogs: {
    proteins: string[];
    carbs: string[];
    vegetables: string[];
    fats: string[];
  };
  cats: {
    proteins: string[];
    carbs: string[];
    vegetables: string[];
    fats: string[];
    fiber_supplements: string[];
    supplements: string[];
  };
  birds: {
    seeds: string[];
    nuts: string[]; // Added for large parrots
    vegetables: string[];
    fruits: string[];
    supplements: string[];
  };
  reptiles: {
    insects: string[];
    whole_prey: string[]; // Added for snakes
    vegetables: string[];
    fruits: string[];
  };
  'pocket-pets': {
    hay: string[];
    vegetables: string[];
    pellets: string[];
    fruits: string[];
    hamster_additions: string[];
    sugar_glider_special: string[]; // Added for gliders
  };
}

// This is the complete ingredient list from generate-recipes.js
// Contains all scraped AAFCO and research-based ingredients
export const ALL_INGREDIENTS: AllIngredients = {
  dogs: {
    proteins: [
      'ground chicken', 'ground turkey', 'ground beef (lean)', 'ground lamb', 'salmon (boneless)',
      'chicken breast', 'chicken thighs', 'turkey breast', 'beef liver', 'chicken liver',
      'chicken hearts', 'sardines (canned in water)', 'eggs', 'Turkey Giblets', 'Chicken Giblets',
      'Duck Breast', 'Venison', 'Rabbit Meat', 'quail', 'ground pork (lean)', 'turkey necks',
      'Ground Duck', 'Turkey Thighs', 'Chicken Necks', 'Ground Venison', 'Ground Rabbit',
      'Lamb Liver', 'Turkey Liver', 'Duck Hearts', 'Quail Eggs', 'Ground Quail'
    ],
    carbs: [
      'brown rice', 'white rice', 'quinoa', 'sweet potato', 'Regular Potato',
      'oats', 'Barley', 'pumpkin', 'Butternut Squash', 'lentils',
      'chickpeas', 'black beans', 'green peas', 'Wild Rice',
      'Amaranth', 'Buckwheat', 'Millet', 'Sorghum', 'Farro', 'Bulgur',
      'Split Peas', 'Kidney Beans (mashed)', 'Pinto Beans (mashed)', 'Navy Beans (mashed)',
      'Acorn Squash', 'Spaghetti Squash', 'Delicata Squash', 'Kabocha Squash'
    ],
    vegetables: [
      'carrots', 'green beans', 'Peas', 'spinach', 'broccoli', 'zucchini',
      'kale', 'celery', 'Bell Peppers (red/green)', 'brussels sprouts', 'asparagus', 'parsley',
      'cucumber', 'lettuce (romaine)', 'arugula', 'Endive', 'Escarole', 'Dandelion Greens',
      'Collard Greens', 'Turnip Greens', 'Beet Greens', 'Radish Greens',
      'Swiss Chard', 'bok choy', 'Napa Cabbage', 'Red Cabbage', 'Green Cabbage',
      'Cauliflower', 'Romanesco Broccoli', 'Snow Peas', 'Sugar Snap Peas',
      'Fennel', 'Leeks', 'Shallots', 'Garlic (small amounts)', 'Ginger (small amounts)',
      'Artichokes', 'Eggplant', 'Tomatoes (small amounts)', 'Yellow Squash', 'Pattypan Squash',
      'Radicchio', 'Frisee', 'Mache', 'Watercress', 'Purslane', 'Miner\'s Lettuce',
      'Lamb\'s Quarters', 'Amaranth Leaves', 'Malabar Spinach', 'New Zealand Spinach'
    ],
    fats: [
      'Coconut Oil', 'Olive Oil', 'Salmon Oil', 'Flaxseed (ground)', 'Hemp Seeds',
      'Eggshells (crushed)', 'Kelp Powder', 'Turmeric', 'Fish Oil', 'Avocado Oil',
      'Sunflower Oil', 'Sesame Oil', 'Pumpkin Seed Oil', 'Walnut Oil', 'Almond Oil',
      'Cod Liver Oil', 'Herring Oil', 'Mackerel Oil', 'Sardine Oil', 'Anchovy Oil',
      'Evening Primrose Oil', 'Borage Oil', 'Black Currant Oil', 'Chia Seed Oil'
    ]
  },
  cats: {
    proteins: [
      'ground chicken', 'ground turkey', 'ground beef (lean)', 'chicken thighs',
      'Turkey Thighs', 'salmon (boneless)', 'tuna', 'chicken liver',
      'Turkey Liver', 'sardines (canned in water)', 'eggs', 'Ground Duck', 'Rabbit Meat',
      'Venison', 'quail', 'ground lamb', 'Turkey Giblets', 'Chicken Giblets',
      'Ground Venison', 'Ground Rabbit', 'Duck Liver', 'Quail Meat', 'Ground Quail',
      'turkey necks', 'Chicken Necks', 'Duck Hearts', 'Turkey Hearts', 'Mackerel (canned)',
      'Herring (canned)', 'Anchovies (canned)', 'Ground Mackerel', 'Ground Herring',
      'Lamb Liver', 'beef liver', 'ground pork (lean)',
      'Turkey Sausage (no additives)', 'Chicken Sausage (no additives)'
    ],
    carbs: [
      'pumpkin', 'brown rice', 'oats',
      'sweet potato', 'quinoa', 'Barley (cooked, minimal)',
      'Butternut Squash (mashed, minimal)', 'Acorn Squash (mashed, minimal)', 'pumpkin',
      'Oat Bran (small amounts)', 'Rice Bran (small amounts)', 'Millet (tiny amounts)',
      'Amaranth (tiny amounts)', 'Buckwheat (tiny amounts)', 'lentils',
      'chickpeas', 'green peas', 'Split Peas (mashed)',
      'black beans', 'Kidney Beans (mashed, tiny amounts)'
    ],
    vegetables: [
      'carrots', 'Peas (mashed)', 'zucchini', 'spinach',
      'broccoli', 'green beans', 'Asparagus (tips only)',
      'celery', 'parsley', 'cucumber', 'lettuce (romaine)',
      'kale', 'Collard Greens (cooked, tiny amounts)',
      'Dandelion Greens (fresh, small amounts)', 'Endive (small amounts)', 'arugula',
      'bok choy', 'Napa Cabbage (small amounts)', 'green beans',
      'Snow Peas (mashed)', 'Sugar Snap Peas (mashed)', 'Fennel (small amounts)',
      'Swiss Chard (cooked, tiny amounts)', 'Beet Greens (cooked, tiny amounts)', 'Turnip Greens (cooked, tiny amounts)',
      'Radish Greens (cooked, tiny amounts)', 'Watercress (small amounts)', 'Purslane (small amounts)',
      'Cat Grass (wheatgrass)', 'Barley Grass', 'Alfalfa Sprouts (small amounts)'
    ],
    fats: [
      'Salmon Oil', 'Fish Oil', 'Cod Liver Oil', 'Herring Oil', 'Sardine Oil',
      'Mackerel Oil', 'Anchovy Oil', 'Krill Oil', 'Algae Oil (DHA)', 'Evening Primrose Oil',
      'Borage Oil', 'Black Currant Oil', 'Chia Seed Oil', 'Hemp Seed Oil', 'Flaxseed Oil',
      'Coconut Oil', 'Olive Oil (small amounts)', 'Avocado Oil (tiny amounts)', 'Wheat Germ Oil'
    ],
    fiber_supplements: [
      'Hairball Control Paste', 'Psyllium Husk', 'Probiotic Powder', 'Digestive Enzymes',
      'Brewer\'s Yeast', 'Spirulina Powder', 'Kelp Powder', 'Wheat Germ', 'Oat Bran',
      'Rice Bran', 'Inulin (prebiotic)', 'Fructooligosaccharides (FOS)', 'Mannanoligosaccharides (MOS)',
      'Beta-glucans', 'Pectin (from apples)', 'Chicory Root', 'Jerusalem Artichoke'
    ],
    supplements: [
      'Taurine Powder', 'L-Carnitine Powder', 'Lysine Powder', 'Vitamin E Oil',
      'Vitamin C (small amounts)', 'Vitamin B Complex', 'Niacinamide', 'Biotin',
      'Egg Yolks', 'Eggshells (crushed)', 'Chicken Broth (no salt)', 'Turkey Broth (no salt)',
      'Fish Broth (no salt)', 'Bone Broth (low sodium)', 'Cranberry Extract', 'D-Mannose',
      'Ursodeoxycholic Acid (UDCA)', 'S-Adenosyl methionine (SAM-e)', 'Milk Thistle',
      'Curcumin (turmeric extract)', 'Quercetin', 'Omega-3 Capsules', 'Joint Health Supplement',
      'Glucosamine Sulfate', 'Chondroitin Sulfate', 'MSM (methylsulfonylmethane)', 'Hyaluronic Acid'
    ]
  },
  birds: {
    seeds: [
      'Millet (white/red)', 'Canary Seed', 'Niger Seed', 'Oat Groats', 'Hemp Seeds',
      'Flaxseeds', 'Sesame Seeds', 'Chia Seeds', 'quinoa', 'Rapeseed',
      'Sunflower Seeds (small amounts)', 'Pumpkin Seeds', 'Safflower Seeds', 'Nyjer Seeds',
      'Amaranth Seeds', 'Buckwheat (hulled)', 'Barley (hulled)', 'Wheat (hulled)',
      'Rice (hulled)', 'Corn (cracked)', 'Poppy Seeds', 'Teff Seeds', 'Wild Bird Mix'
    ],
    nuts: [
      'Walnuts (in shell)', 'Almonds', 'Brazil Nuts', 'Pecans', 'Macadamia Nuts', 
      'Hazelnuts', 'Pine Nuts', 'Cashews', 'Pistachios', 'Peanuts (unsalted, roasted)'
    ],
    vegetables: [
      'carrots', 'broccoli', 'spinach', 'kale', 'Bell Peppers', 'zucchini',
      'sweet potato', 'Peas', 'Corn (fresh)', 'lettuce (romaine)', 'Endive',
      'Escarole', 'arugula', 'Dandelion Greens', 'Collard Greens',
      'Turnip Greens', 'Beet Greens', 'Swiss Chard', 'bok choy', 'Napa Cabbage',
      'Cauliflower', 'Romanesco Broccoli', 'Snow Peas', 'Sugar Snap Peas', 'asparagus',
      'celery', 'Fennel', 'parsley', 'Cilantro', 'Basil', 'Mint', 'Thyme'
    ],
    fruits: [
      'Apples (no seeds)', 'blueberries', 'Strawberries', 'Mango', 'bananas',
      'Grapes (chopped)', 'Papaya', 'Melon', 'Pineapple (small amounts)', 'Kiwi',
      'Raspberries', 'Blackberries', 'Cranberries', 'Cherries (pitted)', 'Pears (no seeds)',
      'Peaches (pitted)', 'Plums (pitted)', 'Apricots (pitted)', 'Figs', 'Dates (pitted)',
      'Raisins (unsweetened)', 'Currants', 'Goji Berries', 'Mulberries'
    ],
    supplements: [
      'eggs', 'Pellets (fortified)', 'Cuttlebone', 'Honey (tiny amounts)',
      'Peanut Butter (unsalted, tiny amounts)', 'Brewer\'s Yeast', 'Spirulina Powder',
      'Kelp Powder', 'Probiotic Powder', 'Vitamin D3 Drops', 'calcium carbonate',
      'Electrolyte Powder', 'Amino Acid Supplement', 'Fish Oil', 'Joint Health Powder'
    ]
  },
  reptiles: {
    insects: [
      'Dubia Roaches', 'Crickets', 'Mealworms', 'Superworms', 'Black Soldier Fly Larvae', 'Hornworms',
      'Silkworms', 'Waxworms', 'Butterworms', 'Phoenix Worms', 'Earthworms', 'Grasshoppers',
      'Locusts', 'Mantids', 'Fruit Flies', 'Pinhead Crickets', 'Small Dubia Roaches'
    ],
    whole_prey: [
      'Pinkie Mice (frozen/thawed)', 'Fuzzy Mice', 'Hopper Mice', 'Adult Mice',
      'Rat Pups', 'Adult Rats', 'Day-Old Chicks', 'quail', 'Feeder Fish (Guppies)', 'Silversides'
    ],
    vegetables: [
      'Collard Greens', 'Turnip Greens', 'Dandelion Greens', 'Butternut Squash',
      'Bell Peppers', 'carrots', 'zucchini', 'green beans', 'Snap Peas',
      'Acorn Squash', 'Endive', 'Escarole', 'arugula', 'kale', 'Swiss Chard', 'bok choy',
      'Napa Cabbage', 'Romaine Lettuce', 'Iceberg Lettuce', 'Red Leaf Lettuce', 'Butter Lettuce',
      'Cauliflower', 'broccoli', 'Romanesco Broccoli', 'asparagus', 'celery', 'Fennel',
      'parsley', 'Cilantro', 'Basil', 'Mint', 'Thyme', 'Oregano', 'Sage', 'Rosemary',
      'sweet potato', 'pumpkin', 'Squash (various)', 'cucumber', 'Eggplant'
    ],
    fruits: [
      'blueberries', 'Mango', 'Papaya', 'Strawberries', 'Figs', 'Apples (no seeds)',
      'Pears (no seeds)', 'bananas', 'Melon', 'Cantaloupe', 'Honeydew', 'Watermelon',
      'Pineapple', 'Kiwi', 'Raspberries', 'Blackberries', 'Cranberries', 'Cherries (pitted)',
      'Peaches (pitted)', 'Plums (pitted)', 'Apricots (pitted)', 'Grapes (seedless)',
      'Raisins (unsweetened)', 'Dates (pitted)', 'Prunes', 'Goji Berries', 'Mulberries'
    ]
  },
  'pocket-pets': {
    hay: [
      'Timothy Hay', 'Meadow Hay', 'Orchard Grass Hay', 'Alfalfa Hay (babies/pregnant only)',
      'Bermuda Hay', 'Bluegrass Hay', 'Fescue Hay', 'Ryegrass Hay', 'Wheat Hay',
      'Oat Hay', 'Barley Hay', 'Straw (wheat/pine)', 'Dried Grass'
    ],
    vegetables: [
      'lettuce (romaine)', 'Bell Peppers (high vitamin C)', 'carrots', 'cucumber', 'zucchini',
      'celery', 'parsley', 'Cilantro', 'kale', 'spinach', 'broccoli',
      'arugula', 'Endive', 'Basil', 'Mint', 'Collard Greens', 'Turnip Greens',
      'Dandelion Greens', 'Swiss Chard', 'bok choy', 'Napa Cabbage', 'Red Cabbage',
      'Green Cabbage', 'Cauliflower', 'asparagus', 'Fennel', 'Leeks', 'Shallots',
      'Garlic Chives', 'Radicchio', 'Frisee', 'Mache', 'Watercress', 'Purslane',
      'Miner\'s Lettuce', 'Lamb\'s Quarters', 'Amaranth Leaves', 'Malabar Spinach',
      'New Zealand Spinach', 'sweet potato', 'pumpkin', 'Squash (cooked)'
    ],
    pellets: [
      'Guinea Pig Pellets (with vitamin C)', 'Rabbit Pellets (high fiber)', 'Hamster Pellets (higher protein)',
      'Gerbil Pellets', 'Mouse/Rat Pellets', 'Chinchilla Pellets', 'Degus Pellets',
      'Fortified Pellets (vitamin C)', 'Timothy-Based Pellets', 'Alfalfa-Based Pellets'
    ],
    fruits: [
      'Apples (no seeds)', 'Strawberries', 'blueberries', 'bananas', 'Melon', 'Grapes', 'Papaya',
      'Pears (no seeds)', 'Peaches (pitted)', 'Plums (pitted)', 'Apricots (pitted)', 'Cherries (pitted)',
      'Raspberries', 'Blackberries', 'Cranberries', 'Kiwi', 'Pineapple (small amounts)',
      'Mango (small amounts)', 'Papaya (small amounts)', 'Figs', 'Dates (pitted)', 'Raisins (unsweetened)',
      'Goji Berries', 'Mulberries', 'Currants', 'Elderberries'
    ],
    hamster_additions: [
      'Mealworms (freeze-dried)', 'eggs', 'Whole Grain Cheerios',
      'Sunflower Seeds (unsalted)', 'Pumpkin Seeds (unsalted)', 'Flaxseeds', 'Chia Seeds',
      'Hemp Seeds', 'Sesame Seeds', 'Popcorn (plain)', 'Whole Wheat Pasta (cooked)',
      'brown rice', 'quinoa', 'Amaranth (cooked)', 'Buckwheat (cooked)',
      'Millet (cooked)', 'Barley (cooked)', 'oats', 'Corn (cooked)', 'Peas (cooked)'
    ],
    sugar_glider_special: [
      'Nectar Mix (commercial)', 'Gum Arabic', 'Eucalyptus Leaves', 'Acacia Gum', 
      'Bee Pollen', 'Manuka Honey', 'calcium carbonate'
    ]
  }
};

/**
 * Get all ingredients for a specific species
 * Now includes generated ingredients from scraped data
 */
export function getIngredientsForSpecies(species: string): string[] {
  const speciesData = ALL_INGREDIENTS[species as keyof AllIngredients];
  const all: string[] = [];
  
  // Add from manual ALL_INGREDIENTS
  if (speciesData) {
    Object.values(speciesData).forEach(category => {
      if (Array.isArray(category)) {
        all.push(...category);
      }
    });
  }
  
  // Add from generated ingredients based on subtype tags
  const normalizedSpecies = species === 'dog' ? 'dog' : 
                           species === 'cat' ? 'cat' :
                           species === 'bird' || species === 'birds' ? 'bird' :
                           species === 'reptile' || species === 'reptiles' ? 'reptile' :
                           species === 'pocket-pet' || species === 'pocket-pets' ? 'pocket-pet' : species;
  
  // Map species to potential subtypes
  const possibleSubtypes: string[] = [];
  if (normalizedSpecies === 'bird') {
    possibleSubtypes.push('bird_small', 'bird_large');
  } else if (normalizedSpecies === 'reptile') {
    possibleSubtypes.push('reptile_herbivore', 'reptile_insectivore', 'reptile_omnivore', 'reptile_carnivore');
  } else if (normalizedSpecies === 'pocket-pet') {
    possibleSubtypes.push('pocket_hay', 'pocket_varied', 'pocket_carnivore', 'pocket_insectivore');
    // For pocket pets (herbivores/omnivores like hamsters, guinea pigs, rabbits),
    // avoid auto-adding generated ingredients that may include meats (e.g., rabbit).
    // Return only the curated list above.
    return [...new Set(all)];
  }
  
  // Add generated ingredients that match any of the possible subtypes
  GENERATED_INGREDIENTS.forEach(ing => {
    if (possibleSubtypes.length === 0 || possibleSubtypes.some(subtype => ing.subtypeTags.includes(subtype))) {
      all.push(ing.name);
    }
  });
  
  return [...new Set(all)]; // Remove duplicates
}

/**
 * Map ingredient name to ingredient composition key
 */
export function mapIngredientToCompositionKey(ingredientName: string): string | null {
  const normalized = ingredientName
    .toLowerCase()
    .trim()
    .replace(/\s*\([^)]*\)/g, '') // Remove parentheses
    .replace(/\s+/g, '_')
    .replace(/[^a-z0-9_]/g, '');
  
  // Import composition keys dynamically
  const { INGREDIENT_COMPOSITIONS } = require('@/lib/data/ingredientCompositions');
  
  // Direct lookup
  if (INGREDIENT_COMPOSITIONS[normalized]) {
    return normalized;
  }
  
  // Common mappings (only for variants/aliases, not fallbacks)
  const mappings: Record<string, string> = {
    'chicken_breast': 'chicken_breast',
    'chicken_liver': 'chicken_liver',
    'chicken_hearts': 'chicken_hearts',
    'beef_liver': 'beef_liver',
    'ground_beef': 'ground_beef_lean',
    'ground_turkey': 'ground_turkey',
    'ground_chicken': 'ground_chicken', // Now has its own entry
    'turkey_breast': 'turkey_breast',
    'salmon': 'salmon_atlantic',
    'tuna': 'tuna_water',
    'sardines': 'sardines_water',
    'white_rice': 'white_rice_cooked', // Now has its own entry
    'brown_rice': 'brown_rice_cooked',
    'quinoa': 'quinoa_cooked',
    'sweet_potato': 'sweet_potato',
    'pumpkin': 'pumpkin', // Now has its own entry
    'carrots': 'carrots_raw',
    'green_beans': 'green_beans_raw', // Now has its own entry
    'bok_choy': 'bok_choy', // Key uses standard spelling, but display is "Bok Choi"
    'bok_choi': 'bok_choy', // User prefers "bok choi" spelling
    'broccoli': 'broccoli_raw',
    'spinach': 'spinach_raw',
    'kale': 'kale_raw',
    'celery': 'celery_raw',
    'blueberries': 'blueberries_raw',
    'bananas': 'bananas_raw',
    'eggs': 'eggs_whole',
    'fish_oil': 'fish_oil',
    'salmon_oil': 'fish_oil', // Similar enough to use fish_oil
    'herring_oil': 'fish_oil', // Similar enough to use fish_oil
    'mackerel_oil': 'fish_oil', // Similar enough to use fish_oil
    'sardine_oil': 'fish_oil', // Similar enough to use fish_oil
    'cod_liver_oil': 'fish_oil', // Similar enough to use fish_oil
    'olive_oil': 'fish_oil', // Different but acceptable fallback
    'coconut_oil': 'fish_oil', // Different but acceptable fallback
    'avocado_oil': 'fish_oil', // Different but acceptable fallback
    'sunflower_oil': 'fish_oil', // Different but acceptable fallback
    'sesame_oil': 'fish_oil', // Different but acceptable fallback
    'oats': 'oats',
    'taurine': 'taurine_powder',
    'calcium': 'calcium_carbonate',
  };
  
  if (mappings[normalized]) {
    return mappings[normalized];
  }
  
  // Try partial matches
  for (const key in INGREDIENT_COMPOSITIONS) {
    if (normalized.includes(key) || key.includes(normalized)) {
      return key;
    }
  }
  
  return null;
}

/**
 * Get all available ingredients for recipe builder (all species combined)
 */
export function getAllAvailableIngredients(): string[] {
  const all = new Set<string>();
  
  Object.keys(ALL_INGREDIENTS).forEach(species => {
    getIngredientsForSpecies(species).forEach(ing => all.add(ing));
  });
  
  return Array.from(all).sort();
}

/**
 * Get display name for an ingredient composition key
 * Maps back to the original scraped ingredient name if available
 */
export function getIngredientDisplayName(compositionKey: string, species?: string): string {
  // If we have a species, try to find the original name from scraped data
  if (species) {
    const speciesData = ALL_INGREDIENTS[species as keyof AllIngredients];
    if (speciesData) {
      // Search through all categories for this species
      for (const category of Object.values(speciesData)) {
        if (Array.isArray(category)) {
          for (const ingName of category) {
            const mappedKey = mapIngredientToCompositionKey(ingName);
            if (mappedKey === compositionKey) {
              return ingName; // Return the original scraped name
            }
          }
        }
      }
    }
  }
  
  // Fallback: convert composition key to readable name
  return compositionKey
    .split('_')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}
</file>

<file path="lib/utils/auth.ts">
// lib/utils/auth.ts
// Centralized authentication utilities

import { useAuth, useUser } from '@clerk/nextjs';

/**
 * Get the current user ID from Clerk
 * Falls back to simulated ID for development
 */
export function useCurrentUserId(): string | null {
  const { userId } = useAuth();
  
  // Use Clerk user ID if available
  if (userId) return userId;
  
  // Fallback for development (when not authenticated)
  if (typeof window !== 'undefined') {
    const stored = localStorage.getItem('last_user_id');
    if (stored) return stored;
  }
  
  return null;
}

/**
 * Server-side: Get user ID from localStorage fallback
 * This is a temporary bridge during migration
 */
export function getStoredUserId(): string {
  if (typeof window === 'undefined') return 'server-fallback-id';
  
  const stored = localStorage.getItem('last_user_id');
  return stored || 'clerk_simulated_user_id_123';
}

/**
 * Check if user is authenticated
 */
export function useIsAuthenticated(): boolean {
  const { isSignedIn, isLoaded } = useAuth();
  return isLoaded && (isSignedIn ?? false);
}
</file>

<file path="lib/utils/badgeChecker.ts">
// lib/utils/badgeChecker.ts
// Badge checking logic for pet achievements

import { BadgeType, BadgeTier, BadgeCheckContext } from '@/lib/types/badges';
import { getPetBadges, unlockBadge, updateBadgeProgress, hasBadge } from './badgeStorage';
import { getTierForProgress, getNextTierThreshold } from '@/lib/data/badgeDefinitions';
import { getPetPurchaseCount } from './petPurchaseTracking';
import { getPets } from './petStorage';
import { logger } from './logger';

/**
 * Check The Nutrient Navigator badge (100% compatibility score)
 */
export async function checkNutrientNavigatorBadge(
  userId: string,
  petId: string,
  compatibilityScore: number
): Promise<boolean> {
  if (compatibilityScore !== 100) {
    return false;
  }

  const badges = getPetBadges(userId, petId);
  if (hasBadge(badges, BadgeType.NUTRIENT_NAVIGATOR)) {
    return false; // Already unlocked
  }

  return unlockBadge(userId, petId, BadgeType.NUTRIENT_NAVIGATOR);
}

/**
 * Check The Master Meal Planner badge (requires ALL THREE conditions)
 */
export async function checkMasterMealPlannerBadge(
  userId: string,
  petId: string,
  mealPlanCount: number,
  savedRecipesCount: number,
  weeklyPlanCompleted: boolean
): Promise<boolean> {
  // Check if ALL THREE conditions are met
  const has4PlusMeals = mealPlanCount >= 4;
  const has10PlusSaved = savedRecipesCount >= 10;
  const hasCompletedWeek = weeklyPlanCompleted;

  if (!has4PlusMeals || !has10PlusSaved || !hasCompletedWeek) {
    return false; // Not all conditions met
  }

  const badges = getPetBadges(userId, petId);
  if (hasBadge(badges, BadgeType.MASTER_MEAL_PLANNER)) {
    return false; // Already unlocked
  }

  return unlockBadge(userId, petId, BadgeType.MASTER_MEAL_PLANNER);
}

/**
 * Check Planning Volume badge (progressive: 1, 10, 50)
 */
export async function checkPlanningVolumeBadge(
  userId: string,
  petId: string,
  completionCount: number
): Promise<boolean> {
  if (completionCount < 1) {
    return false;
  }

  const tier = getTierForProgress(BadgeType.PLANNING_VOLUME, completionCount);
  if (!tier) {
    return false;
  }

  const nextThreshold = getNextTierThreshold(BadgeType.PLANNING_VOLUME, tier);
  
  updateBadgeProgress(
    userId,
    petId,
    BadgeType.PLANNING_VOLUME,
    completionCount,
    tier
  );

  // Also unlock if this is a new tier
  const badges = getPetBadges(userId, petId);
  const existingBadge = badges.badges.find(b => b.type === BadgeType.PLANNING_VOLUME);
  
  if (!existingBadge || existingBadge.tier !== tier) {
    // New tier unlocked
    unlockBadge(userId, petId, BadgeType.PLANNING_VOLUME, tier);
    return true;
  }

  // Update progress
  if (existingBadge) {
    existingBadge.progress = completionCount;
    existingBadge.nextTierThreshold = nextThreshold || undefined;
  }

  return false; // No new unlock, just progress update
}

/**
 * Check Purchase Commitment badge (progressive: 1, 10, 20, 30, 40, 50+)
 */
export async function checkPurchaseCommitmentBadge(
  userId: string,
  petId: string,
  purchaseCount: number
): Promise<boolean> {
  if (purchaseCount < 1) {
    return false;
  }

  const tier = getTierForProgress(BadgeType.PURCHASE_COMMITMENT, purchaseCount);
  if (!tier) {
    return false;
  }

  const nextThreshold = getNextTierThreshold(BadgeType.PURCHASE_COMMITMENT, tier);
  
  updateBadgeProgress(
    userId,
    petId,
    BadgeType.PURCHASE_COMMITMENT,
    purchaseCount,
    tier
  );

  // Also unlock if this is a new tier
  const badges = getPetBadges(userId, petId);
  const existingBadge = badges.badges.find(b => b.type === BadgeType.PURCHASE_COMMITMENT);
  
  if (!existingBadge || existingBadge.tier !== tier) {
    // New tier unlocked
    unlockBadge(userId, petId, BadgeType.PURCHASE_COMMITMENT, tier);
    return true;
  }

  // Update progress
  if (existingBadge) {
    existingBadge.progress = purchaseCount;
    existingBadge.nextTierThreshold = nextThreshold || undefined;
  }

  return false; // No new unlock, just progress update
}

/**
 * Main function to check all relevant badges based on action context
 */
export async function checkAllBadges(
  userId: string,
  petId: string,
  context: BadgeCheckContext
): Promise<{ unlocked: BadgeType[]; updated: BadgeType[] }> {
  const unlocked: BadgeType[] = [];
  const updated: BadgeType[] = [];

  try {
    // Load pet data for context
    const pets = await getPets(userId);
    const pet = pets.find(p => p.id === petId);
    
    if (!pet) {
      logger.warn('Pet not found for badge checking', { userId, petId });
      return { unlocked, updated };
    }

    // Check Nutrient Navigator (100% compatibility)
    if (context.compatibilityScore === 100) {
      const wasUnlocked = await checkNutrientNavigatorBadge(
        userId,
        petId,
        context.compatibilityScore
      );
      if (wasUnlocked) {
        unlocked.push(BadgeType.NUTRIENT_NAVIGATOR);
      }
    }

    // Check Master Meal Planner (requires all conditions)
    if (context.action === 'meal_plan_created' || 
        context.action === 'recipe_saved' || 
        context.action === 'recipe_removed' ||
        context.action === 'meal_plan_completed') {
      
      const mealPlanCount = context.mealPlanCount ?? 0;
      const savedRecipesCount = context.savedRecipesCount ?? (pet.savedRecipes?.length || 0);
      const weeklyPlanCompleted = context.weeklyPlanCompleted ?? false;

      const wasUnlocked = await checkMasterMealPlannerBadge(
        userId,
        petId,
        mealPlanCount,
        savedRecipesCount,
        weeklyPlanCompleted
      );
      if (wasUnlocked) {
        unlocked.push(BadgeType.MASTER_MEAL_PLANNER);
      }
    }

    // Check Planning Volume (progressive)
    if (context.action === 'meal_plan_completed' && context.completionCount !== undefined) {
      const wasUnlocked = await checkPlanningVolumeBadge(
        userId,
        petId,
        context.completionCount
      );
      if (wasUnlocked) {
        unlocked.push(BadgeType.PLANNING_VOLUME);
      } else {
        updated.push(BadgeType.PLANNING_VOLUME);
      }
    }

    // Check Purchase Commitment (progressive)
    if (context.action === 'purchase_confirmed') {
      const purchaseCount = context.purchaseCount ?? getPetPurchaseCount(userId, petId);
      
      const wasUnlocked = await checkPurchaseCommitmentBadge(
        userId,
        petId,
        purchaseCount
      );
      if (wasUnlocked) {
        unlocked.push(BadgeType.PURCHASE_COMMITMENT);
      } else {
        updated.push(BadgeType.PURCHASE_COMMITMENT);
      }
    }

  } catch (error) {
    logger.error('Error checking badges', error as Error, { userId, petId, context });
  }

  return { unlocked, updated };
}
</file>

<file path="lib/utils/badgeStorage.ts">
// lib/utils/badgeStorage.ts
// Badge storage system for pet achievements

import { PetBadges, PetBadge, BadgeType, BadgeTier } from '@/lib/types/badges';
import { safeGetItem, safeSetItem, safeParseJSON } from './localStorageSafe';
import { logger } from './logger';

const PREFIX = 'pet_badges_';

/**
 * Get storage key for pet badges
 */
function getStorageKey(userId: string, petId: string): string {
  return `${PREFIX}${userId}_${petId}`;
}

/**
 * Load badges for a pet
 */
export function getPetBadges(userId: string, petId: string): PetBadges {
  if (!userId || !petId) {
    return { badges: [] };
  }

  try {
    const key = getStorageKey(userId, petId);
    const stored = safeGetItem(key);
    
    if (!stored) {
      return { badges: [] };
    }

    const parsed = safeParseJSON<PetBadges>(stored, { badges: [] });
    if (parsed && Array.isArray(parsed.badges)) {
      return parsed;
    }

    return { badges: [] };
  } catch (error) {
    logger.error('Failed to load pet badges', error as Error, { userId, petId } as any);
    return { badges: [] };
  }
}

/**
 * Save badges for a pet
 */
export function savePetBadges(userId: string, petId: string, badges: PetBadges): void {
  if (!userId || !petId) {
    logger.warn('Cannot save badges: missing userId or petId', { userId, petId });
    return;
  }

  try {
    const key = getStorageKey(userId, petId);
    badges.lastChecked = new Date().toISOString();
    safeSetItem(key, JSON.stringify(badges));
  } catch (error) {
    logger.error('Failed to save pet badges', error as Error, { userId, petId });
  }
}

/**
 * Check if a badge is unlocked
 */
export function hasBadge(badges: PetBadges, badgeType: BadgeType, tier?: BadgeTier): boolean {
  if (!badges || !badges.badges) {
    return false;
  }

  const badge = badges.badges.find(b => b.type === badgeType);
  
  if (!badge) {
    return false;
  }

  // For progressive badges, check if tier matches or is higher
  if (tier && badge.tier) {
    const tierOrder: BadgeTier[] = ['bronze', 'silver', 'gold', 'platinum', 'diamond', 'sultan'];
    const badgeTierIndex = tierOrder.indexOf(badge.tier);
    const requiredTierIndex = tierOrder.indexOf(tier);
    return badgeTierIndex >= requiredTierIndex;
  }

  return true;
}

/**
 * Unlock a badge (idempotent - safe to call multiple times)
 */
export function unlockBadge(
  userId: string,
  petId: string,
  badgeType: BadgeType,
  tier?: BadgeTier
): boolean {
  const badges = getPetBadges(userId, petId);
  
  // Check if already unlocked
  if (hasBadge(badges, badgeType, tier)) {
    return false; // Already unlocked
  }

  // Check if badge exists but needs tier upgrade
  const existingBadge = badges.badges.find(b => b.type === badgeType);
  
  if (existingBadge && tier) {
    // Upgrade tier if new tier is higher
    const tierOrder: BadgeTier[] = ['bronze', 'silver', 'gold', 'platinum', 'diamond', 'sultan'];
    const currentTierIndex = tierOrder.indexOf(existingBadge.tier || 'bronze');
    const newTierIndex = tierOrder.indexOf(tier);
    
    if (newTierIndex > currentTierIndex) {
      existingBadge.tier = tier;
      existingBadge.unlockedAt = new Date().toISOString();
      savePetBadges(userId, petId, badges);
      return true; // Tier upgraded
    }
    
    return false; // Already at this tier or higher
  }

  // Create new badge
  const newBadge: PetBadge = {
    type: badgeType,
    tier,
    unlockedAt: new Date().toISOString(),
  };

  badges.badges.push(newBadge);
  savePetBadges(userId, petId, badges);
  return true; // New badge unlocked
}

/**
 * Update progressive badge progress
 */
export function updateBadgeProgress(
  userId: string,
  petId: string,
  badgeType: BadgeType,
  progress: number,
  tier?: BadgeTier
): boolean {
  const badges = getPetBadges(userId, petId);
  const existingBadge = badges.badges.find(b => b.type === badgeType);

  if (existingBadge) {
    // Update existing badge
    existingBadge.progress = progress;
    if (tier) {
      existingBadge.tier = tier;
    }
    existingBadge.unlockedAt = existingBadge.unlockedAt || new Date().toISOString();
    savePetBadges(userId, petId, badges);
    return true;
  } else {
    // Create new badge with progress
    const newBadge: PetBadge = {
      type: badgeType,
      tier,
      progress,
      unlockedAt: new Date().toISOString(),
    };
    badges.badges.push(newBadge);
    savePetBadges(userId, petId, badges);
    return true;
  }
}

/**
 * Get badge by type
 */
export function getBadge(badges: PetBadges, badgeType: BadgeType): PetBadge | null {
  if (!badges || !badges.badges) {
    return null;
  }
  return badges.badges.find(b => b.type === badgeType) || null;
}

/**
 * Remove a badge (for testing/demo purposes)
 */
export function removeBadge(userId: string, petId: string, badgeType: BadgeType): boolean {
  const badges = getPetBadges(userId, petId);
  const index = badges.badges.findIndex(b => b.type === badgeType);
  
  if (index === -1) {
    return false; // Badge not found
  }
  
  badges.badges.splice(index, 1);
  savePetBadges(userId, petId, badges);
  return true; // Badge removed
}
</file>

<file path="lib/utils/beep.ts">
/**
 * Beep utility for task completion notifications
 * Quiet, automatic beeps that don't require user permission
 */

/**
 * Play a quiet beep sound
 * Uses Web Audio API for a softer, less intrusive beep
 */
export function beep(frequency: number = 400, duration: number = 100, volume: number = 0.1): void {
  if (typeof window === 'undefined') return;
  
  try {
    const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    // Set quiet volume (0.1 = 10% volume)
    gainNode.gain.value = volume;
    oscillator.frequency.value = frequency;
    oscillator.type = 'sine'; // Softer sine wave instead of harsh square wave
    
    oscillator.start();
    oscillator.stop(audioContext.currentTime + duration / 1000);
  } catch (error) {
    // Fallback: silent if Web Audio API not available
    // Don't use console.beep as it's too loud and requires permission
  }
}

/**
 * Quiet beep for task completion
 */
export function taskCompleteBeep(): void {
  beep(400, 100, 0.08); // Very quiet completion beep
}

/**
 * Beep when user action is needed (approval/run)
 */
export function actionNeededBeep(): void {
  beep(500, 150, 0.12); // Slightly louder for important notifications
}
</file>

<file path="lib/utils/buyLinkValidation.ts">
// Intent-based buy link validation
// Validates Amazon links point to correct product TYPE, not exact title match

export type BuyLinkIntent =
  | 'produce'        // Fresh fruits/vegetables
  | 'pantry'         // Rice, oats, canned goods, grains
  | 'oil'            // Cooking oils, fish oils, supplements
  | 'supplement'     // Vitamins, minerals, health supplements
  | 'pet-feed'       // Hay, pellets, pet-specific foods
  | 'insect'         // Live/dried insects for reptiles/birds
  | 'meat'           // Fresh/frozen meat, organs
  | 'other';         // Catch-all

export interface IngredientRetailValidation {
  intent: BuyLinkIntent;
  required?: string[];   // Tokens that MUST appear in title (case-insensitive)
  forbidden?: string[];  // Tokens that must NOT appear (indicates wrong product)
  optional?: string[];   // Bonus tokens (not enforced, but good to have)
}

export type ValidationResult = 'PASS' | 'WARN' | 'FAIL';

export interface ValidationReport {
  result: ValidationResult;
  reason?: string;
  matchedRequired?: string[];
  foundForbidden?: string[];
  suggestions?: string[];
}

/**
 * Validates an Amazon product title against ingredient expectations.
 * Uses intent + token matching instead of string similarity.
 */
export function validateProductTitle(
  productTitle: string,
  validation: IngredientRetailValidation
): ValidationReport {
  const normalizedTitle = productTitle.toLowerCase();
  const tokens = normalizedTitle.split(/\s+/);
  
  // Check forbidden tokens (immediate fail)
  if (validation.forbidden) {
    const foundForbidden = validation.forbidden.filter(token => 
      normalizedTitle.includes(token.toLowerCase())
    );
    
    if (foundForbidden.length > 0) {
      return {
        result: 'FAIL',
        reason: `Contains forbidden tokens: ${foundForbidden.join(', ')}`,
        foundForbidden,
        suggestions: ['Find product without these terms', 'Check if this is cosmetic/non-food grade'],
      };
    }
  }
  
  // Check required tokens
  if (validation.required && validation.required.length > 0) {
    const matchedRequired = validation.required.filter(token =>
      normalizedTitle.includes(token.toLowerCase())
    );
    
    if (matchedRequired.length === 0) {
      return {
        result: 'FAIL',
        reason: `Missing all required tokens: ${validation.required.join(', ')}`,
        suggestions: ['Verify ASIN points to correct product type', 'Search for product with required terms'],
      };
    }
    
    if (matchedRequired.length < validation.required.length) {
      return {
        result: 'WARN',
        reason: `Missing some required tokens: ${validation.required.filter(t => !matchedRequired.includes(t)).join(', ')}`,
        matchedRequired,
        suggestions: ['Review if partial match is acceptable'],
      };
    }
    
    return {
      result: 'PASS',
      matchedRequired,
    };
  }
  
  // No required tokens - just check intent is reasonable
  return {
    result: 'PASS',
    reason: 'No specific validation rules, assuming correct',
  };
}

/**
 * Infers validation rules from ingredient name and category.
 * This provides sensible defaults when explicit rules aren't defined.
 */
export function inferValidationRules(
  ingredientName: string,
  category: string
): IngredientRetailValidation {
  const name = ingredientName.toLowerCase();
  
  // Oils - require "oil" and forbid cosmetic terms
  if (category === 'Oil' || name.includes('oil')) {
    const oilType = name.replace(/\s*oil.*/, '').trim();
    return {
      intent: 'oil',
      required: ['oil'],
      forbidden: ['massage', 'hair', 'skin', 'cosmetic', 'beauty', 'lotion', 'aromatherapy'],
      optional: [oilType, 'food', 'grade', 'culinary'],
    };
  }
  
  // Supplements - require supplement-related terms
  if (category === 'Supplement' || name.includes('supplement') || name.includes('vitamin')) {
    return {
      intent: 'supplement',
      forbidden: ['dog', 'cat', 'pet', 'chew', 'treat'], // Avoid pet-specific supplements
    };
  }
  
  // Meat - require meat type, forbid treats/jerky
  if (category === 'Meat') {
    return {
      intent: 'meat',
      forbidden: ['treat', 'jerky', 'chew', 'toy', 'dog', 'cat'],
      optional: ['fresh', 'frozen', 'raw'],
    };
  }
  
  // Insects - require insect type
  if (category === 'Insect') {
    return {
      intent: 'insect',
      forbidden: ['food', 'mix', 'blend'], // Avoid mixes, want pure insects
    };
  }
  
  // Hay/Pellets - pet-specific is OK
  if (category === 'Hay' || category === 'Pellet') {
    return {
      intent: 'pet-feed',
    };
  }
  
  // Vegetables/Fruits - produce
  if (category === 'Vegetable' || category === 'Fruit') {
    return {
      intent: 'produce',
      forbidden: ['juice', 'powder', 'extract'], // Want whole produce
    };
  }
  
  // Grains/Carbs - pantry items
  if (category === 'Carb' || category === 'Grain') {
    return {
      intent: 'pantry',
      forbidden: ['flour', 'bread', 'cereal'], // Want whole grains
    };
  }
  
  // Seeds
  if (category === 'Seed') {
    return {
      intent: 'pantry',
      forbidden: ['mix', 'blend', 'food'], // Want pure seeds
    };
  }
  
  return {
    intent: 'other',
  };
}

/**
 * Generates a suggested Amazon search query for manual ASIN lookup.
 */
export function generateSearchQuery(
  ingredientName: string,
  validation: IngredientRetailValidation
): string {
  const terms = [ingredientName];
  
  // Add intent-specific qualifiers
  if (validation.intent === 'oil') {
    terms.push('food grade', 'culinary');
  } else if (validation.intent === 'supplement') {
    terms.push('dietary supplement');
  } else if (validation.intent === 'meat') {
    terms.push('fresh', 'raw');
  } else if (validation.intent === 'produce') {
    terms.push('organic', 'fresh');
  }
  
  // Add required tokens if specified
  if (validation.required) {
    terms.push(...validation.required);
  }
  
  return terms.join(' ');
}

/**
 * Creates an Amazon search URL with affiliate tag.
 */
export function generateSearchUrl(searchQuery: string): string {
  const encoded = encodeURIComponent(searchQuery);
  return `https://www.amazon.com/s?k=${encoded}&tag=robinfrench-20`;
}
</file>

<file path="lib/utils/convertCustomMealToRecipe.ts">
import type { CustomMeal, Recipe } from '@/lib/types';

/**
 * Converts a CustomMeal to Recipe format for display in recipe detail pages
 */
export function convertCustomMealToRecipe(customMeal: CustomMeal): Recipe {
  return {
    id: customMeal.id,
    name: customMeal.name,
    category: 'custom' as any,
    ageGroup: ['adult'],
    healthConcerns: [],
    description: `Custom meal created on ${customMeal.createdAt ? new Date(customMeal.createdAt).toLocaleDateString() : 'unknown date'}`,
    ingredients: customMeal.ingredients.map((ing, idx) => ({
      id: `${idx + 1}`,
      name: ing.key.replace(/_/g, ' '),
      amount: `${ing.grams}g`,
    })),
    instructions: [
      'Mix all ingredients according to saved recipe',
      'Serve at recommended portion size',
      `Recommended serving: ${customMeal.analysis.recommendedServingGrams}g`,
    ],
    nutritionalInfo: {
      protein: {
        min: (customMeal.analysis.nutrients.protein_g || 0) / (customMeal.analysis.totalRecipeGrams / 100),
        max: (customMeal.analysis.nutrients.protein_g || 0) / (customMeal.analysis.totalRecipeGrams / 100),
        unit: '%',
      },
      fat: {
        min: (customMeal.analysis.nutrients.fat_g || 0) / (customMeal.analysis.totalRecipeGrams / 100),
        max: (customMeal.analysis.nutrients.fat_g || 0) / (customMeal.analysis.totalRecipeGrams / 100),
        unit: '%',
      },
      calories: {
        min: customMeal.analysis.nutrients.kcal || customMeal.analysis.nutrients.calories_kcal || 0,
        max: customMeal.analysis.nutrients.kcal || customMeal.analysis.nutrients.calories_kcal || 0,
        unit: 'kcal',
      },
    },
    rating: 0,
    reviews: 0,
    tags: ['custom', 'user-created'],
  };
}
</file>

<file path="lib/utils/customMealStorage.ts">
// lib/utils/customMealStorage.ts
// Abstracted custom meal storage layer - Migrated to Firestore
// Note: All operations are now ASYNCHRONOUS

import { CustomMeal } from '@/lib/types';
import { MealAnalysis, IngredientSelection } from '@/lib/analyzeCustomMeal';
import * as firestoreService from '@/lib/services/firestoreService';
import { getPets, savePet } from './petStorage';
import { checkAllBadges } from './badgeChecker';

/**
 * Retrieves all custom meals for a given pet.
 * 
 * @param userId - User identifier
 * @param petId - Pet identifier
 * @returns Promise<CustomMeal[]>
 */
export async function getCustomMeals(userId: string, petId: string): Promise<CustomMeal[]> {
  if (!userId || !petId) return [];
  
  // TEMPORARY: Skip Firestore entirely if no Firebase config
  const hasFirebase = typeof process !== 'undefined' && process.env?.NEXT_PUBLIC_FIREBASE_API_KEY;
  if (!hasFirebase) {
    console.log('Firebase not configured - loading custom meals from localStorage only');
    if (typeof window !== 'undefined') {
      const stored = localStorage.getItem(`custom_meals_${userId}_${petId}`);
      try {
        return stored ? JSON.parse(stored) : [];
      } catch {
        return [];
      }
    }
    return [];
  }
  
  try {
    return await firestoreService.getCustomMeals(userId, petId);
  } catch (e) {
    console.warn('Firestore getCustomMeals failed', e);
    // Fallback to localStorage
    if (typeof window !== 'undefined') {
      const stored = localStorage.getItem(`custom_meals_${userId}_${petId}`);
      return stored ? JSON.parse(stored) : [];
    }
    return [];
  }
}

/**
 * Saves a custom meal to storage.
 * 
 * @param userId - User identifier
 * @param petId - Pet identifier
 * @param mealName - Name of the meal
 * @param ingredients - Array of ingredient selections
 * @param analysis - Meal analysis results
 * @returns Promise<CustomMeal>
 */
export async function saveCustomMeal(
  userId: string,
  petId: string,
  mealName: string,
  ingredients: IngredientSelection[],
  analysis: MealAnalysis
): Promise<CustomMeal> {
  const now = new Date().toISOString();
  
  const customMeal: CustomMeal = {
    id: `custom_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    petId,
    userId,
    name: mealName,
    createdAt: now,
    updatedAt: now,
    ingredients: ingredients.map(ing => ({
      key: ing.key,
      grams: ing.grams
    })),
    analysis: {
      score: analysis.score,
      nutrients: analysis.nutrients,
      totalRecipeGrams: analysis.totalRecipeGrams,
      recommendedServingGrams: analysis.recommendedServingGrams,
      breakdown: analysis.breakdown,
      toxicityWarnings: analysis.toxicityWarnings.map(w => ({
        message: w.message,
        severity: w.severity,
        ingredientKey: w.ingredientKey,
        ingredientName: w.ingredientName,
      })),
      allergyWarnings: analysis.allergyWarnings.map(w => ({
        message: typeof w === 'string' ? w : w.message,
        severity: typeof w === 'string' ? 'medium' : w.severity,
      })),
      nutrientWarnings: analysis.nutrientWarnings.map(w => ({
        message: w.message,
        severity: w.severity,
      })),
      suggestions: analysis.suggestions.map(s => ({
        message: typeof s === 'string' ? s : s.message,
        action: typeof s === 'string' ? undefined : s.action,
        confidence: typeof s === 'string' ? undefined : s.confidence,
      })),
    },
  };
  
  // TEMPORARY: Skip Firestore entirely if no Firebase config
  const hasFirebase = typeof process !== 'undefined' && process.env?.NEXT_PUBLIC_FIREBASE_API_KEY;
  if (!hasFirebase) {
    console.log('Firebase not configured - saving custom meal to localStorage only');
    
    // Save to localStorage
    if (typeof window !== 'undefined') {
      const stored = localStorage.getItem(`custom_meals_${userId}_${petId}`);
      const meals = stored ? JSON.parse(stored) : [];
      meals.push(customMeal);
      localStorage.setItem(`custom_meals_${userId}_${petId}`, JSON.stringify(meals));
    }
    
    // Also add the custom meal ID to the pet's savedRecipes array
    const pets = await getPets(userId);
    const pet = pets.find(p => p.id === petId);
    
    if (pet) {
      const savedRecipes = pet.savedRecipes || [];
      if (!savedRecipes.includes(customMeal.id)) {
        const updatedPet = {
          ...pet,
          savedRecipes: [...savedRecipes, customMeal.id],
        };
        await savePet(userId, updatedPet);
      }
    }
    
    // Dispatch custom event for same-tab updates
    if (typeof window !== 'undefined') {
      window.dispatchEvent(new CustomEvent('customMealsUpdated', { 
        detail: { userId, petId, mealId: customMeal.id } 
      }));
    }
    
    // Check badges (Nutrient Navigator if score is 100)
    // Note: analysis.score might be a different metric, we'll check compatibility score separately
    // For now, we'll check badges when the meal is viewed/scored elsewhere
    // This is a placeholder - actual compatibility scoring happens in MealCompleteView
    
    return customMeal;
  }
  
  // Save to Firestore
  await firestoreService.saveCustomMeal(userId, customMeal);
  
  // Also add the custom meal ID to the pet's savedRecipes array
  // We need to fetch the pet, update it, and save it back
  const pets = await getPets(userId);
  const pet = pets.find(p => p.id === petId);
  
  if (pet) {
    const savedRecipes = pet.savedRecipes || [];
    if (!savedRecipes.includes(customMeal.id)) {
      const updatedPet = {
        ...pet,
        savedRecipes: [...savedRecipes, customMeal.id],
      };
      await savePet(userId, updatedPet);
    }
  }
  
  // Backup to localStorage for safety
  if (typeof window !== 'undefined') {
    const stored = localStorage.getItem(`custom_meals_${userId}_${petId}`);
    const meals = stored ? JSON.parse(stored) : [];
    meals.push(customMeal);
    localStorage.setItem(`custom_meals_${userId}_${petId}`, JSON.stringify(meals));
    
    // Dispatch custom event for same-tab updates
    window.dispatchEvent(new CustomEvent('customMealsUpdated', { 
      detail: { userId, petId, mealId: customMeal.id } 
    }));
  }
  
  return customMeal;
}

/**
 * Deletes a custom meal from storage.
 * 
 * @param userId - User identifier
 * @param petId - Pet identifier
 * @param mealId - Meal ID to delete
 * @returns Promise<void>
 */
export async function deleteCustomMeal(userId: string, petId: string, mealId: string): Promise<void> {
  // TEMPORARY: Skip Firestore entirely if no Firebase config
  const hasFirebase = typeof process !== 'undefined' && process.env?.NEXT_PUBLIC_FIREBASE_API_KEY;
  if (!hasFirebase) {
    console.log('Firebase not configured - deleting custom meal from localStorage only');
    
    // Delete from localStorage
    if (typeof window !== 'undefined') {
      const stored = localStorage.getItem(`custom_meals_${userId}_${petId}`);
      if (stored) {
        try {
          const meals: any[] = JSON.parse(stored);
          const filtered = meals.filter(m => m.id !== mealId);
          localStorage.setItem(`custom_meals_${userId}_${petId}`, JSON.stringify(filtered));
        } catch (e) {
          console.error('Error deleting custom meal from localStorage:', e);
        }
      }
    }
    
    // Also remove from pet's savedRecipes
    const pets = await getPets(userId);
    const pet = pets.find(p => p.id === petId);
    
    if (pet) {
      const savedRecipes = pet.savedRecipes || [];
      const updatedPet = {
        ...pet,
        savedRecipes: savedRecipes.filter(id => id !== mealId),
      };
      await savePet(userId, updatedPet);
    }
    
    return;
  }
  
  await firestoreService.deleteCustomMeal(userId, mealId);
  
  // Also remove from pet's savedRecipes
  const pets = await getPets(userId);
  const pet = pets.find(p => p.id === petId);
  
  if (pet) {
    const savedRecipes = pet.savedRecipes || [];
    const updatedPet = {
      ...pet,
      savedRecipes: savedRecipes.filter(id => id !== mealId),
    };
    await savePet(userId, updatedPet);
  }
  
  // Sync localStorage
  if (typeof window !== 'undefined') {
    const stored = localStorage.getItem(`custom_meals_${userId}_${petId}`);
    if (stored) {
      const meals: any[] = JSON.parse(stored);
      const filtered = meals.filter(m => m.id !== mealId);
      localStorage.setItem(`custom_meals_${userId}_${petId}`, JSON.stringify(filtered));
    }
  }
}

/**
 * Gets a single custom meal by ID.
 * 
 * @param userId - User identifier
 * @param petId - Pet identifier
 * @param mealId - Meal ID to retrieve
 * @returns Promise<CustomMeal | null>
 */
export async function getCustomMeal(userId: string, petId: string, mealId: string): Promise<CustomMeal | null> {
  const meals = await getCustomMeals(userId, petId);
  return meals.find(m => m.id === mealId) || null;
}

/**
 * Updates a custom meal's name.
 * 
 * @param userId - User identifier
 * @param petId - Pet identifier
 * @param mealId - Meal ID to update
 * @param newName - New name for the meal
 * @returns Promise<void>
 */
export async function updateCustomMealName(
  userId: string,
  petId: string,
  mealId: string,
  newName: string
): Promise<void> {
  const meal = await getCustomMeal(userId, petId, mealId);
  if (meal) {
    meal.name = newName;
    meal.updatedAt = new Date().toISOString();
    await firestoreService.saveCustomMeal(userId, meal);
    
    // Sync localStorage
    if (typeof window !== 'undefined') {
      const stored = localStorage.getItem(`custom_meals_${userId}_${petId}`);
      if (stored) {
        const meals: any[] = JSON.parse(stored);
        const localMeal = meals.find(m => m.id === mealId);
        if (localMeal) {
          localMeal.name = newName;
          localMeal.updatedAt = meal.updatedAt;
          localStorage.setItem(`custom_meals_${userId}_${petId}`, JSON.stringify(meals));
        }
      }
    }
  }
}
</file>

<file path="lib/utils/customMealStorageFirebase.ts">
// lib/utils/customMealStorageFirebase.ts
// Firebase implementation of custom meal storage
// This replaces localStorage with Firestore while maintaining the same API

import type { CustomMeal } from '@/lib/types';
import type { MealAnalysis, IngredientSelection } from '@/lib/analyzeCustomMeal';
import { getFirebaseServices, getAppId } from './firebaseConfig';
import { 
  collection, 
  doc, 
  addDoc, 
  getDocs, 
  getDoc, 
  deleteDoc, 
  updateDoc,
  onSnapshot,
  query,
  where,
  type Firestore
} from 'firebase/firestore';

/**
 * Firebase implementation of getCustomMeals
 * Uses real-time listener (onSnapshot) for live updates
 */
export function getCustomMealsFirebase(
  userId: string, 
  petId: string,
  onUpdate?: (meals: CustomMeal[]) => void
): () => void {
  const services = getFirebaseServices();
  if (!services) {
    // Fallback to localStorage if Firebase not available
    const { getCustomMeals } = require('./customMealStorage');
    const meals = getCustomMeals(userId, petId);
    if (onUpdate) onUpdate(meals);
    return () => {}; // No-op unsubscribe
  }
  
  const { db } = services;
  const appId = getAppId();
  const recipesRef = collection(db, `artifacts/${appId}/users/${userId}/recipes`);
  
  // Query for recipes for this pet
  const q = query(recipesRef, where('petId', '==', petId));
  
  // Set up real-time listener
  const unsubscribe = onSnapshot(q, (snapshot) => {
    const meals: CustomMeal[] = [];
    snapshot.forEach((docSnap) => {
      const data = docSnap.data();
      meals.push({
        id: docSnap.id,
        ...data
      } as CustomMeal);
    });
    
    // Sort by most recent first
    meals.sort((a, b) => 
      new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
    );
    
    if (onUpdate) {
      onUpdate(meals);
    }
  }, (error) => {
    console.error('Error listening to custom meals:', error);
    // Fallback to localStorage on error
    const { getCustomMeals } = require('./customMealStorage');
    const meals = getCustomMeals(userId, petId);
    if (onUpdate) onUpdate(meals);
  });
  
  return unsubscribe;
}

/**
 * Firebase implementation of saveCustomMeal
 */
export async function saveCustomMealFirebase(
  userId: string,
  petId: string,
  mealName: string,
  ingredients: IngredientSelection[],
  analysis: MealAnalysis
): Promise<CustomMeal> {
  const services = getFirebaseServices();
  if (!services) {
    // Fallback to localStorage
    const { saveCustomMeal } = require('./customMealStorage');
    return saveCustomMeal(userId, petId, mealName, ingredients, analysis);
  }
  
  const { db } = services;
  const appId = getAppId();
  const recipesRef = collection(db, `artifacts/${appId}/users/${userId}/recipes`);
  
  const now = new Date().toISOString();
  
  const customMealData = {
    petId,
    userId,
    name: mealName,
    createdAt: now,
    updatedAt: now,
    ingredients: ingredients.map(ing => ({
      key: ing.key,
      grams: ing.grams
    })),
    analysis: {
      score: analysis.score,
      nutrients: analysis.nutrients,
      totalRecipeGrams: analysis.totalRecipeGrams,
      recommendedServingGrams: analysis.recommendedServingGrams,
      breakdown: {
        nutrientCoverageScore: analysis.breakdown.nutrientCoverageScore,
        toxicityPenalty: analysis.breakdown.toxicityPenalty,
        balanceVarietyScore: analysis.breakdown.balanceVarietyScore,
      },
      toxicityWarnings: analysis.toxicityWarnings.map(w => ({
        message: w.message,
        severity: w.severity,
        ingredientKey: w.ingredientKey,
        ingredientName: w.ingredientName,
      })),
      allergyWarnings: analysis.allergyWarnings.map(w => ({
        message: typeof w === 'string' ? w : w.message,
        severity: typeof w === 'string' ? 'medium' : w.severity,
      })),
      nutrientWarnings: analysis.nutrientWarnings.map(w => ({
        message: w.message,
        severity: w.severity,
      })),
      suggestions: analysis.suggestions.map(s => ({
        message: typeof s === 'string' ? s : s.message,
        action: typeof s === 'string' ? undefined : s.action,
        confidence: typeof s === 'string' ? undefined : s.confidence,
      })),
    },
  };
  
  try {
    const docRef = await addDoc(recipesRef, customMealData);
    return {
      id: docRef.id,
      ...customMealData
    } as CustomMeal;
  } catch (error) {
    console.error('Error saving custom meal to Firestore:', error);
    // Fallback to localStorage
    const { saveCustomMeal } = require('./customMealStorage');
    return saveCustomMeal(userId, petId, mealName, ingredients, analysis);
  }
}

/**
 * Firebase implementation of deleteCustomMeal
 */
export async function deleteCustomMealFirebase(
  userId: string,
  petId: string,
  mealId: string
): Promise<void> {
  const services = getFirebaseServices();
  if (!services) {
    // Fallback to localStorage
    const { deleteCustomMeal } = require('./customMealStorage');
    return deleteCustomMeal(userId, petId, mealId);
  }
  
  const { db } = services;
  const appId = getAppId();
  const mealRef = doc(db, `artifacts/${appId}/users/${userId}/recipes/${mealId}`);
  
  try {
    await deleteDoc(mealRef);
  } catch (error) {
    console.error('Error deleting custom meal from Firestore:', error);
    // Fallback to localStorage
    const { deleteCustomMeal } = require('./customMealStorage');
    return deleteCustomMeal(userId, petId, mealId);
  }
}

/**
 * Firebase implementation of getCustomMeal
 */
export async function getCustomMealFirebase(
  userId: string,
  petId: string,
  mealId: string
): Promise<CustomMeal | null> {
  const services = getFirebaseServices();
  if (!services) {
    // Fallback to localStorage
    const { getCustomMeal } = require('./customMealStorage');
    return getCustomMeal(userId, petId, mealId);
  }
  
  const { db } = services;
  const appId = getAppId();
  const mealRef = doc(db, `artifacts/${appId}/users/${userId}/recipes/${mealId}`);
  
  try {
    const docSnap = await getDoc(mealRef);
    if (docSnap.exists()) {
      return {
        id: docSnap.id,
        ...docSnap.data()
      } as CustomMeal;
    }
    return null;
  } catch (error) {
    console.error('Error getting custom meal from Firestore:', error);
    // Fallback to localStorage
    const { getCustomMeal } = require('./customMealStorage');
    return getCustomMeal(userId, petId, mealId);
  }
}
</file>

<file path="lib/utils/diversityTracker.ts">
import type { Ingredient } from '@/lib/types';

export interface MealHistoryEntry {
  petId: string;
  recipeId: string;
  recipeName: string;
  ingredients: string[];
  fedAt: Date;
}

const HISTORY_KEY = (petId: string) => `mealHistory_${petId}`;

function readHistory(petId: string): MealHistoryEntry[] {
  if (typeof window === 'undefined') return [];
  try {
    const raw = localStorage.getItem(HISTORY_KEY(petId));
    if (!raw) return [];
    const parsed = JSON.parse(raw) as MealHistoryEntry[];
    return parsed.map((e) => ({ ...e, fedAt: new Date(e.fedAt) }));
  } catch {
    return [];
  }
}

function writeHistory(petId: string, entries: MealHistoryEntry[]) {
  if (typeof window === 'undefined') return;
  localStorage.setItem(HISTORY_KEY(petId), JSON.stringify(entries));
}

// Log a meal fed to a pet
export function logMealFed(entry: MealHistoryEntry): void {
  if (typeof window === 'undefined') return;
  const existing = readHistory(entry.petId);
  const withDate = { ...entry, fedAt: new Date(entry.fedAt) };
  existing.unshift(withDate);
  // Cap history to avoid unbounded growth
  writeHistory(entry.petId, existing.slice(0, 200));
}

// Get meal history for a pet, optionally limited by days
export function getMealHistory(petId: string, days?: number): MealHistoryEntry[] {
  const history = readHistory(petId);
  if (!days) return history.sort((a, b) => b.fedAt.getTime() - a.fedAt.getTime());
  const cutoff = Date.now() - days * 24 * 60 * 60 * 1000;
  return history
    .filter((h) => h.fedAt.getTime() >= cutoff)
    .sort((a, b) => b.fedAt.getTime() - a.fedAt.getTime());
}

// Get unique ingredient names used in the past N days
export function getRecentIngredients(petId: string, days: number = 7): string[] {
  const recent = getMealHistory(petId, days);
  const set = new Set<string>();
  recent.forEach((m) => m.ingredients.forEach((ing) => set.add(ing.toLowerCase().trim())));
  return Array.from(set);
}

// Calculate overlap-based diversity penalty
export function calculateDiversityPenalty(
  recipeIngredients: string[],
  recentIngredients: string[]
): { overlap: number; penalty: number } {
  const normRecent = recentIngredients.map((r) => r.toLowerCase());
  const overlap = recipeIngredients.filter((ing) => normRecent.includes(ing.toLowerCase())).length;
  return { overlap, penalty: overlap * 5 };
}

// Normalize ingredient names from Recipe ingredient objects or strings
export function normalizeIngredientNames(ings: (string | Ingredient)[]): string[] {
  return ings.map((ing) => (typeof ing === 'string' ? ing : ing.name || ing.id)).map((n) => n.toLowerCase().trim());
}
</file>

<file path="lib/utils/emojiMapping.ts">
// lib/utils/emojiMapping.ts
// Smart emoji to image mapping based on actual grid content

/**
 * Based on NEW grid analysis (updated with latest uploads):
 * - amojis.png: 8x10 grid, 80 unique animal emojis (NEW - segmented as amojis_001.png through amojis_080.png)
 * - copilot_emojis: 10x11 grid, 110 emojis (more variety, includes symbols)
 * - emoji_grid: 7 grids, 64 each (some duplicates with amojis)
 * - best set: 4x4 grid, 16 ultra-minimalist icons (NEW - segmented with descriptive names)
 * 
 * Priority: best > amojis > copilot > emoji_grid
 * 
 * NEW Best set grid layout (4x4):
 * Row 1: Dog (best_dog.png), Cat (best_cat.png), Bird (best_bird.png), Lizard/Frog (best_reptile.png)
 * Row 2: Rabbit (best_rabbit.png), Hamster (best_hamster.png), Thumbs Up Left (best_thumbs_up_left.png), Thumbs Up Right (best_thumbs_up_right.png)
 * Row 3: Balance Scale (best_balance_scale.png), Warning (best_warning.png), Check Mark (best_check_mark.png), Trophy (best_trophy.png)
 * Row 4: Paw Prints (best_paw_prints.png), Star (best_star.png), Sparkle Single (best_sparkle_single.png), Sparkles Multiple (best_sparkles_multiple.png)
 */

// Primary pet emojis - using mascot images
export const PET_EMOJI_MAP: Record<string, string> = {
  // Main pet types - using mascot images
  'üêï': '/images/emojis/Mascots/Prep Puppy.jpg', // Dog - Prep Puppy mascot
  'üê∂': '/images/emojis/Mascots/Prep Puppy.jpg', // Dog (alternative) - Prep Puppy mascot
  'üêà': '/images/emojis/Mascots/ProfessorPurffesor.jpg', // Cat - Professor Purrfessor mascot
  'üê±': '/images/emojis/Mascots/ProfessorPurffesor.jpg', // Cat (alternative) - Professor Purrfessor mascot
  'ü¶ú': '/images/emojis/Mascots/RobinRed-Route.jpg', // Bird/Parrot - Robin Redroute mascot
  'üê¶': '/images/emojis/Mascots/RobinRed-Route.jpg', // Bird (alternative) - Robin Redroute mascot
  'ü¶é': '/images/emojis/Mascots/SherlockShells.jpg', // Lizard/Frog - Sherlock Shells mascot
  'üê¢': '/images/emojis/Mascots/SherlockShells.jpg', // Turtle (alternative) - Sherlock Shells mascot
  'üê∞': '/images/emojis/Mascots/harvesthamster.jpg', // Rabbit - Harvest Hamster mascot
  'üêá': '/images/emojis/Mascots/harvesthamster.jpg', // Rabbit (alternative) - Harvest Hamster mascot
  
  // Pocket pet variations - using mascot images
  'üêπ': '/images/emojis/Mascots/harvesthamster.jpg', // Hamster - Harvest Hamster mascot
  'üê≠': '/images/emojis/amojis_038.png', // Mouse (not in best set, using amojis fallback - Row 5, position 8)
  'ü¶î': '/images/emojis/Mascots/harvesthamster.jpg', // Hedgehog (use hamster) - Harvest Hamster mascot
  'ü¶¶': '/images/emojis/Mascots/harvesthamster.jpg', // Ferret/Otter (use hamster) - Harvest Hamster mascot
  
  // Additional animals - fallback to amojis for ones not in best set
  // Amojis grid (8x10, 80 icons) - various animals including:
  'üêª': '/images/emojis/amojis_011.png', // Bear (brown, standing on two legs) - Amojis grid Row 1, position 8
  'üêº': '/images/emojis/amojis_012.png', // Panda (black and white, facing left/right) - Amojis grid Row 1, position 9 or Row 2, positions 4-5
  'ü¶ä': '/images/emojis/amojis_014.png', // Fox (orange, pointed ears, bushy tail) - Amojis grid Row 1, position 9 or Row 2, position 6
  'üê®': '/images/emojis/amojis_017.png', // Koala (grey, with leaf) - Amojis grid Row 3, position 1
  'üê∏': '/images/emojis/Mascots/SherlockShells.jpg', // Frog (use reptile mascot) - Sherlock Shells mascot
  'üêü': '/images/emojis/amojis_026.png', // Fish (yellow, with fins) - Amojis grid Row 5, position 2
  'üê¥': '/images/emojis/amojis_049.png', // Horse (yellow/grey/brown/orange, standing on four legs) - Amojis grid Row 6, position 9 or Row 7, positions 1,5,7,8,9
  'ü¶â': '/images/emojis/amojis_007.png', // Owl (black/brown, large white eyes) - Amojis grid Row 1, position 2 or Row 8, position 6
  
  // Paw prints - using best set (Row 4 of best grid)
  'üêæ': '/images/emojis/best_paw_prints.png', // Paw Prints (three dark grey/black prints, diagonal arrangement) - Best grid Row 4, position 1
};

// Status/symbol emojis - using "best" set (ultra-minimalist, best quality)
// Best set grid positions: Row 2 (positions 3-4), Row 3 (positions 1-4), Row 4 (positions 2-4)
export const STATUS_EMOJI_MAP: Record<string, string> = {
  '‚≠ê': '/images/emojis/best_star.png', // Star (five-pointed yellow) - Best grid Row 4, position 2
  '‚ú®': '/images/emojis/best_sparkles_multiple.png', // Sparkles (multiple yellow four-pointed sparkles) - Best grid Row 4, position 4
  '‚úÖ': '/images/emojis/best_check_mark.png', // Check Mark (bold green) - Best grid Row 3, position 3
  '‚ùå': '/images/emojis/copilot_emojis_071.png', // X Mark (not in best set, use copilot)
  '‚ö†Ô∏è': '/images/emojis/best_warning.png', // Warning (yellow equilateral triangle with black exclamation mark) - Best grid Row 3, position 2
  'üëç': '/images/emojis/best_thumbs_up_right.png', // Thumbs Up (yellow hand gesture, pointing right) - Best grid Row 2, position 4
  'üëé': '/images/emojis/copilot_emojis_072.png', // Thumbs Down (not in best set, use copilot)
  '‚öñÔ∏è': '/images/emojis/Mascots/ProfessorPurffesor.jpg', // Balance Scale - Professor Purrfessor mascot (research, balance)
  'üèÜ': '/images/emojis/best_trophy.png', // Trophy (yellow cup with two handles) - Best grid Row 3, position 4
  // Additional celebration emojis used on site - using mascot images
  'üéâ': '/images/emojis/Mascots/Prep Puppy.jpg', // Party Popper - Prep Puppy mascot (celebration)
  'üéä': '/images/emojis/Mascots/Prep Puppy.jpg', // Confetti - Prep Puppy mascot (celebration)
  '‚ù§Ô∏è': '/images/emojis/Mascots/Prep Puppy.jpg', // Red Heart - Prep Puppy mascot (warmth, care)
  'üíö': '/images/emojis/Mascots/Prep Puppy.jpg', // Green Heart - Prep Puppy mascot (warmth, care)
  'üíõ': '/images/emojis/Mascots/Prep Puppy.jpg', // Yellow Heart - Prep Puppy mascot (warmth, care)
  'üéÇ': '/images/emojis/Mascots/Prep Puppy.jpg', // Birthday Cake - Prep Puppy mascot (celebration)
};

// Combined map
export const EMOJI_IMAGE_MAP: Record<string, string> = {
  ...PET_EMOJI_MAP,
  ...STATUS_EMOJI_MAP,
};

/**
 * Get image path for an emoji
 * Returns null if no mapping found (fallback to hash-based selection)
 */
export function getEmojiImagePath(emoji: string): string | null {
  return EMOJI_IMAGE_MAP[emoji] || null;
}

/**
 * Hash-based fallback for unmapped emojis
 * Uses amojis set (most consistent quality)
 */
export function getHashBasedEmojiImage(emoji: string): string {
  // Simple hash function
  let hash = 0;
  for (let i = 0; i < emoji.length; i++) {
    hash = ((hash << 5) - hash) + emoji.charCodeAt(i);
    hash = hash & hash; // Convert to 32bit integer
  }
  
  // Use NEW amojis grid (80 images, most consistent)
  const imageNum = (Math.abs(hash) % 80) + 1;
  return `/images/emojis/amojis_${imageNum.toString().padStart(3, '0')}.png`;
}

/**
 * Mascot face emojis - head/bust portraits of the 5 Meal Masters mascots
 * Source: mascot_face_emojis-removebg-preview.png (5 mascot heads in a horizontal row)
 * 
 * Brand Bible Alignment:
 * - Puppy Prepper (Chef) - Light gold dog with chef hat
 * - Professor Purrfessor (Researcher) - Black cat with glasses
 * - Sherlock Shells (Explorer) - Green turtle with cap and monocle
 * - Farmer Fluff (Ingredient Provider) - Dark brown hamster
 * - Robin Redroute (Delivery Specialist) - Red bird with captain's hat and goggles
 *
 * Usage Guidelines (Strategic Mascot Usage):
 * ‚úÖ GOOD: Meal creation tool, ingredient selection, compatibility scoring, error/success states, 
 *          loading screens, tooltips, achievements, homepage hero, empty states, onboarding,
 *          "ingredient discovered" moments, "new recipe unlocked" popups, delivery confirmations
 * ‚ùå AVOID: Educational nutritional text, legal/policy pages, checkout, payment, longform articles, 
 *          scientific explanations, body text paragraphs, navigation menus, critical flows
 */
export const MASCOT_FACE_EMOJI_MAP: Record<string, string> = {
  // Puppy Prepper - The Chef & Meal-Prep Lead
  // Position 1 (left): Yellow dog's head with friendly expression, small black eyes and nose/mouth, wearing puffy white chef's hat
  // Personality: Serious chef energy, impatient, slightly Gordon Ramsay; secretly soft-hearted
  // Color: Light gold
  'puppy-prepper': '/images/emojis/Mascots/Prep Puppy.jpg', // Official name from brand bible
  'barker': '/images/emojis/Mascots/Prep Puppy.jpg', // Legacy name (deprecated)
  'prepperpuppy': '/images/emojis/Mascots/Prep Puppy.jpg', // Alternative spelling
  
  // Professor Purrfessor - The Researcher & Recipe Tester
  // Position 2: Dark grey/black cat's head with large round white glasses covering eyes, small white triangular nose and mouth, pointed ears
  // Personality: Nerdy, anxious, brilliant, catastrophizes constantly
  // Color: Black/charcoal
  'professor-purrfessor': '/images/emojis/Mascots/ProfessorPurffesor.jpg', // Official name from brand bible
  'whiskers': '/images/emojis/Mascots/ProfessorPurffesor.jpg', // Legacy name (deprecated)
  
  // Sherlock Shells - Explorer & Risk Inspector
  // Position 3: Light green round creature's head (turtle/blob), single large black eye with white highlight, wearing dark orange cap with small brim, black monocle hanging from right eye
  // Personality: Soft-spoken, melancholy, overly thoughtful
  // Color: Green
  'sherlock-shells': '/images/emojis/Mascots/SherlockShells.jpg', // Official name from brand bible
  'scales': '/images/emojis/Mascots/SherlockShells.jpg', // Legacy name (deprecated)
  
  // Farmer Fluff - Ingredient Provider & Farm Manager
  // Position 4: Brown hamster's head, light brown face with darker brown outline for head and ears, small black eyes and nose/mouth
  // Personality: ADHD, upbeat, impulsive, very productive in bursts
  // Color: Dark brown
  'farmer-fluff': '/images/emojis/Mascots/harvesthamster.jpg', // Official name from brand bible
  'pip': '/images/emojis/Mascots/harvesthamster.jpg', // Legacy name (deprecated)
  'harvest-hamster': '/images/emojis/Mascots/harvesthamster.jpg', // Legacy name (deprecated)
  
  // Robin Redroute - Packaging & Delivery Specialist
  // Position 5 (right): Red bird's head with small yellow beak, wearing dark blue/black captain's hat with brim, round green goggles over eyes
  // Personality: Hyper, chatty, easily excited
  // Color: Red
  'robin-redroute': '/images/emojis/Mascots/RobinRed-Route.jpg', // Official name from brand bible
  'robin-red-route': '/images/emojis/Mascots/RobinRed-Route.jpg', // Alternative spelling
  'sunny': '/images/emojis/Mascots/RobinRed-Route.jpg', // Legacy name (deprecated)
};

/**
 * Get emoji image path with fallback
 */
export function getEmojiImage(emoji: string): string {
  return getEmojiImagePath(emoji) || getHashBasedEmojiImage(emoji);
}

/**
 * Get mascot face image path
 * Returns the image path for a mascot face identifier
 */
export function getMascotFaceImage(mascotName: string): string | null {
  const normalized = mascotName.toLowerCase().replace(/\s+/g, '-');
  return MASCOT_FACE_EMOJI_MAP[normalized] || null;
}

/**
 * Get mascot face image for a pet category
 * Maps pet types to their corresponding mascot images
 */
export function getMascotFaceForPetType(petType: string): string {
  const typeLower = (petType || '').toLowerCase();
  const typeToMascot: Record<string, string> = {
    'dogs': '/images/emojis/Mascots/Prep Puppy.jpg',
    'cats': '/images/emojis/Mascots/ProfessorPurffesor.jpg',
    'birds': '/images/emojis/Mascots/RobinRed-Route.jpg',
    'reptiles': '/images/emojis/Mascots/SherlockShells.jpg',
    'pocket-pets': '/images/emojis/Mascots/harvesthamster.jpg',
    // Handle singular forms
    'dog': '/images/emojis/Mascots/Prep Puppy.jpg',
    'cat': '/images/emojis/Mascots/ProfessorPurffesor.jpg',
    'bird': '/images/emojis/Mascots/RobinRed-Route.jpg',
    'reptile': '/images/emojis/Mascots/SherlockShells.jpg',
    'pocket-pet': '/images/emojis/Mascots/harvesthamster.jpg',
  };
  return typeToMascot[typeLower] || '/images/emojis/Mascots/Mascot-Emoji-Faces.png';
}

/**
 * Get full profile picture image for a pet type
 * Used for the large profile picture in profile cards (not thumbnails)
 * Maps to full-body character images based on pet type
 */
export function getProfilePictureForPetType(petType: string): string {
  const typeLower = (petType || '').toLowerCase();
  const typeToProfilePic: Record<string, string> = {
    'dogs': '/images/emojis/Mascots/PrepPuppy/PrepPuppy.jpg', // Yellow dog chef with spoon and bowl
    'cats': '/images/emojis/Mascots/Proffessor Purfessor/PUrfessorDesk.jpg', // Black cat with glasses and lab coat at desk
    'birds': '/images/emojis/Mascots/RobinRed-Route.jpg', // Orange bird with goggles and satchel
    'reptiles': '/images/emojis/Mascots/Sherlock Shells/SherlockShells.jpg', // Green turtle detective with monocle
    'pocket-pets': '/images/emojis/Mascots/Harvest Hamster/HHCarrot.jpg', // Brown beaver/hamster with carrot
    // Handle singular forms
    'dog': '/images/emojis/Mascots/PrepPuppy/PrepPuppy.jpg',
    'cat': '/images/emojis/Mascots/Proffessor Purfessor/PUrfessorDesk.jpg',
    'bird': '/images/emojis/Mascots/RobinRed-Route.jpg',
    'reptile': '/images/emojis/Mascots/Sherlock Shells/SherlockShells.jpg',
    'pocket-pet': '/images/emojis/Mascots/Harvest Hamster/HHCarrot.jpg',
  };
  return typeToProfilePic[typeLower] || '/images/emojis/Mascots/Mascot-Emoji-Faces.png';
}
</file>

<file path="lib/utils/enhancedCompatibilityScoring.ts">
// lib/utils/enhancedCompatibilityScoring.ts
// Enhanced compatibility scoring system with ingredient-level analysis
// and multi-factor evaluation

import type { Recipe } from '@/lib/types';
import { getIngredientComposition, INGREDIENT_COMPOSITIONS } from '@/lib/data/ingredientCompositions';
import { getSpeciesCompatibility, shouldAvoid, shouldLimit, normalizeSpecies } from './ingredientCompatibility';
import { AAFCO_NUTRIENT_PROFILES, validateCriticalNutrients } from '@/lib/data/aafco-standards';
import { getAvianStandards, AVIAN_NUTRITION_STANDARDS } from '@/lib/data/avian-nutrition-standards';
import { getReptileStandards, validateReptileNutrition } from '@/lib/data/reptile-nutrition';
import { getFallbackNutrition } from './nutritionFallbacks';
import { nutritionalGuidelines } from '@/lib/data/nutritional-guidelines';
import {
  getHealthConcernBenefits,
  normalizeHealthConcern,
  isBeneficialIngredient,
  isAvoidIngredient,
  checkMacroAlignment,
} from './healthConcernMatching';
import { calculateIngredientQualityScore } from '@/lib/data/ingredientTiers';
import { matchesSpecies } from './recipeRecommendations';

export interface Pet {
  id: string;
  name: string;
  type: 'dog' | 'cat' | 'bird' | 'reptile' | 'pocket-pet';
  breed: string;
  age: number;
  weight: number;
  activityLevel?: 'sedentary' | 'moderate' | 'active' | 'very-active';
  healthConcerns: string[];
  dietaryRestrictions: string[];
  allergies?: string[];
  dislikes?: string[];
  savedRecipes?: string[];
  names?: string[];
  weightKg?: number;
}

export interface EnhancedCompatibilityScore {
  overallScore: number; // 0-100
  grade: 'A+' | 'A' | 'B+' | 'B' | 'C+' | 'C' | 'D' | 'F';
  usesFallbackNutrition?: boolean; // True if any ingredient used fallback nutrition
  fallbackIngredients?: string[]; // List of ingredients that used fallback nutrition
  factors: {
    ingredientSafety: FactorScore;
    nutritionalAdequacy: FactorScore;
    healthAlignment: FactorScore;
    lifeStageFit: FactorScore;
    activityFit: FactorScore;
    allergenSafety: FactorScore;
    ingredientQuality: FactorScore;
  };
  detailedBreakdown: {
    ingredientAnalysis: IngredientAnalysis[];
    nutritionalGaps: string[];
    nutritionalStrengths: string[];
    healthBenefits: string[];
    warnings: string[];
    recommendations: string[];
  };
}

interface FactorScore {
  score: number; // 0-100
  weight: number; // 0-1, how much this factor contributes
  reasoning: string;
  issues: string[];
  strengths: string[];
}

interface IngredientAnalysis {
  ingredient: string;
  compatibility: 'excellent' | 'good' | 'caution' | 'avoid';
  speciesCompat: 'ok' | 'avoid' | 'limit' | 'caution' | null;
  healthImpact: 'positive' | 'neutral' | 'negative';
  notes: string[];
}

/**
 * Enhanced compatibility scoring with ingredient-level analysis
 * 
 * This system provides:
 * 1. Deep ingredient-by-ingredient compatibility checking
 * 2. Real nutritional analysis using USDA data
 * 3. Multi-factor weighted scoring
 * 4. Detailed breakdown for transparency
 */
export function calculateEnhancedCompatibility(
  recipe: Recipe,
  pet: Pet
): EnhancedCompatibilityScore {
  // All recipes go through full scoring pipeline - no short-circuits
  const normalizedSpecies = normalizeSpecies(pet.type);
  const factors = {
    ingredientSafety: calculateIngredientSafety(recipe, pet, normalizedSpecies),
    nutritionalAdequacy: calculateNutritionalAdequacy(recipe, pet, normalizedSpecies),
    healthAlignment: calculateHealthAlignment(recipe, pet),
    lifeStageFit: calculateLifeStageFit(recipe, pet),
    activityFit: calculateActivityFit(recipe, pet),
    allergenSafety: calculateAllergenSafety(recipe, pet),
    ingredientQuality: calculateIngredientQuality(recipe),
  };

  // Calculate safety score (gate) - used to prevent unsafe recipes from scoring high
  const safetyScore = calculateSafetyScore(recipe, pet, normalizedSpecies);
  
  // Calculate optimality score (quality) - considers quality, ideal ranges, health alignment
  const optimalityScore = calculateOptimalityScore(recipe, pet, normalizedSpecies, factors);
  
  // Safety gates the overall score: if safety < 60, cap at 30-40
  // This prevents unsafe recipes from scoring high regardless of other factors
  let gatedScore: number;
  if (safetyScore < 60) {
    // Unsafe recipes: cap at 30-40 based on safety level
    // Still allow some differentiation based on optimality, but heavily penalized
    gatedScore = Math.min(40, safetyScore * 0.5 + optimalityScore * 0.1);
  } else {
    // Safe recipes: combine safety and optimality, but safety doesn't dominate
    // Use 70% optimality + 30% safety for safe recipes
    gatedScore = optimalityScore * 0.70 + safetyScore * 0.30;
  }
  
  // Add bonus points for perfect matches (reduced generosity)
  const bonuses = calculateBonuses(recipe, pet);
  
  // Perfect match bonus: adds 2-5 points if recipe meets strict perfect match criteria
  // This is a bonus, not an override - all recipes go through full scoring
  const perfectMatchBonus = isPerfectMatch(recipe, pet) ? 3 : 0; // 3 points for perfect match
  
  // Ingredient quality is a bonus, not a requirement (0-2% bonus, reduced to prevent clustering)
  const qualityBonus = factors.ingredientQuality.score * 0.02;
  
  // Calculate final score with bonuses, capped at 100
  // Use maximum precision before rounding
  const scoreWithBonuses = gatedScore + bonuses + qualityBonus + perfectMatchBonus;
  
  let finalScore = scoreWithBonuses;
  
  // Add small deterministic variation (¬±1-2 points) based on recipe ID to break ties
  // This prevents identical recipes from getting identical scores
  function hashString(str: string): number {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
    return Math.abs(hash);
  }
  const variation = (hashString(recipe.id) % 5) - 2; // -2 to +2 (as specified in plan)
  
  const overallScore = Math.round(Math.max(0, Math.min(100, finalScore + variation)));

  // Calculate grade
  const grade = getGrade(overallScore);

  // Detailed breakdown
  const ingredientAnalysis = analyzeIngredients(recipe, pet, normalizedSpecies);
  const nutritionalAnalysis = analyzeNutrition(recipe, pet, normalizedSpecies);
  
  // Check for fallback nutrition usage
  const nutrition = calculateRecipeNutrition(recipe);
  const usesFallback = nutrition.usesFallbackNutrition || false;
  const fallbackIngs = nutrition.fallbackIngredients || [];
  
  const healthBenefits: string[] = [];
  const warnings: string[] = [];
  const recommendations: string[] = [];
  
  // Add warning if fallback nutrition is used
  if (usesFallback && fallbackIngs.length > 0) {
    warnings.push(`Recipe uses estimated nutrition data for: ${fallbackIngs.join(', ')}. Recipe should be marked as needsReview.`);
  }

  // Collect health benefits
  if (factors.healthAlignment.strengths.length > 0) {
    healthBenefits.push(...factors.healthAlignment.strengths);
  }

  // Collect warnings
  Object.values(factors).forEach(factor => {
    if (factor.issues.length > 0) {
      warnings.push(...factor.issues);
    }
  });

  // Generate recommendations
  if (factors.nutritionalAdequacy.score < 70) {
    recommendations.push('Consider adding supplements to meet nutritional requirements');
  }
  if (factors.healthAlignment.score < 60 && pet.healthConcerns.length > 0) {
    recommendations.push('This recipe may not address your pet\'s specific health concerns');
  }
  if (factors.activityFit.score < 70 && pet.activityLevel === 'very-active') {
    recommendations.push('This recipe may need additional calories for very active pets');
  }
  if (factors.ingredientQuality.score < 50) {
    recommendations.push('Consider recipes with higher-quality, less processed ingredients');
  }

  return {
    overallScore: Math.max(0, Math.min(100, overallScore)),
    grade,
    factors,
    usesFallbackNutrition: usesFallback,
    fallbackIngredients: fallbackIngs,
    detailedBreakdown: {
      ingredientAnalysis,
      nutritionalGaps: nutritionalAnalysis.gaps,
      nutritionalStrengths: nutritionalAnalysis.strengths,
      healthBenefits,
      warnings: [...new Set(warnings)], // Remove duplicates
      recommendations: [...new Set(recommendations)],
    },
  };
}

/**
 * Factor 1: Ingredient Safety (Weight: 0.25)
 * Checks each ingredient for species compatibility
 */
function calculateIngredientSafety(
  recipe: Recipe,
  pet: Pet,
  normalizedSpecies: string
): FactorScore {
  const ingredients = recipe.ingredients || [];
  let safeCount = 0;
  let cautionCount = 0;
  let avoidCount = 0;
  const issues: string[] = [];
  const strengths: string[] = [];

  // Check for banned ingredients
  const bannedIngredients = (pet as any).bannedIngredients || [];
  const bannedLower = bannedIngredients.map((b: string) => b.toLowerCase());

  for (const ing of ingredients) {
    const ingName = typeof ing === 'string' ? ing : ing.name;
    const ingKey = ingName.toLowerCase().replace(/\s+/g, '_');
    const ingNameLower = ingName.toLowerCase();
    
    // Check if ingredient is banned by user
    const isBanned = bannedLower.some((banned: string) => 
      ingNameLower.includes(banned) || banned.includes(ingNameLower) || ingKey.includes(banned.toLowerCase())
    );
    
    if (isBanned) {
      avoidCount++;
      issues.push(`${ingName} is banned for this pet`);
      continue; // Skip other checks for banned ingredients
    }
    
    // Check species compatibility
    const compat = getSpeciesCompatibility(ingKey, normalizedSpecies);
    
    if (compat === 'avoid') {
      avoidCount++;
      issues.push(`${ingName} should be avoided for ${pet.type}s`);
    } else if (compat === 'limit' || compat === 'caution') {
      cautionCount++;
      issues.push(`${ingName} should be used with caution for ${pet.type}s`);
    } else if (compat === 'ok') {
      safeCount++;
    } else {
      // Unknown ingredient - assume safe but note
      safeCount++;
    }
  }

  // Calculate score with gradual, proportional penalties for better granularity
  const totalIngredients = ingredients.length || 1;
  let score = 100;
  
  // Avoid ingredients: -20 per avoid (reduced from -30), scaled by proportion for gradual penalties
  // This allows recipes with many safe ingredients + one avoid to score better than recipes with mostly avoids
  const avoidRatio = avoidCount / totalIngredients;
  const avoidPenalty = avoidCount * 20 * (1 + avoidRatio); // More gradual
  score -= Math.min(avoidPenalty, 60); // Max -60 for avoids (reduced from -70)
  
  // Caution ingredients: -5 per caution (reduced from -10), scaled by proportion
  const cautionRatio = cautionCount / totalIngredients;
  const cautionPenalty = cautionCount * 5 * (1 + cautionRatio); // More gradual
  score -= Math.min(cautionPenalty, 30); // Max -30 for cautions (reduced from -40)
  
  score = Math.max(0, score);

  if (avoidCount > 0) {
    // Cap at 50 if any avoids (increased from 40 to allow more differentiation)
    score = Math.min(score, 50);
  }

  if (safeCount === ingredients.length && ingredients.length > 0) {
    strengths.push('All ingredients are safe for this species');
  }

  return {
    score: Math.max(0, Math.min(100, score)),
    weight: 0.25, // Weight already correct
    reasoning: avoidCount > 0
      ? `${avoidCount} ingredient(s) should be avoided`
      : cautionCount > 0
      ? `${cautionCount} ingredient(s) need caution`
      : 'All ingredients are species-appropriate',
    issues,
    strengths,
  };
}

/**
 * Calculate continuous score for a nutrient based on distance from ideal range
 * Returns score from 0-100, where 100 = at ideal midpoint, lower = further from ideal
 */
function calculateNutrientScore(
  actual: number,
  min: number,
  max: number
): { score: number; bonus: number } {
  if (max <= min) return { score: 50, bonus: 0 }; // Invalid range
  
  const ideal = (min + max) / 2;
  const range = max - min;
  
  // Calculate distance from ideal (normalized to 0-1)
  const distance = Math.abs(actual - ideal) / range;
  
  // Score: 100 at ideal, decreases linearly with distance
  // Cap at 0 for values way outside range
  let score = Math.max(0, 100 - (distance * 100));
  
  // Bonus for exceeding minimums (up to +8 points, reduced from +15)
  let bonus = 0;
  if (min > 0 && actual > min) {
    const excessPercent = ((actual - min) / min) * 100;
    // +2 points per 5% over minimum, capped at +8 (reduced to prevent over-scoring)
    bonus = Math.min(8, Math.floor(excessPercent / 5) * 2);
  }
  
  return { score, bonus };
}

/**
 * Calculate ingredient diversity bonus (Phase 2.3)
 * Rewards recipes with varied ingredient categories
 */
function calculateIngredientDiversity(recipe: Recipe): number {
  const ingredients = (recipe.ingredients || []).map(ing => {
    const name = typeof ing === 'string' ? ing : ing.name;
    return name.toLowerCase();
  });
  
  if (ingredients.length === 0) return 0;
  
  // Categorize ingredients
  const categories = new Set<string>();
  ingredients.forEach(ing => {
    if (ing.includes('chicken') || ing.includes('turkey') || ing.includes('beef') || 
        ing.includes('fish') || ing.includes('salmon') || ing.includes('lamb') ||
        ing.includes('pork') || ing.includes('duck') || ing.includes('egg')) {
      categories.add('protein');
    } else if (ing.includes('rice') || ing.includes('quinoa') || ing.includes('oats') ||
               ing.includes('barley') || ing.includes('wheat') || ing.includes('corn')) {
      categories.add('grain');
    } else if (ing.includes('carrot') || ing.includes('broccoli') || ing.includes('spinach') ||
               ing.includes('kale') || ing.includes('peas') || ing.includes('green-bean') ||
               ing.includes('sweet-potato') || ing.includes('pumpkin')) {
      categories.add('vegetable');
    } else if (ing.includes('apple') || ing.includes('blueberry') || ing.includes('banana') ||
               ing.includes('cranberry')) {
      categories.add('fruit');
    } else if (ing.includes('oil') || ing.includes('fat')) {
      categories.add('fat');
    } else if (ing.includes('supplement') || ing.includes('vitamin') || ing.includes('mineral')) {
      categories.add('supplement');
    }
  });
  
  // Bonus: +1 point per unique category (max +10)
  const diversityBonus = Math.min(10, categories.size);
  
  return diversityBonus;
}

/**
 * Factor 2: Nutritional Adequacy (Weight: 0.30)
 * Continuous scoring based on distance from ideal nutritional ranges
 */
function calculateNutritionalAdequacy(
  recipe: Recipe,
  pet: Pet,
  normalizedSpecies: string
): FactorScore {
  const issues: string[] = [];
  const strengths: string[] = [];
  
  // Calculate recipe nutrition from ingredients
  const nutrition = calculateRecipeNutrition(recipe);
  
  // Get pet's age group for nutritional guidelines
  let ageGroup: 'puppy' | 'adult' | 'senior' = 'adult';
  if (normalizedSpecies === 'dog' || normalizedSpecies === 'cat') {
    if (pet.age < 1) ageGroup = 'puppy';
    else if (pet.age >= 7) ageGroup = 'senior';
  }
  
  // Map normalized species to PetCategory
  const speciesMap: Record<string, keyof typeof nutritionalGuidelines> = {
    'dog': 'dogs',
    'cat': 'cats',
    'bird': 'birds',
    'reptile': 'reptiles',
    'pocket-pet': 'pocket-pets',
  };
  
  const petCategory = speciesMap[normalizedSpecies];
  let requirements = petCategory ? nutritionalGuidelines[petCategory]?.[ageGroup] : null;
  
  // Fallback to adult if specific age group not available
  if (!requirements && petCategory) {
    requirements = nutritionalGuidelines[petCategory]?.adult;
  }
  
  // Initialize nutrient scores
  const nutrientScores: { name: string; score: number; bonus: number }[] = [];
  let totalScore = 0;
  let totalWeight = 0;
  
  if (requirements) {
    // Protein scoring (weight: 0.30)
    if (requirements.protein) {
      const { score, bonus } = calculateNutrientScore(
        nutrition.protein,
        requirements.protein.min,
        requirements.protein.max
      );
      nutrientScores.push({ name: 'protein', score, bonus });
      totalScore += score * 0.30;
      totalWeight += 0.30;
      
      if (nutrition.protein < requirements.protein.min) {
        issues.push(`Protein (${nutrition.protein.toFixed(1)}%) below minimum (${requirements.protein.min}%)`);
      } else if (nutrition.protein > requirements.protein.max) {
        issues.push(`Protein (${nutrition.protein.toFixed(1)}%) above maximum (${requirements.protein.max}%)`);
      } else {
        strengths.push(`Protein (${nutrition.protein.toFixed(1)}%) within ideal range`);
      }
    }
    
    // Fat scoring (weight: 0.25)
    if (requirements.fat) {
      const { score, bonus } = calculateNutrientScore(
        nutrition.fat,
        requirements.fat.min,
        requirements.fat.max
      );
      nutrientScores.push({ name: 'fat', score, bonus });
      totalScore += score * 0.25;
      totalWeight += 0.25;
      
      if (nutrition.fat < requirements.fat.min) {
        issues.push(`Fat (${nutrition.fat.toFixed(1)}%) below minimum (${requirements.fat.min}%)`);
      } else if (nutrition.fat > requirements.fat.max) {
        issues.push(`Fat (${nutrition.fat.toFixed(1)}%) above maximum (${requirements.fat.max}%)`);
      }
    }
    
    // Fiber scoring (weight: 0.15)
    if (requirements.fiber) {
      const { score, bonus } = calculateNutrientScore(
        nutrition.fiber,
        requirements.fiber.min,
        requirements.fiber.max
      );
      nutrientScores.push({ name: 'fiber', score, bonus });
      totalScore += score * 0.15;
      totalWeight += 0.15;
    }
    
    // Calcium scoring (weight: 0.15)
    if (requirements.calcium) {
      const { score, bonus } = calculateNutrientScore(
        nutrition.calcium,
        requirements.calcium.min,
        requirements.calcium.max
      );
      nutrientScores.push({ name: 'calcium', score, bonus });
      totalScore += score * 0.15;
      totalWeight += 0.15;
    }
    
    // Phosphorus scoring (weight: 0.15)
    if (requirements.phosphorus) {
      const { score, bonus } = calculateNutrientScore(
        nutrition.phosphorus,
        requirements.phosphorus.min,
        requirements.phosphorus.max
      );
      nutrientScores.push({ name: 'phosphorus', score, bonus });
      totalScore += score * 0.15;
      totalWeight += 0.15;
    }
    
    // Ca:P ratio precision scoring (Phase 2.2)
    if (nutrition.calcium && nutrition.phosphorus && requirements.calcium && requirements.phosphorus) {
      const caPRatio = nutrition.calcium / nutrition.phosphorus;
      // Ideal Ca:P ratio varies by species, but generally 1.2:1 to 2:1
      const idealCaP = petCategory === 'dogs' || petCategory === 'cats' ? 1.5 : 1.8;
      const minCaP = 1.2;
      const maxCaP = 2.0;
      
      if (caPRatio >= minCaP && caPRatio <= maxCaP) {
        // Calculate distance from ideal
        const distance = Math.abs(caPRatio - idealCaP) / (maxCaP - minCaP);
        const ratioScore = 100 - (distance * 50); // Max penalty -50
        totalScore += ratioScore * 0.10; // 10% weight for ratio
        totalWeight += 0.10;
        
        if (distance < 0.1) {
          strengths.push(`Optimal Ca:P ratio (${caPRatio.toFixed(2)})`);
        } else if (distance < 0.3) {
          strengths.push(`Good Ca:P ratio (${caPRatio.toFixed(2)})`);
        } else {
          issues.push(`Ca:P ratio (${caPRatio.toFixed(2)}) could be closer to ideal (${idealCaP})`);
        }
      } else {
        // Outside ideal range - elastic thresholds with diminishing returns
        const safeMin = 0.8; // Animals tolerate broader ranges
        const safeMax = 3.0;
        
        if (caPRatio >= safeMin && caPRatio < minCaP) {
          // Slightly low - small penalty
          const deviation = minCaP - caPRatio;
          const penalty = Math.min(deviation * 5, 10); // Reduced penalty
          totalScore -= penalty * 0.10;
          totalWeight += 0.10;
          issues.push(`Ca:P ratio (${caPRatio.toFixed(2)}) slightly below ideal range`);
        } else if (caPRatio > maxCaP && caPRatio <= safeMax) {
          // Slightly high - small penalty
          const deviation = caPRatio - maxCaP;
          const penalty = Math.min(deviation * 5, 10); // Reduced penalty
          totalScore -= penalty * 0.10;
          totalWeight += 0.10;
          issues.push(`Ca:P ratio (${caPRatio.toFixed(2)}) slightly above ideal range`);
        } else {
          // Outside safe range - larger penalty
          const penalty = caPRatio < safeMin ? (safeMin - caPRatio) * 20 : (caPRatio - safeMax) * 20;
          totalScore -= Math.min(penalty, 50) * 0.10;
          totalWeight += 0.10;
          issues.push(`Ca:P ratio (${caPRatio.toFixed(2)}) outside safe range (${safeMin}-${safeMax})`);
        }
      }
    }
  }
  
  // Calculate weighted average score
  let finalScore = totalWeight > 0 ? totalScore / totalWeight : 50;
  
  // Add bonuses for exceeding minimums (average across nutrients)
  const avgBonus = nutrientScores.length > 0
    ? nutrientScores.reduce((sum, n) => sum + n.bonus, 0) / nutrientScores.length
    : 0;
  finalScore += avgBonus;
  
  // Add ingredient diversity bonus (Phase 2.3)
  const diversityBonus = calculateIngredientDiversity(recipe);
  finalScore += diversityBonus;
  
  // Safety validation check (still important for critical failures)
  if (normalizedSpecies === 'dog' || normalizedSpecies === 'cat') {
    const lifeStage = pet.age < 1 ? 'growth' : 'adult';
    const validation = validateCriticalNutrients(
      recipe,
      normalizedSpecies as 'dog' | 'cat',
      lifeStage
    );
    
    if (!validation.isValid) {
      // Critical violations reduce score gradually using distance-based penalty
      // Penalty = violations^2 * scalingFactor for better granularity
      const violationPenalty = Math.min(30, validation.violations.length * validation.violations.length * 2);
      finalScore -= violationPenalty;
      validation.violations.forEach(v => {
        issues.push(`Critical nutritional gap: ${v}`);
      });
    }
  } else if (normalizedSpecies === 'bird') {
    const standards = getAvianStandards(pet.breed) || AVIAN_NUTRITION_STANDARDS.psittacines;
    if (nutrition.protein < (standards.protein?.min || 12)) {
      // Gradual penalty based on how far below minimum
      const deviation = (standards.protein?.min || 12) - nutrition.protein;
      const penalty = Math.min(20, deviation * deviation * 2); // Quadratic penalty
      finalScore -= penalty;
      issues.push('Protein critically low for birds');
    }
  } else if (normalizedSpecies === 'reptile') {
    const standards = getReptileStandards(pet.breed);
    if (standards) {
      const validation = validateReptileNutrition(recipe, pet.breed || 'unknown');
      if (!validation.isValid) {
        finalScore -= validation.violations.length * 5; // Reduced from -10 to -5
        validation.violations.forEach(v => {
          issues.push(`Reptile nutrition gap: ${v}`);
        });
      }
    }
  } else if (normalizedSpecies === 'pocket-pet') {
    const breed = (pet.breed || '').toLowerCase();
    const isLowFiber = ['sugar', 'glider', 'hamster', 'rat', 'mouse', 'ferret'].some(b => breed.includes(b));
    const isHayEater = ['rabbit', 'guinea', 'chinchilla'].some(b => breed.includes(b));
    
    if (isLowFiber && nutrition.protein < 12) {
      // Gradual penalty based on deviation
      const deviation = 12 - nutrition.protein;
      const penalty = Math.min(20, deviation * deviation * 2);
      finalScore -= penalty;
      issues.push('Protein critically low for this pocket-pet type');
    }
    if (isHayEater && nutrition.fiber < 15) {
      // Gradual penalty based on deviation
      const deviation = 15 - nutrition.fiber;
      const penalty = Math.min(20, deviation * deviation * 2);
      finalScore -= penalty;
      issues.push('Fiber critically low for hay-eating pocket-pets');
    }
    if (breed.includes('ferret') && nutrition.protein < 30) {
      // Gradual penalty based on deviation
      const deviation = 30 - nutrition.protein;
      const penalty = Math.min(25, deviation * deviation * 1.5);
      finalScore -= penalty;
      issues.push('Ferrets require high protein (30%+) as obligate carnivores');
    }
  }
  
  // Add missing data penalty - FIXED: Only penalize for pets with health concerns requiring precise nutrition
  // Use gradual penalty: (100 - coverage) / 10 instead of binary thresholds
  if (nutrition.usesFallbackNutrition && nutrition.fallbackIngredients && pet.healthConcerns.length > 0) {
    const totalIngredients = (recipe.ingredients || []).length;
    const missingPercentage = totalIngredients > 0 
      ? nutrition.fallbackIngredients.length / totalIngredients 
      : 0;
    const coverage = (1 - missingPercentage) * 100;
    const penalty = Math.min(15, (100 - coverage) / 10); // Gradual: -1 per 10% missing
    finalScore -= penalty;
    
    if (penalty > 0) {
      issues.push(`Uses estimated nutrition data for ${nutrition.fallbackIngredients.length} ingredient(s) (${Math.round(missingPercentage * 100)}%)`);
    }
  }
  // For perfect pets, fallback data is acceptable and doesn't penalize
  
  // Add strength messages for good scores
  if (finalScore >= 85) {
    strengths.push('Excellent nutritional profile');
  } else if (finalScore >= 75) {
    strengths.push('Good nutritional profile');
  } else if (finalScore >= 65) {
    strengths.push('Adequate nutritional profile');
  }

  return {
    score: Math.max(0, Math.min(100, Math.round(finalScore))),
    weight: 0.35, // Updated weight to match new distribution
    reasoning: issues.length === 0
      ? `Nutritional score: ${Math.round(finalScore)}% (${strengths[0] || 'within acceptable ranges'})`
      : `${issues.length} nutritional concern(s) identified`,
    issues,
    strengths,
  };
}

/**
 * Factor 3: Health Alignment (Weight: 0.20)
 * Tiered scoring based on precision of health concern matching
 */
function calculateHealthAlignment(
  recipe: Recipe,
  pet: Pet
): FactorScore {
  const issues: string[] = [];
  const strengths: string[] = [];

  if (pet.healthConcerns.length === 0) {
    return {
      score: 100,
      weight: 0.15, // Updated weight to match new distribution
      reasoning: 'No specific health concerns to evaluate',
      issues: [],
      strengths: ['Recipe suitable for healthy pets'],
    };
  }

  // Calculate recipe nutrition for macro alignment checks
  const nutrition = calculateRecipeNutrition(recipe);
  
  // Get recipe ingredients
  const recipeIngredients = (recipe.ingredients || []).map(ing => {
    const name = typeof ing === 'string' ? ing : ing.name;
    return name.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
  });
  
  const recipeConcerns = (recipe.healthConcerns || []).map(c => normalizeHealthConcern(c));
  const recipeNotSuitable = (recipe.notSuitableFor || []).map(c => normalizeHealthConcern(c));
  
  const petConcerns = pet.healthConcerns.map(c => normalizeHealthConcern(c));
  
  // Calculate tiered scores for each concern
  const concernScores: number[] = [];
  const concernWeights: number[] = [];
  
  for (let i = 0; i < petConcerns.length; i++) {
    const concern = petConcerns[i];
    const concernData = getHealthConcernBenefits(concern);
    
    // Weight: Primary concern (first) gets full weight, others get 0.7x
    const weight = i === 0 ? 1.0 : 0.7;
    
    // Check if recipe explicitly says it's not suitable
    const notSuitable = recipeNotSuitable.some(ns => 
      ns.includes(concern) || concern.includes(ns)
    );
    
    if (notSuitable) {
      // Tier 5: Negative match - contains problematic elements
      concernScores.push(20);
      concernWeights.push(weight);
      issues.push(`Recipe is not suitable for ${concern.replace(/-/g, ' ')}`);
      continue;
    }
    
    // Check if recipe explicitly targets this concern
    const explicitlyTargets = recipeConcerns.some(rc => 
      rc.includes(concern) || concern.includes(rc)
    );
    
    if (concernData) {
      // Check for beneficial ingredients
      const beneficialCount = recipeIngredients.filter(ing => 
        isBeneficialIngredient(ing, concernData.beneficialIngredients)
      ).length;
      
      // Check for avoid ingredients
      const avoidCount = recipeIngredients.filter(ing => 
        isAvoidIngredient(ing, concernData.avoidIngredients, pet.allergies)
      ).length;
      
      // Check macro alignment
      const macroAlignment = checkMacroAlignment(nutrition, concernData.targetMacros);
      
      // Tier 1: Perfect match - explicitly targets + has beneficial + avoids problematic + good macros
      if (explicitlyTargets && beneficialCount > 0 && avoidCount === 0 && macroAlignment >= 25) {
        concernScores.push(100);
        concernWeights.push(weight);
        strengths.push(`Perfect match for ${concern.replace(/-/g, ' ')}: targets concern with beneficial ingredients`);
      }
      // Tier 2: Strong match - explicitly targets + has some beneficial ingredients
      else if (explicitlyTargets && beneficialCount > 0) {
        const tier2Score = 70 + Math.min(beneficialCount * 5, 15) + (avoidCount === 0 ? 10 : -avoidCount * 5);
        concernScores.push(Math.min(100, tier2Score));
        concernWeights.push(weight);
        strengths.push(`Strong match for ${concern.replace(/-/g, ' ')}: targets concern with ${beneficialCount} beneficial ingredient(s)`);
      }
      // Tier 3: Supportive match - has beneficial ingredients but doesn't explicitly target
      else if (beneficialCount > 0 && avoidCount === 0) {
        const tier3Score = 50 + Math.min(beneficialCount * 5, 20) + (macroAlignment >= 25 ? 10 : 0);
        concernScores.push(Math.min(100, tier3Score));
        concernWeights.push(weight);
        strengths.push(`Supportive for ${concern.replace(/-/g, ' ')}: contains ${beneficialCount} beneficial ingredient(s)`);
      }
      // Tier 4: Neutral - no alignment but no conflicts
      else if (avoidCount === 0) {
        concernScores.push(50);
        concernWeights.push(weight);
      }
      // Tier 5: Negative - contains problematic ingredients
      else {
        const tier5Score = Math.max(0, 30 - (avoidCount * 10));
        concernScores.push(tier5Score);
        concernWeights.push(weight);
        issues.push(`Contains ${avoidCount} problematic ingredient(s) for ${concern.replace(/-/g, ' ')}`);
      }
    } else {
      // No specific data for this concern - use basic tag matching
      if (explicitlyTargets) {
        concernScores.push(85);
        concernWeights.push(weight);
        strengths.push(`Recipe targets ${concern.replace(/-/g, ' ')}`);
      } else {
        concernScores.push(50);
        concernWeights.push(weight);
      }
    }
  }
  
  // Calculate weighted average across all concerns
  let totalScore = 0;
  let totalWeight = 0;
  for (let i = 0; i < concernScores.length; i++) {
    totalScore += concernScores[i] * concernWeights[i];
    totalWeight += concernWeights[i];
  }
  
  const finalScore = totalWeight > 0 ? totalScore / totalWeight : 50;

  return {
    score: Math.max(0, Math.min(100, Math.round(finalScore))),
    weight: 0.15, // Updated weight to match new distribution
    reasoning: concernScores.length > 0
      ? `Health alignment: ${Math.round(finalScore)}% (${strengths.length > 0 ? strengths[0] : 'neutral'})`
      : 'Neutral health alignment',
    issues,
    strengths,
  };
}

/**
 * Factor 4: Life Stage Fit (Weight: 0.10)
 * Checks if recipe is appropriate for pet's age
 */
function calculateLifeStageFit(
  recipe: Recipe,
  pet: Pet
): FactorScore {
  const issues: string[] = [];
  const strengths: string[] = [];
  
  const petAgeGroup = pet.age < 1 ? 'baby' : pet.age < 2 ? 'young' : pet.age < 7 ? 'adult' : 'senior';
  const recipeAgeGroups = recipe.ageGroup || [];
  
  const isMatch = recipeAgeGroups.includes(petAgeGroup) || 
                  recipeAgeGroups.includes('all') ||
                  recipeAgeGroups.length === 0;

  if (isMatch) {
    strengths.push(`Appropriate for ${petAgeGroup} pets`);
  } else {
    issues.push(`Recipe designed for ${recipeAgeGroups.join(', ')}, but pet is ${petAgeGroup}`);
  }

  return {
    score: isMatch ? 100 : 60,
    weight: 0.10, // Weight already correct
    reasoning: isMatch
      ? `Recipe is appropriate for ${petAgeGroup} pets`
      : `Age group mismatch`,
    issues,
    strengths,
  };
}

/**
 * Factor 5: Activity Fit (Weight: 0.05)
 * Checks if calorie content matches activity level
 */
function calculateActivityFit(
  recipe: Recipe,
  pet: Pet
): FactorScore {
  const issues: string[] = [];
  const strengths: string[] = [];
  
  if (!pet.activityLevel) {
    return {
      score: 100,
      weight: 0.05,
      reasoning: 'Activity level not specified',
      issues: [],
      strengths: [],
    };
  }

  const nutrition = calculateRecipeNutrition(recipe);
  const calories = nutrition.calories || 150; // Default estimate

  // Rough calorie needs by activity (kcal per kg body weight per day)
  const activityMultipliers = {
    'sedentary': 80,
    'moderate': 100,
    'active': 120,
    'very-active': 150,
  };

  const estimatedNeeds = (activityMultipliers[pet.activityLevel] || 100) * pet.weight;
  const recipeCalories = calories * (pet.weight / 10); // Rough estimate for portion

  if (pet.activityLevel === 'very-active' && recipeCalories < estimatedNeeds * 0.8) {
    issues.push('Recipe may be too low in calories for very active pets');
  } else if (pet.activityLevel === 'sedentary' && recipeCalories > estimatedNeeds * 1.2) {
    issues.push('Recipe may be too high in calories for sedentary pets');
  } else {
    strengths.push(`Calorie content appropriate for ${pet.activityLevel} activity level`);
  }

  return {
    score: issues.length > 0 ? 70 : 100,
    weight: 0.05,
    reasoning: issues.length > 0
      ? 'Calorie content may not match activity level'
      : 'Calorie content matches activity level',
    issues,
    strengths,
  };
}

/**
 * Factor 6.5: Ingredient Quality (Weight: 0.10)
 * Scores based on ingredient sophistication and quality
 */
function calculateIngredientQuality(
  recipe: Recipe
): FactorScore {
  const issues: string[] = [];
  const strengths: string[] = [];
  
  const ingredients = (recipe.ingredients || []).map(ing => 
    typeof ing === 'string' ? { name: ing } : ing
  );
  
  const qualityResult = calculateIngredientQualityScore(ingredients);
  
  if (qualityResult.premiumCount > 0) {
    strengths.push(`${qualityResult.premiumCount} premium ingredient(s)`);
  }
  
  if (qualityResult.basicCount > 0) {
    issues.push(`${qualityResult.basicCount} processed/basic ingredient(s)`);
  }
  
  if (qualityResult.freshRatio > 0.5) {
    strengths.push('High proportion of fresh ingredients');
  }
  
  return {
    score: qualityResult.score,
    weight: 0.00, // FIXED: Quality is now a bonus, not part of base weight
    reasoning: qualityResult.score >= 70
      ? `High-quality ingredients (${qualityResult.premiumCount} premium)`
      : qualityResult.score >= 50
      ? 'Standard ingredient quality'
      : 'Contains processed/basic ingredients',
    issues,
    strengths,
  };
}

/**
 * Factor 6: Allergen Safety (Weight: 0.10)
 * Critical safety check for allergies
 */
function calculateAllergenSafety(
  recipe: Recipe,
  pet: Pet
): FactorScore {
  const issues: string[] = [];
  const strengths: string[] = [];
  
  const allAllergens = [
    ...(pet.allergies || []),
    ...pet.dietaryRestrictions.filter(r => 
      ['chicken', 'beef', 'dairy', 'wheat', 'egg', 'fish', 'pork'].some(a => 
        r.toLowerCase().includes(a)
      )
    ),
  ];

  if (allAllergens.length === 0) {
    return {
      score: 100,
      weight: 0.10,
      reasoning: 'No known allergies or restrictions',
      issues: [],
      strengths: ['No allergen concerns'],
    };
  }

  const ingredients = (recipe.ingredients || []).map(i => 
    (typeof i === 'string' ? i : i.name).toLowerCase()
  ).join(' ');

  let hasAllergen = false;
  for (const allergen of allAllergens) {
    if (ingredients.includes(allergen.toLowerCase())) {
      hasAllergen = true;
      issues.push(`Contains ${allergen} - AVOID`);
    }
  }

  if (!hasAllergen) {
    strengths.push('Recipe avoids all known allergens');
  }

  return {
    score: hasAllergen ? 0 : 100, // Zero if allergen present
    weight: 0.10, // Weight already correct
    reasoning: hasAllergen
      ? 'Contains known allergens - NOT SAFE'
      : 'No allergens detected',
    issues,
    strengths,
  };
}

/**
 * Calculate safety score (0-100) - only considers hard safety requirements
 * This is used as a gate to prevent unsafe recipes from scoring high
 */
function calculateSafetyScore(
  recipe: Recipe,
  pet: Pet,
  normalizedSpecies: string
): number {
  const ingredients = recipe.ingredients || [];
  let hasAvoid = false;
  let hasAllergen = false;
  
  // Check for banned ingredients
  const bannedIngredients = (pet as any).bannedIngredients || [];
  const bannedLower = bannedIngredients.map((b: string) => b.toLowerCase());
  
  for (const ing of ingredients) {
    const ingName = typeof ing === 'string' ? ing : ing.name;
    const ingKey = ingName.toLowerCase().replace(/\s+/g, '_');
    const ingNameLower = ingName.toLowerCase();
    
    // Check if ingredient is banned
    const isBanned = bannedLower.some((banned: string) => 
      ingNameLower.includes(banned) || banned.includes(ingNameLower) || ingKey.includes(banned.toLowerCase())
    );
    
    if (isBanned) {
      hasAvoid = true;
      continue;
    }
    
    // Check species compatibility
    const compat = getSpeciesCompatibility(ingKey, normalizedSpecies);
    if (compat === 'avoid') {
      hasAvoid = true;
    }
  }
  
  // Check for allergens
  const allergies = pet.allergies || [];
  const dietaryRestrictions = pet.dietaryRestrictions || [];
  const allAllergens = [...allergies, ...dietaryRestrictions];
  
  if (allAllergens.length > 0) {
    const recipeIngNames = ingredients.map(ing => 
      (typeof ing === 'string' ? ing : ing.name).toLowerCase()
    ).join(' ');
    
    hasAllergen = allAllergens.some(a => 
      recipeIngNames.includes(a.toLowerCase())
    );
  }
  
  // Safety score: 0 if unsafe, 100 if completely safe
  if (hasAvoid || hasAllergen) {
    return 0; // Unsafe - will gate overall score
  }
  
  // Check hard nutritional minimums (meets core species standards)
  const nutrition = calculateRecipeNutrition(recipe);
  const petCategory = normalizedSpecies === 'dog' ? 'dogs' : 
                      normalizedSpecies === 'cat' ? 'cats' :
                      normalizedSpecies === 'bird' ? 'birds' :
                      normalizedSpecies === 'reptile' ? 'reptiles' : 'pocket-pets';
  const ageGroup = pet.age < 1 ? 'puppy' : pet.age >= 7 ? 'senior' : 'adult';
  const requirements = nutritionalGuidelines[petCategory]?.[ageGroup] || nutritionalGuidelines[petCategory]?.adult;
  
  if (requirements) {
    // Check critical minimums
    if (requirements.protein && nutrition.protein < requirements.protein.min * 0.8) {
      return 30; // Critically low protein
    }
    if (requirements.fat && nutrition.fat < requirements.fat.min * 0.8) {
      return 40; // Critically low fat
    }
  }
  
  // All safety checks passed
  return 100;
}

/**
 * Calculate optimality score (0-100) - considers quality, ideal ranges, health alignment
 * This is the "how good is it" score, separate from safety
 */
function calculateOptimalityScore(
  recipe: Recipe,
  pet: Pet,
  normalizedSpecies: string,
  factors: {
    ingredientSafety: FactorScore;
    nutritionalAdequacy: FactorScore;
    healthAlignment: FactorScore;
    lifeStageFit: FactorScore;
    activityFit: FactorScore;
    allergenSafety: FactorScore;
    ingredientQuality: FactorScore;
  }
): number {
  // Optimality weights (different from safety)
  const optimalityWeights = {
    nutritionalAdequacy: 0.40, // How close to ideal nutrient bands
    healthAlignment: 0.20, // Health concern matching
    lifeStageFit: 0.15, // Age appropriateness
    activityFit: 0.10, // Activity level matching
    ingredientQuality: 0.15, // Quality of ingredients
  };
  
  // Calculate weighted optimality score
  const optimalityScore = 
    factors.nutritionalAdequacy.score * optimalityWeights.nutritionalAdequacy +
    factors.healthAlignment.score * optimalityWeights.healthAlignment +
    factors.lifeStageFit.score * optimalityWeights.lifeStageFit +
    factors.activityFit.score * optimalityWeights.activityFit +
    factors.ingredientQuality.score * optimalityWeights.ingredientQuality;
  
  return Math.max(0, Math.min(100, optimalityScore));
}

/**
 * Analyze each ingredient individually
 */
function analyzeIngredients(
  recipe: Recipe,
  pet: Pet,
  normalizedSpecies: string
): IngredientAnalysis[] {
  const ingredients = recipe.ingredients || [];
  const analysis: IngredientAnalysis[] = [];

  for (const ing of ingredients) {
    const ingName = typeof ing === 'string' ? ing : ing.name;
    const ingKey = ingName.toLowerCase().replace(/\s+/g, '_');
    
    const compat = getSpeciesCompatibility(ingKey, normalizedSpecies);
    const composition = getIngredientComposition(ingKey);
    
    let compatibility: 'excellent' | 'good' | 'caution' | 'avoid';
    let healthImpact: 'positive' | 'neutral' | 'negative' = 'neutral';
    const notes: string[] = [];

    if (compat === 'avoid') {
      compatibility = 'avoid';
      healthImpact = 'negative';
      notes.push('Should be avoided for this species');
    } else if (compat === 'limit' || compat === 'caution') {
      compatibility = 'caution';
      notes.push('Use with caution');
    } else if (compat === 'ok') {
      compatibility = 'good';
    } else {
      compatibility = 'good'; // Unknown, assume safe
    }

    // Check health concerns
    const recipeConcerns = (recipe.healthConcerns || []).map(c => c.toLowerCase());
    const petConcerns = pet.healthConcerns.map(c => c.toLowerCase());
    
    // Check if ingredient benefits health concerns
    if (composition) {
      if (composition.omega3 && petConcerns.some(c => c.includes('joint') || c.includes('skin'))) {
        healthImpact = 'positive';
        notes.push('Rich in omega-3, beneficial for joint/skin health');
      }
      if (composition.taurine && pet.type === 'cat') {
        healthImpact = 'positive';
        notes.push('Contains taurine, essential for cats');
      }
    }

    analysis.push({
      ingredient: ingName,
      compatibility,
      speciesCompat: compat,
      healthImpact,
      notes,
    });
  }

  return analysis;
}

/**
 * Analyze nutritional profile
 */
function analyzeNutrition(
  recipe: Recipe,
  pet: Pet,
  normalizedSpecies: string
): { gaps: string[]; strengths: string[] } {
  const gaps: string[] = [];
  const strengths: string[] = [];
  
  const nutrition = calculateRecipeNutrition(recipe);
  
  if (normalizedSpecies === 'dog' || normalizedSpecies === 'cat') {
    if (nutrition.protein < 18) {
      gaps.push('Protein content may be below optimal');
    } else {
      strengths.push('Adequate protein content');
    }
    
    if (nutrition.calcium && nutrition.phosphorus) {
      const caPRatio = nutrition.calcium / nutrition.phosphorus;
      if (caPRatio < 1.0 || caPRatio > 2.0) {
        gaps.push(`Ca:P ratio (${caPRatio.toFixed(2)}) outside ideal range`);
      } else {
        strengths.push('Ideal Ca:P ratio');
      }
    }
  }

  if (nutrition.source === 'real') {
    strengths.push('Nutritional data based on USDA values');
  }

  return { gaps, strengths };
}

/**
 * Calculate recipe nutrition from ingredients
 * Returns nutrition values as percentages (dry matter basis)
 */
export function calculateRecipeNutrition(recipe: Recipe): {
  protein: number;
  fat: number;
  fiber: number;
  calcium: number;
  phosphorus: number;
  calories: number;
  source: 'real' | 'estimated';
  usesFallbackNutrition?: boolean;
  fallbackIngredients?: string[];
} {
  // Check if recipe has pre-calculated nutritional data (from custom meal analysis)
  const nutritionalCalc = (recipe as any).nutritionalCalculation;
  if (nutritionalCalc) {
    const totalGrams = nutritionalCalc.totalGrams || 100;
    // Convert from grams to percentages
    return {
      protein: totalGrams > 0 ? ((nutritionalCalc.protein_g || 0) / totalGrams) * 100 : 0,
      fat: totalGrams > 0 ? ((nutritionalCalc.fat_g || 0) / totalGrams) * 100 : 0,
      fiber: totalGrams > 0 ? ((nutritionalCalc.fiber_g || 0) / totalGrams) * 100 : 0,
      calcium: totalGrams > 0 ? ((nutritionalCalc.ca_mg || 0) / totalGrams) * 100 : 0,
      phosphorus: totalGrams > 0 ? ((nutritionalCalc.p_mg || 0) / totalGrams) * 100 : 0,
      calories: totalGrams > 0 ? ((nutritionalCalc.calories_kcal || nutritionalCalc.kcal || 0) / totalGrams) * 100 : 0,
      source: 'real',
    };
  }

  const ingredients = recipe.ingredients || [];
  const supplements = (recipe as any).supplements || [];
  
  let totalProtein = 0;
  let totalFat = 0;
  let totalFiber = 0;
  let totalCalcium = 0;
  let totalPhosphorus = 0;
  let totalCalories = 0;
  let totalWeight = 0;
  let realDataCount = 0;
  const fallbackIngredients: string[] = [];

  // Helper function to map supplement names to ingredient composition keys
  const mapSupplementToCompositionKey = (supplementName: string): string | null => {
    const lower = supplementName.toLowerCase();
    // Map common supplement names to ingredient composition keys
    if (lower.includes('taurine')) return 'taurine_powder';
    if (lower.includes('calcium') && (lower.includes('carbonate') || lower.includes('supplement'))) return 'calcium_carbonate';
    if (lower.includes('omega') || lower.includes('fish oil') || lower.includes('krill') || lower.includes('salmon oil')) return 'fish_oil';
    // Note: psyllium, probiotics, vitamins don't have composition data yet
    // They can still be added but won't contribute to macro calculations
    return null;
  };

  // Process ingredients
  for (const ingredient of ingredients) {
    const name = typeof ingredient === 'string' ? ingredient : ingredient.name;
    const amount = typeof ingredient === 'string' ? 100 : (ingredient.amount ? parseFloat(String(ingredient.amount).replace(/[^0-9.]/g, '')) : 100);

    const ingKey = name.toLowerCase().replace(/\s+/g, '_');
    const composition = getIngredientComposition(ingKey);
    
    if (composition && composition.protein !== undefined) {
      // Check if composition uses fallback (has needsReview and source is estimated_fallback)
      const usesFallback = (composition as any).needsReview === true && 
                          (composition.source === 'estimated_fallback' || composition.source?.includes('fallback'));
      
      if (usesFallback) {
        fallbackIngredients.push(name);
      }
      
      totalProtein += (composition.protein || 0) * (amount / 100);
      totalFat += (composition.fat || 0) * (amount / 100);
      totalFiber += (composition.fiber || 0) * (amount / 100);
      totalCalcium += (composition.calcium || 0) * (amount / 100);
      totalPhosphorus += (composition.phosphorus || 0) * (amount / 100);
      totalCalories += (composition.kcal || 0) * (amount / 100);
      totalWeight += amount;
      realDataCount++;
    } else {
      // Try fallback nutrition
      const fallback = getFallbackNutrition(name);
      if (fallback) {
        fallbackIngredients.push(name);
        totalProtein += (fallback.protein || 0) * (amount / 100);
        totalFat += (fallback.fat || 0) * (amount / 100);
        totalFiber += (fallback.fiber || 0) * (amount / 100);
        totalCalcium += (fallback.calcium || 0) * (amount / 100);
        totalPhosphorus += (fallback.phosphorus || 0) * (amount / 100);
        totalCalories += (fallback.kcal || 0) * (amount / 100);
        totalWeight += amount;
        realDataCount++;
      }
    }
  }

  // Process supplements - add their nutritional contributions
  for (const supplement of supplements) {
    const name = supplement.name || supplement.productName || '';
    if (!name) continue;
    
    // Map supplement name to ingredient composition key
    const compositionKey = mapSupplementToCompositionKey(name);
    if (!compositionKey) continue;
    
    // Get composition data
    const composition = getIngredientComposition(compositionKey);
    if (!composition) continue;
    
    // Supplements are typically added in small amounts (mg or grams)
    // Parse amount from supplement.amount (e.g., "250mg", "1g", "As directed")
    let supplementAmount = 0;
    const amountStr = supplement.amount || supplement.defaultAmount || '';
    if (amountStr) {
      // Extract numeric value
      const numericMatch = amountStr.match(/([\d.]+)/);
      if (numericMatch) {
        supplementAmount = parseFloat(numericMatch[1]);
        // Convert mg to grams if needed
        if (amountStr.toLowerCase().includes('mg')) {
          supplementAmount = supplementAmount / 1000;
        }
      } else {
        // Default supplement amount (typically 1-5g for powders)
        supplementAmount = 2; // 2g default
      }
    } else {
      supplementAmount = 2; // 2g default
    }
    
    // Add supplement nutrition to totals
    // Supplements contribute nutrients but typically don't add significant weight to the meal
    // We'll add them proportionally to the existing meal weight
    if (totalWeight > 0) {
      // Add supplement nutrients as if they were part of the meal
      totalCalcium += (composition.calcium || 0) * (supplementAmount / 100);
      totalPhosphorus += (composition.phosphorus || 0) * (supplementAmount / 100);
      totalProtein += (composition.protein || 0) * (supplementAmount / 100);
      totalFat += (composition.fat || 0) * (supplementAmount / 100);
      totalFiber += (composition.fiber || 0) * (supplementAmount / 100);
      totalCalories += (composition.kcal || 0) * (supplementAmount / 100);
      // Add supplement weight to total (small contribution)
      totalWeight += supplementAmount;
      realDataCount++;
    }
  }

  if (realDataCount > 0 && totalWeight > 0) {
    return {
      protein: (totalProtein / totalWeight) * 100,
      fat: (totalFat / totalWeight) * 100,
      fiber: (totalFiber / totalWeight) * 100,
      calcium: (totalCalcium / totalWeight) * 100,
      phosphorus: (totalPhosphorus / totalWeight) * 100,
      calories: (totalCalories / totalWeight) * 100,
      source: fallbackIngredients.length > 0 ? 'estimated' : 'real',
      usesFallbackNutrition: fallbackIngredients.length > 0,
      fallbackIngredients: fallbackIngredients.length > 0 ? fallbackIngredients : undefined,
    };
  }

  // Fallback estimates
  return {
    protein: 25,
    fat: 15,
    fiber: 3,
    calcium: 0.8,
    phosphorus: 0.6,
    calories: 150,
    source: 'estimated',
  };
}

/**
 * Perfect path short-circuit: Check if recipe is a perfect match for a perfect pet
 */
function isPerfectMatch(recipe: Recipe, pet: Pet): boolean {
  // Pet must have no health concerns and no allergies
  if (pet.healthConcerns.length > 0) return false;
  if ((pet.allergies?.length ?? 0) > 0) return false;
  if (pet.dietaryRestrictions.length > 0) return false;
  
  // Recipe must match species
  if (!matchesSpecies(recipe, pet)) return false;
  
  // Recipe must match age group
  const petAgeGroup = pet.age < 1 ? 'baby' : pet.age < 2 ? 'young' : pet.age < 7 ? 'adult' : 'senior';
  if (!recipe.ageGroup || !recipe.ageGroup.includes(petAgeGroup)) {
    if (!recipe.ageGroup?.includes('all') && recipe.ageGroup && recipe.ageGroup.length > 0) {
      return false;
    }
  }
  
  // All ingredients must be safe for species
  const normalizedSpecies = normalizeSpecies(pet.type);
  const ingredients = recipe.ingredients || [];
  for (const ing of ingredients) {
    const ingName = typeof ing === 'string' ? ing : ing.name;
    const ingKey = ingName.toLowerCase().replace(/\s+/g, '_');
    const compat = getSpeciesCompatibility(ingKey, normalizedSpecies);
    if (compat === 'avoid') return false;
  }
  
  // Check for banned ingredients
  const bannedIngredients = (pet as any).bannedIngredients || [];
  if (bannedIngredients.length > 0) {
    const recipeIngNames = ingredients.map(ing => 
      (typeof ing === 'string' ? ing : ing.name).toLowerCase()
    );
    for (const banned of bannedIngredients) {
      if (recipeIngNames.some(name => name.includes(banned.toLowerCase()) || banned.toLowerCase().includes(name))) {
        return false;
      }
    }
  }
  
  // Recipe must meet OPTIMAL nutrient requirements (not just minimums)
  const nutrition = calculateRecipeNutrition(recipe);
  const petCategory = normalizedSpecies === 'dog' ? 'dogs' : 
                      normalizedSpecies === 'cat' ? 'cats' :
                      normalizedSpecies === 'bird' ? 'birds' :
                      normalizedSpecies === 'reptile' ? 'reptiles' : 'pocket-pets';
  const ageGroup = pet.age < 1 ? 'puppy' : pet.age >= 7 ? 'senior' : 'adult';
  const requirements = nutritionalGuidelines[petCategory]?.[ageGroup] || nutritionalGuidelines[petCategory]?.adult;
  
  if (requirements) {
    // Require nutrition to be in IDEAL range (middle 30% of min-max range - very strict for perfect match)
    if (requirements.protein) {
      const range = requirements.protein.max - requirements.protein.min;
      const idealMin = requirements.protein.min + (range * 0.35); // Middle 30% of range
      const idealMax = requirements.protein.max - (range * 0.35);
      if (nutrition.protein < idealMin || nutrition.protein > idealMax) {
        return false;
      }
    }
    if (requirements.fat) {
      const range = requirements.fat.max - requirements.fat.min;
      const idealMin = requirements.fat.min + (range * 0.35);
      const idealMax = requirements.fat.max - (range * 0.35);
      if (nutrition.fat < idealMin || nutrition.fat > idealMax) {
        return false;
      }
    }
    
    // Require Ca:P ratio to be in OPTIMAL range (1.4-1.7, very tight for perfect match)
    if (nutrition.calcium && nutrition.phosphorus && requirements.calcium && requirements.phosphorus) {
      const ratio = nutrition.calcium / nutrition.phosphorus;
      if (ratio < 1.4 || ratio > 1.7) {
        return false;
      }
    }
  }
  
  // Require NO fallback nutrition (100% data coverage required for perfect match)
  if (nutrition.usesFallbackNutrition) {
    return false; // Perfect matches must have complete nutritional data
  }
  
  // Require data coverage > 95% (not just "no fallback")
  const totalIngredients = ingredients.length;
  if (nutrition.fallbackIngredients && nutrition.fallbackIngredients.length > 0) {
    const coverage = ((totalIngredients - nutrition.fallbackIngredients.length) / totalIngredients) * 100;
    if (coverage < 95) {
      return false; // Must have >95% data coverage
    }
  }
  
  // Require all core nutrients in ideal bands (not just protein/fat)
  if (requirements) {
    // Check fiber if required
    if (requirements.fiber) {
      const range = requirements.fiber.max - requirements.fiber.min;
      const idealMin = requirements.fiber.min + (range * 0.35);
      const idealMax = requirements.fiber.max - (range * 0.35);
      if (nutrition.fiber < idealMin || nutrition.fiber > idealMax) {
        return false;
      }
    }
    // Check calcium if required
    if (requirements.calcium) {
      const range = requirements.calcium.max - requirements.calcium.min;
      const idealMin = requirements.calcium.min + (range * 0.35);
      const idealMax = requirements.calcium.max - (range * 0.35);
      if (nutrition.calcium < idealMin || nutrition.calcium > idealMax) {
        return false;
      }
    }
    // Check phosphorus if required
    if (requirements.phosphorus) {
      const range = requirements.phosphorus.max - requirements.phosphorus.min;
      const idealMin = requirements.phosphorus.min + (range * 0.35);
      const idealMax = requirements.phosphorus.max - (range * 0.35);
      if (nutrition.phosphorus < idealMin || nutrition.phosphorus > idealMax) {
        return false;
      }
    }
  }
  
  // Require ingredient quality to be above threshold (at least 85% - very strict for perfect match)
  const qualityScore = calculateIngredientQualityScore(recipe.ingredients || []);
  if (qualityScore.score < 85) {
    return false;
  }
  
  // Require sufficient ingredient diversity (at least 3 different ingredient types)
  const ingredientTypes = new Set<string>();
  for (const ing of ingredients) {
    const ingName = typeof ing === 'string' ? ing : ing.name;
    const ingKey = ingName.toLowerCase().replace(/\s+/g, '_');
    const compat = getSpeciesCompatibility(ingKey, normalizedSpecies);
    if (compat === 'ok') {
      // Categorize ingredient type
      if (ingKey.includes('chicken') || ingKey.includes('turkey') || ingKey.includes('beef') || 
          ingKey.includes('lamb') || ingKey.includes('fish') || ingKey.includes('salmon') ||
          ingKey.includes('pork') || ingKey.includes('duck') || ingKey.includes('organ') ||
          ingKey.includes('heart') || ingKey.includes('liver') || ingKey.includes('egg')) {
        ingredientTypes.add('protein');
      } else if (ingKey.includes('rice') || ingKey.includes('potato') || ingKey.includes('oats') ||
                 ingKey.includes('quinoa') || ingKey.includes('barley') || ingKey.includes('grain')) {
        ingredientTypes.add('carb');
      } else if (ingKey.includes('carrot') || ingKey.includes('broccoli') || ingKey.includes('spinach') ||
                 ingKey.includes('kale') || ingKey.includes('vegetable') || ingKey.includes('green')) {
        ingredientTypes.add('vegetable');
      } else if (ingKey.includes('blueberry') || ingKey.includes('apple') || ingKey.includes('fruit')) {
        ingredientTypes.add('fruit');
      } else if (ingKey.includes('oil') || ingKey.includes('fat') || ingKey.includes('supplement')) {
        ingredientTypes.add('supplement');
      }
    }
  }
  if (ingredientTypes.size < 3) {
    return false; // Need at least 3 different ingredient types
  }
  
  return true;
}

/**
 * Calculate bonus points for perfect matches
 */
export function calculateBonuses(recipe: Recipe, pet: Pet): number {
  let bonus = 0;
  
  // Exact species fit (reduced from 2 to 1)
  if (matchesSpecies(recipe, pet)) {
    bonus += 1;
  }
  
  // Exact life stage match (reduced from 2 to 1)
  const petAgeGroup = pet.age < 1 ? 'baby' : pet.age < 2 ? 'young' : pet.age < 7 ? 'adult' : 'senior';
  if (recipe.ageGroup?.includes(petAgeGroup) || recipe.ageGroup?.includes('all')) {
    bonus += 1;
  }
  
  // No allergens (reduced from 2 to 1)
  if ((pet.allergies?.length ?? 0) === 0 && pet.dietaryRestrictions.length === 0) {
    bonus += 1;
  } else {
    // Check if recipe avoids allergens
    const allAllergens = [...(pet.allergies || []), ...pet.dietaryRestrictions];
    const recipeIngNames = (recipe.ingredients || []).map(ing => 
      (typeof ing === 'string' ? ing : ing.name).toLowerCase()
    ).join(' ');
    const hasAllergen = allAllergens.some(a => recipeIngNames.includes(a.toLowerCase()));
    if (!hasAllergen) {
      bonus += 1;
    }
  }
  
  // No fallback nutritional data (reduced from 2 to 1)
  const nutrition = calculateRecipeNutrition(recipe);
  if (!nutrition.usesFallbackNutrition) {
    bonus += 1;
  }
  
  // Ideal nutrient ratios (reduced from 2 to 1)
  if (nutrition.calcium && nutrition.phosphorus) {
    const ratio = nutrition.calcium / nutrition.phosphorus;
    if (ratio >= 1.2 && ratio <= 2.0) {
      bonus += 1;
    }
  }
  
  // Complete ingredient data (check coverage) (reduced from 2 to 1)
  const totalIngredients = (recipe.ingredients || []).length;
  if (nutrition.fallbackIngredients) {
    const coverage = totalIngredients > 0 
      ? 1 - (nutrition.fallbackIngredients.length / totalIngredients)
      : 0;
    if (coverage >= 0.9) {
      bonus += 1;
    }
  } else if (totalIngredients > 0) {
    bonus += 1; // All ingredients have data
  }
  
  return Math.min(2, bonus); // Cap at 2% bonus (further reduced to prevent clustering at 100%)
}

/**
 * Convert score to letter grade
 */
export function getGrade(score: number): 'A+' | 'A' | 'B+' | 'B' | 'C+' | 'C' | 'D' | 'F' {
  if (score >= 95) return 'A+';
  if (score >= 90) return 'A';
  if (score >= 85) return 'B+';
  if (score >= 80) return 'B';
  if (score >= 75) return 'C+';
  if (score >= 70) return 'C';
  if (score >= 60) return 'D';
  return 'F';
}

/**
 * Scoring tier system for better UX
 */
export type ScoreTier = 'A+' | 'A' | 'B+' | 'B' | 'C+' | 'C' | 'D' | 'F';

export function getScoreTier(score: number): ScoreTier {
  if (score >= 95) return 'A+';
  if (score >= 90) return 'A';
  if (score >= 85) return 'B+';
  if (score >= 80) return 'B';
  if (score >= 75) return 'C+';
  if (score >= 70) return 'C';
  if (score >= 60) return 'D';
  return 'F';
}

/**
 * Check if recipe is gold-standard for a simple pet (perfect match criteria)
 */
export function isGoldStandardForSimplePet(recipe: Recipe, pet: Pet): boolean {
  // Species & age correct
  if (!matchesSpecies(recipe, pet)) return false;
  
  const petAgeGroup = pet.age < 1 ? 'baby' : pet.age < 2 ? 'young' : pet.age < 7 ? 'adult' : 'senior';
  if (!recipe.ageGroup || !recipe.ageGroup.includes(petAgeGroup)) {
    if (!recipe.ageGroup?.includes('all') && recipe.ageGroup && recipe.ageGroup.length > 0) {
      return false;
    }
  }
  
  // No allergens/never-feed ingredients
  const allAllergens = [...(pet.allergies || []), ...pet.dietaryRestrictions];
  if (allAllergens.length > 0) {
    const recipeIngNames = (recipe.ingredients || []).map(ing => 
      (typeof ing === 'string' ? ing : ing.name).toLowerCase()
    ).join(' ');
    const hasAllergen = allAllergens.some(a => recipeIngNames.includes(a.toLowerCase()));
    if (hasAllergen) return false;
  }
  
  // Check for banned ingredients
  const bannedIngredients = (pet as any).bannedIngredients || [];
  if (bannedIngredients.length > 0) {
    const recipeIngNames = (recipe.ingredients || []).map(ing => 
      (typeof ing === 'string' ? ing : ing.name).toLowerCase()
    );
    for (const banned of bannedIngredients) {
      if (recipeIngNames.some(name => name.includes(banned.toLowerCase()) || banned.toLowerCase().includes(name))) {
        return false;
      }
    }
  }
  
  // No health concerns OR recipe is neutral/beneficial
  if (pet.healthConcerns.length > 0) {
    const recipeNotSuitable = (recipe.notSuitableFor || []).map(c => normalizeHealthConcern(c));
    const petConcerns = pet.healthConcerns.map(c => normalizeHealthConcern(c));
    const hasConflict = recipeNotSuitable.some(ns => 
      petConcerns.some(pc => ns.includes(pc) || pc.includes(ns))
    );
    if (hasConflict) return false;
  }
  
  // Core nutrients within ideal bands
  const nutrition = calculateRecipeNutrition(recipe);
  const normalizedSpecies = normalizeSpecies(pet.type);
  const petCategory = normalizedSpecies === 'dog' ? 'dogs' : 
                      normalizedSpecies === 'cat' ? 'cats' :
                      normalizedSpecies === 'bird' ? 'birds' :
                      normalizedSpecies === 'reptile' ? 'reptiles' : 'pocket-pets';
  const ageGroup = pet.age < 1 ? 'puppy' : pet.age >= 7 ? 'senior' : 'adult';
  const requirements = nutritionalGuidelines[petCategory]?.[ageGroup] || nutritionalGuidelines[petCategory]?.adult;
  
  if (requirements) {
    if (requirements.protein) {
      if (nutrition.protein < requirements.protein.min || nutrition.protein > requirements.protein.max) {
        return false;
      }
    }
    if (requirements.fat) {
      if (nutrition.fat < requirements.fat.min || nutrition.fat > requirements.fat.max) {
        return false;
      }
    }
    
    // Ca:P ratio in safe range
    if (nutrition.calcium && nutrition.phosphorus && requirements.calcium && requirements.phosphorus) {
      const ratio = nutrition.calcium / nutrition.phosphorus;
      if (ratio < 1.0 || ratio > 2.5) return false;
    }
  }
  
  // No fallback nutrition (or confidence threshold met)
  if (nutrition.usesFallbackNutrition && nutrition.fallbackIngredients) {
    const totalIngredients = (recipe.ingredients || []).length;
    const confidence = totalIngredients > 0 
      ? 1 - (nutrition.fallbackIngredients.length / totalIngredients)
      : 0;
    if (confidence < 0.8) return false; // Require 80% data coverage
  }
  
  return true;
}

/**
 * Per-pet calibration: Rescale scores so best gold-standard recipe becomes 100%
 */
/**
 * Calibrate scores for a pet across multiple recipes
 * Rescales scores so the best perfect match becomes 95-100, or caps at 90-95 if no perfect matches
 * Preserves ranking while improving distribution
 */
export function calibrateScoresForPet(
  recipes: Recipe[],
  pet: Pet
): Map<string, number> {
  // Score all recipes
  const scored = recipes.map(recipe => ({
    recipe,
    rawScore: calculateEnhancedCompatibility(recipe, pet).overallScore,
    isPerfectMatch: isPerfectMatch(recipe, pet)
  }));
  
  // Find best perfect match recipe
  const perfectMatchRecipes = scored.filter(s => s.isPerfectMatch);
  const bestPerfectMatch = perfectMatchRecipes.length > 0
    ? perfectMatchRecipes.reduce((best, current) => 
        current.rawScore > best.rawScore ? current : best
      )
    : null;
  
  // If we have a perfect match recipe, rescale so it becomes 95-100
  if (bestPerfectMatch && bestPerfectMatch.rawScore > 0) {
    // Target: best perfect match should be 98 (allows room for variation)
    const targetScore = 98;
    const scaleFactor = targetScore / bestPerfectMatch.rawScore;
    const calibrated = new Map<string, number>();
    
    // Calculate mean and std dev for monotonic transform
    const scores = scored.map(s => s.rawScore);
    const mean = scores.reduce((a, b) => a + b, 0) / scores.length;
    const variance = scores.reduce((sum, score) => sum + Math.pow(score - mean, 2), 0) / scores.length;
    const stdDev = Math.sqrt(variance);
    
    scored.forEach(({ recipe, rawScore, isPerfectMatch }) => {
      // Rescale proportionally
      let calibratedScore = rawScore * scaleFactor;
      
      // Perfect matches can reach 100, others capped at 95
      if (isPerfectMatch) {
        calibratedScore = Math.min(100, calibratedScore);
      } else {
        calibratedScore = Math.min(95, calibratedScore);
      }
      
      calibrated.set(recipe.id, Math.max(0, Math.min(100, Math.round(calibratedScore))));
    });
    
    return calibrated;
  }
  
  // No perfect match found - cap top score at 90-95 to honestly reflect "no perfect match"
  const maxRawScore = Math.max(...scored.map(s => s.rawScore));
  const calibrated = new Map<string, number>();
  
  if (maxRawScore > 0) {
    // Rescale so max becomes 92 (honest "no perfect match" ceiling)
    const scaleFactor = 92 / maxRawScore;
    
    scored.forEach(({ recipe, rawScore }) => {
      const calibratedScore = rawScore * scaleFactor;
      calibrated.set(recipe.id, Math.max(0, Math.min(92, Math.round(calibratedScore))));
    });
  } else {
    // All scores are 0 - return as-is
    scored.forEach(({ recipe, rawScore }) => {
      calibrated.set(recipe.id, rawScore);
    });
  }
  
  return calibrated;
}

/**
 * Calculate enhanced compatibility with per-pet calibration applied
 * This is a convenience function that scores a single recipe but applies calibration
 * if a recipe set is provided. For batch operations, use calibrateScoresForPet() directly.
 */
export function calculateEnhancedCompatibilityWithCalibration(
  recipe: Recipe,
  pet: Pet,
  allRecipes?: Recipe[]
): EnhancedCompatibilityScore {
  const rawScore = calculateEnhancedCompatibility(recipe, pet);
  
  // If all recipes provided, apply calibration
  if (allRecipes && allRecipes.length > 1) {
    const calibratedScores = calibrateScoresForPet(allRecipes, pet);
    const calibratedScore = calibratedScores.get(recipe.id);
    
    if (calibratedScore !== undefined) {
      // Return score with calibrated overallScore
      return {
        ...rawScore,
        overallScore: calibratedScore,
        grade: getGrade(calibratedScore),
      };
    }
  }
  
  return rawScore;
}
</file>

<file path="lib/utils/errorHandler.ts">
// lib/utils/errorHandler.ts
// Centralized error handling utilities

export class AppError extends Error {
  constructor(
    message: string,
    public code: string,
    public statusCode: number = 500,
    public isOperational: boolean = true
  ) {
    super(message);
    this.name = 'AppError';
    Error.captureStackTrace(this, this.constructor);
  }
}

export class DatabaseError extends AppError {
  constructor(message: string, originalError?: Error) {
    super(message, 'DATABASE_ERROR', 500);
    this.name = 'DatabaseError';
    if (originalError) {
      this.stack = originalError.stack;
    }
  }
}

export class ValidationError extends AppError {
  constructor(message: string, public fields?: Record<string, string>) {
    super(message, 'VALIDATION_ERROR', 400);
    this.name = 'ValidationError';
  }
}

export class AuthenticationError extends AppError {
  constructor(message: string = 'Authentication required') {
    super(message, 'AUTH_ERROR', 401);
    this.name = 'AuthenticationError';
  }
}

/**
 * Handle errors consistently across the app
 */
export function handleError(error: unknown): AppError {
  console.error('Error occurred:', error);
  
  if (error instanceof AppError) {
    return error;
  }
  
  if (error instanceof Error) {
    // Firebase errors
    if (error.message.includes('permission-denied')) {
      return new AuthenticationError('You don\'t have permission to access this resource');
    }
    
    if (error.message.includes('not-found')) {
      return new AppError('Resource not found', 'NOT_FOUND', 404);
    }
    
    if (error.message.includes('already-exists')) {
      return new ValidationError('Resource already exists');
    }
    
    // Network errors
    if (error.message.includes('network')) {
      return new AppError('Network error. Please check your connection.', 'NETWORK_ERROR', 503);
    }
    
    // Generic error
    return new AppError(
      error.message || 'An unexpected error occurred',
      'UNKNOWN_ERROR',
      500,
      false
    );
  }
  
  return new AppError('An unexpected error occurred', 'UNKNOWN_ERROR', 500, false);
}

/**
 * Log error to external service (e.g., Sentry)
 */
export function logError(error: Error | AppError, context?: Record<string, any>) {
  // In production, send to error tracking service
  if (process.env.NODE_ENV === 'production') {
    // TODO: Integrate with Sentry or similar
    console.error('Production error:', { error, context });
  } else {
    console.error('Development error:', error, context);
  }
}

/**
 * Toast-friendly error message
 */
export function getErrorMessage(error: unknown): string {
  if (error instanceof AppError) {
    return error.message;
  }
  
  if (error instanceof Error) {
    return error.message;
  }
  
  return 'An unexpected error occurred. Please try again.';
}
</file>

<file path="lib/utils/firebaseConfig.ts">
// lib/utils/firebaseConfig.ts
// Firebase configuration and initialization with proper error handling

import { initializeApp, type FirebaseApp, getApps } from 'firebase/app';
import { getFirestore, type Firestore, connectFirestoreEmulator } from 'firebase/firestore';
import { getAuth, type Auth, connectAuthEmulator } from 'firebase/auth';

// Firebase configuration from environment variables
const firebaseConfig = {
  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,
};

let app: FirebaseApp | null = null;
let db: Firestore | null = null;
let auth: Auth | null = null;
let initializationError: Error | null = null;

/**
 * Check if Firebase is properly configured
 */
function isFirebaseConfigured(): boolean {
  return !!(
    firebaseConfig.apiKey &&
    firebaseConfig.authDomain &&
    firebaseConfig.projectId
  );
}

/**
 * Initialize Firebase services
 * Returns null if Firebase is not configured
 */
export function initializeFirebase(): { app: FirebaseApp; db: Firestore; auth: Auth } | null {
  // Server-side check
  if (typeof window === 'undefined') return null;
  
  // Return existing instance
  if (app && db && auth) {
    return { app, db, auth };
  }
  
  try {
    // Check if Firebase is configured
    if (!isFirebaseConfigured()) {
      console.warn('Firebase not configured - using localStorage fallback');
      return null;
    }
    
    // Use existing app or initialize new one
    if (getApps().length === 0) {
      app = initializeApp(firebaseConfig);
    } else {
      app = getApps()[0];
    }
    
    // Initialize Firestore
    db = getFirestore(app);
    
    // Initialize Auth
    auth = getAuth(app);
    
    // Connect to emulators in development
    if (process.env.NODE_ENV === 'development' && process.env.NEXT_PUBLIC_USE_FIREBASE_EMULATOR === 'true') {
      try {
        connectFirestoreEmulator(db, 'localhost', 8080);
        connectAuthEmulator(auth, 'http://localhost:9099', { disableWarnings: true });
        console.log('Connected to Firebase emulators');
      } catch (e) {
        // Emulators already connected or not available
      }
    }
    
    return { app, db, auth };
  } catch (error) {
    initializationError = error as Error;
    console.error('Firebase initialization failed:', error);
    return null;
  }
}

/**
 * Get Firebase services (initializes if needed)
 */
export function getFirebaseServices(): { app: FirebaseApp; db: Firestore; auth: Auth } | null {
  if (app && db && auth) {
    return { app, db, auth };
  }
  return initializeFirebase();
}

/**
 * Get app ID from environment
 */
export function getAppId(): string {
  return process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID || 'pet-plates-app';
}

/**
 * Check if Firebase is available
 */
export function isFirebaseAvailable(): boolean {
  return getFirebaseServices() !== null;
}

/**
 * Get initialization error if any
 */
export function getInitializationError(): Error | null {
  return initializationError;
}
</file>

<file path="lib/utils/getAmazonBuyLink.ts">
// Runtime Amazon link finalizer - ensures all buy links are safe before display
// This is the ONLY function that should be used to get Amazon links in the UI

import { ensureSellerId, isValidAmazonUrl, extractASIN } from './affiliateLinks';

export type Region = 'US' | 'UK' | 'DE' | 'AU';

export interface BuyLinkResult {
  url: string | null;
  status: 'ok' | 'missing' | 'invalid' | 'region-unavailable';
  asin?: string;
}

/**
 * Runtime finalizer for Amazon buy links.
 * Guarantees:
 * - Affiliate tag is present (tag=robinfrench-20)
 * - URL is valid Amazon URL
 * - ASIN can be extracted (proves it's a product link, not search)
 * 
 * Returns null if link is broken/invalid - UI should handle gracefully.
 * 
 * @param rawUrl The raw Amazon URL from data files
 * @param region User's region (default: US)
 * @returns Finalized URL with affiliate tag, or null if invalid
 */
export function getAmazonBuyLink(
  rawUrl: string | undefined | null,
  region: Region = 'US'
): string | null {
  if (!rawUrl) return null;
  
  // Validate it's an Amazon URL
  if (!isValidAmazonUrl(rawUrl)) return null;
  
  // Extract ASIN to verify it's a product link (not a search)
  const asin = extractASIN(rawUrl);
  if (!asin) {
    // No ASIN means it's a search URL or malformed - reject it
    return null;
  }
  
  // Add affiliate tag
  const withTag = ensureSellerId(rawUrl);
  
  // Re-validate after mutation (defensive)
  if (!isValidAmazonUrl(withTag)) return null;
  
  return withTag;
}

/**
 * Extended version that returns detailed status for debugging.
 * Use this in admin/debug views to see why links are failing.
 */
export function getAmazonBuyLinkWithStatus(
  rawUrl: string | undefined | null,
  region: Region = 'US'
): BuyLinkResult {
  if (!rawUrl) {
    return { url: null, status: 'missing' };
  }
  
  if (!isValidAmazonUrl(rawUrl)) {
    return { url: null, status: 'invalid' };
  }
  
  const asin = extractASIN(rawUrl);
  if (!asin) {
    return { url: null, status: 'invalid' };
  }
  
  // TODO: Add region-specific validation when we support multi-region
  // For now, all links are US-only
  if (region !== 'US') {
    return { url: null, status: 'region-unavailable', asin };
  }
  
  const withTag = ensureSellerId(rawUrl);
  
  if (!isValidAmazonUrl(withTag)) {
    return { url: null, status: 'invalid', asin };
  }
  
  return { url: withTag, status: 'ok', asin };
}

/**
 * Fallback: Generate Amazon search link if no specific product link exists.
 * Only use this if you explicitly decide to allow generic searches (Policy B).
 * 
 * @param query Search query (e.g., ingredient name + brand)
 * @param region User's region
 * @returns Amazon search URL with affiliate tag
 */
export function getFallbackAmazonSearchLink(
  query: string,
  region: Region = 'US'
): string {
  const base = region === 'US' ? 'https://www.amazon.com/s' : 'https://www.amazon.co.uk/s';
  const url = `${base}?k=${encodeURIComponent(query)}`;
  return ensureSellerId(url);
}
</file>

<file path="lib/utils/healthConcernMatching.ts">
// lib/utils/healthConcernMatching.ts
// Health concern matching system for tiered scoring

export interface HealthConcernBenefits {
  beneficialIngredients: string[];
  avoidIngredients: string[];
  targetMacros?: {
    protein?: 'low' | 'moderate' | 'high';
    fat?: 'low' | 'moderate' | 'high' | 'very-low';
    fiber?: 'low' | 'moderate' | 'high';
    phosphorus?: 'low' | 'moderate' | 'high';
  };
  targetRatios?: {
    caP?: { min: number; max: number };
  };
}

export const HEALTH_CONCERN_BENEFITS: Record<string, HealthConcernBenefits> = {
  'kidney-disease': {
    beneficialIngredients: ['egg-whites', 'white-rice', 'fish-oil', 'low-phosphorus-vegetables', 'sweet-potato'],
    avoidIngredients: ['organ-meats', 'high-phosphorus-foods', 'excess-sodium', 'red-meat'],
    targetMacros: {
      protein: 'low',
      phosphorus: 'low',
      fat: 'moderate',
    },
  },
  'pancreatitis': {
    beneficialIngredients: ['lean-turkey', 'white-fish', 'sweet-potato', 'pumpkin', 'low-fat-protein'],
    avoidIngredients: ['high-fat-meats', 'oils', 'fried-foods', 'fatty-fish', 'pork'],
    targetMacros: {
      fat: 'very-low',
      fiber: 'high',
      protein: 'moderate',
    },
  },
  'allergies': {
    beneficialIngredients: ['novel-proteins', 'fish-oil', 'anti-inflammatory-foods'],
    avoidIngredients: ['common-allergens'], // Will be replaced with pet-specific allergens
    targetMacros: {
      protein: 'moderate',
    },
  },
  'weight-management': {
    beneficialIngredients: ['lean-protein', 'high-fiber-vegetables', 'pumpkin', 'green-beans'],
    avoidIngredients: ['high-calorie-foods', 'excess-fat'],
    targetMacros: {
      fat: 'low',
      fiber: 'high',
      protein: 'moderate',
    },
  },
  'digestive-health': {
    beneficialIngredients: ['pumpkin', 'sweet-potato', 'probiotic-foods', 'fiber-rich-vegetables'],
    avoidIngredients: ['irritating-foods', 'high-fat'],
    targetMacros: {
      fiber: 'high',
      fat: 'moderate',
    },
  },
  'joint-mobility': {
    beneficialIngredients: ['fish-oil', 'omega-3-sources', 'glucosamine-sources', 'anti-inflammatory-foods'],
    avoidIngredients: ['high-purine-foods'],
    targetMacros: {
      fat: 'moderate',
    },
  },
  'skin-coat': {
    beneficialIngredients: ['fish-oil', 'omega-3-sources', 'vitamin-e-sources', 'healthy-fats'],
    avoidIngredients: ['low-quality-fats'],
    targetMacros: {
      fat: 'moderate',
    },
  },
  'dental-health': {
    beneficialIngredients: ['crunchy-vegetables', 'dental-chews', 'raw-bones'],
    avoidIngredients: ['sticky-foods', 'sugary-foods'],
    targetMacros: {},
  },
  'urinary-support': {
    beneficialIngredients: ['moisture-rich-foods', 'low-magnesium-foods', 'cranberry'],
    avoidIngredients: ['high-magnesium-foods', 'excess-minerals'],
    targetMacros: {
      protein: 'moderate',
    },
  },
  'diabetes': {
    beneficialIngredients: ['low-glycemic-vegetables', 'high-fiber-foods', 'lean-protein'],
    avoidIngredients: ['high-sugar-foods', 'simple-carbohydrates'],
    targetMacros: {
      fiber: 'high',
      fat: 'moderate',
      protein: 'moderate',
    },
  },
  'heart-disease': {
    beneficialIngredients: ['omega-3-sources', 'low-sodium-foods', 'lean-protein'],
    avoidIngredients: ['high-sodium-foods', 'excess-fat'],
    targetMacros: {
      fat: 'low',
      protein: 'moderate',
    },
  },
};

/**
 * Normalize health concern name for matching
 */
export function normalizeHealthConcern(concern: string): string {
  return concern
    .toLowerCase()
    .replace(/\s+/g, '-')
    .replace(/[^a-z0-9-]/g, '');
}

/**
 * Get health concern benefits data
 */
export function getHealthConcernBenefits(concern: string): HealthConcernBenefits | null {
  const normalized = normalizeHealthConcern(concern);
  return HEALTH_CONCERN_BENEFITS[normalized] || null;
}

/**
 * Check if an ingredient name matches a beneficial ingredient
 */
export function isBeneficialIngredient(ingredientName: string, beneficialList: string[]): boolean {
  const normalized = ingredientName.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
  return beneficialList.some(beneficial => {
    const normalizedBeneficial = beneficial.toLowerCase().replace(/\s+/g, '-');
    return normalized.includes(normalizedBeneficial) || normalizedBeneficial.includes(normalized);
  });
}

/**
 * Check if an ingredient name matches an avoid ingredient
 */
export function isAvoidIngredient(ingredientName: string, avoidList: string[], petAllergies?: string[]): boolean {
  const normalized = ingredientName.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
  
  // Check against avoid list
  const matchesAvoid = avoidList.some(avoid => {
    if (avoid === 'common-allergens' && petAllergies) {
      // Check against pet's specific allergies
      return petAllergies.some(allergy => 
        normalized.includes(allergy.toLowerCase()) || 
        allergy.toLowerCase().includes(normalized)
      );
    }
    const normalizedAvoid = avoid.toLowerCase().replace(/\s+/g, '-');
    return normalized.includes(normalizedAvoid) || normalizedAvoid.includes(normalized);
  });
  
  return matchesAvoid;
}

/**
 * Check macro alignment with target macros
 */
export function checkMacroAlignment(
  nutrition: { protein: number; fat: number; fiber: number; phosphorus?: number },
  targetMacros?: HealthConcernBenefits['targetMacros']
): number {
  if (!targetMacros) return 50; // Neutral if no targets
  
  let alignmentScore = 0;
  let factors = 0;
  
  if (targetMacros.protein) {
    factors++;
    if (targetMacros.protein === 'low' && nutrition.protein < 20) alignmentScore += 30;
    else if (targetMacros.protein === 'moderate' && nutrition.protein >= 20 && nutrition.protein <= 30) alignmentScore += 30;
    else if (targetMacros.protein === 'high' && nutrition.protein > 30) alignmentScore += 30;
    else alignmentScore += 10; // Partial alignment
  }
  
  if (targetMacros.fat) {
    factors++;
    if (targetMacros.fat === 'very-low' && nutrition.fat < 8) alignmentScore += 30;
    else if (targetMacros.fat === 'low' && nutrition.fat < 12) alignmentScore += 30;
    else if (targetMacros.fat === 'moderate' && nutrition.fat >= 12 && nutrition.fat <= 18) alignmentScore += 30;
    else if (targetMacros.fat === 'high' && nutrition.fat > 18) alignmentScore += 30;
    else alignmentScore += 10;
  }
  
  if (targetMacros.fiber) {
    factors++;
    if (targetMacros.fiber === 'low' && nutrition.fiber < 5) alignmentScore += 30;
    else if (targetMacros.fiber === 'moderate' && nutrition.fiber >= 5 && nutrition.fiber <= 10) alignmentScore += 30;
    else if (targetMacros.fiber === 'high' && nutrition.fiber > 10) alignmentScore += 30;
    else alignmentScore += 10;
  }
  
  if (targetMacros.phosphorus && nutrition.phosphorus !== undefined) {
    factors++;
    if (targetMacros.phosphorus === 'low' && nutrition.phosphorus < 0.6) alignmentScore += 30;
    else if (targetMacros.phosphorus === 'moderate' && nutrition.phosphorus >= 0.6 && nutrition.phosphorus <= 1.0) alignmentScore += 30;
    else if (targetMacros.phosphorus === 'high' && nutrition.phosphorus > 1.0) alignmentScore += 30;
    else alignmentScore += 10;
  }
  
  return factors > 0 ? alignmentScore / factors : 50;
}
</file>

<file path="lib/utils/imageMapping.ts">
// Utility functions for image mapping and emoji groups
import { imageManifest, healthConcernStyles, petCategoryStyles, type ImageGroup } from '@/lib/data/imageManifest';

export type ImageVariant = keyof ImageGroup['variants'];

/**
 * Get the image group key for a given emoji
 */
export function getEmojiGroup(emoji: string): string | null {
  for (const [groupKey, group] of Object.entries(imageManifest)) {
    if (group.emojis.includes(emoji)) {
      return groupKey;
    }
  }
  return null;
}

/**
 * Get the image path for a specific emoji and variant
 */
export function getEmojiImagePath(emoji: string, variant: ImageVariant): string | null {
  const groupKey = getEmojiGroup(emoji);
  if (!groupKey) return null;

  const group = imageManifest[groupKey];
  const variantFile = group.variants[variant as keyof typeof group.variants];

  // Assuming images are in /assets/images/animals/{group}/
  return `/assets/images/animals/${groupKey}/${variantFile}`;
}

/**
 * Get the master icon path for an emoji group
 */
export function getMasterIconPath(groupKey: string): string | null {
  const group = imageManifest[groupKey];
  return group ? group.masterIcon : null;
}

/**
 * Get the master hero path for an emoji group
 */
export function getMasterHeroPath(groupKey: string): string | null {
  const group = imageManifest[groupKey];
  return group ? group.masterHero : null;
}

/**
 * Get health concern style information
 */
export function getHealthConcernStyle(concern: string) {
  return healthConcernStyles[concern] || null;
}

/**
 * Get pet category style information
 */
export function getPetCategoryStyle(category: string) {
  return petCategoryStyles[category] || null;
}

/**
 * Get all emojis in a group
 */
export function getGroupEmojis(groupKey: string): string[] {
  const group = imageManifest[groupKey];
  return group ? group.emojis : [];
}

/**
 * Get all available groups
 */
export function getAllGroups(): string[] {
  return Object.keys(imageManifest);
}

/**
 * Check if an emoji is supported
 */
export function isEmojiSupported(emoji: string): boolean {
  return getEmojiGroup(emoji) !== null;
}
</file>

<file path="lib/utils/improvedCompatibilityScoring.ts">
// lib/utils/improvedCompatibilityScoring.ts
// Improved compatibility scoring with more accuracy and score variation.

import type { Recipe } from '@/lib/types';
import { getIngredientComposition } from '@/lib/data/ingredientCompositions';
import {
  normalizeSpecies,
  getSpeciesCompatibility,
  getMaxInclusionPercent,
} from './ingredientCompatibility';
import { validateCriticalNutrients } from '@/lib/data/aafco-standards';

// -------- Config for quick tuning -------- //
const SCORE_CONFIG = {
  weights: {
    ingredientSafety: 0.20,
    nutritionalAdequacy: 0.26,
    healthAlignment: 0.14,
    lifeStageFit: 0.10,
    allergenSafety: 0.10,
    digestibility: 0.08,
    variety: 0.12,
  },
  safeFloor: 65, // applied if ingredientSafety >= 60 && allergenSafety >= 60
  jitter: {
    low: 0.4,
    mid: 0.3,
    high: 0.2,
  },
  normalize: {
    topKeep: 95,
    topBand: 85,
    midBand: 70,
    lift50: 1.02,
    lift30: 1.05,
    liftLow: 1.08,
  },
  debug: process.env.NEXT_PUBLIC_SCORE_DEBUG === 'true',
};

export interface ImprovedPet {
  id: string;
  name: string;
  type: string; // accepts dogs/cats/birds/reptiles/pocket-pets
  breed?: string;
  age?: string | number;
  weight?: number;
  activityLevel?: 'sedentary' | 'moderate' | 'active' | 'very-active';
  healthConcerns: string[];
  dietaryRestrictions?: string[];
  allergies?: string[];
}

export interface ImprovedScore {
  overallScore: number; // 0-100
  stars: number; // 1-5
  recommendation?: 'excellent' | 'good' | 'acceptable' | 'caution' | 'avoid';
  summaryReasoning?: string;
  factors: {
    ingredientSafety: number;
    nutritionalAdequacy: number;
    healthAlignment: number;
    lifeStageFit: number;
    allergenSafety: number;
    digestibility: number;
    variety: number;
  };
  reasoning: {
    strengths: string[];
    warnings: string[];
    recommendations: string[];
  };
}

/**
 * Entry point: calculate improved compatibility score with better distribution.
 */
export function calculateImprovedCompatibility(
  recipe: Recipe,
  pet: ImprovedPet
): ImprovedScore {
  const species = normalizeSpecies(pet.type);
  const ageNum = typeof pet.age === 'string' ? parseFloat(pet.age) || 0 : pet.age || 0;

  const ingredientSafety = scoreIngredientSafety(recipe, species);
  const nutritionalAdequacy = scoreNutritionalAdequacy(recipe, pet, species, ageNum);
  const healthAlignment = scoreHealthAlignment(recipe, pet);
  const lifeStageFit = scoreLifeStageFit(recipe, ageNum);
  const allergenSafety = scoreAllergenSafety(recipe, pet);
  const digestibility = scoreDigestibility(recipe, species);
  const variety = scoreIngredientVariety(recipe);

  const weighted =
    ingredientSafety * SCORE_CONFIG.weights.ingredientSafety +
    nutritionalAdequacy * SCORE_CONFIG.weights.nutritionalAdequacy +
    healthAlignment * SCORE_CONFIG.weights.healthAlignment +
    lifeStageFit * SCORE_CONFIG.weights.lifeStageFit +
    allergenSafety * SCORE_CONFIG.weights.allergenSafety +
    digestibility * SCORE_CONFIG.weights.digestibility +
    variety * SCORE_CONFIG.weights.variety;

  const normalized = normalizeScore(weighted);
  const variation = applyControlledVariation(normalized);
  const safeFloor =
    ingredientSafety >= 60 && allergenSafety >= 60 ? SCORE_CONFIG.safeFloor : 0; // keep safe recipes from tanking
  const finalScore = clamp(
    Number(Math.max(normalized + variation, safeFloor).toFixed(1)),
    0,
    100
  );

  const strengths: string[] = [];
  const warnings: string[] = [];
  const recommendations: string[] = [];

  if (ingredientSafety >= 90) strengths.push('All ingredients are species-safe');
  if (nutritionalAdequacy < 60) {
    warnings.push('Recipe has nutritional gaps');
    recommendations.push('Add supplements or adjust ingredients for balance');
  }
  if (healthAlignment >= 80) strengths.push('Supports key health concerns');
  if (allergenSafety < 100) warnings.push('Contains known allergens');

  const { stars, recommendation, summaryReasoning } = mapScoreToStarsWithReasoning(finalScore, {
    ingredientSafety,
    nutritionalAdequacy,
    healthAlignment,
    lifeStageFit,
    allergenSafety,
    digestibility,
  });

  if (SCORE_CONFIG.debug) {
    console.log('[ScoreDebug]', {
      recipe: recipe.name,
      finalScore,
      normalized,
      variation,
      safeFloor,
      factors: {
        ingredientSafety,
        nutritionalAdequacy,
        healthAlignment,
        lifeStageFit,
        allergenSafety,
        digestibility,
        variety,
      },
    });
  }

  return {
    overallScore: finalScore,
    stars,
    recommendation,
    summaryReasoning,
    factors: {
      ingredientSafety,
      nutritionalAdequacy,
      healthAlignment,
      lifeStageFit,
      allergenSafety,
      digestibility,
      variety,
    },
    reasoning: { strengths, warnings, recommendations },
  };
}

// ------------------ Factor Calculations ------------------ //

function scoreIngredientSafety(recipe: Recipe, species: string): number {
  const ingredients = recipe.ingredients || [];
  if (!ingredients.length) return 85;

  let score = 85;
  let avoidCount = 0;
  let unknownCount = 0;

  for (const ing of ingredients) {
    const name = typeof ing === 'string' ? ing : ing.name;
    const amount = typeof ing === 'string'
      ? 100
      : ing.amount
      ? parseFloat(String(ing.amount).replace(/[^0-9.]/g, '')) || 0
      : 0;

    const key = name.toLowerCase().replace(/\s+/g, '_');
    const compat = getSpeciesCompatibility(key, species);

    if (compat === 'avoid') {
      avoidCount++;
      score -= 25;
    } else if (compat === 'limit' || compat === 'caution') {
      const maxInclusion = getMaxInclusionPercent(key, species);
      if (maxInclusion && amount / 100 > maxInclusion) {
        score -= 18;
      } else {
        score -= 12;
      }
    } else if (compat === 'ok') {
      // mildly reward clear safe ingredients
      score += 1.5;
    } else {
      // Unknown ingredient: minor uncertainty
      unknownCount++;
      score -= 3;
    }
  }

  if (avoidCount > 1) {
    score -= avoidCount * 6; // gentle compounding
  }

  const unknownRatio = ingredients.length ? unknownCount / ingredients.length : 0;
  if (unknownRatio > 0.5) {
    score -= 10;
  }

  if (avoidCount > 0) {
    score = Math.min(score, 40); // still keep avoids meaningful
  } else if (unknownCount === 0) {
    // Safety floor for clean recipes
    score = Math.max(score, 80);
  }

  return clamp(score, 0, 100);
}

function scoreNutritionalAdequacy(
  recipe: Recipe,
  pet: ImprovedPet,
  species: string,
  ageNum: number
): number {
  let score = 90;
  const nutrition = calcNutrition(recipe);

  if (species === 'dog' || species === 'cat') {
    const lifeStage = ageNum < 1 ? 'growth' : 'adult';
    const validation = validateCriticalNutrients(
      recipe,
      species as 'dog' | 'cat',
      lifeStage
    );
    if (!validation.isValid) {
      const basePenalty = Math.min(validation.violations.length * 8, 40);
      const severe = validation.violations.some(v =>
        v.toLowerCase().includes('critical') || v.toLowerCase().includes('essential')
      );
      score -= basePenalty * (severe ? 1.3 : 1);
    }

    const minProtein = lifeStage === 'growth' ? 22 : 18;
    if (nutrition.protein < minProtein) {
      const deficit = minProtein - nutrition.protein;
      const proteinPenalty = Math.min(Math.pow(deficit, 1.3) * 1.5, 30);
      score -= proteinPenalty;
    }

    if (nutrition.calcium && nutrition.phosphorus) {
      const ratio = nutrition.calcium / nutrition.phosphorus;
      if (ratio < 1.0 || ratio > 2.5) {
        const deviation = ratio < 1.0 ? 1.0 - ratio : ratio - 2.5;
        score -= Math.min(deviation * 15, 20);
      }
    }
  } else {
    // Heuristics for non-dog/cat species
    switch (species) {
      case 'bird': {
        if (nutrition.calcium && nutrition.phosphorus) {
          const ratio = nutrition.calcium / nutrition.phosphorus;
          if (ratio < 1.5 || ratio > 2.5) {
            const deviation = ratio < 1.5 ? 1.5 - ratio : ratio - 2.5;
            score -= Math.min(deviation * 25, 30);
          }
        }
        
        const breed = (pet.breed || '').toLowerCase();
        // Macaws and African Greys need higher fat (nuts)
        const highFatNeeds = ['macaw', 'grey', 'african grey'].some(b => breed.includes(b));
        
        if (highFatNeeds) {
           if (nutrition.fat < 10) score -= 10; // Penalty for low fat in large parrots
        } else {
           // Small birds (parakeets)
           if (nutrition.fat > 12) score -= 5; // Penalty for too much fat
        }

        if ((recipe.ingredients || []).length < 3) {
          score -= 5;
        }
        break;
      }
      case 'reptile': {
        if (nutrition.calcium && nutrition.phosphorus) {
          const ratio = nutrition.calcium / nutrition.phosphorus;
          if (ratio < 1.5) {
            const deviation = 1.5 - ratio;
            score -= Math.min(deviation * 25, 30);
          }
        }
        // Expanded Herbivore/carnivore heuristic
        const breed = (pet.breed || '').toLowerCase();
        const herbivore = ['iguana', 'tortoise', 'uromastyx'].some(b => breed.includes(b));
        // Add 'boa', 'python', 'king' for snakes
        const carnivore = ['snake', 'monitor', 'tegu', 'boa', 'python', 'king'].some(b => breed.includes(b));
        
        if (herbivore && nutrition.protein > 25) score -= 12;
        // Carnivores need HIGH protein
        if (carnivore) {
            if (nutrition.protein < 30) score -= 15;
            if (nutrition.fat < 10) score -= 5;
        } 
        break;
      }
      case 'pocket-pet': {
        const breed = (pet.breed || '').toLowerCase();
        
        // Check Ca:P ratio (critical for all pocket-pets)
        if (nutrition.calcium && nutrition.phosphorus) {
          const ratio = nutrition.calcium / nutrition.phosphorus;
          if (ratio < 1.5 || ratio > 2.5) {
            const deviation = ratio < 1.5 ? 1.5 - ratio : ratio - 2.5;
            score -= Math.min(deviation * 20, 25);
          }
        }
        
        // Sugar gliders & omnivores need less fiber than rabbits
        const isLowFiber = ['sugar', 'glider', 'hamster', 'rat', 'mouse', 'ferret'].some(b => breed.includes(b));
        const isHayEater = ['rabbit', 'guinea', 'chinchilla'].some(b => breed.includes(b));
        
        if (isLowFiber) {
            // They need protein/fruit, not hay
            if (nutrition.fiber > 10) score -= 8; // Increased penalty
            if (nutrition.protein < 12) score -= 15; // Increased penalty
            // Ferrets are obligate carnivores - need very high protein
            if (breed.includes('ferret') && nutrition.protein < 30) {
              score -= 20;
            }
        } else if (isHayEater) {
            // Rabbits/Guinea Pigs (Hay eaters) - need high fiber
            if (nutrition.fiber < 15) {
              score -= Math.min((15 - nutrition.fiber) * 2.5, 25); // Increased penalty
            }
            if (nutrition.protein > 20) {
              score -= Math.min((nutrition.protein - 20) * 2, 20);
            }
        } else {
            // Generic pocket-pet validation
            if (nutrition.protein < 10) score -= 12;
            if (nutrition.fiber > 20) score -= 8;
        }
        break;
      }
      default:
        // Unknown species - apply basic validation
        if (nutrition.protein < 10) {
          score -= 10;
        }
        if (nutrition.calcium && nutrition.phosphorus) {
          const ratio = nutrition.calcium / nutrition.phosphorus;
          if (ratio < 1.0 || ratio > 3.0) {
            score -= 15;
          }
        }
        break;
    }
  }

  // Data quality penalty for limited nutrition info (softer)
  if (!nutrition.hasData) {
    score -= 15;
  } else if (nutrition.dataPoints !== undefined && nutrition.totalIngredients !== undefined) {
    const coverage = nutrition.totalIngredients
      ? (nutrition.dataPoints / nutrition.totalIngredients) * 100
      : 0;
    if (coverage < 30) {
      score -= 20;
    } else if (coverage < 50) {
      score -= 12;
    } else if (coverage < 70) {
      score -= 5;
    }
  }

  return clamp(score, 0, 100);
}

function scoreHealthAlignment(recipe: Recipe, pet: ImprovedPet): number {
  const petConcernsArr = pet.healthConcerns || [];
  if (!petConcernsArr.length) return 90;

  const recipeConcerns = (recipe.healthConcerns || []).map(c => c.toLowerCase());
  const notSuitable = (recipe.notSuitableFor || []).map(c => c.toLowerCase());
  const petConcerns = petConcernsArr.map(c => c.toLowerCase().replace(/\s+/g, '-'));

  const critical = ['kidney-disease', 'diabetes', 'heart-disease', 'pancreatitis'];
  const important = ['allergies', 'digestive-issues', 'urinary-health'];

  let weighted = 0;
  const maxScore = petConcerns.length * 20 || 1;

  for (const concern of petConcerns) {
    const isCritical = critical.some(c => concern.includes(c));
    const isImportant = important.some(c => concern.includes(c));

    const blocked = notSuitable.some(ns => ns.includes(concern) || concern.includes(ns));
    if (blocked) {
      weighted -= isCritical ? 25 : 15;
      continue;
    }

    const supports = recipeConcerns.some(rc => rc.includes(concern) || concern.includes(rc));
    if (supports) {
      weighted += isCritical ? 15 : isImportant ? 12 : 10;
    } else {
      weighted -= isImportant ? 5 : 3;
    }
  }

  const base = 75;
  const score = base + (weighted / maxScore) * 25;
  return clamp(score, 0, 100);
}

function scoreLifeStageFit(recipe: Recipe, ageNum: number): number {
  const petAgeGroup = ageNum < 1 ? 'baby' : ageNum < 2 ? 'young' : ageNum < 7 ? 'adult' : 'senior';
  const groups = recipe.ageGroup || [];
  if (groups.length === 0 || groups.includes('all')) return 100;
  if (groups.includes(petAgeGroup)) return 100;

  const order = ['baby', 'young', 'adult', 'senior'];
  const petIdx = order.indexOf(petAgeGroup);
  const recipeIdxs = groups.map(g => order.indexOf(g)).filter(i => i >= 0);
  if (!recipeIdxs.length) return 60;
  const distance = Math.min(...recipeIdxs.map(i => Math.abs(petIdx - i)));
  if (distance === 1) return 75;
  if (distance === 2) return 60;
  return 45;
}

function scoreAllergenSafety(recipe: Recipe, pet: ImprovedPet): number {
  const allergens = [
    ...((pet.allergies || []) as string[]),
    ...((pet.dietaryRestrictions || []) as string[]).filter(r =>
      ['chicken', 'beef', 'dairy', 'wheat', 'egg', 'fish', 'pork', 'soy', 'corn', 'lamb'].some(a =>
        r.toLowerCase().includes(a)
      )
    ),
  ];
  if (!allergens.length) return 100;

  const ingredientText = (recipe.ingredients || [])
    .map(i => (typeof i === 'string' ? i : i.name).toLowerCase())
    .join(' ');

  const hits = allergens.filter(a => ingredientText.includes(a.toLowerCase()));
  if (!hits.length) return 100;

  const penalty = hits.length === 1 ? 15 : hits.length === 2 ? 30 : hits.length === 3 ? 50 : 70;
  return Math.max(0, 100 - penalty);
}

function scoreDigestibility(recipe: Recipe, species: string): number {
  const ingredients = recipe.ingredients || [];
  if (!ingredients.length) return 50;

  let total = 0;
  let count = 0;

  for (const ing of ingredients) {
    const name = typeof ing === 'string' ? ing : ing.name;
    const key = name.toLowerCase().replace(/\s+/g, '_');
    const comp = getIngredientComposition(key);

    if (comp) {
      if (comp.protein && comp.protein > 15) total += 20;
      if (comp.fiber !== undefined) {
        if (species === 'dog' || species === 'cat') {
          // Dogs and cats: moderate fiber (2-5%) is ideal
          if (comp.fiber >= 2 && comp.fiber <= 5) {
            total += 15;
          } else if (comp.fiber > 10) {
            total -= 10; // Too much fiber for carnivores
          }
        } else if (species === 'bird') {
          // Birds: low to moderate fiber (2-8%) is ideal
          if (comp.fiber >= 2 && comp.fiber <= 8) {
            total += 12;
          } else if (comp.fiber > 15) {
            total -= 8; // Too much fiber for birds
          }
        } else if (species === 'reptile') {
          // Reptiles: fiber needs vary by type, but generally low
          if (comp.fiber > 10) {
            total -= 5; // Most reptiles need low fiber
          }
        } else if (species === 'pocket-pet') {
          // Pocket-pets: fiber needs vary dramatically
          // Hay eaters (rabbits, guinea pigs) need high fiber
          // Omnivores (hamsters, rats) need moderate fiber
          // Carnivores (ferrets) need very low fiber
          if (comp.fiber >= 5 && comp.fiber <= 20) {
            total += 10; // Acceptable range for most pocket-pets
          } else if (comp.fiber > 25) {
            total -= 5; // May be too high for some
          }
        } else {
          // Unknown species: generic handling
          if (comp.fiber > 10) {
            total -= 5;
          }
        }
      }
      if (comp.fat && comp.fat > 0) {
        // Fat digestibility varies by species
        if (species === 'dog' || species === 'cat') {
          total += comp.fat > 10 ? 5 : 10;
        } else if (species === 'bird') {
          // Birds can handle moderate fat
          total += comp.fat > 15 ? 3 : 8;
        } else if (species === 'reptile') {
          // Reptiles generally need lower fat
          total += comp.fat > 8 ? 2 : 6;
        } else if (species === 'pocket-pet') {
          // Pocket-pets vary: ferrets need high fat, rabbits need low
          total += comp.fat > 10 ? 3 : 7;
        } else {
          total += comp.fat > 10 ? 5 : 10;
        }
      }
    } else {
      total += 5; // unknown = modest neutral
    }
    count++;
  }

  return clamp((total / Math.max(1, count)) * 5, 0, 100);
}

function scoreIngredientVariety(recipe: Recipe): number {
  const ingredients = recipe.ingredients || [];
  if (!ingredients.length) return 50;

  const categories = {
    protein: ['chicken', 'beef', 'fish', 'turkey', 'egg', 'meat', 'lamb', 'pork'],
    vegetable: ['carrot', 'spinach', 'kale', 'broccoli', 'pumpkin', 'squash', 'zucchini'],
    fruit: ['apple', 'berry', 'banana', 'melon', 'pear'],
    grain: ['rice', 'oat', 'quinoa', 'barley', 'corn', 'wheat'],
    fat: ['oil', 'butter', 'tallow', 'lard', 'flax', 'omega'],
    supplement: ['vitamin', 'mineral', 'calcium', 'taurine', 'supplement'],
  };

  const found = new Set<string>();
  for (const ing of ingredients) {
    const name = (typeof ing === 'string' ? ing : ing.name).toLowerCase();
    for (const [cat, terms] of Object.entries(categories)) {
      if (terms.some(t => name.includes(t))) {
        found.add(cat);
      }
    }
  }

  const categoriesUsed = found.size;
  let score = 30 + categoriesUsed * 12; // 3 cats => 66, 5 => 90
  if (ingredients.length < 4) {
    score -= 15;
  } else if (ingredients.length > 10) {
    score += 5;
  }
  return clamp(score, 0, 100);
}

// ------------------ Helpers ------------------ //

function calcNutrition(recipe: Recipe) {
  const ingredients = recipe.ingredients || [];
  let totalProtein = 0;
  let totalFat = 0;
  let totalCa = 0;
  let totalP = 0;
  let totalFiber = 0;
  let totalWeight = 0;
  let realData = 0;

  for (const ing of ingredients) {
    const name = typeof ing === 'string' ? ing : ing.name;
    const amount = typeof ing === 'string'
      ? 100
      : ing.amount
      ? parseFloat(String(ing.amount).replace(/[^0-9.]/g, '')) || 0
      : 0;
    const comp = getIngredientComposition(name.toLowerCase().replace(/\s+/g, '_'));
    if (comp && comp.protein !== undefined) {
      totalProtein += (comp.protein || 0) * (amount / 100);
      totalFat += (comp.fat || 0) * (amount / 100);
      totalCa += (comp.calcium || 0) * (amount / 100);
      totalP += (comp.phosphorus || 0) * (amount / 100);
      totalFiber += (comp.fiber || 0) * (amount / 100);
      totalWeight += amount;
      realData++;
    }
  }

  return {
    protein: totalWeight ? (totalProtein / totalWeight) * 100 : 25,
    fat: totalWeight ? (totalFat / totalWeight) * 100 : 15,
    calcium: totalWeight ? (totalCa / totalWeight) * 100 : 0.8,
    phosphorus: totalWeight ? (totalP / totalWeight) * 100 : 0.6,
    fiber: totalWeight ? (totalFiber / totalWeight) * 100 : 2,
    hasData: realData > 0 && totalWeight > 0,
    dataPoints: realData,
    totalIngredients: ingredients.length,
  };
}

function normalizeScore(raw: number): number {
  const n = SCORE_CONFIG.normalize;
  if (raw >= n.topKeep) return raw; // leave excellent scores alone
  if (raw >= n.topBand) return 90 + (raw - n.topBand) * 0.8; // light compression at top
  if (raw >= n.midBand) return raw; // keep solid recipes intact
  if (raw >= 50) return raw * n.lift50; // small lift to mid-low
  if (raw >= 30) return raw * n.lift30; // gentle boost to lows
  return raw * n.liftLow; // slightly more help for very low
}

function applyControlledVariation(score: number): number {
  // deterministic-ish tiny jitter: ¬±0.4 max
  const { high, mid, low } = SCORE_CONFIG.jitter;
  const range = score > 90 || score < 30 ? high : score > 70 ? mid : low;
  return (Math.random() - 0.5) * 2 * range;
}

function mapScoreToStarsWithReasoning(
  score: number,
  factors: {
    ingredientSafety: number;
    nutritionalAdequacy: number;
    healthAlignment: number;
    lifeStageFit: number;
    allergenSafety: number;
    digestibility: number;
  }
): { stars: number; recommendation: ImprovedScore['recommendation']; summaryReasoning: string } {
  // Safety overrides
  if (factors.allergenSafety < 50) {
    return {
      stars: 1,
      recommendation: 'avoid',
      summaryReasoning: 'Contains allergens for this pet',
    };
  }
  if (factors.ingredientSafety < 40) {
    return {
      stars: 1,
      recommendation: 'avoid',
      summaryReasoning: 'Unsafe ingredients detected for this species',
    };
  }

  let recommendation: ImprovedScore['recommendation'] = 'acceptable';
  if (score >= 90) recommendation = 'excellent';
  else if (score >= 80) recommendation = 'good';
  else if (score >= 70) recommendation = 'acceptable';
  else if (score >= 60) recommendation = 'caution';
  else recommendation = 'avoid';

  let summaryReasoning = 'Well-rounded recipe';
  if (score < 60) summaryReasoning = 'Significant concerns detected';
  else if (factors.nutritionalAdequacy < 65) summaryReasoning = 'Not balanced for this pet';
  else if (factors.ingredientSafety < 70) summaryReasoning = 'Ingredient safety concerns';
  else if (factors.allergenSafety < 80) summaryReasoning = 'Possible allergens detected';

  return {
    stars: mapScoreToStars(score),
    recommendation,
    summaryReasoning,
  };
}

function mapScoreToStars(score: number): number {
  if (score >= 90) return 5;
  if (score >= 75) return 4;
  if (score >= 55) return 3;
  if (score >= 30) return 2;
  return 1;
}

function clamp(val: number, min: number, max: number) {
  return Math.min(max, Math.max(min, val));
}
</file>

<file path="lib/utils/ingredientCompatibility.ts">
// lib/utils/ingredientCompatibility.ts
// Utility functions for checking ingredient compatibility with species

import { INGREDIENT_COMPOSITIONS, type SpeciesCompatibility, type FeedingRole } from '@/lib/data/ingredientCompositions';
import { getIngredientComposition } from '@/lib/data/ingredientCompositions';

export type Species = 'dog' | 'cat' | 'bird' | 'reptile' | 'pocket-pet';

/**
 * Normalize species string to standard format
 */
export function normalizeSpecies(species: string): Species | string {
  const s = (species || '').toLowerCase();
  if (s.includes('dog')) return 'dog';
  if (s.includes('cat')) return 'cat';
  if (s.includes('bird') || s.includes('parrot') || s.includes('finch')) return 'bird';
  if (s.includes('reptile') || s.includes('lizard') || s.includes('bearded') || s.includes('dragon')) return 'reptile';
  if (s.includes('pocket') || s.includes('rabbit') || s.includes('guinea') || s.includes('hamster') || s.includes('gerbil')) return 'pocket-pet';
  return s;
}

/**
 * Get species compatibility for an ingredient
 */
export function getSpeciesCompatibility(ingredientKey: string, species: string): SpeciesCompatibility | null {
  const normalizedSpecies = normalizeSpecies(species);
  const composition = getIngredientComposition(ingredientKey);
  
  if (!composition?.speciesCompatibility) return null;
  
  return composition.speciesCompatibility[normalizedSpecies as keyof typeof composition.speciesCompatibility] || null;
}

/**
 * Get max inclusion percentage for an ingredient by species
 */
export function getMaxInclusionPercent(ingredientKey: string, species: string): number | null {
  const normalizedSpecies = normalizeSpecies(species);
  const composition = getIngredientComposition(ingredientKey);
  
  if (!composition?.maxInclusionPercentBySpecies) return null;
  
  return composition.maxInclusionPercentBySpecies[normalizedSpecies as keyof typeof composition.maxInclusionPercentBySpecies] || null;
}

/**
 * Get species-specific notes for an ingredient
 */
export function getSpeciesNotes(ingredientKey: string, species: string): string | null {
  const normalizedSpecies = normalizeSpecies(species);
  const composition = getIngredientComposition(ingredientKey);
  
  if (!composition?.notesBySpecies) return null;
  
  return composition.notesBySpecies[normalizedSpecies as keyof typeof composition.notesBySpecies] || null;
}

/**
 * Get feeding role for an ingredient
 */
export function getFeedingRole(ingredientKey: string): FeedingRole | null {
  const composition = getIngredientComposition(ingredientKey);
  return composition?.feedingRole || null;
}

/**
 * Check if ingredient is compatible with species
 */
export function isCompatible(ingredientKey: string, species: string): boolean {
  const compat = getSpeciesCompatibility(ingredientKey, species);
  return compat === 'ok' || compat === 'limit' || compat === 'caution';
}

/**
 * Check if ingredient should be avoided for species
 */
export function shouldAvoid(ingredientKey: string, species: string): boolean {
  const compat = getSpeciesCompatibility(ingredientKey, species);
  return compat === 'avoid';
}

/**
 * Check if ingredient should be limited for species
 */
export function shouldLimit(ingredientKey: string, species: string): boolean {
  const compat = getSpeciesCompatibility(ingredientKey, species);
  return compat === 'limit' || compat === 'caution';
}
</file>

<file path="lib/utils/ingredientNameNormalizer.ts">
// Centralized ingredient name normalization
// Maps between display names, composition keys, and price lookup names

const INGREDIENT_NAME_MAP: Record<string, {
  display: string;
  compositionKey: string;
  priceKey: string;
}> = {
  // Proteins
  'ground chicken': {
    display: 'ground chicken',
    compositionKey: 'ground_chicken',
    priceKey: 'ground chicken'
  },
  'ground turkey': {
    display: 'ground turkey',
    compositionKey: 'ground_turkey',
    priceKey: 'ground turkey'
  },
  'ground beef (lean)': {
    display: 'ground beef (lean)',
    compositionKey: 'ground_beef_lean',
    priceKey: 'ground beef (lean)'
  },
  'ground lamb': {
    display: 'ground lamb',
    compositionKey: 'ground_lamb',
    priceKey: 'ground lamb'
  },
  'salmon (boneless)': {
    display: 'salmon (boneless)',
    compositionKey: 'salmon_atlantic',
    priceKey: 'salmon (boneless)'
  },
  'chicken breast': {
    display: 'chicken breast',
    compositionKey: 'chicken_breast',
    priceKey: 'chicken breast'
  },
  'chicken thighs': {
    display: 'chicken thighs',
    compositionKey: 'chicken_thighs',
    priceKey: 'chicken thighs'
  },
  'turkey breast': {
    display: 'turkey breast',
    compositionKey: 'turkey_breast',
    priceKey: 'turkey breast'
  },
  'beef liver': {
    display: 'beef liver',
    compositionKey: 'beef_liver',
    priceKey: 'beef liver'
  },
  'chicken liver': {
    display: 'chicken liver',
    compositionKey: 'chicken_liver',
    priceKey: 'chicken liver'
  },
  'chicken hearts': {
    display: 'chicken hearts',
    compositionKey: 'chicken_hearts',
    priceKey: 'chicken hearts'
  },
  'sardines (canned in water)': {
    display: 'sardines (canned in water)',
    compositionKey: 'sardines_water',
    priceKey: 'sardines (canned in water)'
  },
  'eggs': {
    display: 'eggs',
    compositionKey: 'eggs_whole',
    priceKey: 'eggs'
  },
  'quail': {
    display: 'quail',
    compositionKey: 'quail',
    priceKey: 'quail'
  },
  'ground pork (lean)': {
    display: 'ground pork (lean)',
    compositionKey: 'ground_pork_lean',
    priceKey: 'ground pork (lean)'
  },
  'turkey necks': {
    display: 'turkey necks',
    compositionKey: 'turkey_necks',
    priceKey: 'turkey necks'
  },
  'tuna': {
    display: 'tuna',
    compositionKey: 'tuna_water',
    priceKey: 'tuna'
  },

  // Carbs
  'brown rice': {
    display: 'brown rice',
    compositionKey: 'brown_rice_cooked',
    priceKey: 'brown rice'
  },
  'white rice': {
    display: 'white rice',
    compositionKey: 'white_rice_cooked',
    priceKey: 'white rice'
  },
  'quinoa': {
    display: 'quinoa',
    compositionKey: 'quinoa_cooked',
    priceKey: 'quinoa'
  },
  'sweet potato': {
    display: 'sweet potato',
    compositionKey: 'sweet_potato',
    priceKey: 'sweet potato'
  },
  'oats': {
    display: 'oats',
    compositionKey: 'oats',
    priceKey: 'oats'
  },
  'pumpkin': {
    display: 'pumpkin',
    compositionKey: 'pumpkin',
    priceKey: 'pumpkin'
  },
  'lentils': {
    display: 'lentils',
    compositionKey: 'lentils',
    priceKey: 'lentils'
  },
  'chickpeas': {
    display: 'chickpeas',
    compositionKey: 'chickpeas',
    priceKey: 'chickpeas'
  },
  'black beans': {
    display: 'black beans',
    compositionKey: 'black_beans',
    priceKey: 'black beans'
  },
  'green peas': {
    display: 'green peas',
    compositionKey: 'green_peas',
    priceKey: 'green peas'
  },

  // Vegetables
  'carrots': {
    display: 'carrots',
    compositionKey: 'carrots_raw',
    priceKey: 'carrots'
  },
  'green beans': {
    display: 'green beans',
    compositionKey: 'green_beans_raw',
    priceKey: 'green beans'
  },
  'spinach': {
    display: 'spinach',
    compositionKey: 'spinach_raw',
    priceKey: 'spinach'
  },
  'broccoli': {
    display: 'broccoli',
    compositionKey: 'broccoli_raw',
    priceKey: 'broccoli'
  },
  'zucchini': {
    display: 'zucchini',
    compositionKey: 'zucchini',
    priceKey: 'zucchini'
  },
  'kale': {
    display: 'kale',
    compositionKey: 'kale_raw',
    priceKey: 'kale'
  },
  'celery': {
    display: 'celery',
    compositionKey: 'celery_raw',
    priceKey: 'celery'
  },
  'brussels sprouts': {
    display: 'brussels sprouts',
    compositionKey: 'brussels_sprouts',
    priceKey: 'brussels sprouts'
  },
  'asparagus': {
    display: 'asparagus',
    compositionKey: 'asparagus',
    priceKey: 'asparagus'
  },
  'parsley': {
    display: 'parsley',
    compositionKey: 'parsley',
    priceKey: 'parsley'
  },
  'cucumber': {
    display: 'cucumber',
    compositionKey: 'celery_raw',
    priceKey: 'cucumber'
  },
  'lettuce (romaine)': {
    display: 'lettuce (romaine)',
    compositionKey: 'lettuce_romaine',
    priceKey: 'lettuce (romaine)'
  },
  'arugula': {
    display: 'arugula',
    compositionKey: 'arugula',
    priceKey: 'arugula'
  },
  'bok choy': {
    display: 'bok choy',
    compositionKey: 'bok_choy',
    priceKey: 'bok choy'
  },

  // Fruits
  'blueberries': {
    display: 'blueberries',
    compositionKey: 'blueberries_raw',
    priceKey: 'blueberries'
  },
  'bananas': {
    display: 'bananas',
    compositionKey: 'bananas_raw',
    priceKey: 'bananas'
  },

  // Additional proteins
  'turkey giblets': {
    display: 'turkey giblets',
    compositionKey: 'turkey_giblets',
    priceKey: 'turkey giblets'
  },
  'chicken giblets': {
    display: 'chicken giblets',
    compositionKey: 'chicken_giblets',
    priceKey: 'chicken giblets'
  },
  'duck breast': {
    display: 'duck breast',
    compositionKey: 'duck_breast',
    priceKey: 'duck breast'
  },
  'venison': {
    display: 'venison',
    compositionKey: 'venison',
    priceKey: 'venison'
  },
  'rabbit meat': {
    display: 'rabbit meat',
    compositionKey: 'rabbit_meat',
    priceKey: 'rabbit meat'
  },

  // Additional carbs
  'barley': {
    display: 'barley',
    compositionKey: 'barley',
    priceKey: 'barley'
  },
  'butternut squash': {
    display: 'butternut squash',
    compositionKey: 'butternut_squash',
    priceKey: 'butternut squash'
  },
  'acorn squash': {
    display: 'acorn squash',
    compositionKey: 'acorn_squash',
    priceKey: 'acorn squash'
  },

  // Additional vegetables
  'bell peppers': {
    display: 'bell peppers',
    compositionKey: 'bell_peppers',
    priceKey: 'bell peppers'
  },
  'bell peppers (red/green)': {
    display: 'bell peppers (red/green)',
    compositionKey: 'bell_peppers',
    priceKey: 'bell peppers'
  },
  'peas': {
    display: 'peas',
    compositionKey: 'peas',
    priceKey: 'peas'
  },
  'endive': {
    display: 'endive',
    compositionKey: 'endive',
    priceKey: 'endive'
  },
  'collard greens': {
    display: 'collard greens',
    compositionKey: 'collard_greens',
    priceKey: 'collard greens'
  },
  'mustard greens': {
    display: 'mustard greens',
    compositionKey: 'mustard_greens',
    priceKey: 'mustard greens'
  },
  'swiss chard': {
    display: 'swiss chard',
    compositionKey: 'swiss_chard',
    priceKey: 'swiss chard'
  },
  'cauliflower': {
    display: 'cauliflower',
    compositionKey: 'cauliflower',
    priceKey: 'cauliflower'
  },

  // Oils and fats
  'salmon oil': {
    display: 'salmon oil',
    compositionKey: 'salmon_oil',
    priceKey: 'salmon oil'
  },
  'fish oil': {
    display: 'fish oil',
    compositionKey: 'fish_oil',
    priceKey: 'fish oil'
  },
  'cod liver oil': {
    display: 'cod liver oil',
    compositionKey: 'cod_liver_oil',
    priceKey: 'cod liver oil'
  },
  'coconut oil': {
    display: 'coconut oil',
    compositionKey: 'coconut_oil',
    priceKey: 'coconut oil'
  },
  'olive oil': {
    display: 'olive oil',
    compositionKey: 'olive_oil',
    priceKey: 'olive oil'
  },

  // Supplements
  'calcium carbonate': {
    display: 'calcium carbonate',
    compositionKey: 'calcium_carbonate',
    priceKey: 'calcium carbonate'
  },
  'taurine powder': {
    display: 'taurine powder',
    compositionKey: 'taurine_powder',
    priceKey: 'taurine powder'
  },
};

export function getCompositionKey(displayName: string): string {
  const normalized = displayName.toLowerCase().trim();
  const mapping = INGREDIENT_NAME_MAP[normalized];
  if (mapping) {
    return mapping.compositionKey;
  }
  // Fallback: normalize to underscore format (handles unmapped ingredients)
  return normalized
    .replace(/\s*\([^)]*\)/g, '')
    .replace(/\s+/g, '_')
    .replace(/[^a-z0-9_]/g, '');
}

export function getPriceKey(displayName: string): string {
  const normalized = displayName.toLowerCase().trim();
  const mapping = INGREDIENT_NAME_MAP[normalized];
  if (mapping) {
    return mapping.priceKey;
  }
  // Fallback: use lowercase version for price lookup
  return normalized;
}

export function getDisplayName(compositionKeyOrPrice: string): string {
  const normalized = compositionKeyOrPrice.toLowerCase().trim();
  // Search through map for matching composition key or price key
  for (const [display, mapping] of Object.entries(INGREDIENT_NAME_MAP)) {
    if (mapping.compositionKey === normalized || mapping.priceKey === normalized) {
      return mapping.display;
    }
  }
  // Fallback: convert underscore format back to display format
  return normalized
    .replace(/_/g, ' ')
    .split(' ')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}
</file>

<file path="lib/utils/ingredientRegistry.ts">
// lib/utils/ingredientRegistry.ts
// Utility functions for accessing the unified ingredient registry
// Provides convenient accessors and normalization functions

import {
  getIngredientById,
  getIngredientByName,
  normalizeIngredientName,
  getIngredientsForSpecies,
  getIngredientsByCategory,
  getAllIngredients,
  searchIngredients,
  type UnifiedIngredient,
  type Species,
  type IngredientCategory,
} from '../data/unifiedIngredientRegistry';

// Re-export types and functions for convenience
export {
  getIngredientById,
  getIngredientByName,
  normalizeIngredientName,
  getIngredientsForSpecies,
  getIngredientsByCategory,
  getAllIngredients,
  searchIngredients,
  type UnifiedIngredient,
  type Species,
  type IngredientCategory,
};

/**
 * Convert between different ingredient name formats
 */
export function convertIngredientName(
  name: string,
  targetFormat: 'id' | 'display' | 'normalized'
): string {
  const ingredient = getIngredientByName(name);
  
  if (!ingredient) {
    // If not found, return normalized version
    if (targetFormat === 'id' || targetFormat === 'normalized') {
      return normalizeIngredientName(name);
    }
    return name; // Return original for display
  }
  
  switch (targetFormat) {
    case 'id':
      return ingredient.id;
    case 'display':
      return ingredient.primaryDisplayName;
    case 'normalized':
      return ingredient.id;
    default:
      return name;
  }
}

/**
 * Check if an ingredient name matches any known ingredient (fuzzy)
 */
export function isKnownIngredient(name: string): boolean {
  return getIngredientByName(name) !== null;
}

/**
 * Get all display name variations for an ingredient
 */
export function getIngredientNameVariations(name: string): string[] {
  const ingredient = getIngredientByName(name);
  return ingredient?.displayNames || [name];
}

/**
 * Find best matching ingredient name from a list of candidates
 */
export function findBestMatch(
  query: string,
  candidates: string[]
): string | null {
  const normalizedQuery = normalizeIngredientName(query);
  const queryIngredient = getIngredientByName(query);
  
  if (!queryIngredient) {
    return null;
  }
  
  // Find candidate that matches the same ingredient
  for (const candidate of candidates) {
    const candidateIngredient = getIngredientByName(candidate);
    if (candidateIngredient && candidateIngredient.id === queryIngredient.id) {
      return candidate;
    }
  }
  
  return null;
}

/**
 * Get nutrition data for an ingredient (with fallback)
 */
export function getIngredientNutrition(name: string) {
  const ingredient = getIngredientByName(name);
  return ingredient?.nutrition || null;
}

/**
 * Check if ingredient is compatible with species
 */
export function isIngredientCompatibleWithSpecies(
  name: string,
  species: Species
): boolean {
  const ingredient = getIngredientByName(name);
  if (!ingredient) return false;
  
  const compat = ingredient.speciesCompatibility[species];
  return compat === 'ok' || compat === 'limit' || compat === 'caution';
}

/**
 * Check if ingredient should be avoided for species
 */
export function shouldAvoidIngredient(name: string, species: Species): boolean {
  const ingredient = getIngredientByName(name);
  if (!ingredient) return false;
  
  const compat = ingredient.speciesCompatibility[species];
  return compat === 'avoid';
}

/**
 * Get vetted products for an ingredient
 */
export function getIngredientVettedProducts(name: string) {
  const ingredient = getIngredientByName(name);
  return ingredient?.vettedProducts || [];
}
</file>

<file path="lib/utils/ingredientSuggestions.ts">
// lib/utils/ingredientSuggestions.ts
// Generate ingredient suggestions based on pet profile

import { ALL_INGREDIENTS } from './allIngredients';

export interface SuggestedIngredient {
  name: string;
  reason: string;
  category: string;
}

interface PetProfile {
  type: string;
  age?: string;
  healthConcerns?: string[];
  breed?: string;
}

export function generateIngredientSuggestions(pet: PetProfile): SuggestedIngredient[] {
  if (!pet) return [];
  
  const suggestions: SuggestedIngredient[] = [];
  const normalizedSpecies = pet.type === 'dog' ? 'dogs' : 
                           pet.type === 'cat' ? 'cats' :
                           pet.type === 'bird' ? 'birds' :
                           pet.type === 'reptile' ? 'reptiles' :
                           pet.type === 'pocket-pet' ? 'pocket-pets' : pet.type;
  
  const speciesData = ALL_INGREDIENTS[normalizedSpecies as keyof typeof ALL_INGREDIENTS];
  if (!speciesData) return [];

  const healthConcerns = (pet.healthConcerns || []).map(hc => hc.toLowerCase());
  const age = pet.age?.toLowerCase() || '';

  // Safe property access helper
  const getProperty = <T>(obj: any, key: string, defaultValue: T[] = []): T[] => {
    return (key in obj ? obj[key] : defaultValue) || defaultValue;
  };

  const addUnique = (name: string, reason: string, category: string) => {
    if (suggestions.some((s) => s.name === name)) return;
    suggestions.push({ name, reason, category });
  };

  const proteins = getProperty<string>(speciesData, 'proteins');
  const vegetables = getProperty<string>(speciesData, 'vegetables');
  const carbs = getProperty<string>(speciesData, 'carbs');
  const fruits = getProperty<string>(speciesData, 'fruits');
  const fats = getProperty<string>(speciesData, 'fats');
  const supplements = getProperty<string>(speciesData, 'supplements');
  const insects = getProperty<string>(speciesData, 'insects');
  const hay = getProperty<string>(speciesData, 'hay');
  const seeds = getProperty<string>(speciesData, 'seeds');
  const pellets = getProperty<string>(speciesData, 'pellets');

  // Species-specific essentials
  if (normalizedSpecies === 'cats') {
    // Taurine is essential for cats
    if (supplements.includes('Taurine Powder')) {
      suggestions.push({
        name: 'Taurine Powder',
        reason: 'Essential amino acid required for cats - supports heart and eye health',
        category: 'Supplements'
      });
    }
    // High-taurine proteins
    if (proteins.includes('Chicken Liver')) {
      suggestions.push({
        name: 'Chicken Liver',
        reason: 'Rich in taurine and essential nutrients for cats',
        category: 'Proteins'
      });
    }
  }

  if (normalizedSpecies === 'reptiles') {
    // Calcium is essential for reptiles
    if (vegetables.includes('Collard Greens')) {
      suggestions.push({
        name: 'Collard Greens',
        reason: 'High in calcium - essential for bone health in reptiles',
        category: 'Greens & Veggies'
      });
    }
    // Insects for protein
    if (insects.includes('Dubia Roaches')) {
      suggestions.push({
        name: 'Dubia Roaches',
        reason: 'Excellent protein source with ideal calcium-to-phosphorus ratio',
        category: 'Proteins'
      });
    }
  }

  if (normalizedSpecies === 'pocket-pets') {
    // Hay is essential
    if (hay.includes('Timothy Hay')) {
      suggestions.push({
        name: 'Timothy Hay',
        reason: 'Essential fiber source for digestive health',
        category: 'Hay'
      });
    }
    // Vitamin C rich vegetables
    if (vegetables.includes('Bell Peppers (high vitamin C)')) {
      suggestions.push({
        name: 'Bell Peppers (high vitamin C)',
        reason: 'High in vitamin C - essential for guinea pigs and other pocket pets',
        category: 'Greens & Veggies'
      });
    }
  }

  // Age-based suggestions
  if (age.includes('baby') || age.includes('puppy') || age.includes('kitten')) {
    if (proteins.includes('Ground Chicken')) {
      suggestions.push({
        name: 'Ground Chicken',
        reason: 'Easy to digest protein perfect for growing pets',
        category: 'Proteins'
      });
    }
    if (carbs.includes('Sweet Potato') || carbs.includes('Sweet Potato (cooked)')) {
      suggestions.push({
        name: carbs.includes('Sweet Potato') ? 'Sweet Potato' : 'Sweet Potato (cooked)',
        reason: 'Gentle on developing digestive systems and rich in nutrients',
        category: 'Grains & Carbs'
      });
    }
  }

  if (age.includes('senior')) {
    if (supplements.includes('Glucosamine Sulfate')) {
      suggestions.push({
        name: 'Glucosamine Sulfate',
        reason: 'Supports joint health in older pets',
        category: 'Supplements'
      });
    }
    if (fats.includes('Fish Oil') || supplements.includes('Fish Oil')) {
      suggestions.push({
        name: 'Fish Oil',
        reason: 'Omega-3 fatty acids support brain and joint health in seniors',
        category: 'Supplements'
      });
    }
  }

  // Health concern-based suggestions
  if (healthConcerns.some(hc => hc.includes('kidney') || hc.includes('urinary'))) {
    if (vegetables.includes('Green Beans') || vegetables.includes('Green Beans (cooked)')) {
      suggestions.push({
        name: vegetables.includes('Green Beans') ? 'Green Beans' : 'Green Beans (cooked)',
        reason: 'Low in phosphorus - ideal for kidney support',
        category: 'Greens & Veggies'
      });
    }
    if (normalizedSpecies === 'cats' && supplements.includes('Cranberry Extract')) {
      suggestions.push({
        name: 'Cranberry Extract',
        reason: 'Supports urinary tract health',
        category: 'Supplements'
      });
    }
  }

  if (healthConcerns.some(hc => hc.includes('joint') || hc.includes('mobility'))) {
    if (supplements.includes('Glucosamine Sulfate')) addUnique('Glucosamine Sulfate', 'Supports joint cartilage and mobility', 'Supplements');
    if (fats.includes('Fish Oil') || supplements.includes('Fish Oil')) addUnique('Fish Oil', 'Anti-inflammatory omega-3s help reduce joint inflammation', 'Supplements');
  }

  if (healthConcerns.some(hc => hc.includes('weight') || hc.includes('obesity'))) {
    if (proteins.includes('Ground Turkey')) {
      addUnique('Ground Turkey', 'Lean protein helps maintain muscle while managing weight', 'Proteins');
    }
    if (vegetables.includes('Green Beans') || vegetables.includes('Green Beans (cooked)')) {
      addUnique(vegetables.includes('Green Beans') ? 'Green Beans' : 'Green Beans (cooked)', 'Low calorie, high fiber - helps with satiety', 'Greens & Veggies');
    }
  }

  if (healthConcerns.some(hc => hc.includes('digestive') || hc.includes('gi'))) {
    if (carbs.includes('Pumpkin Puree') || carbs.includes('Pumpkin Puree (small amounts)')) {
      addUnique(carbs.includes('Pumpkin Puree') ? 'Pumpkin Puree' : 'Pumpkin Puree (small amounts)', 'Soluble fiber helps regulate digestion', 'Grains & Carbs');
    }
    if (supplements.includes('Probiotic Powder')) {
      addUnique('Probiotic Powder', 'Supports healthy gut bacteria and digestive function', 'Supplements');
    }
  }

  if (healthConcerns.some(hc => hc.includes('skin') || hc.includes('coat'))) {
    if (fats.includes('Salmon Oil') || supplements.includes('Salmon Oil')) {
      addUnique('Salmon Oil', 'Omega-3 fatty acids promote healthy skin and shiny coat', 'Supplements');
    }
    const salmonOptions = proteins.filter(p => p.toLowerCase().includes('salmon'));
    if (salmonOptions.length > 0) {
      addUnique(salmonOptions[0], 'Rich in omega-3s for healthy skin and coat', 'Proteins');
    }
  }

  // Baseline species recommendations to ensure multiple options
  if (normalizedSpecies === 'dogs') {
    addUnique('Chicken Breast', 'Lean, versatile protein for most dogs', 'Proteins');
    addUnique('Brown Rice', 'Gentle carb to mix meals', 'Grains & Carbs');
    addUnique('Carrots', 'Great source of beta-carotene and fiber for dogs', 'Greens & Veggies');
  }

  if (normalizedSpecies === 'cats') {
    const sardineOptions = proteins.filter(p => p.toLowerCase().includes('sardine'));
    if (sardineOptions.length > 0) {
      addUnique(sardineOptions[0], 'High in taurine and omega-3s - excellent for cats', 'Proteins');
    }
    addUnique('Chicken Liver', 'Taurine-rich organ meat for cats', 'Proteins');
    addUnique('Pumpkin Puree (small amounts)', 'Fiber to help digestion', 'Grains & Carbs');
  }

  if (normalizedSpecies === 'birds') {
    addUnique('Millet (white/red)', 'Staple seed birds readily accept', 'Seeds');
    addUnique('Carrots (grated)', 'Vitamin A-rich veggie for birds', 'Greens & Veggies');
    addUnique('Apples (no seeds)', 'Common fruit treat (seed-free)', 'Fruits');
  }

  if (normalizedSpecies === 'reptiles') {
    addUnique('Collard Greens', 'High-calcium staple green', 'Greens & Veggies');
    addUnique('Dubia Roaches', 'Staple insect protein with good Ca:P', 'Proteins');
    addUnique('Blueberries', 'Occasional fruit treat many reptiles accept', 'Fruits');
  }

  if (normalizedSpecies === 'pocket-pets') {
    addUnique('Timothy Hay', 'Essential daily fiber source', 'Hay');
    addUnique('Bell Peppers (high vitamin C)', 'Vitamin C boost for pocket pets', 'Greens & Veggies');
    addUnique('Carrots', 'Crunchy, familiar veggie treat', 'Greens & Veggies');
  }

  // Remove duplicates and keep a healthy list (up to 12)
  const unique = suggestions.filter((sug, idx, self) =>
    idx === self.findIndex(s => s.name === sug.name)
  );

  return unique.slice(0, 12);
}
</file>

<file path="lib/utils/ingredientWhitelists.ts">
// lib/utils/ingredientWhitelists.ts
// Species-specific ingredient whitelists for safe meal building
// This provides a curated "safe" list per species to prevent dangerous combinations
// Now uses global ingredient pool + subtype-based normalization

import { getIngredientComposition, INGREDIENT_COMPOSITIONS, type SpeciesCompatibility } from '@/lib/data/ingredientCompositions';
import { ALL_INGREDIENTS } from './allIngredients';
import { GLOBAL_INGREDIENTS, type GlobalIngredient } from '@/lib/data/globalIngredients';

export type Species = 'dog' | 'cat' | 'bird' | 'reptile' | 'pocket-pet';
export type ReptileType = 'herbivore' | 'insectivore' | 'omnivore';
export type PocketPetType = 'rabbit' | 'guinea-pig' | 'hamster' | 'gerbil';
export type Subtype = 
  | 'bird_small' | 'bird_large'
  | 'reptile_herbivore' | 'reptile_insectivore' | 'reptile_omnivore' | 'reptile_carnivore'
  | 'pocket_hay' | 'pocket_varied' | 'pocket_carnivore' | 'pocket_insectivore'
  | 'dog' | 'cat';

/**
 * Normalize species + breed to subtype
 */
export function normalizeToSubtype(species: Species, breed?: string): Subtype {
  if (species === 'bird') {
    const largeBirds = ['parrot', 'cockatoo', 'african grey', 'macaw', 'conure', 'quaker'];
    const breedLower = breed?.toLowerCase() || '';
    return largeBirds.some(lb => breedLower.includes(lb)) ? 'bird_large' : 'bird_small';
  }
  
  if (species === 'reptile') {
    const herbivores = ['bearded dragon', 'iguana', 'slider', 'tortoise', 'uromastyx'];
    const carnivores = ['python', 'snake', 'monitor', 'chameleon', 'corn snake', 'ball python'];
    const insectivores = ['leopard gecko', 'crested gecko', 'gecko'];
    const breedLower = breed?.toLowerCase() || '';
    
    if (herbivores.some(h => breedLower.includes(h))) return 'reptile_herbivore';
    if (carnivores.some(c => breedLower.includes(c))) return 'reptile_carnivore';
    if (insectivores.some(i => breedLower.includes(i))) return 'reptile_insectivore';
    return 'reptile_omnivore'; // Default for mixed/unknown
  }
  
  if (species === 'pocket-pet') {
    const breedLower = breed?.toLowerCase() || '';
    if (breedLower.includes('rabbit') || breedLower.includes('guinea') || breedLower.includes('chinchilla')) {
      return 'pocket_hay';
    }
    if (breedLower.includes('ferret')) {
      return 'pocket_carnivore';
    }
    if (breedLower.includes('hedgehog')) {
      return 'pocket_insectivore';
    }
    return 'pocket_varied'; // Hamster, gerbil, rat, mouse
  }
  
  return species; // dog, cat
}

/**
 * Base whitelists by subtype - these ensure we always have something to show
 */
export const BASE_WHITELISTS: Record<Subtype, string[]> = {
  bird_small: [
    'millet', 'canary_seed', 'niger_seed', 'oat_groats',
    'carrot_grated', 'broccoli', 'spinach', 'kale',
    'apple_no_seeds', 'blueberries', 'strawberries',
    'egg_hard_boiled', 'pellets_fortified', 'cuttlebone'
  ],
  bird_large: [
    // All bird_small plus:
    'quinoa_cooked', 'brown_rice_cooked', 'oats',
    'bell_peppers', 'sweet_potato_cooked', 'mango', 'papaya',
    'parrot_pellets', 'nuts_unsalted', 'pumpkin', 'carrots'
  ],
  reptile_herbivore: [
    'collard_greens', 'turnip_greens', 'dandelion_greens',
    'butternut_squash', 'bell_peppers', 'carrot_grated', 'zucchini',
    'blueberries', 'mango', 'papaya', 'strawberries',
    'calcium_carbonate', 'vitamin_d3', 'kale', 'spinach'
  ],
  reptile_insectivore: [
    'dubia_roaches', 'crickets', 'mealworms', 'superworms',
    'black_soldier_fly_larvae', 'hornworms', 'calcium_carbonate', 'waxworms'
  ],
  reptile_omnivore: [
    // Combination of herbivore + insectivore
    'collard_greens', 'dandelion_greens',
    'crickets', 'dubia_roaches', 'mealworms',
    'blueberries', 'mango', 'calcium_carbonate'
  ],
  reptile_carnivore: [
    // Placeholder - whole prey items (will need special handling)
    'whole_prey_rodent', 'whole_prey_bird', 'protein_block',
    'chicken_breast', 'ground_turkey'
  ],
  pocket_hay: [
    'timothy_hay', 'orchard_grass_hay', 'alfalfa_hay',
    'romaine_lettuce', 'bell_peppers', 'carrots', 'cucumber',
    'parsley', 'cilantro', 'guinea_pig_pellets', 'rabbit_pellets',
    'vitamin_c_supplement', 'kale', 'spinach'
  ],
  pocket_varied: [
    'hamster_pellets', 'gerbil_pellets', 'oats', 'quinoa_cooked',
    'carrots', 'broccoli', 'apple_no_seeds', 'blueberries',
    'mealworms_freeze_dried', 'sunflower_seeds_unsalted', 'pumpkin_seeds'
  ],
  pocket_carnivore: [
    'chicken_breast', 'ground_turkey', 'salmon', 'egg_whole',
    'organ_meat', 'taurine_supplement', 'heart', 'liver'
  ],
  pocket_insectivore: [
    'mealworms', 'crickets', 'waxworms', 'egg_whole',
    'insectivore_diet_powder', 'superworms'
  ],
  dog: [], // Will be populated from global pool
  cat: []  // Will be populated from global pool
};

/**
 * Get whitelist of safe ingredients for a species
 * Returns ingredient display names that are marked as 'ok' or 'limit' (not 'avoid')
 * Now uses global pool + base whitelists
 */
export function getWhitelistForSpecies(species: Species, breed?: string, subtype?: ReptileType | PocketPetType): string[] {
  const normalizedSubtype = normalizeToSubtype(species, breed);
  const whitelist: Set<string> = new Set();
  
  // 1. Add base whitelist for this subtype (ensures we always have something)
  const baseList = BASE_WHITELISTS[normalizedSubtype] || [];
  baseList.forEach(ing => whitelist.add(ing));
  
  // 2. Add from existing ALL_INGREDIENTS (backward compatibility)
  // Map species to ALL_INGREDIENTS key format
  const speciesKey = species === 'dog' ? 'dogs' : 
                     species === 'cat' ? 'cats' :
                     species === 'bird' ? 'birds' :
                     species === 'reptile' ? 'reptiles' :
                     species === 'pocket-pet' ? 'pocket-pets' : species;
  
  const speciesData = ALL_INGREDIENTS[speciesKey as keyof typeof ALL_INGREDIENTS];
  if (speciesData) {
    Object.values(speciesData).forEach(category => {
      if (Array.isArray(category)) {
        category.forEach(ingName => whitelist.add(ingName));
      }
    });
  }
  
  // 3. Add from global ingredient pool (new approach)
  Object.values(GLOBAL_INGREDIENTS).forEach(globalIng => {
    // Try to find composition data
    const compositionKey = globalIng.compositionKey || globalIng.id;
    const composition = getIngredientComposition(compositionKey);
    
    if (composition?.speciesCompatibility) {
      const compat = composition.speciesCompatibility[species];
      if (compat === 'ok' || compat === 'limit' || compat === 'caution') {
        whitelist.add(globalIng.displayName);
      }
    } else {
      // If no compatibility data but it's in global pool, include it with low confidence
      // This allows discovery of new ingredients
      if (globalIng.confidenceLevel === 'high' || globalIng.confidenceLevel === 'medium') {
        whitelist.add(globalIng.displayName);
      }
    }
  });
  
  // 4. Filter by compatibility from INGREDIENT_COMPOSITIONS
  const filtered: string[] = [];
  whitelist.forEach(ingName => {
    // Try multiple key formats
    const keys = [
      ingName.toLowerCase().replace(/\s+/g, '_').replace(/[^a-z0-9_]/g, ''),
      ingName.toLowerCase().replace(/[^a-z0-9_]/g, '_'),
      ingName.toLowerCase()
    ];
    
    let found = false;
    let shouldInclude = true;
    
    for (const key of keys) {
      const composition = getIngredientComposition(key);
      if (composition?.speciesCompatibility) {
        const compat = composition.speciesCompatibility[species];
        if (compat === 'ok' || compat === 'limit' || compat === 'caution') {
          shouldInclude = true;
          found = true;
          break;
        } else if (compat === 'avoid') {
          shouldInclude = false; // Explicitly avoid, don't add
          found = true;
          break;
        }
      }
    }
    
    // If no composition data found, include it anyway (allows ingredients from ALL_INGREDIENTS)
    // This is important because ALL_INGREDIENTS already contains species-specific safe ingredients
    if (!found || shouldInclude) {
      filtered.push(ingName);
    }
  });
  
  // 5. Apply subtype-specific filters
  if (species === 'reptile' && subtype) {
    const reptileTypes: ReptileType[] = ['herbivore', 'insectivore', 'omnivore'];
    if (reptileTypes.includes(subtype as ReptileType)) {
      return filterByReptileType(filtered, subtype as ReptileType);
    }
  }
  
  if (species === 'pocket-pet' && subtype) {
    const pocketPetTypes: PocketPetType[] = ['rabbit', 'guinea-pig', 'hamster', 'gerbil'];
    if (pocketPetTypes.includes(subtype as PocketPetType)) {
      return filterByPocketPetType(filtered, subtype as PocketPetType);
    }
  }
  
  return filtered;
}

/**
 * Filter ingredients by reptile type
 */
function filterByReptileType(ingredients: string[], type: ReptileType): string[] {
  // Herbivores: no meat, focus on greens/veggies
  if (type === 'herbivore') {
    return ingredients.filter(ing => {
      const lower = ing.toLowerCase();
      return !lower.includes('chicken') && !lower.includes('beef') && 
             !lower.includes('turkey') && !lower.includes('meat') &&
             !lower.includes('salmon') && !lower.includes('fish');
    });
  }
  
  // Insectivores: no plant matter, focus on proteins
  if (type === 'insectivore') {
    return ingredients.filter(ing => {
      const lower = ing.toLowerCase();
      return lower.includes('insect') || lower.includes('cricket') || 
             lower.includes('mealworm') || lower.includes('protein');
    });
  }
  
  // Omnivores: allow both
  return ingredients;
}

/**
 * Filter ingredients by pocket pet type
 */
function filterByPocketPetType(ingredients: string[], type: PocketPetType): string[] {
  // Rabbits and guinea pigs: hay-based, limit fruits
  if (type === 'rabbit' || type === 'guinea-pig') {
    return ingredients.filter(ing => {
      const lower = ing.toLowerCase();
      // Prioritize hay, greens, limit high-sugar fruits
      return lower.includes('hay') || lower.includes('green') || 
             lower.includes('kale') || lower.includes('carrot') ||
             (lower.includes('fruit') && !lower.includes('banana') && !lower.includes('grape'));
    });
  }
  
  // Hamsters and gerbils: more variety, can handle more fruits/grains
  return ingredients;
}

/**
 * Check if an ingredient is in the whitelist for a species
 * Also checks if ingredient is in ALL_INGREDIENTS for that species (even without composition data)
 */
export function isWhitelisted(ingredientName: string, species: Species, subtype?: ReptileType | PocketPetType): boolean {
  // First check the whitelist
  const whitelist = getWhitelistForSpecies(species, subtype);
  const inWhitelist = whitelist.some(ing => 
    ing.toLowerCase() === ingredientName.toLowerCase() ||
    ing.toLowerCase().includes(ingredientName.toLowerCase()) ||
    ingredientName.toLowerCase().includes(ing.toLowerCase())
  );
  
  if (inWhitelist) return true;
  
  // Also check if ingredient is in ALL_INGREDIENTS for this species
  // This ensures ingredients from ALL_INGREDIENTS are included even without composition data
  const speciesKey = species === 'dog' ? 'dogs' : 
                     species === 'cat' ? 'cats' :
                     species === 'bird' ? 'birds' :
                     species === 'reptile' ? 'reptiles' :
                     species === 'pocket-pet' ? 'pocket-pets' : species;
  
  const speciesData = ALL_INGREDIENTS[speciesKey as keyof typeof ALL_INGREDIENTS];
  if (speciesData) {
    for (const category of Object.values(speciesData)) {
      if (Array.isArray(category)) {
        const found = category.some(ing => 
          ing.toLowerCase() === ingredientName.toLowerCase() ||
          ing.toLowerCase().includes(ingredientName.toLowerCase()) ||
          ingredientName.toLowerCase().includes(ing.toLowerCase())
        );
        if (found) return true;
      }
    }
  }
  
  return false;
}

/**
 * Get "do not use" list for a species (ingredients marked as 'avoid')
 */
export function getBlacklistForSpecies(species: Species): string[] {
  const blacklist: string[] = [];
  
  // Check all ingredients in composition database
  const allCompositions = Object.keys(INGREDIENT_COMPOSITIONS);
  
  for (const key of allCompositions) {
    const composition = getIngredientComposition(key);
    if (composition?.speciesCompatibility) {
      const compat = composition.speciesCompatibility[species];
      if (compat === 'avoid') {
        blacklist.push(key.replace(/_/g, ' ')); // Convert to display name
      }
    }
  }
  
  return blacklist;
}

/**
 * Get confidence level for species ingredient coverage
 * 'full' = comprehensive data, 'beta' = partial data, 'limited' = minimal data
 */
export function getSpeciesCoverageLevel(species: Species): 'full' | 'beta' | 'limited' {
  const coverage: Record<Species, 'full' | 'beta' | 'limited'> = {
    'dog': 'full',
    'cat': 'full',
    'bird': 'beta',
    'reptile': 'beta',
    'pocket-pet': 'beta'
  };
  
  return coverage[species] || 'limited';
}
</file>

<file path="lib/utils/localStorageSafe.ts">
// lib/utils/localStorageSafe.ts
// Safe localStorage operations with error handling and transaction support

import { logger } from './logger';

/**
 * Safe localStorage get with error handling
 */
export function safeGetItem(key: string): string | null {
  if (typeof window === 'undefined') return null;
  
  try {
    return localStorage.getItem(key);
  } catch (error) {
    logger.error('Failed to read from localStorage', error, { key });
    return null;
  }
}

/**
 * Safe localStorage set with error handling and quota management
 */
export function safeSetItem(key: string, value: string): { success: boolean; error?: string } {
  if (typeof window === 'undefined') {
    return { success: false, error: 'localStorage not available' };
  }
  
  try {
    localStorage.setItem(key, value);
    return { success: true };
  } catch (error: any) {
    // Handle quota exceeded error
    if (error.name === 'QuotaExceededError' || error.code === 22) {
      logger.error('localStorage quota exceeded', error, { key, valueLength: value.length });
      return { success: false, error: 'Storage limit reached. Please clear some data or use a different browser.' };
    }
    
    // Handle other errors
    logger.error('Failed to write to localStorage', error, { key });
    return { success: false, error: 'Failed to save data. Please try again.' };
  }
}

/**
 * Safe JSON parse with error handling
 */
export function safeParseJSON<T>(jsonString: string | null, defaultValue: T): T {
  if (!jsonString) return defaultValue;
  
  try {
    const parsed = JSON.parse(jsonString);
    return parsed as T;
  } catch (error) {
    logger.error('Failed to parse JSON from localStorage', error, { jsonString: jsonString.substring(0, 100) });
    return defaultValue;
  }
}

/**
 * Safe JSON stringify with error handling
 */
export function safeStringifyJSON(data: any): string | null {
  try {
    return JSON.stringify(data);
  } catch (error) {
    logger.error('Failed to stringify JSON', error, { dataType: typeof data });
    return null;
  }
}

/**
 * Transaction-safe localStorage update
 * Reads, modifies, and writes atomically to prevent race conditions
 */
export function safeUpdateItem<T>(
  key: string,
  updateFn: (currentValue: T | null) => T
): { success: boolean; error?: string; data?: T } {
  if (typeof window === 'undefined') {
    return { success: false, error: 'localStorage not available' };
  }
  
  try {
    // Read current value
    const current = safeGetItem(key);
    const currentData = current ? safeParseJSON<T>(current, null as T) : null;
    
    // Update
    const newData = updateFn(currentData);
    
    // Write back
    const jsonString = safeStringifyJSON(newData);
    if (!jsonString) {
      return { success: false, error: 'Failed to serialize data' };
    }
    
    const writeResult = safeSetItem(key, jsonString);
    if (!writeResult.success) {
      return { success: false, error: writeResult.error };
    }
    
    return { success: true, data: newData };
  } catch (error) {
    logger.error('Failed to update localStorage item', error, { key });
    return { success: false, error: 'Failed to update data' };
  }
}

/**
 * Check if localStorage is available and has space
 */
export function isLocalStorageAvailable(): boolean {
  if (typeof window === 'undefined') return false;
  
  try {
    const testKey = '__localStorage_test__';
    localStorage.setItem(testKey, 'test');
    localStorage.removeItem(testKey);
    return true;
  } catch {
    return false;
  }
}

/**
 * Get estimated localStorage usage
 */
export function getLocalStorageUsage(): { used: number; available: boolean } {
  if (typeof window === 'undefined') {
    return { used: 0, available: false };
  }
  
  try {
    let total = 0;
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key) {
        const value = localStorage.getItem(key);
        if (value) {
          total += key.length + value.length;
        }
      }
    }
    return { used: total, available: true };
  } catch {
    return { used: 0, available: false };
  }
}
</file>

<file path="lib/utils/logger.ts">
// lib/utils/logger.ts
// Centralized logging utility for production-ready logging

type LogLevel = 'debug' | 'info' | 'warn' | 'error';

class Logger {
  private isDevelopment = process.env.NODE_ENV === 'development';

  private log(level: LogLevel, message: string, ...args: any[]): void {
    if (!this.isDevelopment && level === 'debug') {
      return; // Skip debug logs in production
    }

    const timestamp = new Date().toISOString();
    const prefix = `[${timestamp}] [${level.toUpperCase()}]`;

    switch (level) {
      case 'error':
        console.error(prefix, message, ...args);
        // In production, you might want to send to error tracking service
        // e.g., Sentry.captureException(new Error(message));
        break;
      case 'warn':
        console.warn(prefix, message, ...args);
        break;
      case 'info':
        if (this.isDevelopment) {
          console.info(prefix, message, ...args);
        }
        break;
      case 'debug':
        if (this.isDevelopment) {
          console.debug(prefix, message, ...args);
        }
        break;
    }
  }

  debug(message: string, ...args: any[]): void {
    this.log('debug', message, ...args);
  }

  info(message: string, ...args: any[]): void {
    this.log('info', message, ...args);
  }

  warn(message: string, ...args: any[]): void {
    this.log('warn', message, ...args);
  }

  error(message: string, error?: Error | unknown, ...args: any[]): void {
    if (error instanceof Error) {
      this.log('error', message, error.message, error.stack, ...args);
    } else {
      this.log('error', message, error, ...args);
    }
  }
}

export const logger = new Logger();
</file>

<file path="lib/utils/mascotImageMapping.ts">
// lib/utils/mascotImageMapping.ts
// Maps recipe categories to mascot images in /images/emojis/Mascots/

/**
 * Get the mascot image path for a recipe category
 * @param category - Recipe category (dogs, cats, birds, reptiles, pocket-pets)
 * @returns Path to the mascot image for that category
 */
export function getMascotImageForCategory(category: string): string {
  const categoryLower = (category || '').toLowerCase();
  
  const categoryToMascot: Record<string, string> = {
    'dogs': '/images/emojis/Mascots/Prep Puppy.jpg',
    'cats': '/images/emojis/Mascots/ProfessorPurffesor.jpg',
    'birds': '/images/emojis/Mascots/RobinRed-Route.jpg',
    'reptiles': '/images/emojis/Mascots/SherlockShells.jpg',
    'pocket-pets': '/images/emojis/Mascots/harvesthamster.jpg',
    // Handle plural forms
    'dog': '/images/emojis/Mascots/Prep Puppy.jpg',
    'cat': '/images/emojis/Mascots/ProfessorPurffesor.jpg',
    'bird': '/images/emojis/Mascots/RobinRed-Route.jpg',
    'reptile': '/images/emojis/Mascots/SherlockShells.jpg',
    'pocket-pet': '/images/emojis/Mascots/harvesthamster.jpg',
  };
  
  return categoryToMascot[categoryLower] || '/images/emojis/Mascots/Mascot-Emoji-Faces.png';
}
</file>

<file path="lib/utils/mealCalculator.ts">
/**
 * Utility functions for calculating how many meals a shopping list will provide
 */

/**
 * Parse an amount string (e.g., "200g", "1 cup", "500g") and return grams
 * Assumes "g" means grams, otherwise returns 0 if unable to parse
 */
export function parseAmountToGrams(amount: string): number {
  if (!amount) return 0;
  
  // Try to extract number from string like "200g", "500g", etc.
  const match = amount.match(/(\d+(?:\.\d+)?)\s*g/i);
  if (match) {
    return parseFloat(match[1]);
  }
  
  // Try to extract just a number if it's only a number
  const numberMatch = amount.match(/(\d+(?:\.\d+)?)/);
  if (numberMatch) {
    return parseFloat(numberMatch[1]);
  }
  
  return 0;
}

/**
 * Calculate how many meals a shopping list will provide based on recommended servings
 * @param ingredients - Shopping list ingredients with amounts
 * @param selectedIngredients - Original ingredient selections with grams
 * @param totalGrams - Total grams in the recipe
 * @param recommendedServingGrams - Recommended serving size in grams for the entire meal
 * @returns Number of meals the shopping list will provide (minimum across all ingredients)
 */
export function calculateMealsFromShoppingList(
  ingredients: Array<{ id: string; name: string; amount: string }>,
  selectedIngredients: Array<{ key: string; grams: number }>,
  totalGrams: number,
  recommendedServingGrams: number
): number {
  console.log('[calculateMealsFromShoppingList] Starting calculation with:', {
    ingredientsCount: ingredients.length,
    selectedIngredientsCount: selectedIngredients.length,
    totalGrams,
    recommendedServingGrams
  });

  if (!ingredients.length || !selectedIngredients.length || totalGrams === 0 || recommendedServingGrams === 0) {
    console.log('[calculateMealsFromShoppingList] Early return - invalid inputs');
    return 0;
  }

  // Create a map of ingredient key to grams per meal
  const ingredientGramsMap = new Map<string, number>();
  selectedIngredients.forEach(ing => {
    const gramsPerMeal = (ing.grams / totalGrams) * recommendedServingGrams;
    ingredientGramsMap.set(ing.key, gramsPerMeal);
    console.log(`[calculateMealsFromShoppingList] Mapped ${ing.key} -> ${gramsPerMeal.toFixed(2)}g per meal`);
  });

  // Calculate meals for each ingredient
  const mealsPerIngredient: number[] = [];

  ingredients.forEach(ing => {
    const purchasedGrams = parseAmountToGrams(ing.amount);
    console.log(`[calculateMealsFromShoppingList] Processing ingredient: ${ing.name} (id: ${ing.id}), purchased: ${purchasedGrams}g`);
    
    // Try to find by id first
    let gramsPerMeal = ingredientGramsMap.get(ing.id);
    
    // Fallback: try to match by name (for cases where id doesn't match key exactly)
    if (!gramsPerMeal) {
      console.log(`[calculateMealsFromShoppingList] No match by id ${ing.id}, trying name matching...`);
      // Try to find a matching selected ingredient by comparing normalized names
      const normalizedIngName = ing.name.toLowerCase().replace(/\s+/g, '_').replace(/[^a-z0-9_]/g, '');
      for (const [key, grams] of ingredientGramsMap.entries()) {
        const normalizedKey = key.toLowerCase().replace(/\s+/g, '_').replace(/[^a-z0-9_]/g, '');
        if (normalizedKey === normalizedIngName || normalizedIngName.includes(normalizedKey) || normalizedKey.includes(normalizedIngName)) {
          gramsPerMeal = grams;
          console.log(`[calculateMealsFromShoppingList] Found match by name: ${key} -> ${gramsPerMeal.toFixed(2)}g per meal`);
          break;
        }
      }
    } else {
      console.log(`[calculateMealsFromShoppingList] Found match by id: ${ing.id} -> ${gramsPerMeal.toFixed(2)}g per meal`);
    }
    
    if (purchasedGrams > 0 && gramsPerMeal && gramsPerMeal > 0) {
      const meals = purchasedGrams / gramsPerMeal;
      console.log(`[calculateMealsFromShoppingList] ${ing.name}: ${purchasedGrams}g / ${gramsPerMeal.toFixed(2)}g = ${meals.toFixed(2)} meals`);
      mealsPerIngredient.push(meals);
    } else {
      console.log(`[calculateMealsFromShoppingList] Skipping ${ing.name}: purchasedGrams=${purchasedGrams}, gramsPerMeal=${gramsPerMeal}`);
    }
  });

  if (mealsPerIngredient.length === 0) {
    console.log('[calculateMealsFromShoppingList] No valid meal calculations found');
    return 0;
  }

  // Return the minimum (bottleneck ingredient)
  const minMeals = Math.floor(Math.min(...mealsPerIngredient));
  console.log(`[calculateMealsFromShoppingList] Final result: ${minMeals} meals (from ${mealsPerIngredient.map(m => m.toFixed(2)).join(', ')})`);
  return minMeals;
}
</file>

<file path="lib/utils/mealCountCalculator.ts">
/**
 * Meal Count Calculator
 * 
 * Calculates dynamic meal counts based on pet profile characteristics.
 * This makes the count feel more personalized and organic rather than static.
 */

interface PetProfile {
  species: string;
  age?: string | number;
  healthConcerns?: string[];
  allergies?: string[];
}

/**
 * Calculates meal count variation based on pet profile characteristics.
 * 
 * Factors considered:
 * - Species: Different species have different recipe availability
 * - Health concerns: More concerns = fewer suitable options
 * - Allergies: More allergies = fewer safe options
 * - Age: Young and senior animals have more specialized needs
 * 
 * @param baseCount The actual number of filtered recipes
 * @param pet Pet profile information
 * @returns Adjusted count with organic variation
 */
export function calculateMealCountVariation(
  baseCount: number,
  pet: PetProfile
): number {
  let adjustedCount = baseCount;
  
  // 1. Species factor - different species have different recipe availability
  const speciesFactors: Record<string, number> = {
    'dog': 1.2,      // Dogs have more recipe options
    'dogs': 1.2,
    'cat': 1.0,
    'cats': 1.0,
    'bird': 0.8,     // Birds have fewer options
    'birds': 0.8,
    'reptile': 0.7,
    'reptiles': 0.7,
    'pocket-pet': 0.6,
    'pocket-pets': 0.6,
  };
  
  const species = pet.species?.toLowerCase() || 'dog';
  adjustedCount *= speciesFactors[species] || 1.0;
  
  // 2. Health concerns factor - more concerns = more specialized = fewer options
  const healthConcerns = pet.healthConcerns || [];
  const healthFactor = 1.0 - (healthConcerns.length * 0.1);
  adjustedCount *= Math.max(0.5, healthFactor);
  
  // 3. Allergies factor - more allergies = fewer safe options
  const allergies = pet.allergies || [];
  const allergyFactor = 1.0 - (allergies.length * 0.15);
  adjustedCount *= Math.max(0.3, allergyFactor);
  
  // 4. Age factor - young and senior animals have more specialized needs
  let ageFactor = 1.0;
  if (pet.age) {
    const ageNum = typeof pet.age === 'number' 
      ? pet.age 
      : parseFloat(String(pet.age)) || 3;
    
    if (ageNum < 1) {
      ageFactor = 1.3;  // Young animals have more specialized options
    } else if (ageNum > 7) {
      ageFactor = 0.9;  // Senior animals have fewer options
    }
  } else if (typeof pet.age === 'string') {
    const ageStr = pet.age.toLowerCase();
    if (ageStr === 'baby' || ageStr === 'young') {
      ageFactor = 1.3;
    } else if (ageStr === 'senior') {
      ageFactor = 0.9;
    }
  }
  adjustedCount *= ageFactor;
  
  // 5. Add small deterministic variation (¬±10%) for organic feel
  // Use a hash of pet profile to get stable "random" value
  const profileHash = JSON.stringify(pet).split('').reduce((acc, char) => {
    const hash = ((acc << 5) - acc) + char.charCodeAt(0);
    return hash & hash;
  }, 0);
  const stableVariation = 0.9 + ((Math.abs(profileHash) % 20) / 100); // 0.9 to 1.1, stable per pet
  adjustedCount *= stableVariation;
  
  // 6. Ensure reasonable bounds
  adjustedCount = Math.round(adjustedCount);
  adjustedCount = Math.max(8, adjustedCount);   // Never show less than 8
  adjustedCount = Math.min(85, adjustedCount);  // Never show more than 85
  
  return adjustedCount;
}
</file>

<file path="lib/utils/mealEstimation.ts">
/**
 * Meal Estimation Utilities
 * Calculate realistic meal counts based on actual package sizes
 */

import { getPackageSize } from '@/lib/data/packageSizes';
import { getProductPrice, getProductQuantity, getProductByIngredient } from '@/lib/data/product-prices';

export interface MealEstimate {
  estimatedMeals: number;
  totalCost: number;
  costPerMeal: number;
  breakdown: Array<{
    ingredient: string;
    recipeAmount: number; // grams needed per meal
    packageSize: number; // grams in package
    mealsFromPackage: number;
    packageCost: number;
  }>;
  notes: string[];
  exceedsBudget?: boolean; // True if costPerMeal > MAX_COST_PER_MEAL
}

// Maximum cost per meal threshold (matched to commercial pet food pricing)
// Dog: $0.50-$3.50/meal, Cat: $0.75-$4.00/meal, Bird: $0.10-$0.50/meal, Reptile: $1.00-$3.00/meal
// Using $4.00 to allow better ingredient variety and quality
export const MAX_COST_PER_MEAL = 4.00;

export interface ShoppingListItem {
  id: string;
  name: string;
  amount: string; // Recipe amount (e.g., "200g", "2 tbsp", "1 tsp")
  asinLink?: string;
  category?: string;
}

/**
 * Convert Amazon quantity strings to grams
 * Examples: "2 lbs", "24 oz", "18 count", "500 count", "32 oz", "1 head", "2 lbs"
 */
export function quantityToGrams(quantity: string): number {
  if (!quantity) return 0;
  
  const q = quantity.toLowerCase().trim();
  
  // Weight conversions
  const lbMatch = q.match(/(\d+(?:\.\d+)?)\s*(?:lb|lbs|pound|pounds)/);
  if (lbMatch) {
    return parseFloat(lbMatch[1]) * 453.592; // 1 lb = 453.592g
  }
  
  const ozMatch = q.match(/(\d+(?:\.\d+)?)\s*(?:oz|ounce|fl oz|fluid ounce)/);
  if (ozMatch) {
    return parseFloat(ozMatch[1]) * 28.3495; // 1 oz = 28.3495g
  }
  
  const kgMatch = q.match(/(\d+(?:\.\d+)?)\s*(?:kg|kilogram)/);
  if (kgMatch) {
    return parseFloat(kgMatch[1]) * 1000;
  }
  
  const gMatch = q.match(/(\d+(?:\.\d+)?)\s*(?:g|gram)/);
  if (gMatch) {
    return parseFloat(gMatch[1]);
  }
  
  // Count-based items (assume average weights)
  const countMatch = q.match(/(\d+)\s*(?:count|piece|pieces|can|cans|jar|jars|box|boxes|bag|bags|head|heads|bunch|bunches)/);
  if (countMatch) {
    const count = parseInt(countMatch[1]);
    const unit = countMatch[0].toLowerCase();
    
    // Estimate weights based on common items
    if (unit.includes('egg') || unit.includes('count')) {
      // Eggs: ~50g each
      if (q.includes('egg')) return count * 50;
      // Generic count: assume 100g per unit
      return count * 100;
    }
    if (unit.includes('can')) return count * 400; // Average can ~400g
    if (unit.includes('jar')) return count * 500; // Average jar ~500g
    if (unit.includes('box')) return count * 300; // Average box ~300g
    if (unit.includes('bag')) return count * 500; // Average bag ~500g
    if (unit.includes('head')) return count * 500; // Lettuce head ~500g
    if (unit.includes('bunch')) return count * 200; // Bunch of herbs ~200g
    
    return count * 100; // Default 100g per unit
  }
  
  return 0;
}

/**
 * Convert various units to grams
 */
export function parseAmountToGrams(amount: string | number, unit?: string): number {
  console.log('[parseAmountToGrams] Input - amount:', amount, 'unit:', unit);
  
  let numAmount: number;
  let unitStr: string;
  
  if (typeof amount === 'string') {
    // Try to parse amount and unit from string like "200g", "2 tbsp", etc.
    const match = amount.match(/(\d+(?:\.\d+)?)\s*(.*)/i);
    console.log('[parseAmountToGrams] Regex match result:', match);
    if (match) {
      numAmount = parseFloat(match[1]);
      unitStr = (match[2] || unit || 'g').trim().toLowerCase();
      console.log('[parseAmountToGrams] Parsed - numAmount:', numAmount, 'unitStr:', unitStr);
    } else {
      numAmount = parseFloat(amount) || 0;
      unitStr = (unit || 'g').toLowerCase();
      console.log('[parseAmountToGrams] No match, using parseFloat - numAmount:', numAmount, 'unitStr:', unitStr);
    }
  } else {
    numAmount = amount;
    unitStr = (unit || 'g').toLowerCase();
    console.log('[parseAmountToGrams] Number input - numAmount:', numAmount, 'unitStr:', unitStr);
  }
  
  if (!numAmount || isNaN(numAmount)) {
    console.log('[parseAmountToGrams] ‚ùå Invalid amount, returning 0');
    return 0;
  }
  
  // Weight conversions
  if (unitStr === 'g' || unitStr === 'gram' || unitStr === 'grams') {
    console.log('[parseAmountToGrams] ‚úÖ Weight (g) conversion:', numAmount);
    return numAmount;
  }
  if (unitStr === 'kg' || unitStr === 'kilogram' || unitStr === 'kilograms') {
    const result = numAmount * 1000;
    console.log('[parseAmountToGrams] ‚úÖ Weight (kg) conversion:', result);
    return result;
  }
  if (unitStr === 'lb' || unitStr === 'pound' || unitStr === 'pounds') {
    const result = numAmount * 453.592;
    console.log('[parseAmountToGrams] ‚úÖ Weight (lb) conversion:', result);
    return result;
  }
  if (unitStr === 'oz' || unitStr === 'ounce' || unitStr === 'ounces') {
    const result = numAmount * 28.3495;
    console.log('[parseAmountToGrams] ‚úÖ Weight (oz) conversion:', result);
    return result;
  }
  
  // Volume conversions (approximate, assuming water density for liquids)
  if (unitStr === 'ml' || unitStr === 'milliliter' || unitStr === 'milliliters') {
    console.log('[parseAmountToGrams] ‚úÖ Volume (ml) conversion:', numAmount);
    return numAmount; // ~1:1 for water
  }
  if (unitStr === 'l' || unitStr === 'liter' || unitStr === 'liters') {
    const result = numAmount * 1000;
    console.log('[parseAmountToGrams] ‚úÖ Volume (l) conversion:', result);
    return result;
  }
  if (unitStr === 'cup' || unitStr === 'cups') {
    const result = numAmount * 240;
    console.log('[parseAmountToGrams] ‚úÖ Volume (cup) conversion:', result);
    return result; // ~240g for water
  }
  if (unitStr === 'tbsp' || unitStr === 'tablespoon' || unitStr === 'tablespoons') {
    const result = numAmount * 15;
    console.log('[parseAmountToGrams] ‚úÖ Volume (tbsp) conversion:', result);
    return result; // ~15g for water
  }
  if (unitStr === 'tsp' || unitStr === 'teaspoon' || unitStr === 'teaspoons') {
    const result = numAmount * 5;
    console.log('[parseAmountToGrams] ‚úÖ Volume (tsp) conversion:', result);
    return result; // ~5g for water
  }
  
  // Count conversions (rough estimates)
  if (unitStr === 'piece' || unitStr === 'pieces' || unitStr === 'whole' || unitStr === 'pinch' || unitStr === 'pinches') {
    const result = numAmount * 10;
    console.log('[parseAmountToGrams] ‚úÖ Count conversion:', result);
    return result; // Assume 10g per piece/pinch (conservative estimate)
  }
  
  // Default: assume grams
  console.log('[parseAmountToGrams] ‚ö†Ô∏è Unknown unit, defaulting to grams:', numAmount);
  return numAmount;
}

/**
 * Calculate how many meals can be made from a shopping list
 * based on actual package sizes
 */
export function calculateMealsFromGroceryList(
  shoppingList: ShoppingListItem[],
  recipeGramsPerMeal?: number, // Optional: total recipe grams per meal
  species?: string, // Optional: species for species-aware product matching
  preferBudget: boolean = true // Default to true for cost calculations - prefer budget-tier products
): MealEstimate {
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/0b2cb572-34bf-468c-9297-dd079c8c4c2d',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'mealEstimation.ts:136',message:'calculateMealsFromGroceryList entry',data:{preferBudget},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
  // #endregion
  console.log('[calculateMealsFromGroceryList] ========== Starting calculation ==========');
  console.log('[calculateMealsFromGroceryList] Input shoppingList:', shoppingList);
  console.log('[calculateMealsFromGroceryList] shoppingList.length:', shoppingList?.length);
  console.log('[calculateMealsFromGroceryList] getProductPrice available:', typeof getProductPrice !== 'undefined');
  
  const breakdown: MealEstimate['breakdown'] = [];
  const notes: string[] = [];
  let totalCost = 0;
  
  if (!shoppingList || shoppingList.length === 0) {
    console.log('[calculateMealsFromGroceryList] ‚ùå Empty shopping list, returning 0 meals');
    return {
      estimatedMeals: 0,
      totalCost: 0,
      costPerMeal: 0,
      breakdown: [],
      notes: ['No ingredients in shopping list']
    };
  }
  
  // Calculate for each ingredient
  for (let i = 0; i < shoppingList.length; i++) {
    const item = shoppingList[i];
    console.log(`[calculateMealsFromGroceryList] Processing item ${i + 1}/${shoppingList.length}:`, item);
    
    const ingredientNameLower = item.name.toLowerCase();
    
    // Try to get product data from product-prices.json first
    let packageSizeGrams = 0;
    let itemCost = 0;
    let priceSource = 'package-estimate';
    
    const product = getProductByIngredient(ingredientNameLower);
    if (product) {
      // Use actual product quantity from Amazon
      if (product.quantity) {
        packageSizeGrams = quantityToGrams(product.quantity);
        console.log(`[calculateMealsFromGroceryList]   ‚úÖ Got quantity from product-prices.json: "${product.quantity}" = ${packageSizeGrams}g`);
      }
      
      // Use actual product price
      if (product.price?.amount) {
        itemCost = product.price.amount;
        priceSource = 'product-prices-json';
        console.log(`[calculateMealsFromGroceryList]   ‚úÖ Using product-prices.json price: $${itemCost}`);
      }
    }
    
    // Fall back to package size estimates if no product data
    if (packageSizeGrams === 0) {
      const packageInfo = getPackageSize(item.name, item.category);
      packageSizeGrams = packageInfo.typicalSize;
      if (!itemCost) {
        itemCost = packageInfo.estimatedCost;
      }
      console.log(`[calculateMealsFromGroceryList]   ‚ö†Ô∏è Using package estimate: ${packageSizeGrams}g, $${itemCost}`);
    }
    
    // Parse recipe amount to grams
    const recipeGrams = parseAmountToGrams(item.amount);
    console.log(`[calculateMealsFromGroceryList]   Recipe amount input: "${item.amount}" (type: ${typeof item.amount})`);
    console.log(`[calculateMealsFromGroceryList]   Recipe grams parsed:`, recipeGrams);
    
    if (recipeGrams <= 0) {
      console.log(`[calculateMealsFromGroceryList]   ‚ùå Skipping - invalid recipeGrams:`, recipeGrams);
      notes.push(`‚ö†Ô∏è Could not parse amount for ${item.name}: "${item.amount}"`);
      continue;
    }
    
    // How many meals can this package make? Keep as decimal for accurate calculation
    const mealsFromPackage = packageSizeGrams / recipeGrams;
    console.log(`[calculateMealsFromGroceryList]   Meals from package: ${packageSizeGrams} / ${recipeGrams} = ${mealsFromPackage}`);
    
    const breakdownItem = {
      ingredient: item.name,
      recipeAmount: recipeGrams,
      packageSize: packageSizeGrams,
      mealsFromPackage: mealsFromPackage,
      packageCost: itemCost,
    };
    breakdown.push(breakdownItem);
    console.log(`[calculateMealsFromGroceryList]   ‚úÖ Added to breakdown (price source: ${priceSource}):`, breakdownItem);
    
    totalCost += itemCost;
    
    // Add notes for very small or very large ratios
    if (mealsFromPackage > 100) {
      notes.push(`${item.name}: Package will last 100+ meals`);
    } else if (mealsFromPackage < 5) {
      notes.push(`${item.name}: Package only makes ${Math.round(mealsFromPackage)} meals - consider larger size`);
    }
  }
  
  console.log('[calculateMealsFromGroceryList] Breakdown array after processing:', breakdown);
  console.log('[calculateMealsFromGroceryList] breakdown.length:', breakdown.length);
  console.log('[calculateMealsFromGroceryList] Total cost so far:', totalCost);
  
  if (breakdown.length === 0) {
    console.log('[calculateMealsFromGroceryList] ‚ùå No valid breakdown items, returning 0 meals');
    return {
      estimatedMeals: 0,
      totalCost: 0,
      costPerMeal: 0,
      breakdown: [],
      notes: ['Could not parse ingredient amounts']
    };
  }
  
  // Filter out staples (ingredients lasting 100+ meals) - they shouldn't limit the calculation
  const substantialIngredients = breakdown.filter(b => b.mealsFromPackage < 100);
  console.log('[calculateMealsFromGroceryList] Substantial ingredients (< 100 meals):', substantialIngredients);
  console.log('[calculateMealsFromGroceryList] substantialIngredients.length:', substantialIngredients.length);
  
  // ‚úÖ FIX: Handle empty array from Math.min - ensure we never pass empty array
  let estimatedMeals = 0;
  if (substantialIngredients.length > 0) {
    estimatedMeals = Math.min(...substantialIngredients.map(b => b.mealsFromPackage));
  } else if (breakdown.length > 0) {
    estimatedMeals = Math.min(...breakdown.map(b => b.mealsFromPackage));
  } else {
    console.error('[calculateMealsFromGroceryList] ‚ùå No valid ingredients in breakdown after processing');
    return {
      estimatedMeals: 0,
      totalCost: 0,
      costPerMeal: 0,
      breakdown: [],
      notes: ['Could not calculate meals from provided ingredients - no valid data after processing']
    };
  }
  console.log('[calculateMealsFromGroceryList] Estimated meals (before rounding):', estimatedMeals);
  
  // ‚úÖ FIX: Floor the final result (not individual ingredients) to get whole meals
  // This gives accurate estimates without compounding rounding errors
  const finalMeals = Math.max(1, Math.floor(estimatedMeals));
  const costPerMeal = finalMeals > 0 ? totalCost / finalMeals : 0;
  console.log('[calculateMealsFromGroceryList] Final meals after rounding:', finalMeals);
  console.log('[calculateMealsFromGroceryList] Cost per meal:', costPerMeal);
  
  // Check if cost exceeds budget threshold
  const finalCostPerMeal = Math.round(costPerMeal * 100) / 100;
  const exceedsBudget = finalCostPerMeal > MAX_COST_PER_MEAL;
  
  // Add general notes
  if (finalMeals < 5) {
    notes.push('‚ö†Ô∏è Some packages are small - consider buying larger sizes');
  } else if (finalMeals > 20) {
    notes.push('‚úì Great value - ingredients will last many meals');
  }
  
  // Add budget warning if exceeded
  if (exceedsBudget) {
    notes.push(`‚ö†Ô∏è Cost per meal ($${finalCostPerMeal.toFixed(2)}) exceeds the $${MAX_COST_PER_MEAL} target. Consider choosing cheaper ingredient alternatives.`);
  }
  
  const finalResult = {
    estimatedMeals: finalMeals,
    totalCost: Math.round(totalCost * 100) / 100,
    costPerMeal: finalCostPerMeal,
    breakdown,
    notes: [...new Set(notes)], // Remove duplicates
    exceedsBudget,
  };
  
  console.log('[calculateMealsFromGroceryList] ‚úÖ Final result:', finalResult);
  if (exceedsBudget) {
    console.log(`[calculateMealsFromGroceryList] ‚ö†Ô∏è  WARNING: Cost per meal exceeds $${MAX_COST_PER_MEAL}`);
  }
  console.log('[calculateMealsFromGroceryList] ============================================');
  
  return finalResult;
}
</file>

<file path="lib/utils/mealImageAssignment.ts">
/**
 * Utility to assign meal images to recipes based on hash of recipe ID
 * Cycles through 25 images per species for consistent assignment
 */

/**
 * Hash a string to a number (deterministic)
 */
function hashStringToNumber(s: string): number {
  let hash = 0;
  for (let i = 0; i < s.length; i++) {
    const char = s.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  return Math.abs(hash);
}

/**
 * Get meal image path for a recipe based on its ID and category
 * Returns path like: /images/meals/dogs-meal-01.png
 * 
 * @param recipeId - Unique recipe identifier
 * @param category - Recipe category (dogs, cats, birds, reptiles, pocket-pets)
 * @returns Image path string
 */
export function getMealImageForRecipe(recipeId: string, category: string): string {
  // Normalize category to match image naming
  const categoryMap: Record<string, string> = {
    'dogs': 'dogs',
    'cats': 'cats',
    'birds': 'birds',
    'reptiles': 'reptiles',
    'pocket-pets': 'pocket-pets'
  };
  
  const normalizedCategory = categoryMap[category.toLowerCase()] || 'dogs';
  
  // Hash the recipe ID to get a number between 0-24 (for 25 images)
  const hash = hashStringToNumber(recipeId);
  const imageNumber = (hash % 25) + 1; // 1-25
  
  // Format as 01-25
  const imageNumberStr = imageNumber.toString().padStart(2, '0');
  
  return `/images/meals/${normalizedCategory}-meal-${imageNumberStr}.png`;
}

/**
 * Get all available meal images for a species
 * Useful for checking which images exist
 */
export function getAvailableMealImages(category: string): string[] {
  const categoryMap: Record<string, string> = {
    'dogs': 'dogs',
    'cats': 'cats',
    'birds': 'birds',
    'reptiles': 'reptiles',
    'pocket-pets': 'pocket-pets'
  };
  
  const normalizedCategory = categoryMap[category.toLowerCase()] || 'dogs';
  const images: string[] = [];
  
  for (let i = 1; i <= 25; i++) {
    const imageNumber = i.toString().padStart(2, '0');
    images.push(`/images/meals/${normalizedCategory}-meal-${imageNumber}.png`);
  }
  
  return images;
}
</file>

<file path="lib/utils/mealNameGenerator.ts">
// lib/utils/mealNameGenerator.ts
// Enhanced meal naming system with semantic awareness, health context, and pet personalization

import { getIngredientById, getIngredientByName, type UnifiedIngredient, type IngredientCategory } from '../data/unifiedIngredientRegistry';
import type { Recipe } from '../types';

// =================================================================
// Phase 1: Foundation - Ingredient Display Name Integration
// =================================================================

/**
 * Get display name for an ingredient from unified registry
 */
function getIngredientDisplayName(ingredientKey: string): string {
  // Try to find ingredient by ID (snake_case)
  let ingredient: UnifiedIngredient | null = getIngredientById(ingredientKey);
  
  // If not found, try by name
  if (!ingredient) {
    ingredient = getIngredientByName(ingredientKey);
  }
  
  // If found, return primary display name
  if (ingredient) {
    return ingredient.primaryDisplayName;
  }
  
  // Fallback: format key to Title Case
  return ingredientKey
    .split(/[_\s-]+/)
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(' ');
}

/**
 * Categorize ingredients by type using unified registry
 */
function categorizeIngredients(ingredientKeys: string[]): {
  proteins: string[];
  carbs: string[];
  vegetables: string[];
  fruits: string[];
  supplements: string[];
} {
  const categories = {
    proteins: [] as string[],
    carbs: [] as string[],
    vegetables: [] as string[],
    fruits: [] as string[],
    supplements: [] as string[],
  };
  
  for (const key of ingredientKeys) {
    let ingredient: UnifiedIngredient | null = getIngredientById(key);
    if (!ingredient) {
      ingredient = getIngredientByName(key);
    }
    
    if (ingredient) {
      const category = ingredient.category;
      const displayName = getIngredientDisplayName(key);
      
      switch (category) {
        case 'protein':
        case 'insect':
          categories.proteins.push(displayName);
          break;
        case 'grain':
          categories.carbs.push(displayName);
          break;
        case 'vegetable':
          categories.vegetables.push(displayName);
          break;
        case 'fruit':
          categories.fruits.push(displayName);
          break;
        case 'supplement':
          categories.supplements.push(displayName);
          break;
        default:
          // Try to infer from name
          const lower = key.toLowerCase();
          if (lower.match(/\b(chicken|turkey|beef|lamb|fish|salmon|tuna|meat|protein|pork|duck|organ|heart|liver|kidney|venison|rabbit|quail)\b/)) {
            categories.proteins.push(displayName);
          } else if (lower.match(/\b(rice|oats|quinoa|barley|wheat|grain|seed|millet|potato|sweet.*potato|pumpkin|squash)\b/)) {
            categories.carbs.push(displayName);
          } else if (lower.match(/\b(carrot|broccoli|spinach|kale|lettuce|pepper|vegetable|green)\b/)) {
            categories.vegetables.push(displayName);
          }
          break;
      }
    } else {
      // Fallback categorization by name
      const lower = key.toLowerCase();
      if (lower.match(/\b(chicken|turkey|beef|lamb|fish|salmon|tuna|meat|protein|pork|duck|organ|heart|liver|kidney|venison|rabbit|quail)\b/)) {
        categories.proteins.push(getIngredientDisplayName(key));
      } else if (lower.match(/\b(rice|oats|quinoa|barley|wheat|grain|seed|millet|potato|sweet.*potato|pumpkin|squash)\b/)) {
        categories.carbs.push(getIngredientDisplayName(key));
      } else if (lower.match(/\b(carrot|broccoli|spinach|kale|lettuce|pepper|vegetable|green)\b/)) {
        categories.vegetables.push(getIngredientDisplayName(key));
      }
    }
  }
  
  return categories;
}

// =================================================================
// Phase 2: Semantic Metadata Extraction
// =================================================================

interface MealSemantics {
  dominantProtein: string;
  dominantCarb: string;
  dominantVeg: string;
  nutritionalAngle: 'High Protein' | 'Low Fat' | 'High Fiber' | 'Balanced';
  cookingStyle: 'Slow-Cooked' | 'Oven-Baked' | 'Fresh' | 'Stewed' | 'Raw' | null;
  healthTags: string[];
}

/**
 * Extract semantic metadata from recipe/ingredients
 */
function extractMealSemantics(
  ingredientKeys: string[],
  options?: {
    nutritionalProfile?: {
      protein?: number;
      fat?: number;
      fiber?: number;
    };
    healthConcerns?: string[];
    recipe?: Recipe;
  }
): MealSemantics {
  const categorized = categorizeIngredients(ingredientKeys);
  
  // Determine dominant ingredients
  const dominantProtein = categorized.proteins[0] || '';
  const dominantCarb = categorized.carbs[0] || '';
  const dominantVeg = categorized.vegetables[0] || '';
  
  // Determine nutritional angle
  let nutritionalAngle: 'High Protein' | 'Low Fat' | 'High Fiber' | 'Balanced' = 'Balanced';
  if (options?.nutritionalProfile) {
    const { protein, fat, fiber } = options.nutritionalProfile;
    if (protein && protein > 30) {
      nutritionalAngle = 'High Protein';
    } else if (fat && fat < 10) {
      nutritionalAngle = 'Low Fat';
    } else if (fiber && fiber > 5) {
      nutritionalAngle = 'High Fiber';
    }
  }
  
  // Determine cooking style (from recipe metadata or infer)
  let cookingStyle: 'Slow-Cooked' | 'Oven-Baked' | 'Fresh' | 'Stewed' | 'Raw' | null = null;
  if (options?.recipe) {
    const recipe = options.recipe;
    const nameLower = recipe.name?.toLowerCase() || '';
    const descLower = recipe.description?.toLowerCase() || '';
    const instructions = (recipe.instructions || []).join(' ').toLowerCase();
    
    if (nameLower.includes('slow') || instructions.includes('slow cook')) {
      cookingStyle = 'Slow-Cooked';
    } else if (nameLower.includes('baked') || instructions.includes('bake') || instructions.includes('oven')) {
      cookingStyle = 'Oven-Baked';
    } else if (nameLower.includes('fresh') || descLower.includes('fresh')) {
      cookingStyle = 'Fresh';
    } else if (nameLower.includes('stew') || instructions.includes('stew')) {
      cookingStyle = 'Stewed';
    } else if (nameLower.includes('raw') || instructions.includes('raw')) {
      cookingStyle = 'Raw';
    }
  }
  
  // Map health concerns to naming tags
  const healthTags: string[] = [];
  if (options?.healthConcerns && options.healthConcerns.length > 0) {
    healthTags.push(...options.healthConcerns);
  }
  
  return {
    dominantProtein,
    dominantCarb,
    dominantVeg,
    nutritionalAngle,
    cookingStyle,
    healthTags,
  };
}

// =================================================================
// Phase 5: Health Concern Lexicon
// =================================================================

const HEALTH_CONCERN_NAMING_MAP: Record<string, string> = {
  'joint-health': 'Mobility',
  'joint health': 'Mobility',
  'kidney-disease': 'Renal Support',
  'kidney disease': 'Renal Support',
  'digestive-health': 'Digestive Ease',
  'digestive health': 'Digestive Ease',
  'weight-management': 'Weight Control',
  'weight management': 'Weight Control',
  'allergies': 'Hypoallergenic',
  'diabetes': 'Blood Sugar Balance',
  'dental-health': 'Dental Care',
  'dental health': 'Dental Care',
  'pancreatitis': 'Low-Fat',
  'urinary-health': 'Urinary Support',
  'urinary health': 'Urinary Support',
  'skin-health': 'Skin & Coat',
  'skin health': 'Skin & Coat',
  'heart-health': 'Heart Health',
  'heart health': 'Heart Health',
  'immune-support': 'Immune Support',
  'immune support': 'Immune Support',
  'senior-health': 'Senior Support',
  'senior health': 'Senior Support',
};

/**
 * Map health concern to naming-friendly tag
 */
function mapHealthConcernToTag(concern: string): string {
  const normalized = concern.toLowerCase().trim();
  return HEALTH_CONCERN_NAMING_MAP[normalized] || concern;
}

// =================================================================
// Phase 3: Naming Families (25+ Patterns)
// =================================================================

type NamingFamily = 'ingredient-driven' | 'health-focused' | 'pet-personalized' | 'nutritional-style' | 'creative';

interface NamingPattern {
  family: NamingFamily;
  pattern: string;
  requires?: {
    protein?: boolean;
    carb?: boolean;
    veggie?: boolean;
    healthTag?: boolean;
    petName?: boolean;
  };
}

const NAMING_PATTERNS: NamingPattern[] = [
  // Family 1: Ingredient-Driven (Classic)
  { family: 'ingredient-driven', pattern: '{protein} & {carb} Bowl', requires: { protein: true, carb: true } },
  { family: 'ingredient-driven', pattern: '{protein} with {veggie} Medley', requires: { protein: true, veggie: true } },
  { family: 'ingredient-driven', pattern: 'Fresh {protein} & {secondIngredient}', requires: { protein: true } },
  { family: 'ingredient-driven', pattern: '{protein} {carb} Harmony', requires: { protein: true, carb: true } },
  { family: 'ingredient-driven', pattern: '{protein} Garden Blend', requires: { protein: true } },
  
  // Family 2: Health-Focused
  { family: 'health-focused', pattern: '{healthFocus} {protein} Recipe', requires: { protein: true, healthTag: true } },
  { family: 'health-focused', pattern: 'Balanced {protein} & {carb} Plate', requires: { protein: true, carb: true } },
  { family: 'health-focused', pattern: '{protein} {healthTag} Formula', requires: { protein: true, healthTag: true } },
  { family: 'health-focused', pattern: 'Supportive {protein} Blend', requires: { protein: true, healthTag: true } },
  { family: 'health-focused', pattern: 'Gentle {protein} Medley', requires: { protein: true, healthTag: true } },
  
  // Family 3: Pet-Personalized (only for custom meals)
  { family: 'pet-personalized', pattern: "{petName}'s {protein} Dinner", requires: { protein: true, petName: true } },
  { family: 'pet-personalized', pattern: "{petName}'s Favorite {protein} Bowl", requires: { protein: true, petName: true } },
  { family: 'pet-personalized', pattern: 'Special {protein} for {petName}', requires: { protein: true, petName: true } },
  { family: 'pet-personalized', pattern: "{petName}'s {healthTag} {protein}", requires: { protein: true, petName: true, healthTag: true } },
  { family: 'pet-personalized', pattern: '{breed} {protein} Feast', requires: { protein: true } },
  
  // Family 4: Nutritional-Style
  { family: 'nutritional-style', pattern: 'High-Protein {protein} Power Bowl', requires: { protein: true } },
  { family: 'nutritional-style', pattern: 'Lean {protein} & {carb} Mix', requires: { protein: true, carb: true } },
  { family: 'nutritional-style', pattern: 'Nutrient-Rich {protein} Medley', requires: { protein: true } },
  { family: 'nutritional-style', pattern: 'Complete {protein} Formula', requires: { protein: true } },
  { family: 'nutritional-style', pattern: 'Premium {protein} Blend', requires: { protein: true } },
  
  // Family 5: Creative/Descriptive
  { family: 'creative', pattern: 'Rustic {protein} Farmhouse Bowl', requires: { protein: true } },
  { family: 'creative', pattern: 'Savory {protein} Kitchen Creation', requires: { protein: true } },
  { family: 'creative', pattern: 'Golden {protein} & {carb} Plate', requires: { protein: true, carb: true } },
  { family: 'creative', pattern: 'Ultimate {protein} Feast', requires: { protein: true } },
  { family: 'creative', pattern: "Chef's Choice {protein} Blend", requires: { protein: true } },
  { family: 'creative', pattern: 'Heritage {protein} & {veggie} Bowl', requires: { protein: true, veggie: true } },
  { family: 'creative', pattern: 'Wholesome {protein} Delight', requires: { protein: true } },
  { family: 'creative', pattern: 'Gourmet {protein} & {carb} Mix', requires: { protein: true, carb: true } },
  { family: 'creative', pattern: 'Premium {protein} Medley', requires: { protein: true } },
  { family: 'creative', pattern: 'Classic {protein} & {veggie} Recipe', requires: { protein: true, veggie: true } },
  
  // More ingredient-driven patterns for variety
  { family: 'ingredient-driven', pattern: '{protein} Power Bowl', requires: { protein: true } },
  { family: 'ingredient-driven', pattern: '{protein} & {veggie} Delight', requires: { protein: true, veggie: true } },
  { family: 'ingredient-driven', pattern: '{protein} {carb} Fusion', requires: { protein: true, carb: true } },
  
  // More nutritional-style patterns
  { family: 'nutritional-style', pattern: 'Vital {protein} Formula', requires: { protein: true } },
  { family: 'nutritional-style', pattern: 'Optimal {protein} & {carb} Blend', requires: { protein: true, carb: true } },
];

// =================================================================
// Phase 4: Pattern Selection Logic
// =================================================================

/**
 * Simple hash function for deterministic pattern selection
 */
function hashString(str: string): number {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32-bit integer
  }
  return Math.abs(hash);
}

/**
 * Select naming family based on context
 */
function selectNamingFamily(
  semantics: MealSemantics,
  options?: {
    petName?: string;
    isCustomMeal?: boolean;
    recipeId?: string;
  }
): NamingFamily {
  // For custom meals, add randomness using timestamp + ingredients for variety
  const seed = options?.recipeId || 
    (options?.isCustomMeal ? `${Date.now()}-${semantics.dominantProtein}-${semantics.dominantCarb}` : '');
  
  if (seed) {
    const hash = hashString(seed);
    const families: NamingFamily[] = ['ingredient-driven', 'health-focused', 'nutritional-style', 'creative', 'pet-personalized'];
    return families[hash % families.length];
  }
  
  // Prioritize health-focused if health concerns present
  if (semantics.healthTags.length > 0) {
    return 'health-focused';
  }
  
  // Use pet-personalized for custom meals (30% chance to avoid repetition)
  if (options?.isCustomMeal && options?.petName) {
    const hash = hashString(options.petName + seed);
    if (hash % 10 < 3) { // 30% chance
      return 'pet-personalized';
    }
  }
  
  // Use nutritional-style if nutritional angle is strong
  if (semantics.nutritionalAngle !== 'Balanced') {
    return 'nutritional-style';
  }
  
  // Default to ingredient-driven
  return 'ingredient-driven';
}

/**
 * Select a pattern from the chosen family
 */
function selectPattern(
  family: NamingFamily,
  semantics: MealSemantics,
  options?: {
    petName?: string;
    petBreed?: string;
    recipeId?: string;
    isCustomMeal?: boolean;
  }
): NamingPattern {
  // Filter patterns by family and requirements
  const familyPatterns = NAMING_PATTERNS.filter(p => p.family === family);
  
  // Filter by requirements
  const availablePatterns = familyPatterns.filter(pattern => {
    if (pattern.requires) {
      if (pattern.requires.protein && !semantics.dominantProtein) return false;
      if (pattern.requires.carb && !semantics.dominantCarb) return false;
      if (pattern.requires.veggie && !semantics.dominantVeg) return false;
      if (pattern.requires.healthTag && semantics.healthTags.length === 0) return false;
      if (pattern.requires.petName && !options?.petName) return false;
    }
    return true;
  });
  
  if (availablePatterns.length === 0) {
    // Fallback to any pattern in family
    return familyPatterns[0] || NAMING_PATTERNS[0];
  }
  
  // For custom meals, add timestamp for more variety
  const seed = options?.recipeId || 
    (options?.isCustomMeal 
      ? `${Date.now()}-${semantics.dominantProtein}-${semantics.dominantCarb}-${semantics.dominantVeg}`
      : `${semantics.dominantProtein}-${semantics.dominantCarb}-${semantics.dominantVeg}`);
  const hash = hashString(seed);
  return availablePatterns[hash % availablePatterns.length];
}

/**
 * Clean breed/pet type by removing parenthetical content like "(budgie)"
 */
function cleanBreedOrSpecies(text: string | undefined): string | undefined {
  if (!text) return undefined;
  // Remove content in parentheses like "(budgie)" or "(common)"
  return text.replace(/\s*\([^)]*\)/g, '').trim();
}

/**
 * Fill pattern with actual values
 */
function fillPattern(
  pattern: NamingPattern,
  semantics: MealSemantics,
  options?: {
    petName?: string;
    petBreed?: string;
    secondIngredient?: string;
  }
): string {
  let result = pattern.pattern;
  
  // Replace placeholders
  result = result.replace(/{protein}/g, semantics.dominantProtein || 'Protein');
  result = result.replace(/{carb}/g, semantics.dominantCarb || 'Grain');
  result = result.replace(/{veggie}/g, semantics.dominantVeg || 'Vegetable');
  result = result.replace(/{secondIngredient}/g, options?.secondIngredient || semantics.dominantCarb || semantics.dominantVeg || 'Mix');
  
  // Health tags
  if (semantics.healthTags.length > 0) {
    const healthTag = mapHealthConcernToTag(semantics.healthTags[0]);
    result = result.replace(/{healthTag}/g, healthTag);
    result = result.replace(/{healthFocus}/g, healthTag);
  }
  
  // Pet context - clean breed to remove parentheses
  if (options?.petName) {
    result = result.replace(/{petName}/g, options.petName);
  }
  if (options?.petBreed) {
    const cleanedBreed = cleanBreedOrSpecies(options.petBreed);
    if (cleanedBreed) {
      result = result.replace(/{breed}/g, cleanedBreed);
    }
  }
  
  return result;
}

// =================================================================
// Phase 6: Collision Avoidance
// =================================================================

// In-memory collision map (per session)
const nameCollisionMap = new Map<string, number>();

/**
 * Ensure unique name by appending suffix if needed
 */
function ensureUniqueName(
  baseName: string,
  ingredientSignature: string
): string {
  // Check if we've seen this signature before
  const existingCount = nameCollisionMap.get(ingredientSignature);
  
  if (existingCount === undefined) {
    // First time seeing this signature - don't add any suffix
    nameCollisionMap.set(ingredientSignature, 1);
    return baseName;
  }
  
  // Collision detected - append numeric suffix (skip 0, start at 2)
  const suffix = existingCount + 1;
  nameCollisionMap.set(ingredientSignature, suffix);
  return `${baseName} ${suffix}`;
}

/**
 * Create ingredient signature for collision detection
 */
function createIngredientSignature(ingredientKeys: string[]): string {
  return ingredientKeys
    .map(k => k.toLowerCase().trim())
    .sort()
    .join('|');
}

// =================================================================
// Phase 7: Short Name Generation
// =================================================================

/**
 * Generate short name (max 20 characters)
 */
function generateShortName(semantics: MealSemantics): string {
  const parts: string[] = [];
  
  if (semantics.dominantProtein) {
    parts.push(semantics.dominantProtein);
  }
  
  if (semantics.dominantCarb) {
    parts.push(semantics.dominantCarb);
  } else if (semantics.dominantVeg) {
    parts.push(semantics.dominantVeg);
  }
  
  if (parts.length === 0) {
    return 'Custom Meal';
  }
  
  const shortName = parts.join(' & ');
  
  // Truncate if too long
  if (shortName.length > 20) {
    return shortName.substring(0, 17) + '...';
  }
  
  return shortName;
}

// =================================================================
// Phase 9: Quality Assurance
// =================================================================

/**
 * Validate and format meal name
 */
function validateMealName(name: string): string {
  // Remove underscores
  let cleaned = name.replace(/_/g, ' ');
  
  // Remove any trailing numbers or "0" that might have been added
  cleaned = cleaned.replace(/\s+0+\s*$/, '').trim();
  
  // Remove any parenthetical content that might have slipped through
  cleaned = cleaned.replace(/\s*\([^)]*\)\s*/g, ' ');
  
  // Fix spacing
  cleaned = cleaned.replace(/\s+/g, ' ').trim();
  
  // Ensure proper capitalization (Title Case)
  cleaned = cleaned
    .split(' ')
    .map(word => {
      // Skip small words unless they're the first word
      const smallWords = ['a', 'an', 'and', 'as', 'at', 'but', 'by', 'for', 'if', 'in', 'of', 'on', 'or', 'the', 'to'];
      if (smallWords.includes(word.toLowerCase()) && cleaned.indexOf(word) > 0) {
        return word.toLowerCase();
      }
      return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
    })
    .join(' ');
  
  // Check for generic patterns and add descriptor if needed
  const genericPatterns = [
    /^Chicken Bowl$/i,
    /^Beef Mix$/i,
    /^Salmon Bowl$/i,
  ];
  
  for (const pattern of genericPatterns) {
    if (pattern.test(cleaned)) {
      cleaned = cleaned.replace(/Bowl|Mix/, 'Power Bowl');
    }
  }
  
  // Validate length
  if (cleaned.length < 10) {
    cleaned = cleaned + ' Meal';
  } else if (cleaned.length > 60) {
    cleaned = cleaned.substring(0, 57) + '...';
  }
  
  // Final cleanup - remove any trailing whitespace or special characters
  cleaned = cleaned.trim();
  
  return cleaned;
}

// =================================================================
// Main Export: generateMealName
// =================================================================

export interface MealNameOptions {
  petName?: string;
  petBreed?: string;
  petSpecies?: string;
  healthConcerns?: string[];
  nutritionalProfile?: {
    protein?: number;
    fat?: number;
    fiber?: number;
  };
  mealType?: 'complete' | 'treat' | 'supplement';
  recipeId?: string;
  recipe?: Recipe;
  isCustomMeal?: boolean;
}

export interface MealNameResult {
  fullName: string;
  shortName: string;
}

/**
 * Generate meal name with full context awareness
 */
export function generateMealName(
  ingredients: string[],
  options?: MealNameOptions
): MealNameResult {
  if (ingredients.length === 0) {
    return {
      fullName: 'Custom Meal',
      shortName: 'Custom Meal',
    };
  }
  
  // Extract semantics
  const semantics = extractMealSemantics(ingredients, {
    nutritionalProfile: options?.nutritionalProfile,
    healthConcerns: options?.healthConcerns,
    recipe: options?.recipe,
  });
  
  // Select naming family
  const family = selectNamingFamily(semantics, {
    petName: options?.petName,
    isCustomMeal: options?.isCustomMeal,
    recipeId: options?.recipeId,
  });
  
  // Clean petBreed to remove parenthetical content
  const cleanedBreed = options?.petBreed ? cleanBreedOrSpecies(options.petBreed) : undefined;
  
  // Select pattern
  const pattern = selectPattern(family, semantics, {
    petName: options?.petName,
    petBreed: cleanedBreed,
    recipeId: options?.recipeId,
    isCustomMeal: options?.isCustomMeal,
  });
  
  // Get second ingredient for patterns that need it
  const categorized = categorizeIngredients(ingredients);
  const secondIngredient = categorized.proteins[1] || categorized.carbs[0] || categorized.vegetables[0];
  
  // Fill pattern (use cleaned breed)
  let fullName = fillPattern(pattern, semantics, {
    petName: options?.petName,
    petBreed: cleanedBreed,
    secondIngredient,
  });
  
  // Clean up any remaining parenthetical content that might have been in the name
  fullName = fullName.replace(/\s*\([^)]*\)\s*/g, ' ').replace(/\s+/g, ' ').trim();
  
  // Handle nutritional angle in name
  if (semantics.nutritionalAngle === 'High Protein' && !fullName.includes('High-Protein') && !fullName.includes('Power')) {
    fullName = fullName.replace(/{protein}/g, 'High-Protein ' + semantics.dominantProtein);
  }
  
  // Create ingredient signature for collision detection
  const ingredientSignature = createIngredientSignature(ingredients);
  
  // Ensure uniqueness
  fullName = ensureUniqueName(fullName, ingredientSignature);
  
  // Validate and format
  fullName = validateMealName(fullName);
  
  // Generate short name
  const shortName = generateShortName(semantics);
  
  return {
    fullName,
    shortName,
  };
}

/**
 * Legacy function for backward compatibility
 * @deprecated Use generateMealName with options instead
 */
export function getShortMealName(ingredients: string[]): string {
  const result = generateMealName(ingredients);
  return result.shortName;
}
</file>

<file path="lib/utils/nutritionalRecommendations.ts">
// lib/utils/nutritionalRecommendations.ts
// Maps nutritional deficiencies to recommended supplements and ingredients

import { petSupplements, type Supplement } from '@/lib/data/supplements';
import { getVettedProduct } from '@/lib/data/vetted-products';

export interface RecommendedSupplement {
  name: string;
  description: string;
  benefits: string;
  addressesDeficiency: string;
  defaultAmount: string;
  amazonLink?: string;
  asinLink?: string;
  isIngredient?: boolean;
  productName?: string;
  vetNote?: string;
}

/**
 * Map nutritional gaps to recommended supplements/ingredients
 */
export function getRecommendationsForDeficiency(
  deficiency: string,
  species: 'dog' | 'cat' | 'bird' | 'reptile' | 'pocket-pet',
  healthConcerns: string[] = []
): RecommendedSupplement[] {
  const recommendations: RecommendedSupplement[] = [];
  const lowerDeficiency = deficiency.toLowerCase();

  // Normalize species for supplement lookup
  const supplementSpecies = species === 'pocket-pet' ? 'pocket-pets' : 
                            species === 'reptile' ? 'reptiles' : 
                            species;

  // Map deficiency patterns to supplement categories
  const deficiencyMappings: Record<string, string[]> = {
    'protein': ['allergy-support', 'digestive-health'],
    'calcium': ['joint-mobility', 'digestive-health'],
    'phosphorus': ['joint-mobility'],
    'ca:p': ['joint-mobility'],
    'taurine': ['allergy-support'],
    'fiber': ['digestive-health', 'weight-management'],
    'vitamin': ['skin-coat'],
    'omega': ['skin-coat', 'allergy-support'],
    'fat': ['skin-coat', 'allergy-support'],
  };

  // Find matching supplement categories
  const matchingCategories: string[] = [];
  for (const [pattern, categories] of Object.entries(deficiencyMappings)) {
    if (lowerDeficiency.includes(pattern)) {
      matchingCategories.push(...categories);
    }
  }

  // Get supplements from petSupplements data
  const speciesSupplements = petSupplements[supplementSpecies as keyof typeof petSupplements];
  if (speciesSupplements) {
    for (const category of matchingCategories) {
      const categorySupplements = speciesSupplements[category as keyof typeof speciesSupplements];
      if (Array.isArray(categorySupplements)) {
        for (const supplement of categorySupplements) {
          // Check if vetted product exists
          const vettedProduct = getVettedProduct(supplement.name);
          
          recommendations.push({
            name: supplement.name,
            description: supplement.description,
            benefits: supplement.benefits,
            addressesDeficiency: deficiency,
            defaultAmount: 'As directed',
            amazonLink: supplement.amazonLink,
            asinLink: vettedProduct?.asinLink || supplement.amazonLink,
            productName: vettedProduct?.productName || supplement.name,
            vetNote: vettedProduct?.vetNote,
          });
        }
      }
    }
  }

  // Species-specific ingredient recommendations
  if (lowerDeficiency.includes('protein') && species === 'cat') {
    recommendations.push({
      name: 'Taurine Supplement',
      description: 'Essential amino acid for cats',
      benefits: 'Prevents taurine deficiency, supports heart and eye health',
      addressesDeficiency: 'Low protein / Taurine deficiency',
      defaultAmount: '250-500mg per day',
      isIngredient: false,
    });
  }

  if (lowerDeficiency.includes('calcium') || lowerDeficiency.includes('ca:p')) {
    if (species === 'reptile' || species === 'bird') {
      recommendations.push({
        name: 'Calcium with Vitamin D3',
        description: 'Essential for bone health',
        benefits: 'Prevents metabolic bone disease, supports proper Ca:P ratio',
        addressesDeficiency: 'Calcium deficiency / Ca:P imbalance',
        defaultAmount: 'Lightly dust food 2-3x per week',
        isIngredient: false,
      });
    } else {
      recommendations.push({
        name: 'Calcium Supplement',
        description: 'Calcium for bone and dental health',
        benefits: 'Supports proper Ca:P ratio, bone strength',
        addressesDeficiency: 'Calcium deficiency / Ca:P imbalance',
        defaultAmount: 'As directed on package',
        isIngredient: false,
      });
    }
  }

  if (lowerDeficiency.includes('fiber')) {
    recommendations.push({
      name: 'Pumpkin Powder',
      description: 'Natural fiber source',
      benefits: 'Promotes digestive regularity and satiety',
      addressesDeficiency: 'Low fiber',
      defaultAmount: '1-2 tsp per meal',
      isIngredient: true,
    });
  }

  // Health concern-based recommendations
  if (healthConcerns.includes('joint-health') || healthConcerns.includes('joint-mobility')) {
    recommendations.push({
      name: 'Glucosamine & Chondroitin',
      description: 'Joint health supplements',
      benefits: 'Supports cartilage health and joint mobility',
      addressesDeficiency: 'Joint support needed',
      defaultAmount: 'As directed on package',
      isIngredient: false,
    });
  }

  // Remove duplicates based on name
  const uniqueRecommendations = recommendations.filter((rec, index, self) =>
    index === self.findIndex(r => r.name === rec.name)
  );

  return uniqueRecommendations;
}

/**
 * Get all recommendations for a recipe based on nutritional gaps
 */
export function getRecommendationsForRecipe(
  nutritionalGaps: string[],
  species: 'dog' | 'cat' | 'bird' | 'reptile' | 'pocket-pet',
  healthConcerns: string[] = []
): RecommendedSupplement[] {
  const allRecommendations: RecommendedSupplement[] = [];

  for (const gap of nutritionalGaps) {
    const recommendations = getRecommendationsForDeficiency(gap, species, healthConcerns);
    allRecommendations.push(...recommendations);
  }

  // Remove duplicates
  const uniqueRecommendations = allRecommendations.filter((rec, index, self) =>
    index === self.findIndex(r => r.name === rec.name)
  );

  return uniqueRecommendations;
}
</file>

<file path="lib/utils/nutritionFallbacks.ts">
// lib/utils/nutritionFallbacks.ts
// Category-based nutrition fallback data for ingredients missing from INGREDIENT_COMPOSITIONS
// Used when ingredient lookup fails to ensure recipe generation can continue

import type { IngredientComposition } from '@/lib/data/ingredientCompositions';

/**
 * Category-based nutrition templates for fallback data
 * Based on USDA averages and research-based estimates for common ingredient categories
 */
export const CATEGORY_NUTRITION_FALLBACKS: Record<string, IngredientComposition> = {
  poultry: {
    protein: 20.0,
    fat: 8.0,
    carbs: 0,
    fiber: 0,
    moisture: 70,
    calcium: 10,
    phosphorus: 180,
    kcal: 145,
    source: 'estimated_fallback',
    needsReview: true,
  },
  red_meat: {
    protein: 22.0,
    fat: 12.0,
    carbs: 0,
    fiber: 0,
    moisture: 65,
    calcium: 12,
    phosphorus: 190,
    kcal: 180,
    source: 'estimated_fallback',
    needsReview: true,
  },
  fish: {
    protein: 19.0,
    fat: 6.0,
    carbs: 0,
    fiber: 0,
    moisture: 75,
    calcium: 25,
    phosphorus: 220,
    omega3: 1.5,
    kcal: 130,
    source: 'estimated_fallback',
    needsReview: true,
  },
  insect: {
    protein: 15.0,
    fat: 8.0,
    carbs: 5,
    fiber: 2,
    moisture: 70,
    calcium: 30,
    phosphorus: 200,
    kcal: 140,
    source: 'estimated_fallback',
    needsReview: true,
  },
  vegetable: {
    protein: 2.0,
    fat: 0.5,
    carbs: 12,
    fiber: 3,
    moisture: 85,
    calcium: 30,
    phosphorus: 40,
    kcal: 50,
    source: 'estimated_fallback',
    needsReview: true,
  },
  fruit: {
    protein: 1.0,
    fat: 0.3,
    carbs: 15,
    fiber: 2,
    moisture: 80,
    calcium: 10,
    phosphorus: 20,
    kcal: 60,
    source: 'estimated_fallback',
    needsReview: true,
  },
  supplement: {
    protein: 0,
    fat: 0,
    carbs: 0,
    fiber: 0,
    moisture: 5,
    calcium: 500, // High calcium for supplements
    phosphorus: 300,
    kcal: 0,
    source: 'estimated_fallback',
    needsReview: true,
  },
  grain: {
    protein: 8.0,
    fat: 2.0,
    carbs: 75,
    fiber: 5,
    moisture: 10,
    calcium: 20,
    phosphorus: 150,
    kcal: 350,
    source: 'estimated_fallback',
    needsReview: true,
  },
  seed: {
    protein: 15.0,
    fat: 10.0,
    carbs: 50,
    fiber: 8,
    moisture: 8,
    calcium: 50,
    phosphorus: 400,
    kcal: 500,
    source: 'estimated_fallback',
    needsReview: true,
  },
  hay: {
    protein: 8.0,
    fat: 2.0,
    carbs: 60,
    fiber: 30,
    moisture: 10,
    calcium: 40,
    phosphorus: 30,
    kcal: 200,
    source: 'estimated_fallback',
    needsReview: true,
  },
  // Enhanced categories
  leafy_green: {
    protein: 2.5,
    fat: 0.4,
    carbs: 3,
    fiber: 2.5,
    moisture: 92,
    calcium: 100,
    phosphorus: 50,
    kcal: 20,
    source: 'estimated_fallback',
    needsReview: true,
  },
  starchy_veg: {
    protein: 2.0,
    fat: 0.2,
    carbs: 20,
    fiber: 3,
    moisture: 75,
    calcium: 30,
    phosphorus: 50,
    kcal: 85,
    source: 'estimated_fallback',
    needsReview: true,
  },
  fatty_protein: {
    protein: 18.0,
    fat: 15.0,
    carbs: 0,
    fiber: 0,
    moisture: 65,
    calcium: 15,
    phosphorus: 200,
    kcal: 220,
    source: 'estimated_fallback',
    needsReview: true,
  },
  lean_protein: {
    protein: 28.0,
    fat: 3.0,
    carbs: 0,
    fiber: 0,
    moisture: 68,
    calcium: 10,
    phosphorus: 200,
    kcal: 140,
    source: 'estimated_fallback',
    needsReview: true,
  },
};

/**
 * Confidence levels for fallback categories
 */
export const FALLBACK_CONFIDENCE: Record<string, 'high' | 'medium' | 'low'> = {
  poultry: 'medium',
  red_meat: 'medium',
  fish: 'medium',
  insect: 'low',
  vegetable: 'medium',
  fruit: 'medium',
  supplement: 'low',
  grain: 'medium',
  seed: 'medium',
  hay: 'medium',
  leafy_green: 'medium',
  starchy_veg: 'medium',
  fatty_protein: 'medium',
  lean_protein: 'medium',
};

/**
 * Species-specific fallback adjustments
 */
export const SPECIES_FALLBACK_ADJUSTMENTS: Record<string, Partial<IngredientComposition>> = {
  // Cats need more protein and taurine
  cat: {
    // No direct adjustment, but recipes should be tagged
  },
  // Birds need more calcium
  bird: {
    // No direct adjustment, but recipes should be tagged
  },
  // Reptiles need specific Ca:P ratios
  reptile: {
    // No direct adjustment, but recipes should be tagged
  },
};

/**
 * Get fallback nutrition data for an ingredient based on its name patterns
 * @param ingredientName - The ingredient name to match
 * @returns IngredientComposition with estimated values, or default fallback
 */
export function getFallbackNutrition(ingredientName: string): IngredientComposition {
  const lowerName = ingredientName.toLowerCase().trim();
  
  // Lean protein patterns (breast, fillet)
  if ((lowerName.includes('chicken') || lowerName.includes('turkey')) && 
      (lowerName.includes('breast') || lowerName.includes('fillet'))) {
    return { ...CATEGORY_NUTRITION_FALLBACKS.lean_protein };
  }
  
  // Fatty protein patterns (thigh, dark meat, organ meats)
  if (lowerName.includes('thigh') || lowerName.includes('dark meat') ||
      lowerName.includes('liver') || lowerName.includes('heart') ||
      lowerName.includes('kidney') || lowerName.includes('giblet')) {
    return { ...CATEGORY_NUTRITION_FALLBACKS.fatty_protein };
  }
  
  // Poultry patterns (general)
  if (lowerName.includes('chicken') || lowerName.includes('turkey') || 
      lowerName.includes('duck') || lowerName.includes('quail') ||
      lowerName.includes('pheasant')) {
    return { ...CATEGORY_NUTRITION_FALLBACKS.poultry };
  }
  
  // Red meat patterns
  if (lowerName.includes('beef') || lowerName.includes('lamb') || 
      lowerName.includes('venison') || lowerName.includes('rabbit') ||
      lowerName.includes('bison') || lowerName.includes('elk') ||
      lowerName.includes('goat')) {
    return { ...CATEGORY_NUTRITION_FALLBACKS.red_meat };
  }
  
  // Fish patterns
  if (lowerName.includes('fish') || lowerName.includes('salmon') || 
      lowerName.includes('sardine') || lowerName.includes('tuna') ||
      lowerName.includes('mackerel') || lowerName.includes('herring') ||
      lowerName.includes('trout') || lowerName.includes('cod')) {
    return { ...CATEGORY_NUTRITION_FALLBACKS.fish };
  }
  
  // Insect patterns
  if (lowerName.includes('mealworm') || lowerName.includes('cricket') || 
      lowerName.includes('insect') || lowerName.includes('waxworm') ||
      lowerName.includes('superworm') || lowerName.includes('roach') ||
      lowerName.includes('locust')) {
    return { ...CATEGORY_NUTRITION_FALLBACKS.insect };
  }
  
  // Leafy green patterns (more specific)
  if (lowerName.includes('spinach') || lowerName.includes('kale') || 
      lowerName.includes('lettuce') || lowerName.includes('arugula') ||
      lowerName.includes('endive') || lowerName.includes('escarole') ||
      lowerName.includes('collard') || lowerName.includes('mustard') ||
      lowerName.includes('turnip') || lowerName.includes('dandelion') ||
      lowerName.includes('watercress') || lowerName.includes('mache') ||
      lowerName.includes('frisee') || lowerName.includes('radicchio') ||
      lowerName.includes('swiss chard') || lowerName.includes('beet green')) {
    return { ...CATEGORY_NUTRITION_FALLBACKS.leafy_green };
  }
  
  // Starchy vegetable patterns
  if (lowerName.includes('potato') || lowerName.includes('sweet potato') || 
      lowerName.includes('yam') || lowerName.includes('butternut') ||
      lowerName.includes('acorn squash') || lowerName.includes('pumpkin') ||
      lowerName.includes('winter squash') || lowerName.includes('kabocha')) {
    return { ...CATEGORY_NUTRITION_FALLBACKS.starchy_veg };
  }
  
  // Other vegetable patterns
  if (lowerName.includes('broccoli') || lowerName.includes('carrot') || 
      lowerName.includes('pea') || lowerName.includes('bean') ||
      lowerName.includes('cabbage') || lowerName.includes('celery') ||
      lowerName.includes('zucchini') || lowerName.includes('pepper') ||
      lowerName.includes('cucumber') || lowerName.includes('bok') ||
      lowerName.includes('radish') || lowerName.includes('asparagus') ||
      lowerName.includes('fennel') || lowerName.includes('leek')) {
    return { ...CATEGORY_NUTRITION_FALLBACKS.vegetable };
  }
  
  // Fruit patterns
  if (lowerName.includes('apple') || lowerName.includes('berry') || 
      lowerName.includes('banana') || lowerName.includes('melon') ||
      lowerName.includes('pear') || lowerName.includes('peach') ||
      lowerName.includes('plum') || lowerName.includes('cherry') ||
      lowerName.includes('grape') || lowerName.includes('mango') ||
      lowerName.includes('papaya') || lowerName.includes('fig')) {
    return { ...CATEGORY_NUTRITION_FALLBACKS.fruit };
  }
  
  // Supplement patterns
  if (lowerName.includes('supplement') || lowerName.includes('powder') || 
      lowerName.includes('vitamin') || lowerName.includes('mineral') ||
      lowerName.includes('calcium') || lowerName.includes('kelp') ||
      lowerName.includes('spirulina') || lowerName.includes('probiotic')) {
    return { ...CATEGORY_NUTRITION_FALLBACKS.supplement };
  }
  
  // Grain patterns
  if (lowerName.includes('rice') || lowerName.includes('oats') || 
      lowerName.includes('barley') || lowerName.includes('wheat') ||
      lowerName.includes('quinoa') || lowerName.includes('buckwheat') ||
      lowerName.includes('millet') || lowerName.includes('corn')) {
    return { ...CATEGORY_NUTRITION_FALLBACKS.grain };
  }
  
  // Seed patterns
  if (lowerName.includes('seed') || lowerName.includes('sunflower') || 
      lowerName.includes('pumpkin') || lowerName.includes('flax') ||
      lowerName.includes('chia') || lowerName.includes('hemp')) {
    return { ...CATEGORY_NUTRITION_FALLBACKS.seed };
  }
  
  // Hay patterns
  if (lowerName.includes('hay') || lowerName.includes('timothy') || 
      lowerName.includes('alfalfa') || lowerName.includes('orchard')) {
    return { ...CATEGORY_NUTRITION_FALLBACKS.hay };
  }
  
  // Default fallback (average of all categories)
  return {
    protein: 12.0,
    fat: 6.0,
    carbs: 6,
    fiber: 1.5,
    moisture: 70,
    calcium: 86,
    phosphorus: 150,
    kcal: 110,
    source: 'estimated_fallback',
    needsReview: true,
  };
}
</file>

<file path="lib/utils/organicCount.ts">
/**
 * Organic Count Utilities
 * 
 * Makes numeric counts feel more natural and less robotic by:
 * - Avoiding perfect multiples of 10/5
 * - Adding subtle variation
 * - Providing contextual messaging
 */

/**
 * Makes a count look more organic by avoiding "perfect" numbers.
 * Uses deterministic variation based on the count itself to ensure stability.
 * 
 * Examples:
 * - 40 ‚Üí 42 or 38 (avoids multiples of 10)
 * - 35 ‚Üí 36 or 34 (sometimes avoids multiples of 5)
 * - Adds subtle variation (¬±2) to make numbers feel less robotic
 * 
 * @param count The base count to make organic
 * @returns An organic-looking count (stable for the same input)
 */
export function makeCountOrganic(count: number): number {
  let organic = count;
  
  // Use count as seed for deterministic "random" variation
  const seed = count * 17 + 23; // Simple hash function
  
  // Don't show "perfect" multiples of 10
  if (count % 10 === 0) {
    // Convert 40 ‚Üí 42, 50 ‚Üí 47, etc. (deterministic based on count)
    organic = count + ((seed % 2 === 0) ? 2 : -3);
  }
  
  // Don't show "perfect" multiples of 5 (sometimes, deterministic)
  if (count % 5 === 0 && (seed % 10) > 2) {
    organic = count + 1;
  }
  
  // Add subtle variation (¬±2) to make numbers feel less robotic (deterministic)
  const variation = ((seed % 5) - 2); // -2 to +2, stable per count
  organic += variation;
  
  // Ensure it doesn't go below 1
  organic = Math.max(1, organic);
  
  // Round to nearest integer
  organic = Math.round(organic);
  
  return organic;
}

/**
 * Gets a contextual message based on the meal count.
 * 
 * @param count The number of meals found
 * @param species The pet species (optional, for personalization)
 * @returns A contextual message string
 */
export function getCountMessage(count: number, species?: string): string {
  if (count > 60) {
    return `Amazing! We found ${count} perfect meals`;
  }
  if (count > 40) {
    return `Great news! We found ${count} excellent meals`;
  }
  if (count > 25) {
    return `We found ${count} great meal options`;
  }
  if (count > 15) {
    return `We found ${count} good meal options`;
  }
  if (count > 5) {
    return `We found ${count} suitable meals`;
  }
  return `We found ${count} meal option${count !== 1 ? 's' : ''}`;
}

/**
 * Gets subtext based on the meal count.
 * 
 * @param count The number of meals found
 * @param species The pet species (optional, for personalization)
 * @returns A subtext string
 */
export function getSubtext(count: number, species?: string): string {
  const speciesName = species || 'pet';
  
  if (count > 50) {
    return `That's a lot of options! Your ${speciesName} is going to love these.`;
  }
  if (count > 30) {
    return `Plenty of variety for your ${speciesName}.`;
  }
  if (count > 15) {
    return `Good selection for your ${speciesName}'s needs.`;
  }
  if (count > 5) {
    return `Curated selection based on your ${speciesName}'s profile.`;
  }
  return `Limited options due to specific dietary requirements.`;
}
</file>

<file path="lib/utils/petPurchaseTracking.ts">
// lib/utils/petPurchaseTracking.ts
// Per-pet purchase tracking (separate from global village purchase tracking)

import { safeGetItem, safeSetItem, safeParseJSON, safeUpdateItem } from './localStorageSafe';
import { logger } from './logger';
import { validateUserId } from './validation';

export interface PetPurchaseRecord {
  ingredientId: string;
  ingredientName?: string;
  recipeId?: string; // Optional: which recipe this purchase was for
  purchaseDate: string; // ISO string
  confirmed: boolean;
  amazonOrderId?: string;
}

const PREFIX = 'pet_purchases_';

/**
 * Get storage key for pet purchases
 */
function getStorageKey(userId: string, petId: string): string {
  return `${PREFIX}${userId}_${petId}`;
}

/**
 * Load purchases for a pet
 */
export function getPetPurchases(userId: string, petId: string): PetPurchaseRecord[] {
  if (!userId || !petId) {
    return [];
  }

  const userIdValidation = validateUserId(userId);
  if (!userIdValidation.valid) {
    logger.warn('Invalid userId in getPetPurchases', { userId, petId });
    return [];
  }

  try {
    const key = getStorageKey(userId, petId);
    const stored = safeGetItem(key);
    
    if (!stored) {
      return [];
    }

    const parsed = safeParseJSON<PetPurchaseRecord[]>(stored, []);
    if (Array.isArray(parsed)) {
      return parsed;
    }

    return [];
  } catch (error) {
    logger.error('Failed to load pet purchases', error as Error, { userId, petId });
    return [];
  }
}

/**
 * Get count of confirmed purchases for a pet
 */
export function getPetPurchaseCount(userId: string, petId: string): number {
  const purchases = getPetPurchases(userId, petId);
  return purchases.filter(p => p.confirmed).length;
}

/**
 * Add a purchase record for a pet
 */
export function addPetPurchase(
  userId: string,
  petId: string,
  ingredientId: string,
  ingredientName?: string,
  recipeId?: string,
  amazonOrderId?: string
): PetPurchaseRecord[] {
  if (!userId || !petId || !ingredientId) {
    logger.warn('Missing required parameters in addPetPurchase', { userId, petId, ingredientId });
    return getPetPurchases(userId, petId);
  }

  const userIdValidation = validateUserId(userId);
  if (!userIdValidation.valid) {
    logger.warn('Invalid userId in addPetPurchase', { userId, petId });
    return getPetPurchases(userId, petId);
  }

  const key = getStorageKey(userId, petId);
  const result = safeUpdateItem<PetPurchaseRecord[]>(key, (records) => {
    const currentRecords = records || [];
    
    // Check if purchase already exists (avoid duplicates)
    const exists = currentRecords.some(
      r => r.ingredientId === ingredientId && r.confirmed
    );
    
    if (exists) {
      return currentRecords; // Already exists
    }

    // Add new purchase record
    const newRecord: PetPurchaseRecord = {
      ingredientId,
      ingredientName,
      recipeId,
      purchaseDate: new Date().toISOString(),
      confirmed: false,
      ...(amazonOrderId && { amazonOrderId }),
    };

    return [...currentRecords, newRecord];
  });

  if (!result.success) {
    logger.error('Failed to add pet purchase', undefined, { userId, petId, ingredientId, error: result.error });
    return getPetPurchases(userId, petId);
  }

  return result.data || [];
}

/**
 * Confirm a purchase for a pet
 */
export function confirmPetPurchase(
  userId: string,
  petId: string,
  ingredientId: string,
  ingredientName?: string,
  recipeId?: string,
  amazonOrderId?: string
): { success: boolean; error?: string } {
  if (!userId || !petId || !ingredientId) {
    return { success: false, error: 'Missing required parameters' };
  }

  const userIdValidation = validateUserId(userId);
  if (!userIdValidation.valid) {
    return { success: false, error: userIdValidation.error };
  }

  const key = getStorageKey(userId, petId);
  const result = safeUpdateItem<PetPurchaseRecord[]>(key, (records) => {
    const currentRecords = records || [];
    
    // Find existing unconfirmed record
    const existingIndex = currentRecords.findIndex(
      r => r.ingredientId === ingredientId && !r.confirmed
    );

    if (existingIndex >= 0) {
      // Update existing record
      const updated = [...currentRecords];
      updated[existingIndex] = {
        ...updated[existingIndex],
        ingredientName: ingredientName || updated[existingIndex].ingredientName,
        recipeId: recipeId || updated[existingIndex].recipeId,
        confirmed: true,
        purchaseDate: new Date().toISOString(),
        ...(amazonOrderId && { amazonOrderId }),
      };
      return updated;
    }

    // Add new confirmed record
    return [
      ...currentRecords,
      {
        ingredientId,
        ingredientName,
        recipeId,
        purchaseDate: new Date().toISOString(),
        confirmed: true,
        ...(amazonOrderId && { amazonOrderId }),
      },
    ];
  });

  if (!result.success) {
    logger.error('Failed to confirm pet purchase', undefined, { userId, petId, ingredientId, error: result.error });
    return { success: false, error: result.error };
  }

  return { success: true };
}
</file>

<file path="lib/utils/petRatingSystem.ts">
// lib/utils/petRatingSystem.ts
import type { Recipe as BaseRecipe } from '@/lib/types';
import { INGREDIENT_COMPOSITIONS, getIngredientComposition } from '@/lib/data/ingredientCompositions';
import { AVIAN_NUTRITION_STANDARDS, getAvianStandards } from '@/lib/data/avian-nutrition-standards';
import { AAFCO_NUTRIENT_PROFILES, getAAFCOStandards, validateCriticalNutrients } from '@/lib/data/aafco-standards';
import { REPTILE_NUTRITION_STANDARDS, getReptileStandards, validateReptileNutrition } from '@/lib/data/reptile-nutrition';
import { BALANCEIT_ANALYSIS } from '@/lib/competitors/balanceit-analysis';

export interface Pet {
  id: string;
  name: string;
  type: 'dog' | 'cat' | 'bird' | 'reptile' | 'pocket-pet';
  breed: string;
  age: number;
  weight?: number;
  activityLevel?: 'sedentary' | 'moderate' | 'active' | 'very-active';
  healthConcerns: string[];
  dietaryRestrictions: string[];
  allergies?: string[];
  dislikes?: string[];
  savedRecipes?: string[];
  names?: string[];
  weightKg?: number;
}

// Helper to detect if data is just the auto-generated placeholder
function isGenericNutrition(n: any): boolean {
  if (!n) return true;
  // Checks for the specific ranges found in your recipes-complete.ts
  return n.protein?.min === 25 && n.fat?.min === 10 && n.fiber?.min === 2;
}

function extractNutrition(recipe: any): {
  protein: number;
  fat: number;
  fiber: number;
  calories: number;
  phosphorus: number;
  isGeneric: boolean;
} | null {
  // Check for nutritionalInfo object
  if (recipe.nutritionalInfo) {
    const isGeneric = isGenericNutrition(recipe.nutritionalInfo);
    return {
      protein: recipe.nutritionalInfo.protein?.min || 0,
      fat: recipe.nutritionalInfo.fat?.min || 0,
      fiber: recipe.nutritionalInfo.fiber?.min || 0,
      calories: recipe.nutritionalInfo.calories?.min || 0,
      phosphorus: recipe.nutritionalInfo.phosphorus?.min || 0,
      isGeneric
    };
  }
  return null;
}

function enrichRecipeFromIngredients(recipe: any): {
  estimatedProtein: number;
  estimatedFat: number;
  estimatedPhosphorus: 'low' | 'moderate' | 'high';
  healthBenefits: string[];
  allergens: string[];
} {
  const name = recipe.name?.toLowerCase() || '';
  const ingredients = recipe.ingredients
    ?.map((i: any) => (typeof i === 'string' ? i : i.name).toLowerCase())
    .join(' ') || '';

  const allText = `${name} ${ingredients}`;

  // Create variation based on protein source
  let estimatedProtein = 25;
  if (allText.includes('venison')) estimatedProtein = 34; // Leaner, high protein
  else if (allText.includes('rabbit')) estimatedProtein = 33;
  else if (allText.includes('salmon') || allText.includes('fish')) estimatedProtein = 32;
  else if (allText.includes('chicken')) estimatedProtein = 30;
  else if (allText.includes('turkey')) estimatedProtein = 29;
  else if (allText.includes('beef')) estimatedProtein = 28;
  else if (allText.includes('pork')) estimatedProtein = 27;

  // Fat estimation
  let estimatedFat = 15;
  if (allText.includes('salmon') || allText.includes('duck')) estimatedFat = 18;
  else if (allText.includes('lean') || allText.includes('turkey')) estimatedFat = 10;
  else if (allText.includes('pork') || allText.includes('lamb')) estimatedFat = 16;

  // Phosphorus estimation
  let estimatedPhosphorus: 'low' | 'moderate' | 'high' = 'moderate';
  if (allText.includes('liver') || allText.includes('kidney') || allText.includes('organ')) {
    estimatedPhosphorus = 'high';
  } else if (allText.includes('egg whites') || allText.includes('rice')) {
    estimatedPhosphorus = 'low';
  }

  // Auto-detect Health benefits if tags are missing
  const healthBenefits: string[] = [];
  if (allText.includes('salmon') || allText.includes('fish oil') || allText.includes('flaxseed')) {
    healthBenefits.push('joint-health', 'skin-conditions');
  }
  if (allText.includes('pumpkin') || allText.includes('rice')) {
    healthBenefits.push('digestive-issues');
  }
  if (allText.includes('lean') || allText.includes('turkey') || allText.includes('white fish')) {
    healthBenefits.push('weight-management', 'pancreatitis');
  }
  if (allText.includes('liver') || allText.includes('organ')) {
    // Often good for general vitality but bad for kidney
    healthBenefits.push('recovery');
  }

  // Allergens
  const allergens: string[] = [];
  if (allText.includes('chicken')) allergens.push('chicken');
  if (allText.includes('beef')) allergens.push('beef');
  if (allText.includes('dairy') || allText.includes('milk')) allergens.push('dairy');
  if (allText.includes('wheat') || allText.includes('grain')) allergens.push('grain');
  if (allText.includes('egg')) allergens.push('egg');

  return {
    estimatedProtein,
    estimatedFat,
    estimatedPhosphorus,
    healthBenefits,
    allergens
  };
}

// Enhanced nutrition calculation using real USDA data
function calculateRecipeNutrition(recipe: any): {
  protein: number;
  fat: number;
  calcium: number;
  phosphorus: number;
  calories: number;
  omega3?: number;
  vitaminA?: number;
  vitaminC?: number;
  source: 'real' | 'estimated';
} {
  const ingredients = recipe.ingredients || [];
  let totalProtein = 0;
  let totalFat = 0;
  let totalCalcium = 0;
  let totalPhosphorus = 0;
  let totalCalories = 0;
  let totalOmega3 = 0;
  let totalVitaminA = 0;
  let totalVitaminC = 0;
  let totalWeight = 0;

  // Try to get real nutritional data
  for (const ingredient of ingredients) {
    const name = typeof ingredient === 'string' ? ingredient : ingredient.name;
    const amount = typeof ingredient === 'string' ? 100 : (ingredient.amount || 100); // Assume 100g if not specified

    const composition = getIngredientComposition(name);
    if (composition) {
      totalProtein += (composition.protein || 0) * (amount / 100);
      totalFat += (composition.fat || 0) * (amount / 100);
      totalCalcium += (composition.calcium || 0) * (amount / 100);
      totalPhosphorus += (composition.phosphorus || 0) * (amount / 100);
      totalCalories += (composition.kcal || 0) * (amount / 100);
      totalOmega3 += (composition.omega3 || 0) * (amount / 100);
      totalVitaminA += (composition.vitaminA || 0) * (amount / 100);
      totalVitaminC += (composition.vitaminC || 0) * (amount / 100);
      totalWeight += amount;
    }
  }

  // If we have real data for at least 50% of ingredients, use it
  const realDataRatio = totalWeight / (ingredients.length * 100);
  if (realDataRatio >= 0.5) {
    return {
      protein: totalProtein / totalWeight * 100,
      fat: totalFat / totalWeight * 100,
      calcium: totalCalcium / totalWeight * 100,
      phosphorus: totalPhosphorus / totalWeight * 100,
      calories: totalCalories / totalWeight * 100,
      omega3: totalOmega3 > 0 ? totalOmega3 / totalWeight * 100 : undefined,
      vitaminA: totalVitaminA > 0 ? totalVitaminA / totalWeight * 100 : undefined,
      vitaminC: totalVitaminC > 0 ? totalVitaminC / totalWeight * 100 : undefined,
      source: 'real'
    };
  }

  // Fall back to estimated values
  const enriched = enrichRecipeFromIngredients(recipe);
  return {
    protein: enriched.estimatedProtein,
    fat: enriched.estimatedFat,
    calcium: 0.8, // Estimated
    phosphorus: enriched.estimatedPhosphorus === 'high' ? 0.8 : enriched.estimatedPhosphorus === 'low' ? 0.3 : 0.5,
    calories: 150, // Estimated
    source: 'estimated'
  };
}

// Species-specific compatibility scoring
function calculateAvianCompatibility(recipe: any, pet: Pet): number {
  const standards = getAvianStandards(pet.breed) || AVIAN_NUTRITION_STANDARDS.psittacines;
  const nutrition = calculateRecipeNutrition(recipe);

  let score = 100;

  // Check Ca:P ratio (most critical for birds)
  const caPRatio = nutrition.calcium / nutrition.phosphorus;
  const caPMin = standards.CaP_ratio?.min || 1.5;
  const caPMax = standards.CaP_ratio?.max || 2.5;
  const caPIdeal = (standards.CaP_ratio as any)?.ideal || 2.0;

  if (caPRatio < caPMin || caPRatio > caPMax) {
    score -= 40; // Major penalty for improper ratio
  } else if (Math.abs(caPRatio - caPIdeal) < 0.5) {
    score += 10; // Bonus for ideal ratio
  }

  // Check protein levels
  const proteinMin = standards.protein?.min || 12;
  const proteinMax = standards.protein?.max || 18;
  if (nutrition.protein < proteinMin || nutrition.protein > proteinMax) {
    score -= 20;
  }

  // Check fat levels
  const fatMin = standards.fat?.min || 4;
  const fatMax = standards.fat?.max || 10;
  if (nutrition.fat < fatMin || nutrition.fat > fatMax) {
    score -= 15;
  }

  return Math.max(0, Math.min(100, score));
}

function calculateReptileCompatibility(recipe: any, pet: Pet): number {
  const standards = getReptileStandards(pet.breed);
  if (!standards) return 75; // Default score if species not found

  const nutrition = calculateRecipeNutrition(recipe);
  let score = 100;

  // Check Ca:P ratio (critical for reptiles)
  const caPRatio = nutrition.calcium / nutrition.phosphorus;
  if (caPRatio < standards.CaP_ratio.min || caPRatio > standards.CaP_ratio.max) {
    score -= 50; // Severe penalty for improper ratio
  } else if (Math.abs(caPRatio - standards.CaP_ratio.ideal) < 0.5) {
    score += 15; // Bonus for ideal ratio
  }

  // Check calcium levels
  if (nutrition.calcium < standards.calcium.min) {
    score -= 30;
  }

  // Check protein levels
  if (nutrition.protein < standards.protein.min || nutrition.protein > standards.protein.max) {
    score -= 20;
  }

  return Math.max(0, Math.min(100, score));
}

function calculateSpeciesSpecificScore(recipe: any, pet: Pet): number {
  switch (pet.type) {
    case 'bird':
      return calculateAvianCompatibility(recipe, pet);
    case 'reptile':
      return calculateReptileCompatibility(recipe, pet);
    case 'dog':
    case 'cat':
      // Use AAFCO validation for mammals
      const lifeStage = pet.age < 1 ? 'growth' : 'adult';
      const validation = validateCriticalNutrients(recipe, pet.type as 'dog' | 'cat', lifeStage);
      return validation.isValid ? 95 : Math.max(60, 95 - (validation.violations.length * 15));
    default:
      return 85; // Default score for pocket pets
  }
}

interface RatingFactor {
  score: number;
  weight: number;
  reason: string;
}

export interface CompatibilityRating {
  overallScore: number;
  compatibility: 'excellent' | 'good' | 'fair' | 'poor';
  breakdown: Record<string, RatingFactor>;
  warnings: string[];
  strengths: string[];
  recommendations: string[];
}

// Helper to normalize health concern keys
function normalizeHealthConcernKey(concern: string): string {
  const normalized = concern.toLowerCase().trim()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-|-$/g, '');
  
  // Map variations to standard keys
  const mapping: Record<string, string> = {
    'pancreatitis': 'pancreatitis',
    'pancreatic': 'pancreatitis',
    'heart-disease': 'heart-disease',
    'heart disease': 'heart-disease',
    'heart': 'heart-disease',
    'diabetes': 'diabetes',
    'diabetic': 'diabetes',
    'skin-conditions': 'skin-conditions',
    'skin conditions': 'skin-conditions',
    'skin condition': 'skin-conditions',
    'skin-coat': 'skin-conditions',
    'allergies': 'allergies',
    'allergy': 'allergies',
    'skin-issues': 'allergies',
    'skin issues': 'allergies',
    'kidney-disease': 'kidney-disease',
    'kidney disease': 'kidney-disease',
    'kidney': 'kidney-disease',
    'digestive-issues': 'digestive-issues',
    'digestive issues': 'digestive-issues',
    'digestive': 'digestive-issues',
    'joint-health': 'joint-health',
    'joint health': 'joint-health',
    'arthritis': 'joint-health',
    'joint pain': 'joint-health',
    'weight-management': 'weight-management',
    'weight management': 'weight-management',
    'obesity': 'weight-management',
    'dental-issues': 'dental-issues',
    'dental issues': 'dental-issues',
    'dental': 'dental-issues'
  };
  
  return mapping[normalized] || normalized;
}

const HEALTH_CONCERNS: Record<string, { maxPhosphorus?: number; maxFat?: number; maxProtein?: number; minProtein?: number; restrictions: string[]; requires?: string[] }> = {
  'kidney-disease': { maxPhosphorus: 200, restrictions: ['liver', 'kidney', 'organ'], requires: ['low-phosphorus', 'high-quality-protein'] },
  'pancreatitis': { maxFat: 12, restrictions: ['high-fat', 'pork', 'lamb', 'duck', 'fried', 'greasy'], requires: ['low-fat', 'easily-digestible'] },
  'obesity': { maxFat: 12, maxProtein: 30, restrictions: ['high-calorie', 'treats'], requires: ['low-calorie', 'high-fiber'] },
  'digestive-issues': { restrictions: ['spicy', 'raw', 'high-fiber', 'dairy'], requires: ['easily-digestible', 'bland'] },
  'allergies': { restrictions: ['chicken', 'beef', 'dairy', 'wheat', 'corn', 'soy', 'eggs'], requires: ['novel-protein', 'hypoallergenic'] },
  'joint-health': { restrictions: [], requires: ['omega-3', 'glucosamine', 'chondroitin'] },
  'skin-conditions': { restrictions: ['artificial-colors', 'preservatives'], requires: ['omega-3', 'quality-protein', 'vitamin-e'] },
  'heart-disease': { maxFat: 15, restrictions: ['high-sodium', 'processed'], requires: ['taurine', 'omega-3', 'low-sodium'] },
  'diabetes': { maxFat: 15, restrictions: ['high-sugar', 'simple-carbs', 'corn-syrup'], requires: ['complex-carbs', 'high-fiber', 'low-glycemic'] }
};

/**
 * Calculates compatibility rating between a recipe and a pet profile.
 * 
 * @param recipe - Recipe object from recipes-complete.ts
 * @param pet - Pet profile with type, age, weight, health concerns, etc.
 * @returns CompatibilityRating with overall score (0-100), breakdown, warnings, and recommendations
 * 
 * @example
 * ```ts
 * const rating = rateRecipeForPet(recipe, pet);
 * console.log(rating.overallScore); // 85
 * console.log(rating.compatibility); // 'excellent'
 * ```
 * 
 * @contract
 * - Input: Recipe from lib/data/recipes-complete.ts, Pet from localStorage/backend
 * - Output: CompatibilityRating with standardized structure
 * - Side effects: None (pure function)
 * - Migration: Compatible with Firebase/Supabase (receives Pet object, not storage)
 */
export function rateRecipeForPet(recipe: any, pet: Pet): CompatibilityRating {
  // Normalize array-like fields to avoid runtime errors
  const safePet: Pet = {
    ...pet,
    dietaryRestrictions: Array.isArray((pet as any).dietaryRestrictions) ? (pet as any).dietaryRestrictions : [],
    allergies: Array.isArray(pet.allergies) ? pet.allergies : [],
    healthConcerns: Array.isArray(pet.healthConcerns) ? pet.healthConcerns : [],
    dislikes: Array.isArray((pet as any).dislikes) ? (pet as any).dislikes : [],
  };

  const warnings: string[] = [];
  const strengths: string[] = [];
  const recommendations: string[] = [];

  const nutrition = extractNutrition(recipe);
  const enriched = enrichRecipeFromIngredients(recipe);
  const realNutrition = calculateRecipeNutrition(recipe);

  // 1. Pet Type Match (20%)
  const petTypeMatch = (recipe.category === safePet.type || recipe.category === `${safePet.type}s`) ? 100 : 0;

  // 2. Age Appropriate (15%)
  const petAgeGroup = safePet.age < 1 ? 'baby' : safePet.age < 2 ? 'young' : safePet.age < 7 ? 'adult' : 'senior';
  const ageMatch = (recipe.ageGroup || []).includes(petAgeGroup) || (recipe.ageGroup || []).includes('all');
  const ageScore = ageMatch ? 100 : 70;

  // 3. Species-Specific Nutritional Fit (30%)
  const speciesScore = calculateSpeciesSpecificScore(recipe, safePet);

  // 4. Health Compatibility (25%)
  // Fix: Start at 100 for pets with no health concerns, not 90
  let healthScore = safePet.healthConcerns.length === 0 ? 100 : 90;

  // Use recipe tags if available, otherwise fallback to ingredient inference
  const effectiveHealthTags = (recipe.healthConcerns && recipe.healthConcerns.length > 0)
    ? recipe.healthConcerns
    : enriched.healthBenefits;

  if (safePet.healthConcerns.length > 0) {
    healthScore = 70; // Start lower

    for (const concern of safePet.healthConcerns) {
      // Bonus for matching benefits
      if (effectiveHealthTags.some((tag: string) => tag.includes(concern) || concern.includes(tag))) {
        healthScore += 20;
        strengths.push(`Great for ${concern}`);
      }

      // Penalties for contradictions
      const normalizedConcern = normalizeHealthConcernKey(concern);
      const rules = HEALTH_CONCERNS[normalizedConcern];
      if (rules) {
        // Check Fat cap
        const fatVal = (nutrition && !nutrition.isGeneric) ? nutrition.fat : enriched.estimatedFat;
        if (rules.maxFat && fatVal > rules.maxFat) {
          healthScore -= 25;
          warnings.push(`Fat content slightly high for ${concern}`);
        }

        // Check ingredient restrictions
        const hasRestricted = rules.restrictions.some(r => enriched.allergens.includes(r));
        if (hasRestricted) {
           healthScore -= 30;
        }
      }
    }
  }

  // 5. Allergen Safety (10%)
  let allergenScore = 100;
  const allRestrictions = [...(safePet.dietaryRestrictions || []), ...(safePet.healthConcerns?.includes('allergies') ? safePet.allergies || [] : [])];

  for (const restriction of allRestrictions) {
    const rLower = restriction.toLowerCase();
    // Check against inferred allergens from ingredients
    if (enriched.allergens.some(a => rLower.includes(a) || a.includes(rLower))) {
      allergenScore = 0;
      warnings.push(`Contains ${restriction}`);
    }
  }

  // 6. Picky Eater Check (5% penalty for disliked ingredients)
  let pickyEaterPenalty = 0;
  if (pet.dislikes && pet.dislikes.length > 0) {
    for (const dislike of pet.dislikes) {
      const dLower = dislike.toLowerCase();
      // Check if recipe contains disliked ingredients
      if (enriched.allergens.some(a => dLower.includes(a) || a.includes(dLower))) {
        pickyEaterPenalty = 5; // Small penalty
        warnings.push(`Contains ${dislike} (pet may not like)`);
        break; // Only penalize once
      }
    }
  }

  // Calculate Overall
  const overallScore = Math.max(0, Math.min(100, Math.round(
    (petTypeMatch * 0.20) +
    (ageScore * 0.15) +
    (speciesScore * 0.30) +
    (healthScore * 0.25) +
    (allergenScore * 0.10)
  ) - pickyEaterPenalty));

  let compatibility: 'excellent' | 'good' | 'fair' | 'poor';
  if (overallScore >= 85) compatibility = 'excellent';
  else if (overallScore >= 70) compatibility = 'good';
  else if (overallScore >= 50) compatibility = 'fair';
  else compatibility = 'poor';

  return {
    overallScore,
    compatibility,
    breakdown: {
      petTypeMatch: {
        score: petTypeMatch,
        weight: 25,
        reason: petTypeMatch === 100
          ? `Recipe is specifically designed for ${pet.type}s`
          : `Recipe is designed for ${recipe.category}, but your pet is a ${pet.type}`
      },
      ageAppropriate: {
        score: ageScore,
        weight: 15,
        reason: ageMatch
          ? `Recipe is suitable for ${petAgeGroup} ${pet.type}s`
          : `Recipe is designed for ${recipe.ageGroup?.join(', ') || 'different age groups'}, but your pet is ${petAgeGroup}`
      },
      nutritionalFit: {
        score: speciesScore,
        weight: 30,
        reason: realNutrition.source === 'real'
          ? `Recipe uses real USDA nutritional data and meets ${pet.type} nutritional standards`
          : `Recipe meets estimated nutritional requirements for ${pet.type}s`
      },
      healthCompatibility: {
        score: healthScore,
        weight: 25,
        reason: pet.healthConcerns.length === 0
          ? 'No specific health concerns to evaluate'
          : `${effectiveHealthTags.length > 0 ? 'Recipe contains ingredients beneficial for' : 'Recipe may not address'} your pet's health concerns: ${pet.healthConcerns.join(', ')}`
      },
      allergenSafety: {
        score: allergenScore,
        weight: 10,
        reason: allRestrictions.length === 0
          ? 'No dietary restrictions or allergies specified'
          : allergenScore === 100
            ? 'Recipe avoids all known allergens and restrictions'
            : `Recipe contains ingredients that may conflict with restrictions: ${allRestrictions.join(', ')}`
      }
    },
    warnings,
    strengths,
    recommendations
  };
}

// Utility functions for pet profile management
export function savePetProfile(pet: Pet): void {
  if (typeof window === 'undefined') return;

  const pets = getUserPets();
  const existingIndex = pets.findIndex(p => p.id === pet.id);

  if (existingIndex >= 0) {
    pets[existingIndex] = pet;
  } else {
    pets.push(pet);
  }

  localStorage.setItem('userPets', JSON.stringify(pets));
}

export function getUserPets(): Pet[] {
  if (typeof window === 'undefined') return [];

  const stored = localStorage.getItem('userPets');
  return stored ? JSON.parse(stored) : [];
}

export function deletePetProfile(petId: string): void {
  if (typeof window === 'undefined') return;

  const pets = getUserPets().filter(p => p.id !== petId);
  localStorage.setItem('userPets', JSON.stringify(pets));
}

export const healthConcernOptions = [
  { value: 'kidney-disease', label: 'Kidney Disease' },
  { value: 'heart-disease', label: 'Heart Disease' },
  { value: 'diabetes', label: 'Diabetes' },
  { value: 'allergies', label: 'Food Allergies' },
  { value: 'obesity', label: 'Weight Management/Obesity' },
  { value: 'pancreatitis', label: 'Pancreatitis' },
  { value: 'digestive-issues', label: 'Digestive Issues' },
  { value: 'joint-health', label: 'Joint Problems/Arthritis' },
  { value: 'dental-issues', label: 'Dental Issues' },
  { value: 'hip-dysplasia', label: 'Hip Dysplasia' },
  { value: 'skin-conditions', label: 'Skin Conditions' }
];

export const dietaryRestrictionOptions = [
  { value: 'grain-free', label: 'Grain-Free' },
  { value: 'no-chicken', label: 'No Chicken' },
  { value: 'no-beef', label: 'No Beef' },
  { value: 'no-dairy', label: 'No Dairy' },
  { value: 'low-sodium', label: 'Low Sodium' },
  { value: 'low-phosphorus', label: 'Low Phosphorus' },
  { value: 'low-fat', label: 'Low Fat' },
  { value: 'soft-food', label: 'Soft Food Only' },
  { value: 'hypoallergenic', label: 'Hypoallergenic' }
];

export const activityLevels = [
  {
    value: 'sedentary' as const,
    label: 'Sedentary',
    description: 'Mostly inactive, minimal exercise'
  },
  {
    value: 'moderate' as const,
    label: 'Moderate',
    description: 'Regular walks, some playtime'
  },
  {
    value: 'active' as const,
    label: 'Active',
    description: 'Daily exercise, lots of playtime'
  },
  {
    value: 'very-active' as const,
    label: 'Very Active',
    description: 'Working dog, intensive daily exercise'
  }
];
</file>

<file path="lib/utils/petStorage.ts">
// lib/utils/petStorage.ts
// Abstracted pet storage layer - Migrated to Firestore
// Note: All operations are now ASYNCHRONOUS

import { Pet } from '@/lib/types'; // Updated import to use shared type
import * as firestoreService from '@/lib/services/firestoreService';

/**
 * Retrieves all pets for a given user.
 * 
 * @param userId - User identifier
 * @returns Promise<Pet[]>
 */
export async function getPets(userId: string): Promise<Pet[]> {
  if (!userId) return [];
  
  // TEMPORARY: Skip Firestore entirely if no Firebase config
  const hasFirebase = typeof process !== 'undefined' && process.env?.NEXT_PUBLIC_FIREBASE_API_KEY;
  if (!hasFirebase) {
    console.log('Firebase not configured - using localStorage only');
    if (typeof window !== 'undefined') {
      const stored = localStorage.getItem(`pets_${userId}`);
      if (stored) {
        try {
          return JSON.parse(stored);
        } catch {
          return [];
        }
      }
    }
    return [];
  }
  
  // Try Firestore first
  try {
    const pets = await firestoreService.getPets(userId);
    if (pets.length > 0) return pets;
    
    // Auto-migration: If Firestore is empty but localStorage has data, upload it
    if (typeof window !== 'undefined') {
      const stored = localStorage.getItem(`pets_${userId}`);
      if (stored) {
        try {
          const localPets: Pet[] = JSON.parse(stored);
          if (localPets.length > 0) {
            console.log('Migrating local pets to Firestore...');
            // Upload all local pets
            await Promise.all(localPets.map(p => firestoreService.savePet(userId, p)));
            return localPets;
          }
        } catch (e) {
          console.error('Migration failed:', e);
        }
      }
    }
  } catch (e) {
    console.warn('Firestore getPets failed, falling back to localStorage if available', e);
  }

  // Fallback to localStorage for smooth migration/offline (optional)
  if (typeof window !== 'undefined') {
    const stored = localStorage.getItem(`pets_${userId}`);
    if (stored) {
      try {
        return JSON.parse(stored);
      } catch {
        return [];
      }
    }
  }
  return [];
}

/**
 * Saves a pet to storage.
 * 
 * @param userId - User identifier
 * @param pet - Pet object to save
 * @returns Promise<void>
 */
export async function savePet(userId: string, pet: Pet): Promise<void> {
  if (!userId) return;
  
  // TEMPORARY: Skip Firestore entirely if no Firebase config
  const hasFirebase = typeof process !== 'undefined' && process.env?.NEXT_PUBLIC_FIREBASE_API_KEY;
  if (!hasFirebase) {
    console.log('Firebase not configured - saving to localStorage only');
    if (typeof window !== 'undefined') {
      const stored = localStorage.getItem(`pets_${userId}`);
      let localPets: Pet[] = [];
      try {
        localPets = stored ? JSON.parse(stored) : [];
      } catch {
        localPets = [];
      }
      // Update or add the pet
      const index = localPets.findIndex(p => p.id === pet.id);
      if (index >= 0) {
        localPets[index] = pet;
      } else {
        localPets.push(pet);
      }
      localStorage.setItem(`pets_${userId}`, JSON.stringify(localPets));
      
      // Dispatch custom event for same-tab updates
      if (typeof window !== 'undefined') {
        window.dispatchEvent(new CustomEvent('petsUpdated', { detail: { userId, petId: pet.id } }));
      }
    }
    return;
  }
  
  // Save to Firestore
  await firestoreService.savePet(userId, pet);
  
  // Also sync to localStorage for backup/offline compatibility
  if (typeof window !== 'undefined') {
    const pets = await getPets(userId); // Recalculate or just append?
    // Optimization: Just update local array without refetching if possible, but simplest is to fetch-update-save logic
    // Let's mimic old sync logic for localStorage mirror
    const stored = localStorage.getItem(`pets_${userId}`);
    let localPets: Pet[] = stored ? JSON.parse(stored) : [];
    
    const index = localPets.findIndex(p => p.id === pet.id);
    if (index >= 0) {
      localPets[index] = pet;
    } else {
      localPets.push(pet);
    }
    localStorage.setItem(`pets_${userId}`, JSON.stringify(localPets));
    
    // Dispatch custom event for same-tab updates
    window.dispatchEvent(new CustomEvent('petsUpdated', { detail: { userId, petId: pet.id } }));
  }
}

/**
 * Deletes a pet from storage.
 * 
 * @param userId - User identifier
 * @param petId - Pet ID to delete
 * @returns Promise<void>
 */
export async function deletePet(userId: string, petId: string): Promise<void> {
  if (!userId) return;
  
  // TEMPORARY: Skip Firestore entirely if no Firebase config
  const hasFirebase = typeof process !== 'undefined' && process.env?.NEXT_PUBLIC_FIREBASE_API_KEY;
  if (!hasFirebase) {
    console.log('Firebase not configured - deleting from localStorage only');
    if (typeof window !== 'undefined') {
      const stored = localStorage.getItem(`pets_${userId}`);
      if (stored) {
        try {
          const pets: Pet[] = JSON.parse(stored);
          const filtered = pets.filter(p => p.id !== petId);
          localStorage.setItem(`pets_${userId}`, JSON.stringify(filtered));
        } catch (e) {
          console.error('Error deleting pet from localStorage:', e);
        }
      }
    }
    return;
  }
  
  await firestoreService.deletePet(userId, petId);
  
  // Sync localStorage
  if (typeof window !== 'undefined') {
    const stored = localStorage.getItem(`pets_${userId}`);
    if (stored) {
      const pets: Pet[] = JSON.parse(stored);
      const filtered = pets.filter(p => p.id !== petId);
      localStorage.setItem(`pets_${userId}`, JSON.stringify(filtered));
    }
  }
}

/**
 * Gets a single pet by ID.
 * 
 * @param userId - User identifier
 * @param petId - Pet ID to retrieve
 * @returns Promise<Pet | null>
 */
export async function getPet(userId: string, petId: string): Promise<Pet | null> {
  const pets = await getPets(userId);
  return pets.find(p => p.id === petId) || null;
}
</file>

<file path="lib/utils/petUtils.ts">
// Utility functions for pet management
import type { Pet } from '../types';
export type { Pet } from '../types';

/**
 * Get a random name from the pet's names array
 * Falls back to the first name if array is empty
 */
export function getRandomName(names: string[]): string {
  if (!names || names.length === 0) {
    return 'Unnamed Pet';
  }
  const randomIndex = Math.floor(Math.random() * names.length);
  return names[randomIndex];
}

/**
 * Get the primary name (first in the array)
 */
export function getPrimaryName(names: string[]): string {
  if (!names || names.length === 0) {
    return 'Unnamed Pet';
  }
  return names[0];
}

/**
 * Format names for display (e.g., "Buddy, Max, Charlie")
 */
export function formatNames(names: string[]): string {
  if (!names || names.length === 0) {
    return 'Unnamed Pet';
  }
  if (names.length === 1) {
    return names[0];
  }
  return names.join(', ');
}
</file>

<file path="lib/utils/priceValidation.ts">
/**
 * Price validation utilities for vetted products
 * Prevents outlier prices from scraping errors (e.g., third-party sellers with inflated prices)
 */

export type ProductCategory = 'Meat' | 'Supplement' | 'Carb' | 'Vegetable' | 'Oil' | 'Seed' | 'Fruit' | 'Insect' | 'Hay' | 'Pellet';

/**
 * Maximum reasonable prices per category (USD)
 * These are conservative limits to catch obvious errors from third-party sellers
 */
const MAX_REASONABLE_PRICES: Record<ProductCategory, number> = {
  Vegetable: 15,      // Bulk vegetables, but $124 for collard greens is clearly wrong
  Meat: 80,           // Bulk frozen meat can be expensive
  Carb: 75,           // Bulk grains/potatoes
  Oil: 40,            // Cooking oils and supplements
  Supplement: 100,    // Supplements can be expensive but have limits
  Fruit: 30,          // Fresh fruits
  Seed: 50,           // Seeds and nuts
  Insect: 50,         // Dried insects for pets
  Hay: 50,            // Hay bales
  Pellet: 80,         // Pellet food
};

/**
 * Check if a price is reasonable for the given category
 */
export function isPriceReasonable(price: number, category?: ProductCategory | string): boolean {
  if (!category) return true; // No category = no validation
  
  const normalizedCategory = category as ProductCategory;
  if (!(normalizedCategory in MAX_REASONABLE_PRICES)) {
    // Unknown category, allow it (might be a new category)
    return true;
  }
  
  const maxPrice = MAX_REASONABLE_PRICES[normalizedCategory];
  return price <= maxPrice;
}

/**
 * Get the maximum reasonable price for a category
 */
export function getMaxReasonablePrice(category?: ProductCategory | string): number | null {
  if (!category) return null;
  
  const normalizedCategory = category as ProductCategory;
  return MAX_REASONABLE_PRICES[normalizedCategory] || null;
}

/**
 * Validate and optionally cap a price
 * Returns the original price if valid, or null if it exceeds the max
 */
export function validatePrice(
  price: number,
  category?: ProductCategory | string
): number | null {
  if (isPriceReasonable(price, category)) {
    return price;
  }
  
  // Price exceeds reasonable limit - return null to mark as invalid/unavailable
  return null;
}
</file>

<file path="lib/utils/purchaseLinks.ts">
import { ensureSellerId, isValidAmazonUrl } from '@/lib/utils/affiliateLinks';
import { getProductPriceUrl } from '@/lib/data/product-prices';

export function buildAmazonSearchUrl(query: string): string {
  const q = String(query || '').trim();
  if (!q) return '';
  return `https://www.amazon.com/s?k=${encodeURIComponent(q)}`;
}

export function getIngredientPurchaseUrl(
  ingredientName: string,
  existingUrl?: string | null,
  species?: string
): string {
  const baseName = String(ingredientName || '').trim();

  const pricedUrl = getProductPriceUrl(baseName);
  if (pricedUrl) return ensureSellerId(pricedUrl);

  const candidate = String(existingUrl || '').trim();
  if (candidate && isValidAmazonUrl(candidate)) return ensureSellerId(candidate);

  const searchUrl = buildAmazonSearchUrl(baseName);
  return searchUrl ? ensureSellerId(searchUrl) : '';
}
</file>

<file path="lib/utils/purchaseTracking.ts">
/**
 * Purchase Tracking System
 * Tracks cumulative ingredient purchases across all pets for village evolution
 * 
 * Combines:
 * - Simple API from guide (loadPurchases, addPurchase, etc.)
 * - Transaction safety from our implementation (prevents race conditions)
 * - Robust error handling and validation
 */

import { safeGetItem, safeSetItem, safeParseJSON, safeStringifyJSON, safeUpdateItem } from './localStorageSafe';
import { logger } from './logger';
import { validateUserId } from './validation';

export interface PurchaseRecord {
  ingredientId: string;
  ingredientName?: string; // Optional for backward compatibility
  purchaseDate: string; // ISO string
  confirmed: boolean;
  amazonOrderId?: string; // For Amazon API integration
}

const PREFIX = 'ingredient_purchases_';

/**
 * Get storage key for user's purchases
 */
export function getStorageKey(userId: string): string {
  return `${PREFIX}${userId}`;
}

// =================================================================
// SIMPLE API (from guide) - Transaction-safe implementation
// =================================================================

/**
 * Load all purchase records for a user
 * Simple API matching guide's interface
 */
export function loadPurchases(userId: string): PurchaseRecord[] {
  const userIdValidation = validateUserId(userId);
  if (!userIdValidation.valid) {
    logger.warn('Invalid userId in loadPurchases', { userId });
    return [];
  }
  
  const key = getStorageKey(userId);
  const raw = safeGetItem(key);
  return safeParseJSON<PurchaseRecord[]>(raw, []);
}

/**
 * Save purchase records for a user
 * Simple API matching guide's interface
 */
export function savePurchases(userId: string, records: PurchaseRecord[]): boolean {
  const userIdValidation = validateUserId(userId);
  if (!userIdValidation.valid) {
    logger.warn('Invalid userId in savePurchases', { userId });
    return false;
  }
  
  const key = getStorageKey(userId);
  const jsonString = safeStringifyJSON(records);
  if (!jsonString) {
    logger.error('Failed to stringify purchase records', undefined, { userId, recordCount: records.length });
    return false;
  }
  
  const result = safeSetItem(key, jsonString);
  if (!result.success) {
    logger.error('Failed to save purchase records', undefined, { userId, error: result.error });
  }
  
  return result.success;
}

/**
 * Add a purchase (transaction-safe)
 * Simple API matching guide's interface
 * @param confirmed - Whether purchase is confirmed (default: false)
 */
export function addPurchase(
  userId: string,
  ingredientId: string,
  confirmed: boolean = false,
  ingredientName?: string
): PurchaseRecord[] {
  const userIdValidation = validateUserId(userId);
  if (!userIdValidation.valid) {
    logger.warn('Invalid userId in addPurchase', { userId });
    return [];
  }
  
  if (!ingredientId) {
    logger.warn('Missing ingredientId in addPurchase', { userId });
    return loadPurchases(userId);
  }
  
  const key = getStorageKey(userId);
  const result = safeUpdateItem<PurchaseRecord[]>(key, (records) => {
    const currentRecords = records || [];
    
    // Add new purchase record
    return [
      ...currentRecords,
      {
        ingredientId,
        ingredientName: ingredientName || ingredientId, // Use ingredientId as fallback
        purchaseDate: new Date().toISOString(),
        confirmed
      }
    ];
  });
  
  if (!result.success) {
    logger.error('Failed to add purchase', undefined, { userId, ingredientId, error: result.error });
    return loadPurchases(userId); // Return current state on failure
  }
  
  return result.data || [];
}

/**
 * Confirm a purchase (mark as confirmed)
 * Simple API matching guide's interface
 * Uses transaction-safe update to prevent race conditions
 */
export function confirmPurchase(userId: string, ingredientId: string): PurchaseRecord[] {
  const userIdValidation = validateUserId(userId);
  if (!userIdValidation.valid) {
    logger.warn('Invalid userId in confirmPurchase', { userId });
    return [];
  }
  
  if (!ingredientId) {
    logger.warn('Missing ingredientId in confirmPurchase', { userId });
    return loadPurchases(userId);
  }
  
  const key = getStorageKey(userId);
  const result = safeUpdateItem<PurchaseRecord[]>(key, (records) => {
    const currentRecords = records || [];
    
    // Find and update existing record
    const idx = currentRecords.findIndex(r => r.ingredientId === ingredientId && !r.confirmed);
    if (idx >= 0) {
      const updated = [...currentRecords];
      updated[idx] = {
        ...updated[idx],
        confirmed: true,
        purchaseDate: new Date().toISOString() // Update timestamp
      };
      return updated;
    }
    
    // If not found, add as confirmed
    return [
      ...currentRecords,
      {
        ingredientId,
        ingredientName: ingredientId,
        purchaseDate: new Date().toISOString(),
        confirmed: true
      }
    ];
  });
  
  if (!result.success) {
    logger.error('Failed to confirm purchase', undefined, { userId, ingredientId, error: result.error });
    return loadPurchases(userId); // Return current state on failure
  }
  
  return result.data || [];
}

/**
 * Get count of confirmed purchases
 * Simple API matching guide's interface
 */
export function getConfirmedCount(userId: string): number {
  const records = loadPurchases(userId);
  return records.filter(r => r.confirmed).length;
}

/**
 * Get total purchased ingredients (alias for getConfirmedCount)
 * Simple API matching guide's interface
 */
export function getTotalPurchasedIngredients(userId: string): number {
  return getConfirmedCount(userId);
}

/**
 * Get village level from purchase count
 * Simple API matching guide's interface
 * Default: +10 per level (0-9 = level 0, 10-19 = level 1, etc.)
 */
export function getVillageLevelFromCount(count: number): number {
  if (count >= 50) return 5;
  return Math.floor(count / 10);
}

// =================================================================
// ENHANCED API (our additions) - More features, same safety
// =================================================================

/**
 * Get all purchase records for a user
 * Enhanced version with validation
 * @deprecated Use loadPurchases() for simpler API
 */
export function getPurchaseRecords(userId: string): PurchaseRecord[] {
  return loadPurchases(userId);
}

/**
 * Add a pending purchase (not yet confirmed)
 * Enhanced version - used when user clicks "Buy" button
 * Uses transaction-safe update to prevent race conditions
 */
export function addPendingPurchase(
  userId: string,
  ingredientId: string,
  ingredientName: string
): { success: boolean; error?: string } {
  const userIdValidation = validateUserId(userId);
  if (!userIdValidation.valid) {
    return { success: false, error: userIdValidation.error };
  }
  
  if (!ingredientId || !ingredientName) {
    return { success: false, error: 'Ingredient ID and name are required' };
  }
  
  const key = getStorageKey(userId);
  const result = safeUpdateItem<PurchaseRecord[]>(key, (records) => {
    const currentRecords = records || [];
    
    // Check if already exists as pending
    const exists = currentRecords.some(
      r => r.ingredientId === ingredientId && !r.confirmed
    );
    
    if (!exists) {
      return [
        ...currentRecords,
        {
          ingredientId,
          ingredientName,
          purchaseDate: new Date().toISOString(),
          confirmed: false
        }
      ];
    }
    
    return currentRecords;
  });
  
  if (!result.success) {
    logger.error('Failed to add pending purchase', undefined, { userId, ingredientId, error: result.error });
  }
  
  return result;
}

/**
 * Confirm a purchase with full details (enhanced version)
 * Enhanced version with ingredientName and amazonOrderId support
 */
export function confirmPurchaseWithDetails(
  userId: string,
  ingredientId: string,
  ingredientName: string,
  amazonOrderId?: string
): { success: boolean; error?: string } {
  const userIdValidation = validateUserId(userId);
  if (!userIdValidation.valid) {
    return { success: false, error: userIdValidation.error };
  }
  
  if (!ingredientId || !ingredientName) {
    return { success: false, error: 'Ingredient ID and name are required' };
  }
  
  const key = getStorageKey(userId);
  const result = safeUpdateItem<PurchaseRecord[]>(key, (records) => {
    const currentRecords = records || [];
    
    // Check if purchase already exists
    const existingIndex = currentRecords.findIndex(
      r => r.ingredientId === ingredientId && !r.confirmed
    );
    
    if (existingIndex >= 0) {
      // Update existing record
      const updated = [...currentRecords];
      updated[existingIndex] = {
        ...updated[existingIndex],
        ingredientName,
        confirmed: true,
        purchaseDate: new Date().toISOString(),
        ...(amazonOrderId && { amazonOrderId })
      };
      return updated;
    } else {
      // Add new purchase record
      return [
        ...currentRecords,
        {
          ingredientId,
          ingredientName,
          purchaseDate: new Date().toISOString(),
          confirmed: true,
          ...(amazonOrderId && { amazonOrderId })
        }
      ];
    }
  });
  
  if (!result.success) {
    logger.error('Failed to confirm purchase with details', undefined, { userId, ingredientId, error: result.error });
  }
  
  return result;
}

/**
 * Get village level based on purchase count
 * Every 10 ingredients = new level
 * @deprecated Use getVillageLevelFromCount() for simpler API
 */
export function getVillageLevel(purchaseCount: number): number {
  return getVillageLevelFromCount(purchaseCount);
}

/**
 * Get progress toward next village level (0-9)
 */
export function getProgressToNextLevel(purchaseCount: number): number {
  return purchaseCount % 10;
}

/**
 * Get purchase statistics for a user
 * Enhanced version with detailed stats
 */
export function getPurchaseStats(userId: string) {
  const records = loadPurchases(userId);
  const confirmed = records.filter(r => r.confirmed);
  const pending = records.filter(r => !r.confirmed);
  const total = confirmed.length;
  const level = getVillageLevelFromCount(total);
  const progress = getProgressToNextLevel(total);
  
  return {
    totalPurchases: total,
    pendingPurchases: pending.length,
    currentLevel: level,
    progressToNextLevel: progress,
    nextLevelThreshold: (level + 1) * 10,
    ingredientsRemaining: (level + 1) * 10 - total
  };
}
</file>

<file path="lib/utils/ratings.ts">
// lib/utils/ratings.ts - Core rating utilities for PetPlates

export interface RatingData {
  averageRating: number;
  totalReviews: number;
  distribution: { [key: number]: number }; // 1-5 stars count
}

export interface UserRating {
  recipeId: string;
  rating: number;
  timestamp: number;
}

// Storage keys
const USER_RATINGS_KEY = (userId: string) => `user_ratings_${userId}`;
const RECIPE_RATINGS_KEY = (recipeId: string) => `recipe_ratings_${recipeId}`;

/**
 * Save a user's rating for a recipe
 */
export const saveUserRating = (userId: string, recipeId: string, rating: number): void => {
  if (typeof window === 'undefined') return;

  const key = USER_RATINGS_KEY(userId);
  const existing = localStorage.getItem(key);
  const userRatings: UserRating[] = existing ? JSON.parse(existing) : [];

  // Remove existing rating for this recipe
  const filtered = userRatings.filter(r => r.recipeId !== recipeId);

  // Add new rating
  filtered.push({
    recipeId,
    rating,
    timestamp: Date.now()
  });

  localStorage.setItem(key, JSON.stringify(filtered));

  // Update global recipe ratings
  updateRecipeRatings(recipeId);
};

/**
 * Get a user's rating for a specific recipe
 */
export const getUserRating = (userId: string, recipeId: string): number | null => {
  if (typeof window === 'undefined') return null;

  const key = USER_RATINGS_KEY(userId);
  const existing = localStorage.getItem(key);

  if (!existing) return null;

  const userRatings: UserRating[] = JSON.parse(existing);
  const rating = userRatings.find(r => r.recipeId === recipeId);

  return rating ? rating.rating : null;
};

/**
 * Check if user has already rated a recipe
 */
export const hasUserRated = (userId: string, recipeId: string): boolean => {
  return getUserRating(userId, recipeId) !== null;
};

/**
 * Get all ratings for a recipe from all users
 */
export const getRecipeRatings = (recipeId: string): number[] => {
  if (typeof window === 'undefined') return [];

  // Optimized approach: iterate through all user_ratings keys more efficiently
  const ratings: number[] = [];

  for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    if (key && key.startsWith('user_ratings_')) {
      try {
        const userRatings: UserRating[] = JSON.parse(localStorage.getItem(key) || '[]');
        const userRating = userRatings.find(r => r.recipeId === recipeId);
        if (userRating) {
          ratings.push(userRating.rating);
        }
      } catch (error) {
        // Skip corrupted data
        console.warn(`Skipping corrupted user ratings data for key: ${key}`);
      }
    }
  }

  return ratings;
};

/**
 * Update the global recipe ratings data
 */
export const updateRecipeRatings = (recipeId: string): void => {
  if (typeof window === 'undefined') return;

  const ratings = getRecipeRatings(recipeId);
  const key = RECIPE_RATINGS_KEY(recipeId);

  if (ratings.length === 0) {
    localStorage.removeItem(key);
    return;
  }

  const averageRating = ratings.reduce((sum, r) => sum + r, 0) / ratings.length;
  const distribution = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 };

  ratings.forEach(rating => {
    distribution[rating as keyof typeof distribution]++;
  });

  const ratingData: RatingData = {
    averageRating: Math.round(averageRating * 10) / 10, // Round to 1 decimal
    totalReviews: ratings.length,
    distribution
  };

  localStorage.setItem(key, JSON.stringify(ratingData));
};

/**
 * Get rating data for a recipe
 */
export const getRecipeRatingData = (recipeId: string): RatingData => {
  if (typeof window === 'undefined') {
    return { averageRating: 0, totalReviews: 0, distribution: { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 } };
  }

  const key = RECIPE_RATINGS_KEY(recipeId);
  const stored = localStorage.getItem(key);

  // If we have stored user ratings, use those
  if (stored) {
    return JSON.parse(stored);
  }

  // Otherwise, return default data (will be handled by RecipeCard using recipe.rating/reviews)
  return { averageRating: 0, totalReviews: 0, distribution: { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 } };
};

/**
 * Calculate rating data on the fly (alternative to stored data)
 */
export const calculateRecipeRatingData = (recipeId: string): RatingData => {
  const ratings = getRecipeRatings(recipeId);

  if (ratings.length === 0) {
    return { averageRating: 0, totalReviews: 0, distribution: { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 } };
  }

  const averageRating = ratings.reduce((sum, r) => sum + r, 0) / ratings.length;
  const distribution = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 };

  ratings.forEach(rating => {
    distribution[rating as keyof typeof distribution]++;
  });

  return {
    averageRating: Math.round(averageRating * 10) / 10,
    totalReviews: ratings.length,
    distribution
  };
};

/**
 * Get star states for display (filled/empty stars)
 */
export const getStarStates = (rating: number): boolean[] => {
  const stars: boolean[] = [];
  for (let i = 1; i <= 5; i++) {
    stars.push(i <= Math.round(rating));
  }
  return stars;
};

/**
 * Get partial star fill percentage for smooth display
 */
export const getStarFillPercentage = (rating: number, starIndex: number): number => {
  const fullStars = Math.floor(rating);
  const partialStar = rating - fullStars;

  if (starIndex < fullStars) return 100;
  if (starIndex === fullStars) return partialStar * 100;
  return 0;
};
</file>

<file path="lib/utils/recipeIngredients.ts">
// lib/utils/recipeIngredients.ts
// Utility to extract and map ingredients from recipes to ingredient composition keys

import { INGREDIENT_COMPOSITIONS } from '@/lib/data/ingredientCompositions';

/**
 * Extract all unique ingredient names from all recipes
 */
export function getAllRecipeIngredients(): string[] {
  const ingredientNames = new Set<string>();
  
  recipes.forEach(recipe => {
    recipe.ingredients?.forEach(ing => {
      if (ing.name) {
        ingredientNames.add(ing.name);
      }
    });
  });
  
  return Array.from(ingredientNames).sort();
}

/**
 * Map recipe ingredient name to ingredient composition key
 * Handles variations and common naming patterns
 */
export function mapIngredientNameToKey(ingredientName: string): string | null {
  // Normalize the name
  const normalized = ingredientName
    .toLowerCase()
    .trim()
    .replace(/\s*\([^)]*\)/g, '') // Remove parentheses and contents
    .replace(/\s+/g, '_')
    .replace(/[^a-z0-9_]/g, '');
  
  // Direct lookup
  if (INGREDIENT_COMPOSITIONS[normalized]) {
    return normalized;
  }
  
  // Common mappings
  const mappings: Record<string, string | null> = {
    'ground_chicken': 'ground_turkey', // Use turkey as closest match
    'chicken_breast': 'chicken_breast',
    'chicken_liver': 'chicken_liver',
    'chicken_hearts': 'chicken_hearts',
    'beef_liver': 'beef_liver',
    'ground_beef': 'ground_beef_lean',
    'ground_turkey': 'ground_turkey',
    'turkey_breast': 'turkey_breast',
    'salmon_fillet': 'salmon_atlantic',
    'salmon': 'salmon_atlantic',
    'tuna': 'tuna_water',
    'sardines': 'sardines_water',
    'white_rice': 'brown_rice_cooked', // Use brown rice as closest match
    'brown_rice': 'brown_rice_cooked',
    'quinoa': 'quinoa_cooked',
    'sweet_potato': 'sweet_potato',
    'pumpkin': 'sweet_potato', // Use sweet potato as closest match
    'carrots': 'carrots_raw',
    'carrot': 'carrots_raw',
    'green_beans': 'broccoli_raw', // Use broccoli as closest match
    'bok_choy': 'kale_raw', // Use kale as closest match
    'broccoli': 'broccoli_raw',
    'spinach': 'spinach_raw',
    'kale': 'kale_raw',
    'celery': 'celery_raw',
    'blueberries': 'blueberries_raw',
    'bananas': 'bananas_raw',
    'eggs': 'eggs_whole',
    'fish_oil': 'fish_oil',
    'herring_oil': 'fish_oil', // Use fish oil as closest match
    'olive_oil': 'fish_oil', // Use fish oil as closest match
    'coconut_oil': 'fish_oil', // Use fish oil as closest match
    'chicken_broth': null, // No composition data
    'navy_beans': null, // No composition data
    'oats': 'oats',
    'taurine': 'taurine_powder',
    'calcium': 'calcium_carbonate',
  };
  
  // Check mappings
  if (mappings[normalized]) {
    return mappings[normalized];
  }
  
  // Try partial matches
  for (const key in INGREDIENT_COMPOSITIONS) {
    if (normalized.includes(key) || key.includes(normalized)) {
      return key;
    }
  }
  
  return null;
}

/**
 * Get all ingredients that can be used in the recipe builder
 * Returns both ingredients from recipes and existing composition ingredients
 */
export function getAvailableIngredientsForBuilder(): string[] {
  const recipeIngredients = getAllRecipeIngredients();
  const compositionKeys = Object.keys(INGREDIENT_COMPOSITIONS);
  
  // Map recipe ingredients to composition keys
  const mappedKeys = new Set<string>();
  
  recipeIngredients.forEach(name => {
    const key = mapIngredientNameToKey(name);
    if (key) {
      mappedKeys.add(key);
    }
  });
  
  // Also include all composition keys
  compositionKeys.forEach(key => mappedKeys.add(key));
  
  return Array.from(mappedKeys).sort();
}
</file>

<file path="lib/utils/recipeRecommendations.ts">
import { Recipe } from '@/lib/types';

interface Pet {
  id: string;
  name: string;
  type: string;
  breed: string;
  age: string;
  healthConcerns: string[];
  weight?: number;
  activityLevel?: 'sedentary' | 'moderate' | 'active' | 'very-active';
  allergies?: string[];
  dietaryRestrictions?: string[];
  savedRecipes?: string[];
  names?: string[];
  weightKg?: number;
}

import { normalizeToSubtype, type Subtype } from './ingredientWhitelists';
import { getHealthTemplatesForSpecies, applyHealthTemplate, type HealthConcernTemplate } from '@/lib/data/healthConcernTemplates';
import {
  calculateEnhancedCompatibility,
  type Pet as EnhancedPet,
} from './enhancedCompatibilityScoring';

/**
 * Check if recipe matches species/subtype
 * Exported so scoreRecipe can use it
 */
export function matchesSpecies(recipe: Recipe, pet: Pet): boolean {
  // Exact match
  if (recipe.category === pet.type) return true;
  
  // Subtype matching for exotics (Beta feature)
  const subtype = normalizeToSubtype(pet.type as any, pet.breed);
  
  if (pet.type === 'bird') {
    const largeBirds = ['parrot', 'cockatoo', 'african grey', 'macaw', 'conure', 'quaker'];
    const isLargeBird = largeBirds.some(lb => (pet.breed || '').toLowerCase().includes(lb));
    
    // Allow generic bird recipes for all birds
    if (recipe.category === 'birds' || recipe.category === 'bird') return true;
    
    // Allow subtype-specific recipes
    if (recipe.category === 'bird_large' && isLargeBird) return true;
    if (recipe.category === 'bird_small' && !isLargeBird) return true;
  }
  
  if (pet.type === 'reptile') {
    // Allow generic reptile recipes
    if (recipe.category === 'reptiles' || recipe.category === 'reptile') return true;
    
    // Allow subtype-specific recipes
    const subtypeCategories = [
      'reptile_herbivore', 'reptile_insectivore', 
      'reptile_omnivore', 'reptile_carnivore'
    ];
    if (subtypeCategories.includes(recipe.category)) {
      // Check if recipe category matches subtype
      return recipe.category === subtype;
    }
  }
  
  if (pet.type === 'pocket-pet') {
    // Allow generic pocket-pet recipes
    if (recipe.category === 'pocket-pets' || recipe.category === 'pocket-pet') return true;
    
    // Allow subtype-specific recipes
    const subtypeCategories = [
      'pocket_hay', 'pocket_varied', 
      'pocket_carnivore', 'pocket_insectivore'
    ];
    if (subtypeCategories.includes(recipe.category)) {
      return recipe.category === subtype;
    }
  }
  
  return false;
}

/**
 * Tiered recommendation system - ensures users never see "0 meals"
 * 
 * Tier 1: Exact match (species + age + health concern)
 * Tier 2: Subtype + health concern template match
 * Tier 3: Species + age match (no health concern)
 * Tier 4: Species match only (all ages)
 * Tier 5: Subtype match (generic)
 * Tier 6: Health template-based suggestions (always available)
 */
export interface RecipeRecommendation {
  recipe: Recipe;
  tier: number;
  tierLabel: string;
  healthConcernMatch?: string;
  template?: HealthConcernTemplate;
  warning?: string;
  score: number;
  enhancedScore?: any; // Optional improved scoring
}

/**
 * Normalize pet age to age group string
 * Handles both string ("adult") and number (5) formats
 */
function normalizePetAgeToGroup(age: string | number): string {
  if (typeof age === 'string') {
    // Already a string like "adult", "young", etc.
    const normalized = age.toLowerCase().trim();
    if (['baby', 'young', 'adult', 'senior', 'all'].includes(normalized)) {
      return normalized;
    }
    // Try to parse if it's a number string
    const numAge = parseFloat(normalized);
    if (!isNaN(numAge)) {
      if (numAge < 1) return 'baby';
      if (numAge < 2) return 'young';
      if (numAge < 7) return 'adult';
      return 'senior';
    }
    return normalized; // Return as-is if can't parse
  }
  // Convert number to age group
  if (age < 1) return 'baby';
  if (age < 2) return 'young';
  if (age < 7) return 'adult';
  return 'senior';
}

/**
 * Normalize health concern names to match recipe database format
 * Maps user-friendly names to database keys
 */
function normalizeHealthConcern(concern: string): string {
  const mapping: Record<string, string> = {
    'dental health': 'dental-issues',
    'dental-health': 'dental-issues',
    'weight management': 'weight-management',
    'weight-management': 'weight-management',
    'joint & mobility': 'joint-health',
    'joint-health': 'joint-health',
    'skin & coat': 'skin-coat',
    'skin-coat': 'skin-coat',
    'kidney/urinary support': 'kidney',
    'kidney/urinary-support': 'kidney',
    'digestive health': 'digestive',
    'digestive': 'digestive',
    'allergy support': 'allergies',
    'allergies': 'allergies',
  };
  
  const normalized = concern.toLowerCase().trim();
  return mapping[normalized] || normalized.replace(/\s+/g, '-').toLowerCase();
}

/**
 * Get recommended recipes with optional enhanced scoring
 * @param pet - Pet profile
 * @param minCount - Minimum number of recipes to return
 * @param useEnhancedScoring - Whether to use the enhanced compatibility scoring system
 * @param customRecipes - Optional custom recipes to include in recommendations
 */
export const getRecommendedRecipes = (
  pet: Pet,
  minCount: number = 20,
  useEnhancedScoring: boolean = false,
  customRecipes?: Recipe[]
): RecipeRecommendation[] => {
  const { type, age, healthConcerns } = pet;
  // Normalize health concerns to match recipe database format
  const normalizedConcerns = (healthConcerns || []).map(normalizeHealthConcern);
  const results: RecipeRecommendation[] = [];

  // Use provided recipes only - static recipes are no longer available
  const allRecipes = customRecipes || [];

  // Normalize pet age to age group string
  const petAgeGroup = normalizePetAgeToGroup(age);
  
  // Tier 1: Perfect matches (species + age) - health concerns handled in scoring, not filtering
  const tier1 = allRecipes.filter(r => {
    const speciesMatch = matchesSpecies(r, pet);
    const ageMatch = (r.ageGroup || []).includes(petAgeGroup) || (r.ageGroup || []).includes('all');
    // Health concerns are scoring modifiers, not filters
    return speciesMatch && ageMatch;
  }).map(r => {
    // Find matching health concern for display (but don't filter by it)
    const matchingConcern = normalizedConcerns.length > 0 
      ? normalizedConcerns.find(hc => r.healthConcerns?.includes(hc) || r.healthConcerns?.some(rc => rc.toLowerCase().includes(hc.toLowerCase())))
      : undefined;
    return {
      recipe: r,
      tier: 1,
      tierLabel: matchingConcern ? 'Best Match' : 'Age-Appropriate',
      healthConcernMatch: matchingConcern,
      score: 100
    };
  });
  results.push(...tier1);
  
  // Tier 2: Subtype + health concern template match - ALWAYS run when concerns exist
  if (normalizedConcerns.length > 0) {
    const subtype = normalizeToSubtype(type as any, pet.breed);
    
    // Process each health concern (use normalized version)
    normalizedConcerns.forEach(concern => {
      const templates = getHealthTemplatesForSpecies(type, pet.breed, concern);
      
      templates.forEach(template => {
        // Find recipes that match subtype and age (can be adapted)
        const subtypeRecipes = allRecipes.filter(r => {
          const speciesMatch = matchesSpecies(r, pet);
          const ageMatch = (r.ageGroup || []).includes(petAgeGroup) || (r.ageGroup || []).includes('all');
          // Don't include recipes already in results
          const notIncluded = !results.some(res => res.recipe.id === r.id);
          return speciesMatch && ageMatch && notIncluded;
        });
        
        // Actually apply the template to adapt ingredients
        subtypeRecipes.forEach(r => {
          const ingredientNames = r.ingredients.map(i => i.name);
          const adapted = applyHealthTemplate(ingredientNames, template);
          
          // Create adapted recipe
          const adaptedRecipe: Recipe = {
            ...r,
            id: `${r.id}__${template.id}`, // Avoid ID clash
            name: `${r.name} (Adapted for ${concern})`,
            description: `${r.description} Adapted using ${template.name} template.`,
            ingredients: adapted.adjustedIngredients.map((name, idx) => ({
              id: `adapted-${idx}`,
              name,
              amount: 'varies',
              asinLink: r.ingredients[0]?.asinLink || ''
            })),
            healthConcerns: Array.from(new Set([
              ...(r.healthConcerns || []),
              concern
            ])),
            tags: [...(r.tags || []), 'template-adapted']
          };
          
          results.push({
            recipe: adaptedRecipe,
            tier: 2,
            tierLabel: `Adapted for ${concern}`,
            healthConcernMatch: concern,
            template,
            warning: adapted.warnings.length > 0 
              ? `${template.warning || ''} ${adapted.warnings.join('; ')}`
              : template.warning,
            score: 80
          });
        });
      });
    });
  }
  
  // Tier 3: Species + age match (no health concern) - Fill up to minCount
  const tier3 = allRecipes.filter(r => {
    const speciesMatch = matchesSpecies(r, pet);
    const ageMatch = (r.ageGroup || []).includes(petAgeGroup) || (r.ageGroup || []).includes('all');
    const notIncluded = !results.some(res => res.recipe.id === r.id);
    return speciesMatch && ageMatch && notIncluded;
  }).slice(0, Math.max(0, minCount - results.length)) // Only take what we need
  .map(r => ({
    recipe: r,
    tier: 3,
    tierLabel: normalizedConcerns.length > 0 ? 'General Safe Meal' : 'Age-Appropriate',
    warning: normalizedConcerns.length > 0 
      ? `No ${normalizedConcerns[0]} recipes yet; this is a general safe meal`
      : undefined,
    score: 60
  }));
  results.push(...tier3);
  
  // Tier 4: Species match only (all ages) - Fill up to minCount
  // Always ensure we have at least minCount recipes
  const neededFromTier4 = Math.max(0, minCount - results.length);
  const tier4 = allRecipes.filter(r => {
    const speciesMatch = matchesSpecies(r, pet);
    const notIncluded = !results.some(res => res.recipe.id === r.id);
    return speciesMatch && notIncluded;
  }).slice(0, neededFromTier4) // Take only what we need to reach minCount
  .map(r => ({
    recipe: r,
    tier: 4,
    tierLabel: 'Species-Appropriate',
    warning: 'Not optimized for age or health concerns',
    score: 40
  }));
  results.push(...tier4);
  
  // Tier 5: Subtype match (generic) - Fill up to minCount for exotics
  if (results.length < minCount && ['bird', 'reptile', 'pocket-pet', 'birds', 'reptiles', 'pocket-pets'].includes(type)) {
    const subtype = normalizeToSubtype(type as any, pet.breed);
    const tier5 = allRecipes.filter(r => {
      const matchesSubtype = r.category === subtype || 
        (r.category && r.category.includes(subtype.split('_')[0])) ||
        matchesSpecies(r, pet); // Also include any species matches
      const notIncluded = !results.some(res => res.recipe.id === r.id);
      return matchesSubtype && notIncluded;
    }).slice(0, minCount - results.length) // Only take what we need
    .map(r => ({
      recipe: r,
      tier: 5,
      tierLabel: 'Generic ' + subtype.replace('_', ' ') + ' Template',
      warning: 'Generic template - confirm with your vet',
      score: 30
    }));
    results.push(...tier5);
  }
  
  // Tier 6: Health template-based suggestions (always ensure something shows)
  // Also run if we're below minCount for exotics
  if ((results.length === 0 || (results.length < minCount && ['bird', 'reptile', 'pocket-pet', 'birds', 'reptiles', 'pocket-pets'].includes(type))) && normalizedConcerns.length > 0) {
    const templates = getHealthTemplatesForSpecies(type, pet.breed, normalizedConcerns[0]);
    if (templates.length > 0) {
      // Create a placeholder recipe from template
      const template = templates[0];
      const placeholderRecipe: Recipe = {
        id: `template-${template.id}`,
        name: template.name,
        category: type,
        ageGroup: [age],
        healthConcerns: [normalizedConcerns[0]],
        description: template.description,
        ingredients: (template.rules.preferIngredients || []).map((ing, idx) => ({
          id: `ing-${idx}`,
          name: ing,
          amount: 'varies',
          asinLink: ''
        })),
        instructions: ['Use custom meal builder with this template', 'Follow template guidelines'],
        tags: ['template', 'health-concern'],
        rating: 0,
        reviews: 0,
        prepTime: '0 min',
        cookTime: '0 min',
        servings: 1
      };
      
      results.push({
        recipe: placeholderRecipe,
        tier: 6,
        tierLabel: 'Template-Based',
        template,
        warning: template.warning || 'Use custom meal builder with health template',
        score: 20
      });
    }
  }
  
  // Apply improved scoring if requested
  if (useEnhancedScoring) {
    results.forEach(result => {
      try {
        // Convert pet format for improved scoring
        const enhancedPet: EnhancedPet = {
          id: pet.id,
          name: pet.name,
          type: pet.type as 'dog' | 'cat' | 'bird' | 'reptile' | 'pocket-pet',
          breed: pet.breed,
          age: parseFloat(pet.age) || 1,
          weight: pet.weight || 10,
          activityLevel: pet.activityLevel,
          healthConcerns: pet.healthConcerns || [],
          dietaryRestrictions: pet.dietaryRestrictions || [],
          allergies: pet.allergies || [],
        };
        
        const enhanced = calculateEnhancedCompatibility(result.recipe, enhancedPet);
        result.enhancedScore = enhanced;
        result.score = enhanced.overallScore;
      } catch (error) {
        // If enhanced scoring fails, keep original score
        console.warn('Enhanced scoring failed for recipe:', result.recipe.id, error);
      }
    });
  }

  // Sort by score (tier or enhanced score) and return
  const sorted = results.sort((a, b) => {
    // If both have enhanced scores, use those
    if (a.enhancedScore && b.enhancedScore) {
      return b.enhancedScore.overallScore - a.enhancedScore.overallScore;
    }
    // Otherwise use tier score
    return b.score - a.score;
  });
  // Return up to minCount recipes, or all if we have fewer than minCount
  return sorted.slice(0, Math.min(minCount, sorted.length));
};

/**
 * Get count of recipes by priority level for display purposes
 * Returns empty stats since recipes are now generated dynamically
 */
export const getRecommendationStats = (pet: Pet) => {
  return {
    perfect: 0,
    typeAge: 0,
    typeOnly: 0,
    total: 0
  };
};
</file>

<file path="lib/utils/recipeScoring.ts">
// lib/utils/recipeScoring.ts
// Scoring system that ranks recipes 0-100 based on pet profile matching

import type { Recipe } from '@/lib/types';

export interface Pet {
  species: 'dogs' | 'cats' | 'birds' | 'reptiles' | 'pocket-pets';
  breed: string;
  ageGroup: 'baby' | 'young' | 'adult' | 'senior';
  weightStatus?: 'overweight' | 'underweight' | 'ideal';
  healthConcerns: string[];
  savedRecipes?: string[];
  names?: string[];
  weightKg?: number;
  weight?: number | string;
  dietaryRestrictions?: string[];
  allergies?: string[];
  dislikes?: string[];
}

export interface ScoreResult {
  compatibilityScore: number; // 0-100 (formerly matchScore)
  matchScore: number; // 0-100 (deprecated - use compatibilityScore)
  stars: number; // 1-5
  reasoning: {
    goodMatches: string[];
    conflicts: string[];
  };
}

// Common allergens to check
const ALLERGEN_KEYWORDS: Record<string, string[]> = {
  chicken: ['chicken', 'poultry', 'hen'],
  beef: ['beef', 'cow'],
  dairy: ['dairy', 'milk', 'cheese', 'yogurt'],
  grain: ['wheat', 'grain', 'corn', 'barley', 'oats'],
  egg: ['egg'],
};

function hasAllergen(recipe: Recipe, allergen: string): boolean {
  const keywords = ALLERGEN_KEYWORDS[allergen.toLowerCase()] || [allergen.toLowerCase()];
  const allText = `${recipe.name} ${recipe.description} ${recipe.ingredients.map(i => i.name).join(' ')}`.toLowerCase();
  return keywords.some(kw => allText.includes(kw));
}

function isLowCalorie(recipe: Recipe): boolean {
  const name = recipe.name.toLowerCase();
  const desc = (recipe.description || '').toLowerCase();
  return name.includes('low-fat') || name.includes('lean') || name.includes('slim') ||
         desc.includes('low-calorie') || desc.includes('weight') || desc.includes('diet');
}

function isInAAFCORange(recipe: Recipe, species: 'dogs' | 'cats'): boolean {
  if (!recipe.nutritionalInfo) return false;
  
  const protein = recipe.nutritionalInfo.protein?.min || 0;
  const fat = recipe.nutritionalInfo.fat?.min || 0;
  
  if (species === 'dogs') {
    return protein >= 18 && protein <= 30 && fat >= 5 && fat <= 20;
  } else { // cats
    return protein >= 26 && protein <= 40 && fat >= 9 && fat <= 25;
  }
}

export function scoreRecipe(recipe: Recipe, pet: Pet): ScoreResult {
  let score = 0;
  const goodMatches: string[] = [];
  const conflicts: string[] = [];

  // 1. Species Match (Required Gate - 0 if wrong species)
  if (recipe.category !== pet.species) {
    return {
      compatibilityScore: 0,
      matchScore: 0,
      stars: 1,
      reasoning: {
        goodMatches: [],
        conflicts: [`Recipe is for ${recipe.category}, but pet is ${pet.species}`]
      }
    };
  }

  // 2. Age Group Match (+20)
  if (recipe.ageGroup.includes(pet.ageGroup)) {
    score += 20;
    goodMatches.push('Age group match');
  } else {
    conflicts.push('Age group mismatch');
  }

  // 3. Breed Relevance (+10)
  if (recipe.breed) {
    const breeds = Array.isArray(recipe.breed) ? recipe.breed : [recipe.breed];
    const breedMatch = breeds.some(b =>
      b && b.toLowerCase().replace(/-/g, ' ') === pet.breed.toLowerCase().replace(/-/g, ' ')
    );
    if (breedMatch) {
      score += 10;
      goodMatches.push('Breed-specific recipe');
    }
  }

  // 4. Health Concern Overlap (+10 per match, max +40)
  if (pet.healthConcerns.length > 0 && recipe.healthConcerns.length > 0) {
    const matches = pet.healthConcerns.filter(hc => 
      recipe.healthConcerns.some(rc => 
        rc.toLowerCase().includes(hc.toLowerCase()) || 
        hc.toLowerCase().includes(rc.toLowerCase())
      )
    );
    const healthScore = Math.min(matches.length * 10, 40);
    score += healthScore;
    if (matches.length > 0) {
      goodMatches.push(`${matches.length} health concern${matches.length > 1 ? 's' : ''} addressed`);
    }
  }

  // 5. Weight Control Fit (+10)
  if (pet.weightStatus === 'overweight' && isLowCalorie(recipe)) {
    score += 10;
    goodMatches.push('Low-calorie option for weight management');
  }

  // 6. Allergy Safety (-40 penalty if allergen present)
  if (pet.healthConcerns.includes('allergies')) {
    const hasAllergy = pet.healthConcerns.some(concern => {
      const allergen = concern.toLowerCase();
      return Object.keys(ALLERGEN_KEYWORDS).some(key => 
        allergen.includes(key) && hasAllergen(recipe, key)
      );
    });
    if (hasAllergy) {
      score = Math.max(0, score - 40);
      conflicts.push('Contains common allergen');
    }
  }

  // 7. Nutrient Fit (+20 if in AAFCO range for dogs/cats)
  if ((pet.species === 'dogs' || pet.species === 'cats') && isInAAFCORange(recipe, pet.species)) {
    score += 20;
    goodMatches.push('Meets AAFCO nutritional standards');
  } else if (pet.species === 'dogs' || pet.species === 'cats') {
    // Small penalty if not in range
    score = Math.max(0, score - 5);
  }

  // Cap at 100
  score = Math.min(100, Math.max(0, score));

  // Map to stars
  let stars: number;
  if (score >= 90) stars = 5;
  else if (score >= 75) stars = 4;
  else if (score >= 50) stars = 3;
  else if (score >= 25) stars = 2;
  else stars = 1;

  return {
    compatibilityScore: score,
    matchScore: score, // Keep for backward compatibility
    stars,
    reasoning: {
      goodMatches,
      conflicts
    }
  };
}
</file>

<file path="lib/utils/scoringDiagnostics.ts">
import { Recipe, Pet } from '../types';
import { calculateEnhancedCompatibility } from './enhancedCompatibilityScoring';

export interface ScoreDistributionAnalysis {
  totalRecipes: number;
  scoreRanges: {
    '95-100': number;
    '90-94': number;
    '80-89': number;
    '70-79': number;
    '60-69': number;
    '50-59': number;
    '40-49': number;
    '30-39': number;
    '0-29': number;
  };
  perfectMatches: number;
  clustering: {
    at40: number;
    at100: number;
  };
  averageScore: number;
  medianScore: number;
  standardDeviation: number;
  isBinaryDistribution: boolean;
  recommendations: string[];
}

/**
 * Analyze score distribution for a set of recipes and a pet
 * Helps identify clustering, binary distributions, and scoring issues
 */
export function analyzeScoreDistribution(
  recipes: Recipe[],
  pet: Pet
): ScoreDistributionAnalysis {
  const scores = recipes.map(recipe => 
    calculateEnhancedCompatibility(recipe, pet).overallScore
  );
  
  // Calculate statistics
  const totalRecipes = scores.length;
  const averageScore = scores.reduce((a, b) => a + b, 0) / totalRecipes;
  const sortedScores = [...scores].sort((a, b) => a - b);
  const medianScore = totalRecipes > 0 
    ? sortedScores[Math.floor(totalRecipes / 2)]
    : 0;
  
  // Calculate standard deviation
  const variance = scores.reduce((sum, score) => {
    return sum + Math.pow(score - averageScore, 2);
  }, 0) / totalRecipes;
  const standardDeviation = Math.sqrt(variance);
  
  // Count score ranges
  const scoreRanges = {
    '95-100': scores.filter(s => s >= 95).length,
    '90-94': scores.filter(s => s >= 90 && s < 95).length,
    '80-89': scores.filter(s => s >= 80 && s < 90).length,
    '70-79': scores.filter(s => s >= 70 && s < 80).length,
    '60-69': scores.filter(s => s >= 60 && s < 70).length,
    '50-59': scores.filter(s => s >= 50 && s < 60).length,
    '40-49': scores.filter(s => s >= 40 && s < 50).length,
    '30-39': scores.filter(s => s >= 30 && s < 40).length,
    '0-29': scores.filter(s => s < 30).length,
  };
  
  // Count perfect matches (95-100)
  const perfectMatches = scoreRanges['95-100'];
  
  // Detect clustering (scores within 2 points of 40 or 100)
  const clustering = {
    at40: scores.filter(s => Math.abs(s - 40) < 2).length,
    at100: scores.filter(s => Math.abs(s - 100) < 2).length,
  };
  
  // Check for binary distribution
  // Binary if >30% at 40 and >30% at 100, or if standard deviation is very low
  const isBinaryDistribution = 
    (clustering.at40 > totalRecipes * 0.3 && clustering.at100 > totalRecipes * 0.3) ||
    (standardDeviation < 10 && (clustering.at40 > totalRecipes * 0.2 || clustering.at100 > totalRecipes * 0.2));
  
  // Generate recommendations
  const recommendations: string[] = [];
  
  if (isBinaryDistribution) {
    recommendations.push('‚ö†Ô∏è Binary distribution detected - adjust scoring granularity');
  }
  
  if (clustering.at40 > totalRecipes * 0.2) {
    recommendations.push('‚ö†Ô∏è Too many recipes clustering at 40% - lower safety floor or improve penalty granularity');
  }
  
  if (clustering.at100 > totalRecipes * 0.2) {
    recommendations.push('‚ö†Ô∏è Too many perfect scores - make isPerfectMatch() stricter or reduce perfect match bonus');
  }
  
  if (standardDeviation < 15) {
    recommendations.push('‚ö†Ô∏è Scores too similar - increase penalty/bonus differentiation');
  }
  
  if (perfectMatches > totalRecipes * 0.2) {
    recommendations.push('‚ö†Ô∏è Too many perfect matches (>20%) - tighten perfect match criteria');
  }
  
  if (perfectMatches === 0 && averageScore > 80) {
    recommendations.push('‚ÑπÔ∏è No perfect matches but high average - consider allowing some 95-100% scores');
  }
  
  if (scoreRanges['0-29'] > totalRecipes * 0.3) {
    recommendations.push('‚ö†Ô∏è Too many very low scores - check if penalties are too harsh');
  }
  
  return {
    totalRecipes,
    scoreRanges,
    perfectMatches,
    clustering,
    averageScore: Math.round(averageScore * 10) / 10,
    medianScore,
    standardDeviation: Math.round(standardDeviation * 10) / 10,
    isBinaryDistribution,
    recommendations,
  };
}

/**
 * Generate a detailed report of score distribution
 */
export function generateDistributionReport(
  recipes: Recipe[],
  pet: Pet
): string {
  const analysis = analyzeScoreDistribution(recipes, pet);
  
  let report = `\n=== Score Distribution Analysis ===\n\n`;
  report += `Total Recipes: ${analysis.totalRecipes}\n`;
  report += `Average Score: ${analysis.averageScore}%\n`;
  report += `Median Score: ${analysis.medianScore}%\n`;
  report += `Standard Deviation: ${analysis.standardDeviation}\n\n`;
  
  report += `Score Ranges:\n`;
  report += `  95-100: ${analysis.scoreRanges['95-100']} (${Math.round(analysis.scoreRanges['95-100'] / analysis.totalRecipes * 100)}%)\n`;
  report += `  90-94: ${analysis.scoreRanges['90-94']} (${Math.round(analysis.scoreRanges['90-94'] / analysis.totalRecipes * 100)}%)\n`;
  report += `  80-89: ${analysis.scoreRanges['80-89']} (${Math.round(analysis.scoreRanges['80-89'] / analysis.totalRecipes * 100)}%)\n`;
  report += `  70-79: ${analysis.scoreRanges['70-79']} (${Math.round(analysis.scoreRanges['70-79'] / analysis.totalRecipes * 100)}%)\n`;
  report += `  60-69: ${analysis.scoreRanges['60-69']} (${Math.round(analysis.scoreRanges['60-69'] / analysis.totalRecipes * 100)}%)\n`;
  report += `  50-59: ${analysis.scoreRanges['50-59']} (${Math.round(analysis.scoreRanges['50-59'] / analysis.totalRecipes * 100)}%)\n`;
  report += `  40-49: ${analysis.scoreRanges['40-49']} (${Math.round(analysis.scoreRanges['40-49'] / analysis.totalRecipes * 100)}%)\n`;
  report += `  30-39: ${analysis.scoreRanges['30-39']} (${Math.round(analysis.scoreRanges['30-39'] / analysis.totalRecipes * 100)}%)\n`;
  report += `  0-29: ${analysis.scoreRanges['0-29']} (${Math.round(analysis.scoreRanges['0-29'] / analysis.totalRecipes * 100)}%)\n\n`;
  
  report += `Clustering:\n`;
  report += `  At 40%: ${analysis.clustering.at40} recipes\n`;
  report += `  At 100%: ${analysis.clustering.at100} recipes\n\n`;
  
  report += `Binary Distribution: ${analysis.isBinaryDistribution ? 'YES ‚ö†Ô∏è' : 'NO ‚úì'}\n\n`;
  
  if (analysis.recommendations.length > 0) {
    report += `Recommendations:\n`;
    analysis.recommendations.forEach(rec => {
      report += `  ${rec}\n`;
    });
  }
  
  return report;
}
</file>

<file path="lib/utils/scoringTransparency.ts">
// lib/utils/scoringTransparency.ts
// Scoring transparency debug tool

import type { Recipe } from '@/lib/types';
import { calculateEnhancedCompatibility, type Pet, calculateBonuses, calculateRecipeNutrition } from './enhancedCompatibilityScoring';

export interface ScoringReport {
  factors: Record<string, {
    score: number;
    weight: number;
    contribution: number;
    canBe100: boolean;
    explanation: string;
    issues: string[];
  }>;
  currentScore: number;
  maxPossibleScore: number;
  canReach100: boolean;
  barriersTo100: string[];
  bonuses: number;
  penalties: number;
}

/**
 * Generate a detailed scoring report for debugging
 */
export function generateScoringReport(
  recipe: Recipe,
  pet: Pet
): ScoringReport {
  const result = calculateEnhancedCompatibility(recipe, pet);
  const bonuses = calculateBonuses(recipe, pet);
  
  const factors: ScoringReport['factors'] = {};
  let maxPossible = 0;
  const barriers: string[] = [];
  
  Object.entries(result.factors).forEach(([key, factor]) => {
    const weight = factor.weight || 0;
    const contribution = factor.score * weight;
    const canBe100 = checkIfFactorCanBe100(key, recipe, pet);
    
    if (!canBe100 && factor.score < 100) {
      barriers.push(`${key}: ${factor.reasoning}`);
    }
    
    maxPossible += canBe100 ? 100 * weight : factor.score * weight;
    
    factors[key] = {
      score: factor.score,
      weight,
      contribution,
      canBe100,
      explanation: factor.reasoning,
      issues: factor.issues
    };
  });
  
  return {
    factors,
    currentScore: result.overallScore,
    maxPossibleScore: maxPossible + bonuses,
    canReach100: maxPossible + bonuses >= 99.5,
    barriersTo100: barriers,
    bonuses,
    penalties: result.detailedBreakdown.warnings.length
  };
}

/**
 * Check if a factor can theoretically reach 100% for this recipe+pet combination
 */
function checkIfFactorCanBe100(factorName: string, recipe: Recipe, pet: Pet): boolean {
  switch (factorName) {
    case 'ingredientSafety':
      // Can be 100 if all ingredients are safe
      return true;
    case 'nutritionalAdequacy':
      // Can be 100 if nutrition is perfect and no fallback data (or pet has no concerns)
      const nutrition = calculateRecipeNutrition(recipe);
      if (pet.healthConcerns.length === 0) {
        // Perfect pets don't penalize fallback data
        return true;
      }
      return !nutrition.usesFallbackNutrition;
    case 'healthAlignment':
      // Can be 100 if pet has no health concerns
      return pet.healthConcerns.length === 0;
    case 'lifeStageFit':
      // Can be 100 if age matches
      return true;
    case 'activityFit':
      // Can be 100 if activity level not specified or matches
      return true;
    case 'allergenSafety':
      // Can be 100 if no allergens
      return (pet.allergies?.length ?? 0) === 0 && pet.dietaryRestrictions.length === 0;
    case 'ingredientQuality':
      // Can be 100 if all ingredients are premium (but this is now a bonus, not requirement)
      return true;
    default:
      return true;
  }
}
</file>

<file path="lib/utils/telemetry.ts">
// lib/utils/telemetry.ts
// Client-side telemetry for performance and quality monitoring
// Tracks: JSON load time, scoring time, validation status distribution

interface TelemetryEvent {
  type: 'json_load' | 'scoring' | 'validation_status' | 'page_load';
  timestamp: number;
  duration?: number; // milliseconds
  metadata?: Record<string, any>;
}

const TELEMETRY_KEY = 'pet_plates_telemetry';
const BATCH_SIZE = 10; // Send after N events
const BATCH_INTERVAL_MS = 30000; // Send every 30 seconds
const MAX_EVENTS = 100; // Maximum events to store

class Telemetry {
  private events: TelemetryEvent[] = [];
  private batchTimer: NodeJS.Timeout | null = null;

  constructor() {
    if (typeof window !== 'undefined') {
      this.loadEvents();
      this.startBatchTimer();
      
      // Send on page unload
      window.addEventListener('beforeunload', () => {
        this.flush();
      });
    }
  }

  private loadEvents(): void {
    if (typeof window === 'undefined') return;
    
    try {
      const stored = localStorage.getItem(TELEMETRY_KEY);
      if (stored) {
        this.events = JSON.parse(stored);
        // Keep only recent events (last 100)
        if (this.events.length > MAX_EVENTS) {
          this.events = this.events.slice(-MAX_EVENTS);
        }
      }
    } catch (error) {
      console.warn('Failed to load telemetry events:', error);
      this.events = [];
    }
  }

  private saveEvents(): void {
    if (typeof window === 'undefined') return;
    
    try {
      localStorage.setItem(TELEMETRY_KEY, JSON.stringify(this.events));
    } catch (error) {
      console.warn('Failed to save telemetry events:', error);
    }
  }

  private startBatchTimer(): void {
    if (typeof window === 'undefined') return;
    
    this.batchTimer = setInterval(() => {
      if (this.events.length >= BATCH_SIZE) {
        this.flush();
      }
    }, BATCH_INTERVAL_MS);
  }

  /**
   * Track JSON load time
   */
  trackJsonLoad(duration: number, size?: number): void {
    this.addEvent({
      type: 'json_load',
      timestamp: Date.now(),
      duration,
      metadata: size ? { size } : undefined,
    });
  }

  /**
   * Track scoring time
   */
  trackScoring(duration: number, recipeCount: number, cacheHit?: boolean): void {
    this.addEvent({
      type: 'scoring',
      timestamp: Date.now(),
      duration,
      metadata: {
        recipeCount,
        cacheHit: cacheHit || false,
      },
    });
  }

  /**
   * Track validation status
   */
  trackValidationStatus(status: 'valid' | 'needsReview' | 'invalid', recipeId?: string): void {
    this.addEvent({
      type: 'validation_status',
      timestamp: Date.now(),
      metadata: {
        status,
        recipeId,
      },
    });
  }

  /**
   * Track page load time
   */
  trackPageLoad(duration: number, page: string): void {
    this.addEvent({
      type: 'page_load',
      timestamp: Date.now(),
      duration,
      metadata: { page },
    });
  }

  private addEvent(event: TelemetryEvent): void {
    this.events.push(event);
    
    // Keep only recent events
    if (this.events.length > MAX_EVENTS) {
      this.events = this.events.slice(-MAX_EVENTS);
    }
    
    this.saveEvents();
    
    // Auto-flush if batch size reached
    if (this.events.length >= BATCH_SIZE) {
      this.flush();
    }
  }

  /**
   * Get telemetry summary statistics
   */
  getSummary(): {
    jsonLoadTimes: number[];
    scoringTimes: number[];
    validationStatuses: Record<string, number>;
    pageLoadTimes: Record<string, number[]>;
  } {
    const jsonLoadTimes: number[] = [];
    const scoringTimes: number[] = [];
    const validationStatuses: Record<string, number> = {};
    const pageLoadTimes: Record<string, number[]> = {};

    this.events.forEach(event => {
      switch (event.type) {
        case 'json_load':
          if (event.duration) jsonLoadTimes.push(event.duration);
          break;
        case 'scoring':
          if (event.duration) scoringTimes.push(event.duration);
          break;
        case 'validation_status':
          const status = event.metadata?.status || 'unknown';
          validationStatuses[status] = (validationStatuses[status] || 0) + 1;
          break;
        case 'page_load':
          const page = event.metadata?.page || 'unknown';
          if (!pageLoadTimes[page]) pageLoadTimes[page] = [];
          if (event.duration) pageLoadTimes[page].push(event.duration);
          break;
      }
    });

    return {
      jsonLoadTimes,
      scoringTimes,
      validationStatuses,
      pageLoadTimes,
    };
  }

  /**
   * Flush events to server (if endpoint available) or console
   */
  flush(): void {
    if (this.events.length === 0) return;

    const summary = this.getSummary();
    
    // Log summary to console (in development)
    if (process.env.NODE_ENV === 'development') {
      const { jsonLoadTimes, scoringTimes, validationStatuses, pageLoadTimes } = summary;
      console.log('üìä Telemetry Summary:', {
        totalEvents: this.events.length,
        jsonLoadAvg: jsonLoadTimes.length > 0 
          ? (jsonLoadTimes.reduce((a: number, b: number) => a + b, 0) / jsonLoadTimes.length).toFixed(2) + 'ms'
          : 'N/A',
        scoringAvg: scoringTimes.length > 0
          ? (scoringTimes.reduce((a: number, b: number) => a + b, 0) / scoringTimes.length).toFixed(2) + 'ms'
          : 'N/A',
        validationStatuses,
        pageLoadAvgs: Object.entries(pageLoadTimes).map(([page, times]) => ({
          page,
          avg: (Array.isArray(times) ? times.reduce((a: number, b: number) => a + b, 0) / times.length : 0).toFixed(2) + 'ms',
        })),
      });
    }

    // TODO: Send to analytics endpoint if available
    // Example:
    // fetch('/api/telemetry', {
    //   method: 'POST',
    //   headers: { 'Content-Type': 'application/json' },
    //   body: JSON.stringify({ events: this.events, summary }),
    // }).catch(() => {});

    // Clear events after flushing
    this.events = [];
    this.saveEvents();
  }

  /**
   * Clear all telemetry data
   */
  clear(): void {
    this.events = [];
    this.saveEvents();
  }
}

// Singleton instance
let telemetryInstance: Telemetry | null = null;

export function getTelemetry(): Telemetry {
  if (!telemetryInstance) {
    telemetryInstance = new Telemetry();
  }
  return telemetryInstance;
}

// Convenience functions
export const trackJsonLoad = (duration: number, size?: number) => 
  getTelemetry().trackJsonLoad(duration, size);

export const trackScoring = (duration: number, recipeCount: number, cacheHit?: boolean) =>
  getTelemetry().trackScoring(duration, recipeCount, cacheHit);

export const trackValidationStatus = (status: 'valid' | 'needsReview' | 'invalid', recipeId?: string) =>
  getTelemetry().trackValidationStatus(status, recipeId);

export const trackPageLoad = (duration: number, page: string) =>
  getTelemetry().trackPageLoad(duration, page);

export const getTelemetrySummary = () => getTelemetry().getSummary();

export const flushTelemetry = () => getTelemetry().flush();
</file>

<file path="lib/utils/validation.ts">
// lib/utils/validation.ts
// Input validation and sanitization utilities with Zod schemas

import { z } from 'zod';
import type { Pet } from '../utils/petUtils';
import type { Recipe, Ingredient, PetNutritionProfile, CustomMeal } from '../types';
import type { PurchaseRecord } from './purchaseTracking';

/**
 * Sanitizes user input to prevent XSS attacks
 */
export function sanitizeInput(input: string): string {
  if (typeof input !== 'string') return '';
  
  return input
    .trim()
    .replace(/[<>]/g, '') // Remove < and > to prevent HTML injection
    .replace(/javascript:/gi, '') // Remove javascript: protocol
    .replace(/on\w+=/gi, '') // Remove event handlers like onclick=
    .slice(0, 500); // Limit length
}

/**
 * Validates pet name
 */
export function validatePetName(name: string): { valid: boolean; error?: string } {
  if (!name || typeof name !== 'string') {
    return { valid: false, error: 'Pet name is required' };
  }
  
  const trimmed = name.trim();
  
  if (trimmed.length === 0) {
    return { valid: false, error: 'Pet name cannot be empty' };
  }
  
  if (trimmed.length > 50) {
    return { valid: false, error: 'Pet name must be 50 characters or less' };
  }
  
  // Check for potentially dangerous characters
  if (/[<>]/.test(trimmed)) {
    return { valid: false, error: 'Pet name contains invalid characters' };
  }
  
  return { valid: true };
}

/**
 * Validates pet weight
 */
export function validatePetWeight(weight: string): { valid: boolean; error?: string; value?: number } {
  if (!weight || typeof weight !== 'string') {
    return { valid: false, error: 'Weight is required' };
  }
  
  const trimmed = weight.trim();
  
  if (trimmed.length === 0) {
    return { valid: false, error: 'Weight cannot be empty' };
  }
  
  // Extract number from string (handles "10 lbs", "10kg", etc.)
  const match = trimmed.match(/(\d+\.?\d*)/);
  if (!match) {
    return { valid: false, error: 'Weight must be a number' };
  }
  
  const numValue = parseFloat(match[1]);
  
  if (isNaN(numValue) || numValue <= 0) {
    return { valid: false, error: 'Weight must be a positive number' };
  }
  
  if (numValue > 1000) {
    return { valid: false, error: 'Weight seems too high. Please check your input.' };
  }
  
  return { valid: true, value: numValue };
}

/**
 * Validates recipe ID format
 */
export function validateRecipeId(recipeId: string): { valid: boolean; error?: string } {
  if (!recipeId || typeof recipeId !== 'string') {
    return { valid: false, error: 'Recipe ID is required' };
  }
  
  // Recipe IDs should match pattern like "dog-01", "cat-11", etc.
  if (!/^[a-z]+-\d+$/.test(recipeId)) {
    return { valid: false, error: 'Invalid recipe ID format' };
  }
  
  return { valid: true };
}

/**
 * Validates user rating (1-5)
 */
export function validateRating(rating: number | string): { valid: boolean; error?: string; value?: number } {
  const numRating = typeof rating === 'string' ? parseFloat(rating) : rating;
  
  if (isNaN(numRating)) {
    return { valid: false, error: 'Rating must be a number' };
  }
  
  if (numRating < 1 || numRating > 5) {
    return { valid: false, error: 'Rating must be between 1 and 5' };
  }
  
  return { valid: true, value: Math.round(numRating) };
}

/**
 * Validates userId
 */
export function validateUserId(userId: string | null | undefined): { valid: boolean; error?: string } {
  if (!userId || typeof userId !== 'string') {
    return { valid: false, error: 'User ID is required' };
  }
  
  if (userId.trim().length === 0) {
    return { valid: false, error: 'User ID cannot be empty' };
  }
  
  return { valid: true };
}

/**
 * Validates array of strings (for health concerns, allergies, etc.)
 */
export function validateStringArray(arr: any, maxLength: number = 20): { valid: boolean; error?: string; value?: string[] } {
  if (!Array.isArray(arr)) {
    return { valid: false, error: 'Must be an array' };
  }
  
  if (arr.length > maxLength) {
    return { valid: false, error: `Maximum ${maxLength} items allowed` };
  }
  
  const validItems = arr
    .filter((item): item is string => typeof item === 'string')
    .map(item => sanitizeInput(item))
    .filter(item => item.length > 0);
  
  return { valid: true, value: validItems };
}

// =================================================================
// ZOD SCHEMAS
// =================================================================

/**
 * Zod schema for Pet validation
 */
export const PetSchema = z.object({
  id: z.string().min(1, 'Pet ID is required'),
  names: z.array(z.string().min(1).max(50)).min(1, 'At least one name is required'),
  type: z.enum(['dogs', 'cats', 'birds', 'reptiles', 'pocket-pets'], {
    errorMap: () => ({ message: 'Invalid pet type' })
  }),
  breed: z.string().min(1, 'Breed is required').max(100),
  weight: z.string().min(1, 'Weight is required').refine(
    (val) => {
      const match = val.trim().match(/(\d+\.?\d*)/);
      if (!match) return false;
      const num = parseFloat(match[1]);
      return !isNaN(num) && num > 0 && num <= 1000;
    },
    { message: 'Weight must be a positive number between 0 and 1000' }
  ),
  age: z.string().min(1, 'Age is required'),
  healthConcerns: z.array(z.string()).max(20, 'Maximum 20 health concerns allowed').default([]),
  mealPlan: z.array(z.string()).default([]),
  savedRecipes: z.array(z.string()).default([]),
  dislikes: z.array(z.string()).max(20).optional(),
  image: z.string().url().optional().or(z.literal('')),
}).refine(
  (data) => {
    // Sanitize names
    return data.names.every(name => !/[<>]/.test(name));
  },
  { message: 'Pet names contain invalid characters', path: ['names'] }
);

/**
 * Zod schema for Ingredient validation
 */
export const IngredientSchema = z.object({
  id: z.string().min(1, 'Ingredient ID is required'),
  name: z.string().min(1, 'Ingredient name is required').max(200),
  amount: z.string().min(1, 'Amount is required').max(100),
  asinLink: z.string().url().optional(),
  productName: z.string().max(200).optional(),
  vetNote: z.string().max(500).optional(),
  isVetted: z.boolean().optional(),
  isGeneric: z.boolean().optional(),
  asin: z.string().regex(/^[A-Z0-9]{10}$/, 'Invalid ASIN format').optional(),
});

/**
 * Zod schema for Recipe validation
 */
export const RecipeSchema = z.object({
  id: z.string().regex(/^[a-z]+-\d+$/, 'Invalid recipe ID format'),
  name: z.string().min(1, 'Recipe name is required').max(200),
  shortName: z.string().max(100).optional(),
  celebrityName: z.string().max(100).optional(),
  celebrityQuote: z.string().max(500).optional(),
  category: z.string().min(1),
  breed: z.union([z.string(), z.array(z.string()), z.null()]).optional(),
  ageGroup: z.array(z.string()).min(1, 'At least one age group is required'),
  healthConcerns: z.array(z.string()).default([]),
  notSuitableFor: z.array(z.string()).optional(),
  description: z.string().max(2000).optional(),
  tags: z.array(z.string()).optional(),
  imageUrl: z.string().url().optional(),
  prepTime: z.string().optional(),
  cookTime: z.string().optional(),
  servings: z.number().int().positive().optional(),
  ingredients: z.array(IngredientSchema).min(1, 'At least one ingredient is required'),
  instructions: z.array(z.string()).min(1, 'At least one instruction is required'),
  supplements: z.array(IngredientSchema).optional(),
  nutritionalInfo: z.object({
    protein: z.object({ min: z.number(), max: z.number(), unit: z.string() }).optional(),
    fat: z.object({ min: z.number(), max: z.number(), unit: z.string() }).optional(),
    fiber: z.object({ min: z.number(), max: z.number(), unit: z.string() }).optional(),
    calories: z.object({ min: z.number(), max: z.number(), unit: z.string() }).optional(),
    phosphorus: z.object({ min: z.number(), max: z.number(), unit: z.string() }).optional(),
    calcium: z.object({ min: z.number(), max: z.number(), unit: z.string() }).optional(),
  }).optional(),
  nutritionInfo: z.object({
    protein: z.string().optional(),
    fat: z.string().optional(),
    fiber: z.string().optional(),
    calories: z.string().optional(),
    calcium: z.string().optional(),
  }).optional(),
  rating: z.number().min(1).max(5).optional(),
  reviews: z.number().int().nonnegative().optional(),
});

/**
 * Zod schema for PurchaseRecord validation
 */
export const PurchaseRecordSchema = z.object({
  ingredientId: z.string().min(1, 'Ingredient ID is required'),
  ingredientName: z.string().max(200).optional(),
  purchaseDate: z.string().datetime({ message: 'Invalid ISO date format' }),
  confirmed: z.boolean(),
  amazonOrderId: z.string().max(100).optional(),
});

/**
 * Zod schema for PetNutritionProfile validation
 */
export const PetNutritionProfileSchema = z.object({
  species: z.string().min(1, 'Species is required'),
  ageGroup: z.string().min(1, 'Age group is required'),
  weightKg: z.number().positive('Weight must be positive').max(1000, 'Weight seems too high'),
  breed: z.string().nullable().optional(),
  healthConcerns: z.array(z.string()).max(20).optional(),
  allergies: z.array(z.string()).max(20).optional(),
  caloriesPerKgOverride: z.number().positive().optional(),
  petName: z.string().max(50).optional(),
});

/**
 * Zod schema for CustomMeal validation
 */
export const CustomMealSchema = z.object({
  id: z.string().min(1, 'Meal ID is required'),
  petId: z.string().min(1, 'Pet ID is required'),
  userId: z.string().min(1, 'User ID is required'),
  name: z.string().min(1, 'Meal name is required').max(200),
  createdAt: z.string().datetime({ message: 'Invalid ISO date format' }),
  updatedAt: z.string().datetime({ message: 'Invalid ISO date format' }),
  ingredients: z.array(z.object({
    key: z.string().min(1),
    grams: z.number().positive('Grams must be positive'),
  })).min(1, 'At least one ingredient is required'),
  analysis: z.object({
    score: z.number().min(0).max(100),
    nutrients: z.record(z.string(), z.number()),
    totalRecipeGrams: z.number().positive(),
    recommendedServingGrams: z.number().positive(),
    breakdown: z.object({
      nutrientCoverageScore: z.number(),
      toxicityPenalty: z.number(),
      balanceVarietyScore: z.number(),
    }),
    toxicityWarnings: z.array(z.object({
      message: z.string(),
      severity: z.enum(['low', 'medium', 'high', 'critical']),
      ingredientKey: z.string().optional(),
      ingredientName: z.string().optional(),
    })),
    allergyWarnings: z.array(z.object({
      message: z.string(),
      severity: z.enum(['low', 'medium', 'high', 'critical']),
    })),
    nutrientWarnings: z.array(z.object({
      message: z.string(),
      severity: z.enum(['low', 'medium', 'high', 'critical']),
    })),
    suggestions: z.array(z.object({
      message: z.string(),
      action: z.string().optional(),
      confidence: z.enum(['low', 'medium', 'high']).optional(),
    })),
  }),
});

// =================================================================
// VALIDATION FUNCTIONS USING ZOD
// =================================================================

/**
 * Validate a Pet object using Zod schema
 */
export function validatePetWithZod(pet: unknown): { valid: boolean; error?: string; data?: Pet } {
  try {
    const validated = PetSchema.parse(pet);
    return { valid: true, data: validated };
  } catch (error) {
    if (error instanceof z.ZodError) {
      const firstError = error.errors[0];
      return { 
        valid: false, 
        error: `${firstError.path.join('.')}: ${firstError.message}` 
      };
    }
    return { valid: false, error: 'Validation failed' };
  }
}

/**
 * Validate a Recipe object using Zod schema
 */
export function validateRecipeWithZod(recipe: unknown): { valid: boolean; error?: string; data?: Recipe } {
  try {
    const validated = RecipeSchema.parse(recipe);
    return { valid: true, data: validated };
  } catch (error) {
    if (error instanceof z.ZodError) {
      const firstError = error.errors[0];
      return { 
        valid: false, 
        error: `${firstError.path.join('.')}: ${firstError.message}` 
      };
    }
    return { valid: false, error: 'Validation failed' };
  }
}

/**
 * Validate an Ingredient object using Zod schema
 */
export function validateIngredientWithZod(ingredient: unknown): { valid: boolean; error?: string; data?: Ingredient } {
  try {
    const validated = IngredientSchema.parse(ingredient);
    return { valid: true, data: validated };
  } catch (error) {
    if (error instanceof z.ZodError) {
      const firstError = error.errors[0];
      return { 
        valid: false, 
        error: `${firstError.path.join('.')}: ${firstError.message}` 
      };
    }
    return { valid: false, error: 'Validation failed' };
  }
}

/**
 * Validate a PurchaseRecord object using Zod schema
 */
export function validatePurchaseRecordWithZod(record: unknown): { valid: boolean; error?: string; data?: PurchaseRecord } {
  try {
    const validated = PurchaseRecordSchema.parse(record);
    return { valid: true, data: validated };
  } catch (error) {
    if (error instanceof z.ZodError) {
      const firstError = error.errors[0];
      return { 
        valid: false, 
        error: `${firstError.path.join('.')}: ${firstError.message}` 
      };
    }
    return { valid: false, error: 'Validation failed' };
  }
}

/**
 * Validate a PetNutritionProfile object using Zod schema
 */
export function validatePetNutritionProfileWithZod(profile: unknown): { valid: boolean; error?: string; data?: PetNutritionProfile } {
  try {
    const validated = PetNutritionProfileSchema.parse(profile);
    return { valid: true, data: validated };
  } catch (error) {
    if (error instanceof z.ZodError) {
      const firstError = error.errors[0];
      return { 
        valid: false, 
        error: `${firstError.path.join('.')}: ${firstError.message}` 
      };
    }
    return { valid: false, error: 'Validation failed' };
  }
}

/**
 * Validate a CustomMeal object using Zod schema
 */
export function validateCustomMealWithZod(meal: unknown): { valid: boolean; error?: string; data?: CustomMeal } {
  try {
    const validated = CustomMealSchema.parse(meal);
    return { valid: true, data: validated };
  } catch (error) {
    if (error instanceof z.ZodError) {
      const firstError = error.errors[0];
      return { 
        valid: false, 
        error: `${firstError.path.join('.')}: ${firstError.message}` 
      };
    }
    return { valid: false, error: 'Validation failed' };
  }
}

/**
 * Safe parse with detailed error information
 */
export function safeParseWithZod<T>(schema: z.ZodSchema<T>, data: unknown): {
  success: boolean;
  data?: T;
  errors?: z.ZodError['errors'];
} {
  const result = schema.safeParse(data);
  if (result.success) {
    return { success: true, data: result.data };
  }
  return { success: false, errors: result.error.errors };
}
</file>

<file path="lib/validation/asinClusterer.ts">
// ASIN clustering algorithm - detects legitimate alias groups
// Reduces duplicate ASIN false positives by grouping related ingredients

import { IngredientAliasGroup, KNOWN_SYNONYM_PAIRS, KNOWN_CONFLICT_PATTERNS } from '../types/aliasGroups';

export class ASINClusterer {
  /**
   * Cluster ingredients that share the same ASIN
   * Returns alias groups for legitimate duplicates
   */
  clusterByASIN(
    products: Map<string, { productName: string; asinLink: string }>
  ): {
    aliasGroups: IngredientAliasGroup[];
    conflicts: Array<{ asin: string; ingredients: string[]; reason: string }>;
    singles: string[];
  } {
    // 1. Group by ASIN
    const asinMap = new Map<string, string[]>();
    
    for (const [ingredientName, product] of products) {
      const asin = this.extractASIN(product.asinLink);
      if (!asin) continue;
      
      if (!asinMap.has(asin)) {
        asinMap.set(asin, []);
      }
      asinMap.get(asin)!.push(ingredientName);
    }
    
    // 2. Process each ASIN group
    const aliasGroups: IngredientAliasGroup[] = [];
    const conflicts: Array<{ asin: string; ingredients: string[]; reason: string }> = [];
    const singles: string[] = [];
    
    for (const [asin, ingredients] of asinMap) {
      if (ingredients.length === 1) {
        singles.push(ingredients[0]);
        continue;
      }
      
      // Check if this is a legitimate alias group or a conflict
      const analysis = this.analyzeIngredientGroup(ingredients);
      
      if (analysis.isLegitimate) {
        aliasGroups.push({
          groupId: this.generateGroupId(ingredients),
          canonicalName: this.selectCanonical(ingredients),
          aliases: ingredients,
          sharedASIN: asin,
          validationStatus: 'valid', // Will be validated
          confidence: 'medium',
          lastVerified: new Date(),
          groupingReason: analysis.reason,
          notes: analysis.explanation,
        });
      } else {
        conflicts.push({
          asin,
          ingredients,
          reason: analysis.explanation,
        });
      }
    }
    
    return { aliasGroups, conflicts, singles };
  }
  
  /**
   * Analyze a group of ingredients to determine if they're legitimate aliases
   */
  private analyzeIngredientGroup(ingredients: string[]): {
    isLegitimate: boolean;
    reason: 'same-base-ingredient' | 'known-synonyms' | 'manual-override';
    explanation: string;
  } {
    // Check 1: Known conflicts (different products incorrectly sharing ASIN)
    for (const [conflictA, conflictB] of KNOWN_CONFLICT_PATTERNS) {
      const hasA = ingredients.some(i => i.toLowerCase().includes(conflictA.toLowerCase()));
      const hasB = ingredients.some(i => i.toLowerCase().includes(conflictB.toLowerCase()));
      
      if (hasA && hasB) {
        return {
          isLegitimate: false,
          reason: 'manual-override',
          explanation: `Conflict detected: ${conflictA} and ${conflictB} are different products`,
        };
      }
    }
    
    // Check 2: Known synonym pairs (check all combinations)
    for (const [synonymA, synonymB] of KNOWN_SYNONYM_PAIRS) {
      const hasA = ingredients.some(i => i.toLowerCase().includes(synonymA.toLowerCase()));
      const hasB = ingredients.some(i => i.toLowerCase().includes(synonymB.toLowerCase()));
      
      if (hasA && hasB) {
        return {
          isLegitimate: true,
          reason: 'known-synonyms',
          explanation: `Known synonyms: "${synonymA}" and "${synonymB}"`,
        };
      }
    }
    
    // Check 2b: Transitive synonym relationships
    // If A‚ÜíB and B‚ÜíC are synonyms, then A‚ÜíC should also be grouped
    const synonymGroups = this.buildSynonymGroups(KNOWN_SYNONYM_PAIRS);
    for (const group of synonymGroups) {
      const matchCount = ingredients.filter(ing => 
        group.some(syn => ing.toLowerCase().includes(syn.toLowerCase()))
      ).length;
      
      if (matchCount >= 2) {
        return {
          isLegitimate: true,
          reason: 'known-synonyms',
          explanation: `Part of synonym group: ${group.slice(0, 3).join(', ')}`,
        };
      }
    }
    
    // Check 3: Same base ingredient with preparation variants
    // e.g., "peas" vs "peas (mashed)" vs "peas (cooked)"
    const baseNames = ingredients.map(i => this.extractBaseName(i));
    const uniqueBaseNames = new Set(baseNames);
    
    if (uniqueBaseNames.size === 1) {
      return {
        isLegitimate: true,
        reason: 'same-base-ingredient',
        explanation: `Same base ingredient with preparation variants: ${Array.from(uniqueBaseNames)[0]}`,
      };
    }
    
    // Check 4: Very similar names (Levenshtein distance)
    if (ingredients.length === 2) {
      const similarity = this.calculateSimilarity(ingredients[0], ingredients[1]);
      if (similarity > 0.8) {
        return {
          isLegitimate: true,
          reason: 'same-base-ingredient',
          explanation: `High name similarity (${Math.round(similarity * 100)}%)`,
        };
      }
    }
    
    // Default: flag for manual review
    return {
      isLegitimate: false,
      reason: 'manual-override',
      explanation: 'Ambiguous grouping - needs manual review',
    };
  }
  
  /**
   * Extract base ingredient name by removing preparation notes
   * "peas (mashed)" -> "peas"
   * "brown rice" -> "brown rice"
   */
  private extractBaseName(ingredient: string): string {
    // Remove parenthetical notes
    let base = ingredient.replace(/\s*\([^)]*\)/g, '').trim();
    
    // Remove common preparation prefixes/suffixes
    base = base.replace(/\s+(cooked|raw|fresh|frozen|mashed|ground|minced|chopped)$/i, '');
    
    return base.toLowerCase();
  }
  
  /**
   * Select canonical name from aliases (prefer shortest, most common)
   */
  private selectCanonical(ingredients: string[]): string {
    // Prefer names without parentheses
    const withoutParens = ingredients.filter(i => !i.includes('('));
    if (withoutParens.length > 0) {
      return withoutParens.sort((a, b) => a.length - b.length)[0];
    }
    
    // Otherwise, shortest name
    return ingredients.sort((a, b) => a.length - b.length)[0];
  }
  
  /**
   * Generate a unique group ID from ingredient names
   */
  private generateGroupId(ingredients: string[]): string {
    const base = this.extractBaseName(ingredients[0]);
    const hash = this.simpleHash(ingredients.join('|'));
    return `${base.replace(/\s+/g, '_')}_${hash}`;
  }
  
  /**
   * Extract ASIN from Amazon link
   */
  private extractASIN(link: string): string | null {
    const match = link.match(/\/dp\/([A-Z0-9]{10})/i);
    return match ? match[1] : null;
  }
  
  /**
   * Calculate string similarity (simple Levenshtein-based)
   */
  private calculateSimilarity(a: string, b: string): number {
    const longer = a.length > b.length ? a : b;
    const shorter = a.length > b.length ? b : a;
    
    if (longer.length === 0) return 1.0;
    
    const distance = this.levenshteinDistance(longer.toLowerCase(), shorter.toLowerCase());
    return (longer.length - distance) / longer.length;
  }
  
  /**
   * Levenshtein distance calculation
   */
  private levenshteinDistance(a: string, b: string): number {
    const matrix: number[][] = [];
    
    for (let i = 0; i <= b.length; i++) {
      matrix[i] = [i];
    }
    
    for (let j = 0; j <= a.length; j++) {
      matrix[0][j] = j;
    }
    
    for (let i = 1; i <= b.length; i++) {
      for (let j = 1; j <= a.length; j++) {
        if (b.charAt(i - 1) === a.charAt(j - 1)) {
          matrix[i][j] = matrix[i - 1][j - 1];
        } else {
          matrix[i][j] = Math.min(
            matrix[i - 1][j - 1] + 1,
            matrix[i][j - 1] + 1,
            matrix[i - 1][j] + 1
          );
        }
      }
    }
    
    return matrix[b.length][a.length];
  }
  
  /**
   * Simple hash function for group IDs
   */
  private simpleHash(str: string): string {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return Math.abs(hash).toString(36).substring(0, 6);
  }
  
  /**
   * Build transitive synonym groups from pairs
   * If A‚ÜíB and B‚ÜíC, then [A, B, C] form a group
   */
  private buildSynonymGroups(pairs: Array<[string, string]>): string[][] {
    const groups: string[][] = [];
    const processed = new Set<string>();
    
    for (const [a, b] of pairs) {
      if (processed.has(a) || processed.has(b)) continue;
      
      // Find all connected synonyms
      const group = new Set<string>([a, b]);
      let changed = true;
      
      while (changed) {
        changed = false;
        for (const [pairA, pairB] of pairs) {
          if (group.has(pairA) && !group.has(pairB)) {
            group.add(pairB);
            changed = true;
          }
          if (group.has(pairB) && !group.has(pairA)) {
            group.add(pairA);
            changed = true;
          }
        }
      }
      
      const groupArray = Array.from(group);
      groups.push(groupArray);
      groupArray.forEach(item => processed.add(item));
    }
    
    return groups;
  }
}
</file>

<file path="lib/validation/enhancedRetailValidator.ts">
// Enhanced retail validator with 4-state validation and token equivalence
// Separates structural (safety) from semantic (naming) concerns

import { IngredientRetailSpec, ValidationResult, ValidationIssue } from '../types/retailValidation';
import { tokenMatches, extractIngredientFamily } from './tokenEquivalence';

export class EnhancedRetailValidator {
  /**
   * Validate product title with 4-state logic and token equivalence
   * 
   * States:
   * - VALID: All required tokens matched exactly, no forbidden tokens
   * - STRUCTURALLY_VALID: Safe product, but uses equivalent tokens or flexible matching
   * - AMBIGUOUS: Too many missing tokens, needs human review
   * - INVALID: Contains forbidden tokens or critical failures
   */
  validateProductTitle(
    productTitle: string,
    spec: IngredientRetailSpec,
    asin: string,
    ingredientName?: string
  ): ValidationResult {
    const structuralIssues: ValidationIssue[] = [];
    const semanticIssues: ValidationIssue[] = [];
    
    const reasoning = {
      requiredTokensMatched: [] as string[],
      equivalentTokensUsed: [] as Array<{ token: string; synonym: string }>,
      forbiddenTokensFound: [] as string[],
      structurallySound: true,
    };
    
    const titleLower = spec.validationRules.caseSensitive ? productTitle : productTitle.toLowerCase();
    const ingredientFamily = ingredientName ? extractIngredientFamily(ingredientName) : undefined;
    
    // STEP 1: Check forbidden tokens (HARD FAIL - structural issue)
    for (const forbiddenToken of spec.forbiddenTokens) {
      const searchToken = spec.validationRules.caseSensitive ? forbiddenToken : forbiddenToken.toLowerCase();
      if (titleLower.includes(searchToken)) {
        reasoning.forbiddenTokensFound.push(forbiddenToken);
        reasoning.structurallySound = false;
        
        structuralIssues.push({
          type: 'has-forbidden',
          severity: 'critical',
          message: `Contains forbidden token: "${forbiddenToken}"`,
          details: { token: forbiddenToken },
        });
      }
    }
    
    // If forbidden tokens found, immediately return INVALID
    if (reasoning.forbiddenTokensFound.length > 0) {
      return {
        status: 'invalid',
        confidence: 'low',
        structuralIssues,
        semanticIssues,
        reasoning,
      };
    }
    
    // STEP 2: Check required tokens with equivalence (semantic issue if missing)
    const missingTokens: string[] = [];
    
    for (const requiredToken of spec.requiredTokens) {
      const match = tokenMatches(requiredToken, titleLower, ingredientFamily);
      
      if (match.matched) {
        if (match.via === 'direct') {
          reasoning.requiredTokensMatched.push(requiredToken);
        } else if (match.via === 'equivalent' && match.synonym) {
          reasoning.equivalentTokensUsed.push({
            token: requiredToken,
            synonym: match.synonym,
          });
        }
      } else {
        missingTokens.push(requiredToken);
      }
    }
    
    // STEP 3: Check acceptable forms (if specified)
    let formMatched = true;
    if (spec.acceptableForms && spec.acceptableForms.length > 0) {
      formMatched = spec.acceptableForms.some(form => {
        const searchForm = spec.validationRules.caseSensitive ? form : form.toLowerCase();
        return titleLower.includes(searchForm);
      });
      
      if (!formMatched) {
        semanticIssues.push({
          type: 'form-mismatch',
          severity: 'warning',
          message: `No acceptable form found. Expected one of: ${spec.acceptableForms.join(', ')}`,
          details: { acceptableForms: spec.acceptableForms },
        });
      }
    }
    
    // STEP 4: Determine status based on token matching
    const totalRequired = spec.requiredTokens.length;
    const directMatches = reasoning.requiredTokensMatched.length;
    const equivalentMatches = reasoning.equivalentTokensUsed.length;
    const totalMatches = directMatches + equivalentMatches;
    const matchRate = totalMatches / totalRequired;
    
    // Add semantic issues for missing tokens
    if (missingTokens.length > 0) {
      const severity = matchRate < 0.5 ? 'critical' : 'warning';
      semanticIssues.push({
        type: 'missing-required',
        severity,
        message: `Missing ${missingTokens.length} required token(s): ${missingTokens.join(', ')}`,
        details: { missing: missingTokens, matchRate },
      });
    }
    
    // DECISION LOGIC
    let status: ValidationResult['status'];
    let confidence: ValidationResult['confidence'];
    
    if (totalMatches === totalRequired && directMatches === totalRequired && formMatched) {
      // Perfect match: all tokens direct, form correct
      status = 'valid';
      confidence = 'high';
    } else if (totalMatches === totalRequired) {
      // All tokens matched via equivalence or flexible matching
      status = 'structurally-valid';
      confidence = equivalentMatches > 0 ? 'medium' : 'high';
    } else if (matchRate >= 0.6 && spec.validationRules.titleMatch === 'flexible') {
      // Flexible mode: 60%+ tokens matched
      status = 'structurally-valid';
      confidence = 'medium';
    } else if (matchRate >= 0.5) {
      // Borderline: needs human review
      status = 'ambiguous';
      confidence = 'low';
    } else {
      // Too many missing tokens
      status = 'ambiguous';
      confidence = 'low';
    }
    
    return {
      status,
      confidence,
      structuralIssues,
      semanticIssues,
      reasoning,
    };
  }
  
  /**
   * Batch validate multiple products
   */
  validateBatch(
    products: Array<{
      ingredient: string;
      productTitle: string;
      asin: string;
      spec: IngredientRetailSpec;
    }>
  ): Map<string, ValidationResult> {
    const results = new Map<string, ValidationResult>();
    
    for (const product of products) {
      const result = this.validateProductTitle(
        product.productTitle,
        product.spec,
        product.asin,
        product.ingredient
      );
      results.set(product.ingredient, result);
    }
    
    return results;
  }
}
</file>

<file path="lib/validation/petSchema.ts">
// lib/validation/petSchema.ts
// Data validation schemas using Zod

import { z } from 'zod';

// Pet validation schema
export const PetSchema = z.object({
  id: z.string().min(1),
  names: z.array(z.string().min(1)).min(1, 'At least one name is required'),
  type: z.enum(['dogs', 'cats', 'birds', 'reptiles', 'pocket-pets']),
  breed: z.string().min(1, 'Breed is required'),
  age: z.enum(['baby', 'young', 'adult', 'senior']),
  weight: z.string().optional(),
  weightKg: z.number().positive().optional(),
  healthConcerns: z.array(z.string()).optional(),
  dietaryRestrictions: z.array(z.string()).optional(),
  allergies: z.array(z.string()).optional(),
  dislikes: z.array(z.string()).optional(),
  savedRecipes: z.array(z.string()).optional(),
  image: z.string().optional(),
});

// Custom meal validation schema
export const CustomMealSchema = z.object({
  id: z.string().min(1),
  petId: z.string().min(1),
  userId: z.string().min(1),
  name: z.string().min(1, 'Meal name is required').max(100),
  createdAt: z.string(),
  updatedAt: z.string(),
  ingredients: z.array(z.object({
    key: z.string().min(1),
    grams: z.number().positive('Grams must be positive'),
  })).min(1, 'At least one ingredient is required'),
  analysis: z.object({
    score: z.number().min(0).max(100),
    nutrients: z.record(z.number()),
    totalRecipeGrams: z.number().positive(),
    recommendedServingGrams: z.number().positive(),
    breakdown: z.object({
      nutrientCoverageScore: z.number(),
      toxicityPenalty: z.number(),
      balanceVarietyScore: z.number(),
    }),
    toxicityWarnings: z.array(z.any()),
    allergyWarnings: z.array(z.any()),
    nutrientWarnings: z.array(z.any()),
    suggestions: z.array(z.any()),
  }),
});

// Validation helpers
export function validatePet(data: unknown) {
  return PetSchema.parse(data);
}

export function validateCustomMeal(data: unknown) {
  return CustomMealSchema.parse(data);
}

export function validatePetPartial(data: unknown) {
  return PetSchema.partial().parse(data);
}
</file>

<file path="lib/validation/retailSpecDefinitions.ts">
// Retail specs for high-priority ingredients
// These define what makes a product valid for each ingredient
// 
// IMPORTANT: Specs should only encode retail form constraints, NOT quality/nutrition
// - YES: identity (chicken vs beef), preparation (raw vs cooked), medium (water vs oil)
// - NO: organic, grass-fed, quality language, micronutrients

import { IngredientRetailSpec } from '../types/retailValidation';

export const RETAIL_SPECS: Record<string, IngredientRetailSpec> = {
  // MEATS - High Priority Issues
  'venison': {
    requiredTokens: ['venison', 'deer'],
    forbiddenTokens: ['beef', 'seasoned', 'jerky', 'cooked', 'smoked', 'marinated', 'sausage'],
    acceptableForms: ['raw', 'ground', 'frozen', 'fresh'],
    validationRules: {
      titleMatch: 'strict',
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
  
  'rabbit meat': {
    requiredTokens: ['rabbit'],
    forbiddenTokens: ['lamb', 'seasoned', 'cooked', 'smoked', 'marinated'],
    acceptableForms: ['raw', 'ground', 'frozen', 'fresh', 'whole'],
    validationRules: {
      titleMatch: 'strict',
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
  
  'turkey giblets': {
    requiredTokens: ['turkey', 'giblets'],
    forbiddenTokens: ['chicken', 'seasoned', 'cooked', 'gravy'],
    acceptableForms: ['raw', 'frozen', 'fresh'],
    validationRules: {
      titleMatch: 'strict',
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
  
  'ground beef (lean)': {
    requiredTokens: ['beef', 'ground'],
    forbiddenTokens: ['venison', 'seasoned', 'cooked', 'patties', 'burger'],
    acceptableForms: ['raw', 'frozen', 'fresh', 'lean'],
    validationRules: {
      titleMatch: 'strict',
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
  
  'ground lamb': {
    requiredTokens: ['lamb', 'ground'],
    forbiddenTokens: ['rabbit', 'beef', 'seasoned', 'cooked', 'kebab', 'kofta'],
    acceptableForms: ['raw', 'frozen', 'fresh'],
    validationRules: {
      titleMatch: 'strict',
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
  
  'chicken hearts': {
    requiredTokens: ['chicken', 'hearts'],
    forbiddenTokens: ['turkey', 'duck', 'seasoned', 'cooked'],
    acceptableForms: ['raw', 'frozen', 'fresh'],
    validationRules: {
      titleMatch: 'strict',
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
  
  'duck hearts': {
    requiredTokens: ['duck', 'hearts'],
    forbiddenTokens: ['chicken', 'turkey', 'egg', 'seasoned', 'cooked'],
    acceptableForms: ['raw', 'frozen', 'fresh'],
    validationRules: {
      titleMatch: 'strict',
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
  
  // FISH - High Priority Issues
  'herring (canned)': {
    requiredTokens: ['herring'],
    forbiddenTokens: ['sardines', 'sardine', 'smoked', 'pickled', 'creamed', 'in oil'],
    acceptableForms: ['canned', 'in water', 'water packed'],
    validationRules: {
      titleMatch: 'strict',
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
  
  'sardines (canned in water)': {
    requiredTokens: ['sardines', 'water'],
    forbiddenTokens: ['herring', 'in oil', 'smoked', 'tomato'],
    acceptableForms: ['canned', 'water packed'],
    validationRules: {
      titleMatch: 'strict',
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
  
  'sardines (in water)': {
    requiredTokens: ['sardines', 'water'],
    forbiddenTokens: ['herring', 'in oil', 'smoked', 'tomato'],
    acceptableForms: ['canned', 'water packed'],
    validationRules: {
      titleMatch: 'strict',
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
  
  // SEEDS - High Priority Issues
  'canary seed': {
    requiredTokens: ['canary', 'seed'],
    forbiddenTokens: ['mix', 'blend', 'treat'],
    validationRules: {
      titleMatch: 'flexible', // Seed mixes might be OK
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
  
  'flaxseeds': {
    requiredTokens: ['flax'],
    forbiddenTokens: ['oil', 'meal', 'capsule', 'supplement'],
    acceptableForms: ['seed', 'seeds', 'whole', 'ground'],
    validationRules: {
      titleMatch: 'strict',
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
  
  'niger seed': {
    requiredTokens: ['niger', 'nyjer', 'thistle'],
    forbiddenTokens: ['mix', 'blend'],
    validationRules: {
      titleMatch: 'flexible',
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
  
  'hemp seeds': {
    requiredTokens: ['hemp', 'seed'],
    forbiddenTokens: ['oil', 'protein', 'powder', 'hearts'],
    acceptableForms: ['seed', 'seeds', 'whole', 'hulled'],
    validationRules: {
      titleMatch: 'strict',
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
  
  'chia seeds': {
    requiredTokens: ['chia', 'seed'],
    forbiddenTokens: ['oil', 'powder', 'gel'],
    acceptableForms: ['seed', 'seeds', 'whole'],
    validationRules: {
      titleMatch: 'strict',
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
  
  'sunflower seeds (small amounts)': {
    requiredTokens: ['sunflower', 'seed'],
    forbiddenTokens: ['oil', 'roasted', 'salted', 'flavored'],
    acceptableForms: ['raw', 'shelled', 'unshelled'],
    validationRules: {
      titleMatch: 'strict',
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
  
  'pumpkin seeds': {
    requiredTokens: ['pumpkin', 'seed'],
    forbiddenTokens: ['oil', 'roasted', 'salted', 'flavored'],
    acceptableForms: ['raw', 'shelled', 'pepitas'],
    validationRules: {
      titleMatch: 'strict',
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
  
  // OILS - High Priority Issues
  'chia seed oil': {
    requiredTokens: ['chia', 'oil'],
    forbiddenTokens: ['mango', 'blend', 'capsule'],
    validationRules: {
      titleMatch: 'strict',
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
  
  // EGGS - High Priority Issues
  'egg (hard-boiled)': {
    requiredTokens: ['egg'],
    forbiddenTokens: ['duck', 'quail', 'liquid', 'powder', 'substitute'],
    acceptableForms: ['hard boiled', 'hard-boiled', 'boiled', 'whole'],
    validationRules: {
      titleMatch: 'strict',
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
  
  // VEGETABLES - Dead Link
  'endive': {
    requiredTokens: ['endive'],
    forbiddenTokens: [],
    acceptableForms: ['fresh', 'organic'],
    validationRules: {
      titleMatch: 'strict',
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
  
  // GRAINS
  'brown rice': {
    requiredTokens: ['brown', 'rice'],
    forbiddenTokens: ['white', 'instant', 'minute', 'flavored', 'seasoned'],
    acceptableForms: ['whole grain', 'long grain', 'short grain'],
    validationRules: {
      titleMatch: 'flexible',
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
  
  'rice (hulled)': {
    requiredTokens: ['rice', 'hulled'],
    forbiddenTokens: ['white', 'instant', 'minute', 'flavored', 'seasoned'],
    validationRules: {
      titleMatch: 'flexible',
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
  
  // COMMON PROTEINS - Dogs/Cats
  'ground chicken': {
    requiredTokens: ['chicken', 'ground'],
    forbiddenTokens: ['giblets', 'liver', 'hearts', 'seasoned', 'cooked', 'breaded'],
    acceptableForms: ['raw', 'fresh', 'frozen'],
    validationRules: {
      titleMatch: 'strict',
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
  
  'chicken breast': {
    requiredTokens: ['chicken', 'breast'],
    forbiddenTokens: ['seasoned', 'cooked', 'breaded', 'marinated', 'fried'],
    acceptableForms: ['raw', 'fresh', 'frozen', 'boneless'],
    validationRules: {
      titleMatch: 'strict',
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
  
  'chicken thighs': {
    requiredTokens: ['chicken', 'thigh'],
    forbiddenTokens: ['seasoned', 'cooked', 'breaded', 'marinated', 'fried'],
    acceptableForms: ['raw', 'fresh', 'frozen', 'boneless'],
    validationRules: {
      titleMatch: 'strict',
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
  
  'beef liver': {
    requiredTokens: ['beef', 'liver'],
    forbiddenTokens: ['pork', 'chicken', 'seasoned', 'cooked'],
    acceptableForms: ['raw', 'fresh', 'frozen'],
    validationRules: {
      titleMatch: 'strict',
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
  
  'ground turkey': {
    requiredTokens: ['turkey', 'ground'],
    forbiddenTokens: ['chicken', 'seasoned', 'cooked', 'patties'],
    acceptableForms: ['raw', 'fresh', 'frozen'],
    validationRules: {
      titleMatch: 'strict',
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
  
  'salmon (canned)': {
    requiredTokens: ['salmon'],
    forbiddenTokens: ['smoked', 'seasoned', 'in oil'],
    acceptableForms: ['canned', 'in water', 'water packed'],
    validationRules: {
      titleMatch: 'strict',
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
  
  'tuna (canned in water)': {
    requiredTokens: ['tuna', 'water'],
    forbiddenTokens: ['in oil', 'seasoned', 'flavored'],
    acceptableForms: ['canned', 'water packed'],
    validationRules: {
      titleMatch: 'strict',
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
  
  // COMMON VEGETABLES
  'carrots': {
    requiredTokens: ['carrot'],
    forbiddenTokens: ['candied', 'glazed', 'seasoned'],
    acceptableForms: ['raw', 'fresh', 'baby', 'whole'],
    validationRules: {
      titleMatch: 'flexible',
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
  
  'broccoli': {
    requiredTokens: ['broccoli'],
    forbiddenTokens: ['cheese', 'seasoned', 'sauce'],
    acceptableForms: ['raw', 'fresh', 'frozen', 'florets'],
    validationRules: {
      titleMatch: 'flexible',
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
  
  'spinach': {
    requiredTokens: ['spinach'],
    forbiddenTokens: ['creamed', 'seasoned', 'sauce'],
    acceptableForms: ['raw', 'fresh', 'frozen', 'baby'],
    validationRules: {
      titleMatch: 'flexible',
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
  
  'sweet potato': {
    requiredTokens: ['sweet potato'],
    forbiddenTokens: ['candied', 'glazed', 'seasoned', 'fries'],
    acceptableForms: ['raw', 'fresh', 'whole'],
    validationRules: {
      titleMatch: 'flexible',
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
  
  'pumpkin (canned)': {
    requiredTokens: ['pumpkin'],
    forbiddenTokens: ['pie filling', 'spice', 'seasoned'],
    acceptableForms: ['canned', 'puree', 'pure'],
    validationRules: {
      titleMatch: 'strict',
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
  
  // COMMON SUPPLEMENTS
  'fish oil': {
    requiredTokens: ['fish', 'oil'],
    forbiddenTokens: ['capsule only'],
    acceptableForms: ['liquid', 'omega-3', 'omega 3'],
    validationRules: {
      titleMatch: 'strict',
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
  
  'salmon oil': {
    requiredTokens: ['salmon', 'oil'],
    forbiddenTokens: [],
    acceptableForms: ['liquid', 'omega-3', 'omega 3'],
    validationRules: {
      titleMatch: 'strict',
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
  
  'coconut oil': {
    requiredTokens: ['coconut', 'oil'],
    forbiddenTokens: ['scented', 'cosmetic'],
    acceptableForms: ['virgin', 'unrefined', 'refined'],
    validationRules: {
      titleMatch: 'strict',
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
  
  'probiotic': {
    requiredTokens: ['probiotic'],
    forbiddenTokens: [],
    acceptableForms: ['powder', 'capsule', 'supplement'],
    validationRules: {
      titleMatch: 'flexible',
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
  
  'digestive enzyme': {
    requiredTokens: ['digestive', 'enzyme'],
    forbiddenTokens: [],
    acceptableForms: ['powder', 'capsule', 'supplement'],
    validationRules: {
      titleMatch: 'flexible',
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
  
  // GRAINS
  'oats': {
    requiredTokens: ['oat'],
    forbiddenTokens: ['instant', 'flavored', 'sweetened'],
    acceptableForms: ['rolled', 'steel cut', 'whole'],
    validationRules: {
      titleMatch: 'flexible',
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
  
  'quinoa': {
    requiredTokens: ['quinoa'],
    forbiddenTokens: ['flavored', 'seasoned', 'instant'],
    acceptableForms: ['white', 'red', 'tri-color', 'whole'],
    validationRules: {
      titleMatch: 'flexible',
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
  
  'barley': {
    requiredTokens: ['barley'],
    forbiddenTokens: ['pearled only', 'instant'],
    acceptableForms: ['whole', 'hulled', 'pearled'],
    validationRules: {
      titleMatch: 'flexible',
      allowGenericBrand: true,
      caseSensitive: false,
    },
  },
};
</file>

<file path="lib/validation/retailValidator.ts">
// Title-based retail validation (Phase 1 - no PA-API yet)
// Validates product titles against ingredient specs

import { IngredientRetailSpec, ValidationResult, ValidationIssue, ProductMetadata } from '../types/retailValidation';

export class RetailValidator {
  /**
   * Validate a product title against an ingredient spec
   * This is Phase 1: simple title parsing without PA-API
   */
  validateProductTitle(
    productTitle: string,
    spec: IngredientRetailSpec,
    asin: string
  ): ValidationResult {
    const issues: ValidationIssue[] = [];
    const titleLower = spec.validationRules.caseSensitive ? productTitle : productTitle.toLowerCase();
    
    // Check required tokens
    const missingRequired = spec.requiredTokens.filter(token => {
      const searchToken = spec.validationRules.caseSensitive ? token : token.toLowerCase();
      return !titleLower.includes(searchToken);
    });
    
    if (missingRequired.length > 0) {
      if (spec.validationRules.titleMatch === 'strict') {
        issues.push({
          type: 'missing-required',
          severity: 'critical',
          message: `Missing required tokens: ${missingRequired.join(', ')}`,
          details: { missing: missingRequired },
        });
      } else {
        // Flexible: allow if most tokens present
        const matchRate = (spec.requiredTokens.length - missingRequired.length) / spec.requiredTokens.length;
        if (matchRate < 0.6) {
          issues.push({
            type: 'missing-required',
            severity: 'warning',
            message: `Only ${Math.round(matchRate * 100)}% of required tokens present`,
            details: { missing: missingRequired, matchRate },
          });
        }
      }
    }
    
    // Check forbidden tokens
    const foundForbidden = spec.forbiddenTokens.filter(token => {
      const searchToken = spec.validationRules.caseSensitive ? token : token.toLowerCase();
      return titleLower.includes(searchToken);
    });
    
    if (foundForbidden.length > 0) {
      issues.push({
        type: 'has-forbidden',
        severity: 'critical',
        message: `Contains forbidden tokens: ${foundForbidden.join(', ')}`,
        details: { forbidden: foundForbidden },
      });
    }
    
    // Check acceptable forms (if specified)
    if (spec.acceptableForms && spec.acceptableForms.length > 0) {
      const hasAcceptableForm = spec.acceptableForms.some(form => {
        const searchForm = spec.validationRules.caseSensitive ? form : form.toLowerCase();
        return titleLower.includes(searchForm);
      });
      
      if (!hasAcceptableForm) {
        issues.push({
          type: 'form-mismatch',
          severity: 'warning',
          message: `No acceptable form found. Expected one of: ${spec.acceptableForms.join(', ')}`,
          details: { acceptableForms: spec.acceptableForms },
        });
      }
    }
    
    // Determine status and confidence
    const criticalIssues = issues.filter(i => i.severity === 'critical');
    const warningIssues = issues.filter(i => i.severity === 'warning');
    
    let status: ValidationResult['status'];
    let confidence: ValidationResult['confidence'];
    
    if (criticalIssues.length > 0) {
      status = 'invalid';
      confidence = 'low';
    } else if (warningIssues.length > 0) {
      status = 'ambiguous';
      confidence = 'medium';
    } else {
      status = 'valid';
      confidence = 'high';
    }
    
    // Create basic metadata from what we have
    const metadata: ProductMetadata = {
      asin,
      title: productTitle,
      availability: 'unknown',
      lastFetched: new Date(),
    };
    
    return {
      status,
      confidence,
      issues,
      metadata,
    };
  }
  
  /**
   * Batch validate multiple products
   */
  validateBatch(
    products: Array<{ ingredient: string; productTitle: string; asin: string; spec: IngredientRetailSpec }>
  ): Map<string, ValidationResult> {
    const results = new Map<string, ValidationResult>();
    
    for (const product of products) {
      const result = this.validateProductTitle(product.productTitle, product.spec, product.asin);
      results.set(product.ingredient, result);
    }
    
    return results;
  }
  
  /**
   * Extract package size from title (basic heuristic)
   * This will be improved with PA-API in Phase 2
   */
  extractPackageSize(title: string): { amount: number; unit: string; raw: string } | null {
    // Common patterns: "2 lb", "16 oz", "1 kg", "500g", "12 count"
    const patterns = [
      /(\d+\.?\d*)\s*(lb|lbs|pound|pounds)/i,
      /(\d+\.?\d*)\s*(oz|ounce|ounces)/i,
      /(\d+\.?\d*)\s*(kg|kilogram|kilograms)/i,
      /(\d+\.?\d*)\s*(g|gram|grams)/i,
      /(\d+)\s*(count|ct|pack|pieces)/i,
    ];
    
    for (const pattern of patterns) {
      const match = title.match(pattern);
      if (match) {
        return {
          amount: parseFloat(match[1]),
          unit: match[2].toLowerCase(),
          raw: match[0],
        };
      }
    }
    
    return null;
  }
}
</file>

<file path="lib/validation/tokenEquivalence.ts">
// Token equivalence mapping - handles lexical variants that mean the same thing
// Keep this SMALL and EXPLICIT - no regex expansion, no ML

export interface TokenEquivalenceMap {
  [ingredientFamily: string]: {
    [canonicalToken: string]: string[];
  };
}

// Small, explicit synonym table
// Format: canonical token -> acceptable synonyms
export const TOKEN_EQUIVALENCE: TokenEquivalenceMap = {
  // Rice family
  rice: {
    'hulled': ['brown', 'whole grain', 'unmilled'],
    'white': ['polished', 'refined', 'milled'],
    'long grain': ['basmati', 'jasmine'],
    'short grain': ['arborio', 'sushi'],
  },
  
  // Fish - canning medium
  sardines: {
    'water packed': ['in water', 'water', 'brine'],
    'oil packed': ['in oil', 'olive oil', 'soybean oil'],
    'canned': ['tinned', 'preserved'],
  },
  
  herring: {
    'water packed': ['in water', 'water', 'brine'],
    'canned': ['tinned', 'preserved'],
  },
  
  tuna: {
    'water packed': ['in water', 'water', 'brine'],
    'oil packed': ['in oil', 'olive oil'],
    'canned': ['tinned', 'preserved'],
  },
  
  salmon: {
    'canned': ['tinned', 'preserved'],
    'wild': ['wild caught', 'wild-caught'],
    'fresh': ['raw', 'uncooked'],
  },
  
  // Chicken preparation
  chicken: {
    'raw': ['fresh', 'uncooked'],
    'ground': ['minced', 'mince'],
    'breast': ['white meat'],
    'thigh': ['dark meat'],
    'whole': ['entire', 'complete'],
  },
  
  // Beef preparation
  beef: {
    'raw': ['fresh', 'uncooked'],
    'ground': ['minced', 'mince', 'hamburger'],
    'lean': ['extra lean', '90/10', '93/7', '95/5'],
    'grass fed': ['grass-fed', 'pasture raised'],
  },
  
  // Lamb preparation
  lamb: {
    'raw': ['fresh', 'uncooked'],
    'ground': ['minced', 'mince'],
    'leg': ['shank'],
  },
  
  // Turkey preparation
  turkey: {
    'raw': ['fresh', 'uncooked'],
    'ground': ['minced', 'mince'],
    'breast': ['white meat'],
  },
  
  // Pork preparation
  pork: {
    'raw': ['fresh', 'uncooked'],
    'ground': ['minced', 'mince'],
    'lean': ['trimmed', 'fat removed'],
  },
  
  // Duck preparation
  duck: {
    'raw': ['fresh', 'uncooked'],
    'whole': ['entire', 'complete'],
  },
  
  // Venison preparation
  venison: {
    'raw': ['fresh', 'uncooked'],
    'ground': ['minced', 'mince'],
    'deer': ['elk', 'game'],
  },
  
  // Rabbit preparation
  rabbit: {
    'raw': ['fresh', 'uncooked'],
    'whole': ['entire', 'complete'],
  },
  
  // Eggs
  egg: {
    'hard boiled': ['hard-boiled', 'boiled', 'cooked'],
    'whole': ['entire', 'complete', 'shell on'],
    'chicken': ['hen'],
  },
  
  // Vegetables - preparation
  vegetable: {
    'raw': ['fresh', 'uncooked'],
    'cooked': ['steamed', 'boiled'],
    'organic': ['organically grown'],
  },
  
  // Carrots
  carrot: {
    'raw': ['fresh', 'uncooked'],
    'baby': ['small', 'mini'],
  },
  
  // Broccoli
  broccoli: {
    'raw': ['fresh', 'uncooked'],
    'florets': ['crowns', 'heads'],
  },
  
  // Spinach
  spinach: {
    'raw': ['fresh', 'uncooked'],
    'baby': ['young', 'tender'],
  },
  
  // Sweet potato
  'sweet potato': {
    'raw': ['fresh', 'uncooked'],
    'yam': ['sweet yam'],
  },
  
  // Peas
  peas: {
    'green': ['garden', 'english'],
    'split': ['dried'],
    'sugar snap': ['snap', 'edible pod'],
  },
  
  // Seeds
  seed: {
    'whole': ['intact', 'unprocessed'],
    'raw': ['unroasted', 'natural'],
    'shelled': ['hulled', 'dehulled'],
  },
  
  // Flax
  flax: {
    'ground': ['milled', 'meal'],
    'whole': ['intact', 'seed'],
  },
  
  // Chia
  chia: {
    'whole': ['intact', 'seed'],
    'black': ['dark'],
  },
  
  // Hemp
  hemp: {
    'hulled': ['shelled', 'hearts'],
    'whole': ['intact', 'seed'],
  },
  
  // Nuts
  nut: {
    'raw': ['unroasted', 'natural', 'unsalted'],
    'whole': ['intact', 'unprocessed'],
    'chopped': ['pieces', 'crushed'],
  },
  
  // Almond
  almond: {
    'raw': ['unroasted', 'natural'],
    'whole': ['intact'],
    'sliced': ['slivered'],
  },
  
  // Walnut
  walnut: {
    'raw': ['unroasted', 'natural'],
    'halves': ['pieces'],
  },
  
  // Oils
  oil: {
    'extra virgin': ['cold pressed', 'unrefined'],
    'refined': ['processed'],
  },
  
  // Fish oil
  'fish oil': {
    'omega 3': ['omega-3', 'dha', 'epa'],
    'liquid': ['oil'],
  },
  
  // Supplements
  supplement: {
    'powder': ['powdered'],
    'capsule': ['pill', 'tablet'],
    'liquid': ['oil', 'tincture'],
  },
  
  // Prebiotic
  prebiotic: {
    'fiber': ['fibre'],
    'inulin': ['chicory root', 'fos'],
  },
  
  // Probiotic
  probiotic: {
    'live': ['active', 'viable'],
    'culture': ['bacteria', 'strain'],
  },
  
  // Joint supplements
  joint: {
    'glucosamine': ['glucosamine sulfate', 'glucosamine hcl'],
    'chondroitin': ['chondroitin sulfate'],
    'msm': ['methylsulfonylmethane'],
  },
  
  // Grains
  grain: {
    'whole': ['intact', 'unprocessed'],
    'rolled': ['flaked'],
  },
  
  // Oats
  oats: {
    'rolled': ['old fashioned', 'flaked'],
    'steel cut': ['irish', 'pinhead'],
    'whole': ['groats'],
  },
  
  // Quinoa
  quinoa: {
    'white': ['ivory'],
    'red': ['crimson'],
    'whole': ['grain'],
  },
  
  // Hay (for pocket pets)
  hay: {
    'timothy': ['grass hay'],
    'alfalfa': ['lucerne'],
    'orchard': ['orchard grass'],
  },
  
  // Pellets
  pellet: {
    'fortified': ['enriched', 'supplemented'],
    'complete': ['balanced', 'all-in-one'],
  },
};

/**
 * Get equivalent tokens for a given ingredient family and canonical token
 */
export function getEquivalentTokens(
  ingredientFamily: string | undefined,
  canonicalToken: string
): string[] {
  if (!ingredientFamily) return [];
  
  const familyMap = TOKEN_EQUIVALENCE[ingredientFamily.toLowerCase()];
  if (!familyMap) return [];
  
  const equivalents = familyMap[canonicalToken.toLowerCase()];
  return equivalents || [];
}

/**
 * Check if a token matches either directly or via equivalence
 */
export function tokenMatches(
  searchToken: string,
  targetText: string,
  ingredientFamily?: string
): { matched: boolean; via: 'direct' | 'equivalent' | null; synonym?: string } {
  const searchLower = searchToken.toLowerCase();
  const targetLower = targetText.toLowerCase();
  
  // Direct match
  if (targetLower.includes(searchLower)) {
    return { matched: true, via: 'direct' };
  }
  
  // Check equivalents
  if (ingredientFamily) {
    const equivalents = getEquivalentTokens(ingredientFamily, searchToken);
    for (const equiv of equivalents) {
      if (targetLower.includes(equiv.toLowerCase())) {
        return { matched: true, via: 'equivalent', synonym: equiv };
      }
    }
  }
  
  return { matched: false, via: null };
}

/**
 * Extract ingredient family from ingredient name
 * Used to determine which equivalence map to use
 */
export function extractIngredientFamily(ingredientName: string): string | undefined {
  const name = ingredientName.toLowerCase();
  
  // Check for known families (order matters - most specific first)
  
  // Specific proteins
  if (name.includes('venison') || name.includes('deer')) return 'venison';
  if (name.includes('rabbit')) return 'rabbit';
  if (name.includes('duck')) return 'duck';
  if (name.includes('pork')) return 'pork';
  if (name.includes('turkey')) return 'turkey';
  if (name.includes('lamb')) return 'lamb';
  if (name.includes('beef')) return 'beef';
  if (name.includes('chicken')) return 'chicken';
  
  // Fish
  if (name.includes('salmon')) return 'salmon';
  if (name.includes('tuna')) return 'tuna';
  if (name.includes('sardine')) return 'sardines';
  if (name.includes('herring')) return 'herring';
  
  // Eggs
  if (name.includes('egg')) return 'egg';
  
  // Specific vegetables
  if (name.includes('sweet potato') || name.includes('yam')) return 'sweet potato';
  if (name.includes('carrot')) return 'carrot';
  if (name.includes('broccoli')) return 'broccoli';
  if (name.includes('spinach')) return 'spinach';
  if (name.includes('pea')) return 'peas';
  
  // Specific seeds
  if (name.includes('flax')) return 'flax';
  if (name.includes('chia')) return 'chia';
  if (name.includes('hemp')) return 'hemp';
  
  // Specific nuts
  if (name.includes('almond')) return 'almond';
  if (name.includes('walnut')) return 'walnut';
  
  // Grains
  if (name.includes('rice')) return 'rice';
  if (name.includes('oat')) return 'oats';
  if (name.includes('quinoa')) return 'quinoa';
  
  // Supplements
  if (name.includes('fish oil') || name.includes('omega')) return 'fish oil';
  if (name.includes('prebiotic') || name.includes('inulin') || name.includes('fos')) return 'prebiotic';
  if (name.includes('probiotic')) return 'probiotic';
  if (name.includes('joint') || name.includes('glucosamine') || name.includes('chondroitin')) return 'joint';
  
  // Hay (pocket pets)
  if (name.includes('hay') || name.includes('timothy') || name.includes('alfalfa')) return 'hay';
  
  // Pellets
  if (name.includes('pellet')) return 'pellet';
  
  // Generic categories
  if (name.includes('seed')) return 'seed';
  if (name.includes('nut')) return 'nut';
  if (name.includes('oil')) return 'oil';
  if (name.includes('supplement')) return 'supplement';
  if (name.includes('vegetable') || name.includes('veggie')) return 'vegetable';
  if (name.includes('grain')) return 'grain';
  
  return undefined;
}
</file>

<file path="middleware.tsx">
import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server'

const isProtectedRoute = createRouteMatcher(['/profile(.*)'])

export default clerkMiddleware((auth, req) => {
  // Only protect routes that need authentication
  if (isProtectedRoute(req)) {
    auth.protect()
  }
})

export const config = {
  // Optimize matcher to exclude static files and only match necessary routes
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - api (API routes)
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * - public files (files in public folder)
     */
    '/((?!api|_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp|ico)).*)',
  ],
}
</file>

<file path="PetPlates">

</file>

<file path="src/utils/nutrition-data.ts">
// src/utils/nutrition-data.ts
// Consolidated nutritional data structures and calculation functions
// Moved from App.jsx for better code organization

import { INGREDIENT_COMPOSITIONS as INGREDIENT_COMPOSITIONS_DATA, type IngredientComposition, getIngredientComposition } from '../../lib/data/ingredientCompositions';
import exoticStandards from '../../lib/data/exotic-standards.json';

// Re-export INGREDIENT_COMPOSITIONS for backward compatibility
export const INGREDIENT_COMPOSITIONS = INGREDIENT_COMPOSITIONS_DATA;

// Export exotic standards as EXOTIC_TARGETS
export const EXOTIC_TARGETS = exoticStandards;

// Mock ingredient names (placeholder - update with actual data if needed)
export const MOCK_INGREDIENT_NAMES: string[] = [
  'Chicken Breast',
  'Ground Turkey',
  'Salmon',
  'Beef',
  'Eggs',
  'Kale',
  'Spinach',
  'Carrots',
  'Sweet Potato',
  'Pumpkin',
  'Broccoli',
  'Green Beans',
  'Brown Rice',
  'White Rice',
  'Oats',
  'Quinoa',
  'Blueberries',
  'Bananas'
];

/**
 * Calculate recipe nutrition from ingredients
 * Uses real USDA data when available, falls back to estimates
 */
export function calculateRecipeNutrients(recipe: any): {
  protein: number;
  fat: number;
  calcium: number;
  phosphorus: number;
  calories: number;
  omega3?: number;
  vitaminA?: number;
  vitaminC?: number;
  source: 'real' | 'estimated';
} {
  const ingredients = recipe.ingredients || [];
  let totalProtein = 0;
  let totalFat = 0;
  let totalCalcium = 0;
  let totalPhosphorus = 0;
  let totalCalories = 0;
  let totalOmega3 = 0;
  let totalVitaminA = 0;
  let totalVitaminC = 0;
  let totalWeight = 0;

  // Try to get real nutritional data
  for (const ingredient of ingredients) {
    const name = typeof ingredient === 'string' ? ingredient : ingredient.name;
    const amount = typeof ingredient === 'string' ? 100 : (ingredient.amount || 100); // Assume 100g if not specified

    const composition = getIngredientComposition(name);
    if (composition) {
      totalProtein += (composition.protein || 0) * (amount / 100);
      totalFat += (composition.fat || 0) * (amount / 100);
      totalCalcium += (composition.calcium || 0) * (amount / 100);
      totalPhosphorus += (composition.phosphorus || 0) * (amount / 100);
      totalCalories += (composition.kcal || 0) * (amount / 100);
      totalOmega3 += (composition.omega3 || 0) * (amount / 100);
      totalVitaminA += (composition.vitaminA || 0) * (amount / 100);
      totalVitaminC += (composition.vitaminC || 0) * (amount / 100);
      totalWeight += amount;
    }
  }

  // If we have real data for at least 50% of ingredients, use it
  const realDataRatio = totalWeight / (ingredients.length * 100);
  if (realDataRatio >= 0.5 && totalWeight > 0) {
    return {
      protein: totalProtein / totalWeight * 100,
      fat: totalFat / totalWeight * 100,
      calcium: totalCalcium / totalWeight * 100,
      phosphorus: totalPhosphorus / totalWeight * 100,
      calories: totalCalories / totalWeight * 100,
      omega3: totalOmega3 > 0 ? totalOmega3 / totalWeight * 100 : undefined,
      vitaminA: totalVitaminA > 0 ? totalVitaminA / totalWeight * 100 : undefined,
      vitaminC: totalVitaminC > 0 ? totalVitaminC / totalWeight * 100 : undefined,
      source: 'real'
    };
  }

  // Fall back to estimated values
  const name = recipe.name?.toLowerCase() || '';
  const ingredientsText = ingredients
    .map((i: any) => (typeof i === 'string' ? i : i.name).toLowerCase())
    .join(' ') || '';
  const allText = `${name} ${ingredientsText}`;

  // Estimate protein
  let estimatedProtein = 25;
  if (allText.includes('venison')) estimatedProtein = 34;
  else if (allText.includes('rabbit')) estimatedProtein = 33;
  else if (allText.includes('salmon') || allText.includes('fish')) estimatedProtein = 32;
  else if (allText.includes('chicken')) estimatedProtein = 30;
  else if (allText.includes('turkey')) estimatedProtein = 29;
  else if (allText.includes('beef')) estimatedProtein = 28;
  else if (allText.includes('pork')) estimatedProtein = 27;

  // Estimate fat
  let estimatedFat = 15;
  if (allText.includes('salmon') || allText.includes('duck')) estimatedFat = 18;
  else if (allText.includes('lean') || allText.includes('turkey')) estimatedFat = 10;
  else if (allText.includes('pork') || allText.includes('lamb')) estimatedFat = 16;

  // Estimate phosphorus
  let estimatedPhosphorus = 0.5;
  if (allText.includes('liver') || allText.includes('kidney') || allText.includes('organ')) {
    estimatedPhosphorus = 0.8;
  } else if (allText.includes('egg whites') || allText.includes('rice')) {
    estimatedPhosphorus = 0.3;
  }

  return {
    protein: estimatedProtein,
    fat: estimatedFat,
    calcium: 0.8, // Estimated
    phosphorus: estimatedPhosphorus,
    calories: 150, // Estimated
    source: 'estimated'
  };
}

// Re-export types for convenience
export type { IngredientComposition } from '../../lib/data/ingredientCompositions';
</file>

<file path="tailwind.config.ts">
import type { Config } from "tailwindcss";

const config: Config = {
  content: [
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
    "./lib/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {
      colors: {
        background: 'rgb(var(--background-start-rgb))',
        foreground: 'rgb(var(--foreground-rgb))',
        'dark-green': '#0f2c0f',
        surface: {
          DEFAULT: '#143424',
          highlight: '#1e4a36',
          lighter: '#2a6148',
        },
        "surface-highlight": "#1e4a36",
        primary: {
          50: "#f0fdf4",
          100: "#dcfce7",
          200: "#bbf7d0",
          300: "#86efac",
          400: "#4ade80",
          500: "#22c55e",
          600: "#16a34a",
          700: "#15803d",
          800: "#166534",
          900: "#14532d",
        },
        secondary: {
          50: "#fff7ed",
          100: "#ffedd5",
          200: "#fed7aa",
          300: "#fdba74",
          400: "#fb923c",
          500: "#f97316",
          600: "#ea580c",
          700: "#c2410c",
          800: "#9a3412",
          900: "#7c2d12",
        },
      },
      backgroundImage: {
        "gradient-radial": "radial-gradient(var(--tw-gradient-stops))",
        "gradient-conic": "conic-gradient(from 180deg at 50% 50%, var(--tw-gradient-stops))",
      },
      keyframes: {
        float: {
          "0%, 100%": { transform: "translateY(0px)" },
          "50%": { transform: "translateY(-10px)" },
        },
        breathe: {
          "0%, 100%": { transform: "scale(1)" },
          "50%": { transform: "scale(1.02)" },
        },
      },
      animation: {
        float: "float 3s ease-in-out infinite",
        breathe: "breathe 2s ease-in-out infinite",
      },
    },
  },
  plugins: [],
};

export default config;
</file>

</files>
