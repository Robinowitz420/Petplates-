# Recipe Generation Framework - Corrected Assessment
**Revision:** December 17, 2025 | **Status:** Honest Liability Assessment

---

## EXECUTIVE REFRAME

The initial audit was **architecturally correct but strategically optimistic**. This document corrects that.

**The system is NOT production-ready for external users.** It is production-ready for internal testing with mandatory human review.

---

## WHAT THE SYSTEM ACTUALLY IS

### Strengths (Genuinely)
- ✅ **Biological grammar engine** — Correctly encodes "what is a recipe" as nonexistence, not penalty
- ✅ **Defense-in-depth redundancy** — Heuristic pruning + hard gates is the right architecture
- ✅ **Constraint satisfaction** — Retry logic with failed ingredient tracking prevents infinite loops
- ✅ **99% generation success** — High reliability without permissiveness

### Critical Gaps (Liability)
- ❌ **Micronutrient blindness** — T1/T2/T3 disabled = cannot claim nutritional completeness
- ❌ **Copper/iodine unknown** — Species- and size-dependent toxicity cannot be validated
- ❌ **Vitamin D missing** — Not optional in home-prepared diets
- ❌ **Silent failure mode** — Recipes pass all gates, score well, deficiency emerges over weeks

### What This Means
A recipe generated by this system can:
- ✅ Pass all hard gates
- ✅ Score high on palatability and health
- ❌ Cause slow micronutrient deficiency
- ❌ Appear nutritionally complete (but isn't)

**This is not acute toxicity. This is a liability gap.**

---

## CRITICAL ISSUES (REFRAMED)

### 1. S1 Relaxation Breaks Core Invariant

**Current Code:**
```typescript
const primaryProteins = ingredients.filter(ing =>
  ing.feedingRole === 'staple' && ing.category === 'protein'
);
results.push({
  passed: primaryProteins.length >= 1 && primaryProteins.length <= 2, // WRONG
  // ...
});
```

**Why This Is High-High Severity:**

The system assumes one dominant protein. This assumption is baked into:
- Scoring logic (palatability assumes single protein preference)
- Allergen inference (two proteins = two allergen profiles)
- Micronutrient aggregation (assumes one primary source)
- Composition rules (organ meat limits assume one protein base)

Allowing 2 primary proteins doesn't just violate aesthetics—it **breaks the mathematical model**.

**The Fix:**
```typescript
// Revert to strict enforcement
results.push({
  passed: primaryProteins.length === 1,
  ruleId: 'S1',
  message: `Exactly 1 primary protein required (found ${primaryProteins.length})`,
});

// Then fix ingredient data: mark exactly ONE protein per species as 'staple'
// All others: 'secondary' or 'treat'
```

**Effort:** 2 hours (data audit + updates)

---

### 2. Portion Calculation Is Inverted for Small Animals

**Current Logic:**
```typescript
const estimatedWeightKg = targetCalories / 100; // ~100 cal per kg
const proteinGrams = estimatedWeightKg * 8;     // Then multiply back
```

**The Problem:**

For a 2kg cat needing 150 cal/day:
- Estimated weight: 150 / 100 = 1.5kg ❌ (actual: 2kg)
- Protein grams: 1.5 * 8 = 12g (should be ~16g for 2kg cat)

For a 30kg dog needing 1000 cal/day:
- Estimated weight: 1000 / 100 = 10kg ❌ (actual: 30kg)
- Protein grams: 10 * 8 = 80g (should be ~240g for 30kg dog)

**This is not "rough." This is wrong.**

**The Fix:**
```typescript
interface GenerationConstraints {
  species: Species;
  lifeStage: 'puppy' | 'adult' | 'senior';
  petWeightKg?: number;  // ADD THIS
  targetCalories?: number;
  // ...
}

// Use actual weight
private calculatePortions(ingredients: Ingredient[]): PortionedIngredient[] {
  const petWeightKg = this.constraints.petWeightKg || 20; // Default 20kg dog
  
  for (const ing of ingredients) {
    let grams = 100;
    
    if (ing.category === 'protein') {
      grams = petWeightKg * 8; // 8g per kg
    } else if (ing.category === 'carb') {
      grams = petWeightKg * 6; // 6g per kg
    }
    // ...
  }
}
```

**Effort:** 1 hour

---

### 3. T1/T2/T3 Disabled = System Claims Completeness It Cannot Verify

**Current State:**
```typescript
// T1: Vitamin A (SOFT WARNING - disabled)
results.push({
  passed: true, // Always passes
  ruleId: 'T1',
  message: `Vitamin A tracking (${totalVitaminA} IU) - data limited`,
});
```

**The Liability:**

This system will generate recipes and claim they're nutritionally complete, but:
- Cannot validate vitamin A ceilings (T1 disabled)
- Cannot validate copper toxicity (T2 disabled)
- Cannot validate iodine toxicity (T3 disabled)

**The Fix:**

Promote unknowns from "soft warning" to "hard fail":

```typescript
// T1: Vitamin A ceiling
const totalVitaminA = ingredients.reduce((sum, ing) => sum + (ing.composition.vitaminA || 0), 0);

// If data is missing, FAIL (not pass)
const hasVitaminAData = ingredients.every(ing => ing.composition.vitaminA !== undefined);

results.push({
  passed: hasVitaminAData && totalVitaminA <= ceilings.vitaminA_IU,
  ruleId: 'T1',
  message: hasVitaminAData 
    ? `Vitamin A: ${totalVitaminA} IU (ceiling: ${ceilings.vitaminA_IU})`
    : `Vitamin A data incomplete - cannot validate`,
});
```

**Effort:** 30 minutes (code change) + 10 hours (data collection)

---

## ARCHITECTURAL ISSUES (BEYOND PHASE 1)

### 4. Organ Meat Enforcement Is Fragmented

**Current State:**

Organ meats are governed by:
1. **S2 (hard gate):** Count ≤ 1 per recipe
2. **Q5 (soft gate):** Weight ≤ 10% (penalty if over)
3. **Heuristic pruning:** Risk scoring based on vitamin A + iodine

**The Problem:**

This is cognitively expensive and fragile. Once micronutrient data exists, organ meats should be treated as **radioactive isotopes**:
- Allowed only in narrow nutrient bands
- Governed primarily by copper/vitamin A ceilings
- Composition rules act as guardrails, not primary enforcement

**Why This Matters:**

Right now, liver is doing too much work:
- Palatability booster (100 for dogs)
- Nutrient source (high iron, B12)
- Risk factor (vitamin A spike)

This is why liver keeps showing up in failure modes. The system uses it to compensate for incomplete scoring.

**The Fix (Phase 2):**

```typescript
// Organ meats should be nutrient-ceiling-primary
export function validateOrganMeatByNutrients(
  ingredients: Ingredient[],
  species: Species
): SafetyRuleResult {
  const organMeats = ingredients.filter(ing => isOrganMeat(ing));
  if (organMeats.length === 0) {
    return { passed: true, ruleId: 'T_ORGAN', message: 'No organ meats' };
  }

  // Primary enforcement: nutrient ceilings
  const totalCopper = ingredients.reduce((sum, ing) => sum + (ing.composition.copper || 0), 0);
  const totalVitaminA = ingredients.reduce((sum, ing) => sum + (ing.composition.vitaminA || 0), 0);
  
  const ceilings = NUTRIENT_CEILINGS[species];
  
  return {
    passed: totalCopper <= ceilings.copper_mg && totalVitaminA <= ceilings.vitaminA_IU,
    ruleId: 'T_ORGAN',
    message: `Organ meats within nutrient bounds (Cu: ${totalCopper}/${ceilings.copper_mg}, VA: ${totalVitaminA}/${ceilings.vitaminA_IU})`,
  };
}
```

**Effort:** 4 hours (Phase 2)

---

### 5. Health Scoring Does Conceptual Double Duty

**Current State:**
```typescript
// Health score (40% weight) mixes:
// 1. Disease relevance (joint health, kidney support)
// 2. Ingredient reputation (salmon = healthy)
// 3. Partial nutrient adequacy (protein > 20g = good)

private scoreHealth(ing: Ingredient): number {
  if (!this.constraints.healthConcerns?.length) return 50;
  
  let score = 0;
  for (const concern of this.constraints.healthConcerns) {
    const beneficialIngredients = HEALTH_BENEFIT_MAP[concern] || [];
    if (beneficialIngredients.some(b => ingName.includes(b))) {
      score += 35; // Gradient pressure toward edge cases
    }
  }
  return Math.min(100, score);
}
```

**The Problem:**

This creates gradient pressure toward edge cases. Once micronutrient data exists, the system will optimize for "barely complete" recipes because health scoring rewards marginal improvements.

**The Fix (Phase 2):**

Nutritional completeness should be **binary-gated**, not scored:

```typescript
// BEFORE: Scored (gradient pressure)
// Health: 40% weight, can be 0-100

// AFTER: Binary gate (no gradient pressure)
export function validateNutritionalCompleteness(
  ingredients: Ingredient[],
  species: Species
): SafetyRuleResult {
  const ceilings = NUTRIENT_CEILINGS[species];
  const floors = NUTRIENT_FLOORS[species];
  
  // Check all micronutrients are within bounds
  const isComplete = 
    checkVitaminA(ingredients, floors, ceilings) &&
    checkCopper(ingredients, floors, ceilings) &&
    checkIodine(ingredients, floors, ceilings) &&
    checkVitaminD(ingredients, floors, ceilings) &&
    checkZinc(ingredients, floors, ceilings);
  
  return {
    passed: isComplete,
    ruleId: 'COMPLETE',
    message: isComplete ? 'Nutritionally complete' : 'Incomplete micronutrients',
  };
}

// THEN: Health scoring only answers "which valid recipe is nicer"
// Not "how close to deficiency can I get cheaply"
```

**Effort:** 6 hours (Phase 2)

---

## WHAT NEEDS TO HAPPEN (REVISED ROADMAP)

### Phase 1: Restore Broken Invariants (BLOCKING)
**Must complete before any external deployment**

1. **Fix S1 (2h)** — Revert to exactly 1 primary protein, fix ingredient data
2. **Fix portion calculation (1h)** — Use actual pet weight, not calorie estimate
3. **Promote T1/T2/T3 to hard fail (0.5h)** — Unknown = unsafe for claims
4. **Validate ingredient data (4h)** — Spot-check 50 ingredients against USDA
5. **Add petWeightKg to constraints (0.5h)** — Interface update

**Total: 8 hours**

**Gate:** Until Phase 1 is complete, system cannot be deployed to any external users.

---

### Phase 2: Restore Biological Honesty (REQUIRED)
**Must complete before claiming nutritional completeness**

1. **Add micronutrient data (12h)** — Copper, iodine, vitamin D/E/K for all ingredients
2. **Re-enable T1/T2/T3 gates (2h)** — Now with real data
3. **Refactor organ meat to nutrient-ceiling-primary (4h)** — Remove fragmentation
4. **Refactor health scoring to binary-gate (6h)** — Remove gradient pressure
5. **Collapse composition logic (2h)** — Single authoritative file
6. **Migrate tests to Vitest (3h)** — Proper assertions

**Total: 29 hours**

**Gate:** Until Phase 2 is complete, cannot claim "nutritionally complete" externally.

---

### Phase 3: Adversarial Safety (RECOMMENDED)
**Must complete before scaling**

1. **Add adversarial tests (4h)** — Deliberately try to trick system into:
   - Liver dominance
   - Fat stacking
   - Protein doubling
2. **Introduce diet class enum (2h)** — Maintenance, growth, renal, etc.
3. **Add structured logging (2h)** — Telemetry for production monitoring

**Total: 8 hours**

---

## DEPLOYMENT MATRIX

| Scenario | Requirement | Status |
|----------|-------------|--------|
| **Internal testing** | Phase 1 only | ⚠️ Needs Phase 1 |
| **MVP with human review** | Phase 1 + manual check | ⚠️ Needs Phase 1 |
| **Production (small scale)** | Phase 1 + 2 | ❌ Needs Phase 1 + 2 |
| **Production (scaled)** | Phase 1 + 2 + 3 | ❌ Needs all phases |
| **Autonomous generation** | Phase 1 + 2 + 3 + monitoring | ❌ Not recommended |

---

## THE HONEST BOTTOM LINE

**This system is architecturally correct but biologically incomplete.**

It will not kill pets acutely. It will not generate recipes with grapes or chocolate. It will prevent liver+salmon combinations.

But it **will** generate recipes that look complete, score well, and cause slow micronutrient deficiency over weeks because the system is operating blind to copper, iodine, and vitamin D.

**That's not a bug. That's a liability.**

The good news: You already know that. The better news: The failure modes are now narrow, well-bounded, and boring. That's exactly where you want to be before you fix them.

**Do not deploy autonomously without Phase 1 + 2.**

---

**Next Steps:**
1. Complete Phase 1 (8 hours) — Restore invariants
2. Complete Phase 2 (29 hours) — Add micronutrient data
3. Complete Phase 3 (8 hours) — Adversarial testing
4. Then: Deploy with confidence
