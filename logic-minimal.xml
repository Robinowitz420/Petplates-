This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: app/profile/pet/**, app/api/recipes/**, lib/generator/**, components/MealBuilderWizard.tsx
- Files matching these patterns are excluded: **/*.xml, **/*.json, **/*.md, **/*.txt
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
app/api/recipes/generate/route.ts
app/profile/pet/[id]/custom-meals/[mealId]/page.tsx
app/profile/pet/[id]/custom-meals/page.tsx
app/profile/pet/[id]/meal-plan/page.tsx
app/profile/pet/[id]/page.tsx
app/profile/pet/[id]/recipe-builder/page.tsx
app/profile/pet/[id]/saved-recipes/page.tsx
components/MealBuilderWizard.tsx
lib/generator/AmazonLinkAudit.ts
lib/generator/AutoClassifyLinks.ts
lib/generator/BirdDebug.ts
lib/generator/BirdDetailedDebug.ts
lib/generator/BirdTest.ts
lib/generator/CheckBirdIngredients.ts
lib/generator/CombinatoricsPruning.ts
lib/generator/CommercialPriorEnforcement.test.ts
lib/generator/CommercialPriorEnforcement.ts
lib/generator/ComprehensiveAudit.ts
lib/generator/DebugProteinRole.ts
lib/generator/GenerateVerificationList.ts
lib/generator/Phase1_5_AutoClassify.ts
lib/generator/QuickTest.ts
lib/generator/RecipeBuilder.integration.test.ts
lib/generator/RecipeBuilder.smoke.test.ts
lib/generator/RecipeBuilder.test.ts
lib/generator/RecipeBuilder.ts
lib/generator/RecipeCompositionValidator.ts
lib/generator/RecipeConstraintRules.ts
lib/generator/RecipePMIScoring.ts
lib/generator/RecipePriorScoring.ts
lib/generator/VerifyAmazonLinks.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/api/recipes/generate/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { generateRecipesForPet } from '@/lib/recipe-generator-v3';
import type { Pet } from '@/lib/types';

export const runtime = 'nodejs';

interface RecipeRequest {
  species?: string;
  count?: number;
  petProfile?: {
    name?: string;
    weight?: string;
    weightKg?: number;
    age?: string;
    allergies?: string[];
    healthConcerns?: string[];
  };
}

/**
 * Generate recipes dynamically based on pet species
 * POST /api/recipes/generate
 * Body: { species: 'dogs' | 'cats' | 'birds' | 'reptiles' | 'pocket-pets', count?: number, petProfile?: {...} }
 */
export async function POST(request: NextRequest) {
  try {
    const body: RecipeRequest = await request.json();
    const { species = 'dogs', count = 50, petProfile } = body;

    // Create a mock pet for recipe generation
    const mockPet: any = {
      id: `mock-${species}-${Date.now()}`,
      name: petProfile?.name || 'Your Pet',
      type: species,
      breed: 'Mixed',
      age: petProfile?.age || 'adult',
      weight: petProfile?.weight || '10',
      weightKg: petProfile?.weightKg || 10,
      allergies: petProfile?.allergies || [],
      healthConcerns: petProfile?.healthConcerns || [],
    };

    // Generate recipes using pragmatic system
    console.log('[API] Generating recipes for pet:', {
      name: mockPet.name,
      type: mockPet.type,
      healthConcerns: mockPet.healthConcerns,
      allergies: mockPet.allergies,
    });
    
    const recipes = generateRecipesForPet(
      {
        pet: mockPet as Pet,
      },
      count
    );

    console.log('[API] Generated recipes count:', recipes?.length || 0);

    const generatedRecipes = recipes.map((recipe: any, index: number) => ({
      ...recipe,
      id: recipe.id || `generated-${species}-${index}-${Date.now()}`,
      generatedAt: new Date().toISOString(),
    }));

    if (generatedRecipes.length === 0) {
      console.error('[API] No recipes generated - returning 500');
      return NextResponse.json(
        { error: 'Failed to generate any recipes', species, attemptedCount: count, petProfile: mockPet },
        { status: 500 }
      );
    }

    // Sort by overall score (best first)
    generatedRecipes.sort((a: any, b: any) => (b.scores?.overall || 0) - (a.scores?.overall || 0));

    return NextResponse.json({
      success: true,
      recipes: generatedRecipes,
      stats: {
        total: generatedRecipes.length,
        avgScore: (generatedRecipes.reduce((sum: number, r: any) => sum + (r.scores?.overall || 0), 0) / generatedRecipes.length).toFixed(1),
      },
    });
  } catch (error) {
    console.error('Recipe generation error:', error);
    return NextResponse.json(
      { error: 'Failed to generate recipes', details: String(error) },
      { status: 500 }
    );
  }
}
</file>

<file path="app/profile/pet/[id]/custom-meals/[mealId]/page.tsx">
'use client';

import { useEffect } from 'react';
import { useParams, useRouter } from 'next/navigation';

export default function CustomMealDetailPage() {
  const params = useParams();
  const router = useRouter();
  const petId = params.id as string;
  const mealId = params.mealId as string;

  useEffect(() => {
    // Redirect to recipe detail page with petId query parameter
    if (mealId && petId) {
      router.replace(`/recipe/${mealId}?petId=${petId}`);
    }
  }, [mealId, petId, router]);

  return (
    <div className="min-h-screen bg-background flex items-center justify-center">
      <p className="text-gray-400">Redirecting...</p>
    </div>
  );
}
</file>

<file path="app/profile/pet/[id]/custom-meals/page.tsx">
'use client';

import { useState, useEffect } from 'react';
import { useParams, useRouter } from 'next/navigation';
import Link from 'next/link';
import { ArrowLeft, Trash2, Edit, Calendar, ChefHat } from 'lucide-react';
import { getCustomMeals, deleteCustomMeal } from '@/lib/utils/customMealStorage';
import { getPets } from '@/lib/utils/petStorage'; // Import async storage
import type { CustomMeal, Pet } from '@/lib/types';

const getCurrentUserId = () => {
  if (typeof window === 'undefined') return 'clerk_simulated_user_id_123';
  return localStorage.getItem('last_user_id') || 'clerk_simulated_user_id_123';
};

const getPetsFromLocalStorage = (userId: string): Pet[] => {
  if (typeof window === 'undefined') return [];
  const stored = localStorage.getItem(`pets_${userId}`);
  if (!stored) return [];
  try {
    return JSON.parse(stored);
  } catch {
    return [];
  }
};

export default function CustomMealsHistoryPage() {
  const params = useParams();
  const router = useRouter();
  const petId = params.id as string;
  
  const [pet, setPet] = useState<Pet | null>(null);
  const [customMeals, setCustomMeals] = useState<CustomMeal[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const loadData = async () => {
      const userId = getCurrentUserId();
      try {
        const pets = await getPets(userId);
        const foundPet = pets.find(p => p.id === petId) || null;
        setPet(foundPet);
        
        if (foundPet) {
          const meals = await getCustomMeals(userId, petId);
          // Sort by most recent first
          meals.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
          setCustomMeals(meals);
        }
      } catch (error) {
        console.error('Error loading custom meals:', error);
      }
      setLoading(false);
    };
    loadData();
  }, [petId]);

  const handleDelete = async (mealId: string) => {
    if (!confirm('Are you sure you want to delete this custom meal?')) return;
    
    const userId = getCurrentUserId();
    await deleteCustomMeal(userId, petId, mealId);
    
    // Refresh the list
    const meals = await getCustomMeals(userId, petId);
    meals.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
    setCustomMeals(meals);
  };

  const formatDate = (dateString: string) => {
    const date = new Date(dateString);
    return date.toLocaleDateString('en-US', { 
      year: 'numeric', 
      month: 'short', 
      day: 'numeric' 
    });
  };

  const getScoreColor = (score: number) => {
    if (score >= 80) return 'text-green-600 bg-green-50 border-green-200';
    if (score >= 60) return 'text-yellow-600 bg-yellow-50 border-yellow-200';
    return 'text-red-600 bg-red-50 border-red-200';
  };

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <p className="text-gray-600">Loading custom meals...</p>
      </div>
    );
  }

  if (!pet) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <div className="bg-white p-8 rounded-xl shadow text-center space-y-4">
          <p className="text-xl font-semibold text-gray-800">Pet not found.</p>
          <Link href="/profile" className="text-green-800 font-semibold">
            Back to Profiles
          </Link>
        </div>
      </div>
    );
  }

  // Get random name from pet's names array
  const petNames = Array.isArray(pet.names) ? pet.names.filter(n => n && n.trim() !== '') : [];
  const petDisplayName = petNames.length > 0 
    ? petNames[Math.floor(Math.random() * petNames.length)]
    : 'Pet';

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Header */}
      <div className="bg-white border-b border-gray-200 sticky top-0 z-10">
        <div className="max-w-7xl mx-auto px-4 py-2">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-3">
              <Link
                href={`/profile/pet/${petId}`}
                className="p-1.5 hover:bg-gray-100 rounded-md transition-colors"
              >
                <ArrowLeft size={18} className="text-gray-600" />
              </Link>
              <div>
                <h1 className="text-lg font-bold text-gray-900">
                  Custom Meals for {petDisplayName}
                </h1>
                <p className="text-xs text-gray-600 mt-0.5">
                  {pet.breed} ‚Ä¢ {pet.age} ‚Ä¢ {pet.weight}
                </p>
              </div>
            </div>
            <Link
              href={`/profile/pet/${petId}/recipe-builder`}
              className="flex items-center gap-2 px-4 py-2 text-sm font-medium text-white bg-green-800 rounded-md hover:bg-green-900 transition-colors"
            >
              <ChefHat size={16} />
              Create New Meal
            </Link>
          </div>
        </div>
      </div>

      <div className="max-w-7xl mx-auto px-4 py-3">
        {customMeals.length === 0 ? (
          <div className="bg-white rounded-lg border border-gray-200 p-12 text-center">
            <ChefHat size={48} className="mx-auto text-gray-400 mb-4" />
            <h2 className="text-xl font-semibold text-gray-900 mb-2">No custom meals yet</h2>
            <p className="text-gray-600 mb-6">
              Create your first custom meal to get started!
            </p>
            <Link
              href={`/profile/pet/${petId}/recipe-builder`}
              className="inline-flex items-center gap-2 px-4 py-2 text-sm font-medium text-white bg-primary-600 rounded-md hover:bg-primary-700 transition-colors"
            >
              <ChefHat size={16} />
              Create Your First Meal
            </Link>
          </div>
        ) : (
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            {customMeals.map((meal) => (
              <div
                key={meal.id}
                className="bg-white rounded-lg border border-gray-200 p-6 hover:shadow-lg transition-shadow"
              >
                {/* Meal Header */}
                <div className="flex items-start justify-between mb-4">
                  <div className="flex-1">
                    <h3 className="text-lg font-semibold text-gray-900 mb-1">
                      {meal.name}
                    </h3>
                    <div className="flex items-center gap-2 text-sm text-gray-500">
                      <Calendar size={14} />
                      {formatDate(meal.createdAt)}
                    </div>
                  </div>
                  <button
                    onClick={() => handleDelete(meal.id)}
                    className="p-2 text-red-600 hover:bg-red-50 rounded-md transition-colors"
                    title="Delete meal"
                  >
                    <Trash2 size={16} />
                  </button>
                </div>

                {/* Compatibility Score */}
                <div className={`mb-4 p-3 rounded-lg border ${getScoreColor(meal.analysis.score)}`}>
                  <div className="flex items-center justify-between">
                    <span className="text-sm font-medium">Compatibility Score</span>
                    <span className="text-2xl font-bold">{meal.analysis.score}</span>
                  </div>
                  <div className="w-full bg-white/50 rounded-full h-2 mt-2">
                    <div
                      className={`h-2 rounded-full ${
                        meal.analysis.score >= 80 ? 'bg-green-600' :
                        meal.analysis.score >= 60 ? 'bg-yellow-600' :
                        'bg-red-600'
                      }`}
                      style={{ width: `${meal.analysis.score}%` }}
                    />
                  </div>
                </div>

                {/* Ingredients Summary */}
                <div className="mb-4">
                  <h4 className="text-sm font-medium text-gray-700 mb-2">Ingredients</h4>
                  <div className="space-y-1">
                    {meal.ingredients.slice(0, 3).map((ing, idx) => (
                      <div key={idx} className="text-sm text-gray-600">
                        ‚Ä¢ {ing.key.replace(/_/g, ' ')} ({ing.grams}g)
                      </div>
                    ))}
                    {meal.ingredients.length > 3 && (
                      <div className="text-sm text-gray-500">
                        + {meal.ingredients.length - 3} more
                      </div>
                    )}
                  </div>
                </div>

                {/* Nutritional Summary */}
                <div className="mb-4 text-sm">
                  <div className="flex justify-between mb-1">
                    <span className="text-gray-600">Total Weight:</span>
                    <span className="font-medium">{meal.analysis.totalRecipeGrams}g</span>
                  </div>
                  <div className="flex justify-between mb-1">
                    <span className="text-gray-600">Recommended Serving:</span>
                    <span className="font-medium text-green-800">
                      {meal.analysis.recommendedServingGrams}g
                    </span>
                  </div>
                </div>

                {/* Warnings Summary */}
                {meal.analysis.toxicityWarnings.length > 0 && (
                  <div className="mb-4 p-2 bg-red-50 border border-red-200 rounded text-xs text-red-800">
                    ‚ö†Ô∏è {meal.analysis.toxicityWarnings.length} safety warning(s)
                  </div>
                )}

                {/* Actions */}
                <div className="flex gap-2 pt-4 border-t border-gray-200">
                  <button
                    onClick={() => {
                      // TODO: Implement edit functionality (load meal into builder)
                      router.push(`/profile/pet/${petId}/recipe-builder?mealId=${meal.id}`);
                    }}
                    className="flex-1 flex items-center justify-center gap-2 px-3 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50 transition-colors"
                  >
                    <Edit size={14} />
                    Edit
                  </button>
                  <button
                    onClick={() => {
                      router.push(`/recipe/${meal.id}?petId=${petId}`);
                    }}
                    className="flex-1 px-3 py-2 text-sm font-medium text-green-800 bg-green-900/10 border border-green-800/30 rounded-md hover:bg-green-900/20 transition-colors"
                  >
                    View Details
                  </button>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="app/profile/pet/[id]/meal-plan/page.tsx">
'use client';

import { useEffect, useMemo, useState } from 'react';
import { useParams, useRouter } from 'next/navigation';
import Link from 'next/link';
import { ArrowLeft, ShoppingCart } from 'lucide-react';
import type { Recipe, CustomMeal } from '@/lib/types';
import { getProductPrice } from '@/lib/data/product-prices';
import { VETTED_PRODUCTS, getVettedProduct, getVettedProductByAnyIdentifier } from '@/lib/data/vetted-products';
import { getCustomMeals } from '@/lib/utils/customMealStorage';
import { getPets } from '@/lib/utils/petStorage'; // Import async storage
import { ensureCartUrlSellerId } from '@/lib/utils/affiliateLinks';

// Format price for display
const formatPrice = (price: number) => {
  return `$${price.toFixed(2)}`;
};

const DAYS = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
const SIMULATED_USER_ID = 'clerk_simulated_user_id_123';

interface PetProfile {
  id: string;
  name: string;
  savedRecipes: string[];
}

const getCurrentUserId = () => {
  if (typeof window === 'undefined') return SIMULATED_USER_ID;
  return localStorage.getItem('last_user_id') || SIMULATED_USER_ID;
};

const getPetsFromLocalStorage = (userId: string): PetProfile[] => {
  if (typeof window === 'undefined') return [];
  const stored = localStorage.getItem(`pets_${userId}`);
  if (!stored) return [];
  try {
    const parsed = JSON.parse(stored);
    return Array.isArray(parsed)
      ? parsed.map((pet: any) => ({
          id: pet.id,
          name: pet.name,
          savedRecipes: pet.savedRecipes || [],
        }))
      : [];
  } catch {
    return [];
  }
};

const buildEvenPlan = (meals: Recipe[]) => {
  const totalSlots = DAYS.length * 2;
  const rotation: Recipe[] = [];
  while (rotation.length < totalSlots) {
    rotation.push(...meals);
  }
  return rotation.slice(0, totalSlots);
};

const shuffleMealsNoRepeats = (meals: Recipe[], totalSlots: number) => {
  if (meals.length === 0) return [];
  const poolBase = [...meals];
  const rotation: Recipe[] = [];

  const shuffle = (arr: Recipe[]) => {
    for (let i = arr.length - 1; i > 0; i -= 1) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  };

  let pool = shuffle([...poolBase]);

  while (rotation.length < totalSlots) {
    if (pool.length === 0) {
      pool = shuffle([...poolBase]);
    }
    const next = pool.pop() as Recipe;
    // Avoid duplicate within the same day (pair of two)
    if (rotation.length % 2 === 1 && rotation[rotation.length - 1].id === next.id) {
      // Put it back to the front and try another
      pool.unshift(next);
      continue;
    }
    rotation.push(next);
  }

  return rotation;
};

export default function MealPlanPage() {
  const params = useParams();
  const router = useRouter();
  const petId = params.id as string;

  const [pet, setPet] = useState<PetProfile | null>(null);
  const [savedMeals, setSavedMeals] = useState<Recipe[]>([]);
  const [customMeals, setCustomMeals] = useState<CustomMeal[]>([]);
  const [weeklyPlan, setWeeklyPlan] = useState<{ day: string; meals: Recipe[] }[]>([]);
  const [loading, setLoading] = useState(true);
  const [swapTarget, setSwapTarget] = useState<{ dayIdx: number; mealIdx: number } | null>(null);

  // Convert custom meal to Recipe format for meal plan
  const convertCustomMealToRecipe = (customMeal: CustomMeal): Recipe => {
    return {
      id: customMeal.id,
      name: customMeal.name,
      category: 'custom', // Mark as custom meal
      ageGroup: ['adult'], // Default, could be enhanced
      healthConcerns: [],
      description: `Custom meal created on ${new Date(customMeal.createdAt).toLocaleDateString()}`,
      ingredients: customMeal.ingredients.map((ing, idx) => ({
        id: `${idx + 1}`,
        name: ing.key.replace(/_/g, ' '),
        amount: `${ing.grams}g`,
      })),
      instructions: [
        'Mix all ingredients according to saved recipe',
        'Serve at recommended portion size',
        `Recommended serving: ${customMeal.analysis.recommendedServingGrams}g`,
      ],
      nutritionalInfo: {
        protein: {
          min: (customMeal.analysis.nutrients.protein_g || 0) / (customMeal.analysis.totalRecipeGrams / 100),
          max: (customMeal.analysis.nutrients.protein_g || 0) / (customMeal.analysis.totalRecipeGrams / 100),
          unit: '%',
        },
        fat: {
          min: (customMeal.analysis.nutrients.fat_g || 0) / (customMeal.analysis.totalRecipeGrams / 100),
          max: (customMeal.analysis.nutrients.fat_g || 0) / (customMeal.analysis.totalRecipeGrams / 100),
          unit: '%',
        },
        calories: {
          min: customMeal.analysis.nutrients.kcal || customMeal.analysis.nutrients.calories_kcal || 0,
          max: customMeal.analysis.nutrients.kcal || customMeal.analysis.nutrients.calories_kcal || 0,
          unit: 'kcal',
        },
      },
      rating: 0,
      reviews: 0,
      tags: ['custom', 'user-created'],
    };
  };

  useEffect(() => {
    const loadData = async () => {
      const userId = getCurrentUserId();
      try {
        const pets = await getPets(userId);
        const foundPet = pets.find((p: any) => p.id === petId) || null;
        
        if (foundPet) {
          // Normalize pet profile
          setPet({
            id: foundPet.id,
            name: foundPet.name || foundPet.names?.[0] || 'Pet',
            savedRecipes: foundPet.savedRecipes || [],
          });

          // Saved recipes are no longer stored statically
          setSavedMeals([]);
          
          // Load custom meals
          const customMealsList = await getCustomMeals(userId, petId);
          setCustomMeals(customMealsList);
        } else {
          setPet(null);
        }
      } catch (error) {
        console.error('Error loading meal plan data:', error);
      }
      setLoading(false);
    };
    loadData();
  }, [petId]);

  const generatePlan = (meals: Recipe[]) => {
    const rotation = buildEvenPlan(meals);
    const plan: { day: string; meals: Recipe[] }[] = [];
    for (let i = 0; i < DAYS.length; i += 1) {
      const breakfastIndex = i * 2;
      const dinnerIndex = breakfastIndex + 1;
      const breakfast = rotation[breakfastIndex];
      let dinner = rotation[dinnerIndex];
      if (dinner.id === breakfast.id) {
        const swapIndex = rotation.findIndex(
          (entry, idx) => idx > dinnerIndex && entry.id !== breakfast.id
        );
        if (swapIndex !== -1) {
          [rotation[dinnerIndex], rotation[swapIndex]] = [
            rotation[swapIndex],
            rotation[dinnerIndex],
          ];
          dinner = rotation[dinnerIndex];
        } else {
          dinner = meals.find((meal) => meal.id !== breakfast.id) || dinner;
        }
      }
      plan.push({ day: DAYS[i], meals: [breakfast, dinner] });
    }
    return plan;
  };

  const allMeals = useMemo<Recipe[]>(() => {
    return [
      ...savedMeals,
      ...customMeals.map(convertCustomMealToRecipe),
    ];
  }, [savedMeals, customMeals]);

  useEffect(() => {
    if (allMeals.length > 0) {
      setWeeklyPlan(generatePlan(allMeals));
    }
  }, [allMeals]);

  const handleRegenerate = () => {
    setWeeklyPlan(generatePlan(allMeals));
  };

  const handleRandomize = () => {
    const totalSlots = DAYS.length * 2;
    const rotation = shuffleMealsNoRepeats(allMeals, totalSlots);
    const plan: { day: string; meals: Recipe[] }[] = [];
    for (let i = 0; i < DAYS.length; i += 1) {
      const breakfastIndex = i * 2;
      const dinnerIndex = breakfastIndex + 1;
      const breakfast = rotation[breakfastIndex];
      const dinner = rotation[dinnerIndex];
      plan.push({ day: DAYS[i], meals: [breakfast, dinner] });
    }
    setWeeklyPlan(plan);
  };

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <p className="text-gray-600">Loading meal plan...</p>
      </div>
    );
  }

  if (!pet) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <div className="bg-white p-8 rounded-xl shadow text-center space-y-4">
          <p className="text-xl font-semibold text-gray-800">Pet not found.</p>
          <Link href="/profile" className="text-green-800 font-semibold">
            Back to Profiles
          </Link>
        </div>
      </div>
    );
  }

  const allMealsCount = savedMeals.length + customMeals.length;
  
  if (allMealsCount < 1) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center px-4">
        <div className="max-w-lg bg-white rounded-xl shadow p-8 text-center space-y-4">
          <div className="text-5xl">üçΩÔ∏è</div>
          <h1 className="text-2xl font-bold text-gray-900">Add more meals first</h1>
          <p className="text-gray-600">
            Save at least two meals (recipes or custom meals) for {pet.name} to build a balanced weekly rotation.
          </p>
          <div className="flex flex-col gap-2">
            <button
              onClick={() => router.push(`/recipes/recommended/${pet.id}`)}
              className="bg-green-800 text-white font-semibold px-6 py-3 rounded-lg hover:bg-green-900 transition-colors"
            >
              See Recommended Meals
            </button>
            <button
              onClick={() => router.push(`/profile/pet/${pet.id}/recipe-builder`)}
              className="bg-green-800 text-white font-semibold px-6 py-3 rounded-lg hover:bg-green-900 transition-colors"
            >
              Create Custom Meal
            </button>
            <button
              onClick={() => router.push(`/profile/pet/${pet.id}`)}
              className="text-green-800 font-semibold"
            >
              Find More Meals for {pet.name}
            </button>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50 py-10 px-4">
      <div className="max-w-6xl mx-auto space-y-8">
        <div className="bg-white rounded-xl shadow p-6 flex flex-col gap-4">
          <div className="flex items-center gap-3 text-green-800">
            <button
              onClick={() => router.push('/profile')}
              className="inline-flex items-center gap-2 font-semibold"
            >
              <ArrowLeft size={20} />
              Back to pets
            </button>
          </div>
            <div>
              <p className="text-sm uppercase tracking-wide text-gray-500 font-semibold">
                Weekly Meal Prep
              </p>
              <h1 className="text-3xl font-bold text-gray-900">
                7-Day Meal Plan for {pet.name}
              </h1>
              <p className="text-gray-600 mt-1">
                Two meals per day. No repeats on the same day. Each saved meal gets equal play.
              </p>
            </div>
          </div>
        

        <div className="grid grid-cols-7 gap-2">
          {weeklyPlan.map((dayPlan, index) => (
            <div key={dayPlan.day} className="bg-white rounded-lg shadow p-2">
              <div className="text-center mb-2">
                <p className="text-xs uppercase tracking-wide text-gray-500 font-semibold">
                  {dayPlan.day.slice(0, 3)}
                </p>
              </div>
              <div className="space-y-2">
                {dayPlan.meals.map((meal, mealIndex) => (
                  <div key={meal.id + mealIndex} className="text-center">
                    <Link
                      href={`/recipe/${meal.id}?petId=${petId}`}
                      className="block hover:text-primary-600 transition-colors mb-1"
                    >
                      <p className="font-medium text-gray-900 text-xs leading-tight">
                        {meal.name}
                        {meal.category === 'custom' && (
                          <span className="ml-1 text-xs text-green-800">(Custom)</span>
                        )}
                      </p>
                    </Link>
                    <div className="flex flex-col items-center gap-1">
                      <button
                        onClick={(e) => {
                          e.preventDefault();
                          const cartItems = meal.ingredients
                            .map((ing, index) => {
                              const genericName = ing.name.toLowerCase().trim();
                              const vettedProduct = VETTED_PRODUCTS[genericName];
                              const link = vettedProduct ? vettedProduct.purchaseLink : ing.asinLink;
                              if (link) {
                                // Extract ASIN from /dp/ASIN format
                                const asinMatch = link.match(/\/dp\/([A-Z0-9]{10})/);
                                if (asinMatch) {
                                  return `ASIN.${index + 1}=${asinMatch[1]}&Quantity.${index + 1}=1`;
                                }
                              }
                              return null;
                            })
                            .filter(Boolean);

                          if (cartItems.length > 0) {
                            const cartUrl = ensureCartUrlSellerId(`https://www.amazon.com/gp/aws/cart/add.html?${cartItems.join('&')}`);
                            window.open(cartUrl, '_blank');
                          } else {
                            alert('No ingredient links available for this recipe.');
                          }
                        }}
                        className="inline-flex items-center gap-1 text-xs bg-green-600 text-black px-1 py-0.5 rounded hover:bg-green-700 transition-colors"
                        title="Add all vetted ingredients to your Amazon cart"
                      >
                        <ShoppingCart size={8} />
                        Buy
                      </button>
                      {/* Price Display */}
                      {(() => {
                        const mealTotalPrice = meal.ingredients?.reduce((sum, ing) => {
                          const price = getProductPrice(ing.name);
                          if (typeof price === 'number') return sum + price;
                          return sum;
                        }, 0) || 0;
                        return mealTotalPrice > 0 ? (
                          <span className="text-[10px] text-green-700 font-semibold">
                            {formatPrice(mealTotalPrice)}
                          </span>
                        ) : null;
                      })()}
                    </div>
                    <button
                      onClick={(e) => {
                        e.preventDefault();
                        setSwapTarget({ dayIdx: index, mealIdx: mealIndex });
                      }}
                    className="mt-2 w-full inline-flex items-center justify-center gap-1 text-xs px-2 py-1 rounded border border-primary-500 text-primary-700 bg-white hover:bg-primary-50 transition-colors"
                      title="Edit this slot"
                    >
                    Edit
                    </button>
                  </div>
                ))}
              </div>
            </div>
          ))}
        </div>

        {swapTarget && (
          <div className="fixed inset-0 z-50 bg-black/60 flex items-center justify-center px-4">
            <div className="bg-white rounded-xl shadow-2xl max-w-lg w-full p-5 border border-gray-200">
              <div className="flex items-center justify-between mb-3">
                <h3 className="text-lg font-bold text-gray-900">Swap Meal</h3>
                <button
                  onClick={() => setSwapTarget(null)}
                  className="text-gray-500 hover:text-gray-700"
                  aria-label="Close swap dialog"
                >
                  ‚úï
                </button>
              </div>
              <p className="text-sm text-gray-600 mb-3">Choose a saved meal to place into this slot.</p>
              <div className="max-h-72 overflow-y-auto space-y-2">
                {allMeals.map((meal) => (
                  <button
                    key={meal.id}
                    onClick={() => {
                      if (!swapTarget) return;
                      const planCopy = weeklyPlan.map((d) => ({ ...d, meals: [...d.meals] }));
                      planCopy[swapTarget.dayIdx].meals[swapTarget.mealIdx] = meal;
                      setWeeklyPlan(planCopy);
                      setSwapTarget(null);
                    }}
                    className="w-full text-left p-3 rounded-lg border border-gray-200 hover:border-green-600 hover:bg-green-50 transition-colors"
                  >
                    <div className="flex justify-between items-center">
                      <span className="font-semibold text-gray-900">{meal.name}</span>
                      {meal.category === 'custom' && (
                        <span className="text-xs text-green-700 bg-green-100 px-2 py-0.5 rounded-full">Custom</span>
                      )}
                    </div>
                  </button>
                ))}
                {allMeals.length === 0 && (
                  <p className="text-sm text-gray-500">No saved meals available.</p>
                )}
              </div>
              <div className="mt-4 flex justify-end gap-2">
                <button
                  onClick={() => setSwapTarget(null)}
                  className="px-4 py-2 text-sm text-gray-700 border border-gray-300 rounded-lg hover:bg-gray-50"
                >
                  Cancel
                </button>
              </div>
            </div>
          </div>
        )}

        <div className="bg-white rounded-xl shadow p-6">
          <h3 className="text-lg font-bold text-gray-900 mb-2">How rotation works</h3>
          <p className="text-gray-600 text-sm mb-2">
            We loop through every saved meal (recipes and custom meals) equally, then shuffle lightly to keep variety.
            Each day uses two different meals so {pet.name} never sees a repeat on the same day.
          </p>
          <div className="mt-3 pt-3 border-t border-gray-200">
            <p className="text-xs text-gray-500">
              <strong>Meals included:</strong> {savedMeals.length} saved recipe{savedMeals.length !== 1 ? 's' : ''} 
              {customMeals.length > 0 && ` + ${customMeals.length} custom meal${customMeals.length !== 1 ? 's' : ''}`}
            </p>
          </div>
        </div>

        <div className="flex flex-wrap gap-2 mt-4">
          <button
            onClick={handleRandomize}
            className="btn btn-success btn-sm"
          >
            Randomize Week
          </button>
          <Link
            href={`/pets/${petId}/nutrition`}
            className="btn btn-success btn-sm"
          >
            View Nutrition Dashboard
          </Link>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/profile/pet/[id]/page.tsx">
'use client';

import { useState, useEffect, useMemo, useRef } from 'react';
import { useParams } from 'next/navigation';
import Link from 'next/link';
import Image from 'next/image';
import { ArrowLeft, Plus } from 'lucide-react';
import type { ModifiedRecipeResult, Recipe } from '@/lib/types';
import { calculateEnhancedCompatibility, type Pet as EnhancedPet, getGrade } from '@/lib/utils/enhancedCompatibilityScoring';
import { CompatibilityBadge } from '@/components/CompatibilityBadge';
import { getRandomName } from '@/lib/utils/petUtils';
import EmojiIcon from '@/components/EmojiIcon';
import { getPets, savePet } from '@/lib/utils/petStorage'; // Import from storage util
import { useChunkedRecipeScoring } from '@/lib/hooks/useChunkedRecipeScoring';
import ScoringProgress from '@/components/ScoringProgress';
import { calculateMealCountVariation } from '@/lib/utils/mealCountCalculator';
import { makeCountOrganic, getCountMessage, getSubtext } from '@/lib/utils/organicCount';
import { useProgressiveMealCount } from '@/hooks/useProgressiveMealCount';


type PetCategory = 'dogs' | 'cats' | 'birds' | 'reptiles' | 'pocket-pets';
type AgeGroup = 'baby' | 'young' | 'adult' | 'senior';

interface Pet {
  id: string;
  name?: string; // Legacy field, prefer names array
  names?: string[]; // Array of names
  type: PetCategory;
  breed: string;
  age: AgeGroup;
  healthConcerns?: string[];
  dietaryRestrictions?: string[];
  savedRecipes?: string[];
  allergies?: string[];
  weightKg?: number;
  weight?: string;
  dislikes?: string[];
}

// Same simulated user ID setup as profile and saved-recipes pages
const SIMULATED_USER_ID = 'clerk_simulated_user_id_123';

const getCurrentUserId = () => {
  if (typeof window === 'undefined') return SIMULATED_USER_ID;
  return localStorage.getItem('last_user_id') || SIMULATED_USER_ID;
};

// Get custom recipes from localStorage
const getCombinedRecipes = (): Recipe[] => {
  if (typeof window !== 'undefined') {
    try {
      const customRecipes = JSON.parse(localStorage.getItem('custom_recipes') || '[]');
      return customRecipes;
    } catch (error) {
      console.error('Error loading custom recipes:', error);
    }
  }

  return [];
};

export default function RecommendedRecipesPage() {
  const params = useParams();
  const [pet, setPet] = useState<Pet | null>(null);
  const [hoveredRecipe, setHoveredRecipe] = useState<string | null>(null);
  const [engineMeals, setEngineMeals] = useState<ModifiedRecipeResult[] | null>(null);
  const [engineError, setEngineError] = useState<string | null>(null);
  const [loadingMeals, setLoadingMeals] = useState(true);
  const [cardMessage, setCardMessage] = useState<{ id: string; text: string } | null>(null);
  const petId = params.id as string;

  // Get pet display name (use names array if available, fallback to name field) - memoized for stability
  const petDisplayName = useMemo(() => {
    if (!pet) return 'Pet';
    return getRandomName(pet.names || (pet.name ? [pet.name] : ['Unnamed Pet']));
  }, [pet?.id, pet?.names, pet?.name]);

  // Convert pet data to rating system format - memoized to prevent recalculation when only savedRecipes changes
  // Use JSON.stringify for arrays to ensure stable comparison
  const healthConcernsKey = pet ? JSON.stringify(pet.healthConcerns || []) : '';
  const allergiesKey = pet ? JSON.stringify(pet.allergies || []) : '';
  const dislikesKey = pet ? JSON.stringify(pet.dislikes || []) : '';
  
  // Convert pet data to enhanced compatibility format
  const enhancedPet: EnhancedPet | null = useMemo(() => {
    if (!pet) return null;
    const petAge = pet.age === 'baby' ? 0.5 : pet.age === 'young' ? 2 : pet.age === 'adult' ? 5 : 10;
    return {
      id: pet.id,
      name: petDisplayName,
      type: (pet.type === 'dogs' ? 'dog' : pet.type === 'cats' ? 'cat' : pet.type === 'birds' ? 'bird' : pet.type === 'reptiles' ? 'reptile' : 'pocket-pet') as 'dog' | 'cat' | 'bird' | 'reptile' | 'pocket-pet',
      breed: pet.breed,
      age: petAge,
      weight: pet.weightKg || (pet.type === 'dogs' ? 25 : pet.type === 'cats' ? 10 : 5),
      activityLevel: 'moderate' as const,
      healthConcerns: pet.healthConcerns || [],
      dietaryRestrictions: pet.dietaryRestrictions || [],
      allergies: pet.allergies || [],
    };
  }, [pet?.id, pet?.type, pet?.breed, pet?.age, pet?.weightKg, healthConcernsKey, allergiesKey, petDisplayName, pet?.dietaryRestrictions]);


  useEffect(() => {
    const userId = getCurrentUserId();
    if (!userId || !petId) return;

    const loadPet = async () => {
      try {
        // Add 5 second timeout to prevent hanging
        const timeoutPromise = new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Timeout loading pets')), 5000)
        );
        
        const pets = await Promise.race([
          getPets(userId),
          timeoutPromise
        ]) as any[];
        
        // Normalize names when loading
        const normalizedPets = pets.map((p: any) => ({
          ...p,
          names: p.names || (p.name ? [p.name] : []),
          savedRecipes: p.savedRecipes || [],
          healthConcerns: p.healthConcerns || [],
        }));
        
        const foundPet = normalizedPets.find((p: any) => p.id === petId) || null;
        setPet(foundPet);
        
        if (!foundPet) {
          console.warn('Pet not found with id:', petId);
          setLoadingMeals(false); // Stop loading if pet not found
        }
      } catch (error) {
        console.error('Failed to load pet data:', error);
        setPet(null);
        setLoadingMeals(false); // CRITICAL: Stop loading on error
      }
    };
    loadPet();
  }, [petId]); // petId is the only dependency needed

useEffect(() => {
  if (!pet) return;
  let isMounted = true;
  setLoadingMeals(true);
  setEngineError(null);

  (async () => {
    try {
      // First try the new cost-optimized recipe generation API
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
      
      const response = await fetch('/api/recipes/generate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        signal: controller.signal,
        body: JSON.stringify({
          species: pet.type,
          count: 50,
          petProfile: {
            name: petDisplayName,
            weight: pet.weight,
            weightKg: pet.weightKg,
            age: pet.age,
            allergies: pet.allergies || [],
            healthConcerns: pet.healthConcerns || [],
          },
        }),
      });
      
      clearTimeout(timeoutId);

      if (!response.ok) {
        throw new Error(`Recipe generation failed (${response.status})`);
      }

      const data = await response.json();
      if (!isMounted) return;
      
      if (data?.recipes && data.recipes.length > 0) {
        // Convert generated recipes to ModifiedRecipeResult format
        const generatedMeals = data.recipes.map((recipe: any) => ({
          recipe,
          explanation: `Cost-optimized meal: $${recipe.estimatedCostPerMeal?.toFixed(2) || 'N/A'} per meal`,
        }));
        setEngineMeals(generatedMeals as ModifiedRecipeResult[]);
      } else {
        throw new Error('No recipes generated');
      }
    } catch (error) {
      if (!isMounted) return;
      console.error('Recipe generation error:', error);
      // Fall back to recommendations API if generation fails
      try {
        const concerns = (pet.healthConcerns || []).filter((concern) => concern !== 'none');
        const allergies = pet.allergies?.filter((allergy) => allergy !== 'none') || [];
        
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000);
        
        const response = await fetch('/api/recommendations', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          signal: controller.signal,
          body: JSON.stringify({
            profile: {
              species: pet.type,
              ageGroup: pet.age,
              breed: pet.breed,
              weightKg: pet.weightKg || 10,
              healthConcerns: concerns,
              allergies,
              petName: petDisplayName,
            },
            limit: 50,
          }),
        });
        
        clearTimeout(timeoutId);

        if (!response.ok) {
          throw new Error(`Recommendations failed (${response.status})`);
        }

        const data = await response.json();
        if (!isMounted) return;
        
        setEngineMeals((data?.results as ModifiedRecipeResult[]) || []);
      } catch (fallbackError) {
        if (!isMounted) return;
        setEngineMeals(null);
        setEngineError('Unable to load meals‚Äîshowing standard matches.');
      }
    } finally {
      if (isMounted) {
        setLoadingMeals(false);
      }
    }
  })();

  return () => {
    isMounted = false;
  };
}, [pet]);

  // Debug logging (as suggested by DeepSeek) - MUST be after all useState hooks, before early returns
  useEffect(() => {
    // Only log state variables, not computed values
    if (pet) {
      const { getRecommendedRecipes } = require('@/lib/utils/recipeRecommendations');
      const tieredRecommendations = getRecommendedRecipes(pet, 20, true);
      const fallbackCount = tieredRecommendations.length;
      
      // Using engine meals or fallback
    }
  }, [engineMeals, pet]);

  // Import subtype matching
  const { normalizeToSubtype } = require('@/lib/utils/ingredientWhitelists');
  
  // Helper to check species/subtype match
  const matchesSpecies = (recipe: Recipe, currentPet: Pet): boolean => {
    if (recipe.category === currentPet.type) return true;
    
    // Subtype matching for exotics
    const subtype = normalizeToSubtype(currentPet.type as any, currentPet.breed);
    
    if (currentPet.type === 'birds') {
      if (recipe.category === 'birds' || recipe.category === 'bird') return true;
      if (recipe.category === subtype) return true;
    }
    
    if (currentPet.type === 'reptiles') {
      if (recipe.category === 'reptiles' || recipe.category === 'reptile') return true;
      if (recipe.category === subtype) return true;
    }
    
    if (currentPet.type === 'pocket-pets') {
      if (recipe.category === 'pocket-pets' || recipe.category === 'pocket-pet') return true;
      if (recipe.category === subtype) return true;
    }
    
    return false;
  };

  // Use tiered recommendation system to ensure we always have results
  // Only depend on properties that affect recommendations, NOT savedRecipes
  // Use JSON.stringify for arrays to ensure stable comparison
  const tieredHealthConcernsKey = pet ? JSON.stringify(pet.healthConcerns || []) : '';
  const tieredAllergiesKey = pet ? JSON.stringify(pet.allergies || []) : '';

  const tieredRecommendations = useMemo(() => {
    if (!pet) return [];
    const { getRecommendedRecipes } = require('@/lib/utils/recipeRecommendations');
    // Pass combined recipes (base + custom) to the recommendation system
    const combinedRecipes = getCombinedRecipes();
    return getRecommendedRecipes(pet, 20, true, combinedRecipes);
  }, [pet?.id, pet?.type, pet?.breed, pet?.age, tieredHealthConcernsKey, pet?.weightKg, tieredAllergiesKey]);
  
  const buildFallbackExplanation = (recipe: Recipe, currentPet: Pet, tierLabel?: string, warning?: string) => {
    if (warning) {
      return warning;
    }
    if (tierLabel && tierLabel !== 'Best Match') {
      return `${recipe.name} - ${tierLabel}`;
    }
    const concern = (currentPet.healthConcerns || [])[0]?.replace(/-/g, ' ') || 'overall wellness';
    const highlight = recipe.tags?.[0] || (recipe.description || '').split('. ')[0] || recipe.name;
    return `${recipe.name} keeps ${currentPet.name || 'pet'}'s ${concern} on track with ${highlight?.toLowerCase()}.`;
  };

  // Convert tiered recommendations to format expected by UI
  // Only depend on properties that affect meal recommendations, NOT savedRecipes
  const fallbackHealthConcernsKey = pet ? JSON.stringify(pet.healthConcerns || []) : '';
  const fallbackPetName = pet?.name || '';
  
  const fallbackMeals = useMemo(() => {
    if (!pet) return [];
    return tieredRecommendations.map((rec: any) => ({
      recipe: rec.recipe,
      explanation: buildFallbackExplanation(rec.recipe, pet, rec.tierLabel, rec.warning),
      _tierLabel: rec.tierLabel,
      _warning: rec.warning,
      _healthMatch: rec.healthConcernMatch,
      _tier: rec.tier
    }));
  }, [pet?.id, pet?.type, pet?.breed, pet?.age, fallbackHealthConcernsKey, fallbackPetName, tieredRecommendations]);

  // Fix: Properly check for empty array - use fallback if engineMeals is null, undefined, empty, or has too few results
  // Use fallback if API returns fewer than 15 meals (threshold to ensure we get a good selection)
  const MIN_MEALS_THRESHOLD = 15;
  // Memoize mealsToRender to prevent recalculation when only savedRecipes changes
  const mealsToRender: (ModifiedRecipeResult | { recipe: Recipe; explanation: string })[] = useMemo(() => {
    const hasEnoughFromAPI = engineMeals && Array.isArray(engineMeals) && engineMeals.length >= MIN_MEALS_THRESHOLD;
    return hasEnoughFromAPI ? engineMeals : fallbackMeals;
  }, [engineMeals, fallbackMeals]);

  // Use chunked scoring hook for non-blocking performance
  const { scoredMeals, isLoading: isScoring, progress, totalMeals: totalMealsToScore, scoredCount } = useChunkedRecipeScoring(
    mealsToRender,
    null, // ratingPet deprecated - using enhancedPet only
    enhancedPet
  );

  // Store sorted meals (already sorted by the hook, but ensure final sort)
  const sortedMealsToRender = useMemo(() => {
    return [...scoredMeals].sort((a: any, b: any) => {
      const aScore = ('score' in a && typeof a.score === 'number') ? a.score : 0;
      const bScore = ('score' in b && typeof b.score === 'number') ? b.score : 0;
      const scoreDiff = bScore - aScore;
      // If scores differ, sort by score (descending)
      if (Math.abs(scoreDiff) > 0.001) {
        return scoreDiff;
      }
      // If scores are equal, use recipe ID as tiebreaker
      const aId = a.recipe?.id || '';
      const bId = b.recipe?.id || '';
      return aId.localeCompare(bId);
    });
  }, [scoredMeals]);

  // Calculate base meal count (before early returns to ensure hooks are always called)
  const baseTotalMeals = sortedMealsToRender.length;
  
  // Memoize the count calculation - use actual count with minimal organic tweaking
  // Only recalculate when pet profile or base count changes
  const { countMessage, countSubtext, targetDisplayCount } = useMemo(() => {
    // Use the actual count as the base
    const message = getCountMessage(baseTotalMeals, pet?.type);
    const subtext = getSubtext(baseTotalMeals, pet?.type);
    // Use actual count
    const target = baseTotalMeals;
    
    return {
      countMessage: message,
      countSubtext: subtext,
      targetDisplayCount: target,
    };
  }, [baseTotalMeals, pet?.type]);
  
  // Progressive count animation - MUST be called before any early returns
  const { displayCount, isCounting } = useProgressiveMealCount({
    target: targetDisplayCount,
    duration: 1000,
    steps: 20,
  });

  // Track saved recipes separately to avoid triggering meal recalculation
  const [savedRecipeIds, setSavedRecipeIds] = useState<Set<string>>(new Set());

  // Initialize savedRecipeIds from pet when pet loads
  useEffect(() => {
    if (pet?.savedRecipes) {
      setSavedRecipeIds(new Set(pet.savedRecipes));
    }
  }, [pet?.id]); // Only update when pet ID changes, not when savedRecipes changes

  const handleSaveRecipe = async (recipeId: string, recipeName: string) => {
    const userId = getCurrentUserId();
    if (!userId || !pet) return;

    // Check if already saved (using local state)
    if (savedRecipeIds.has(recipeId)) {
      setCardMessage({ id: recipeId, text: 'Already saved for this pet.' });
      setTimeout(() => setCardMessage(null), 2500);
      return;
    }

    // Update via storage util
    const updatedPet = {
      ...pet,
      savedRecipes: [...(pet.savedRecipes || []), recipeId]
    };
    
    await savePet(userId, updatedPet);

    // Update local state to reflect the change immediately
    setPet(updatedPet);
    setSavedRecipeIds(new Set([...savedRecipeIds, recipeId]));
    setCardMessage({ id: recipeId, text: `${recipeName} added to ${petDisplayName}'s meals.` });
    setTimeout(() => setCardMessage(null), 2500);
  };

  if (!pet) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-background text-foreground">
        <p>Loading...</p>
      </div>
    );
  }

  const usingEngine = Boolean(engineMeals && engineMeals.length > 0);

  const getPetEmoji = (type: PetCategory) => {
    const emojis = {
      dogs: 'üêï',
      cats: 'üêà',
      birds: 'ü¶ú',
      reptiles: 'ü¶é',
      'pocket-pets': 'üê∞',
    };
    return emojis[type];
  };
  
  // Component to render pet emoji as image
  const PetEmojiIcon = ({ type, size = 24 }: { type: PetCategory; size?: number }) => {
    const emoji = getPetEmoji(type);
    return <EmojiIcon emoji={emoji} size={size} />;
  };

  const getHealthCompatibilityScore = (recipe: any, pet: Pet): number => {
    const concerns = pet.healthConcerns || [];
    if (!concerns.length) return 0;
    const overlaps = concerns.filter((c) => (recipe.healthConcerns || []).includes(c));
    if (!overlaps.length) return 0;
    return overlaps.length / concerns.length; // 0..1
  };

  const getHealthMatchBadge = (score: number) => {
    if (score >= 0.67)
      return {
        label: 'Great health match',
        className: 'bg-green-900/50 text-green-200 border border-green-700/50',
      };
    if (score >= 0.34)
      return {
        label: 'Good health match',
        className: 'bg-yellow-900/50 text-yellow-200 border border-yellow-700/50',
      };
    if (score > 0)
      return {
        label: 'Some health benefit',
        className: 'bg-blue-900/50 text-blue-200 border border-blue-700/50',
      };
    return null;
  };

  const getStarStates = (rating: number): boolean[] => {
    const fullStars = Math.round(rating); // 0..5
    return Array.from({ length: 5 }, (_, i) => i < fullStars);
  };

  return (
    <div className="min-h-screen bg-background text-foreground py-4">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <Link
          href="/profile"
          className="inline-flex items-center gap-2 text-gray-400 hover:text-primary-400 mb-6"
        >
          <ArrowLeft className="h-5 w-5" />
          Back to Profile
        </Link>

        <div 
          className="bg-surface rounded-lg shadow-md border border-surface-highlight p-4 mb-3"
        >
          <div className="flex items-start gap-4">
            {/* Left: Turtle Image (twice as large) */}
            <div className="flex-shrink-0">
              <Image
                src="/images/emojis/Mascots/Sherlock Shells/Shell4.jpg"
                alt="Sherlock Shells Detective"
                width={288}
                height={288}
                className="w-72 h-72 object-contain mascot-icon mascot-sherlock-shells"
                unoptimized
              />
            </div>

            {/* Left-Middle: Title and Bio Info in Grid */}
            <div className="flex-1 min-w-0">
              <h1 className="text-2xl font-bold text-foreground mb-6 mt-8">
                Sherlock Shells is detecting meals...
              </h1>
              
              {/* Three Column Layout: Bio, Health Concerns, Allergies */}
              <div className="flex gap-6 mt-8">
                {/* Bio Column */}
                <div className="flex-1 min-w-0">
                  <h3 className="text-sm font-semibold text-gray-300 mb-2">Bio</h3>
                  <div className="grid grid-cols-1 gap-y-1 text-sm text-gray-300">
                    {pet.breed && (
                      <div className="flex items-start gap-1.5">
                        <span className="text-orange-400 mt-0.5">‚Ä¢</span>
                        <span><strong className="text-gray-200">Breed:</strong> {pet.breed}</span>
                      </div>
                    )}
                    {pet.age && (
                      <div className="flex items-start gap-1.5">
                        <span className="text-orange-400 mt-0.5">‚Ä¢</span>
                        <span><strong className="text-gray-200">Age:</strong> {pet.age}</span>
                      </div>
                    )}
                    {(pet.weightKg || pet.weight) && (
                      <div className="flex items-start gap-1.5">
                        <span className="text-orange-400 mt-0.5">‚Ä¢</span>
                        <span><strong className="text-gray-200">Weight:</strong> {pet.weightKg ? `${pet.weightKg}kg` : pet.weight}</span>
                      </div>
                    )}
                    {pet.type && (
                      <div className="flex items-start gap-1.5">
                        <span className="text-orange-400 mt-0.5">‚Ä¢</span>
                        <span><strong className="text-gray-200">Type:</strong> {pet.type}</span>
                      </div>
                    )}
                    {pet.savedRecipes && pet.savedRecipes.length > 0 && (
                      <div className="flex items-start gap-1.5">
                        <span className="text-orange-400 mt-0.5">‚Ä¢</span>
                        <span><strong className="text-gray-200">Total Meals:</strong> {pet.savedRecipes.length}</span>
                      </div>
                    )}
                    {(pet.dietaryRestrictions || []).length > 0 && (
                      <div className="flex items-start gap-1.5">
                        <span className="text-orange-400 mt-0.5">‚Ä¢</span>
                        <span><strong className="text-gray-200">Dietary Restrictions:</strong> {(pet.dietaryRestrictions || []).join(', ')}</span>
                      </div>
                    )}
                    {(pet.dislikes || []).length > 0 && (
                      <div className="flex items-start gap-1.5">
                        <span className="text-orange-400 mt-0.5">‚Ä¢</span>
                        <span><strong className="text-gray-200">Dislikes:</strong> {(pet.dislikes || []).join(', ')}</span>
                      </div>
                    )}
                  </div>
                </div>

                {/* Health Concerns Column - Always rendered for consistent layout */}
                <div className="flex-shrink-0 min-w-[180px]">
                  <h3 className="text-sm font-semibold text-gray-300 mb-2">Health Concerns</h3>
                  <div className="flex flex-col gap-1.5">
                    {(pet.healthConcerns || []).length > 0 ? (
                      (pet.healthConcerns || []).map((concern) => (
                        <div
                          key={concern}
                          className="px-2 py-1 bg-orange-900/40 text-orange-200 border border-orange-700/50 text-xs rounded"
                        >
                          {concern.replace(/-/g, ' ')}
                        </div>
                      ))
                    ) : (
                      <div className="px-2 py-1 text-gray-500 text-xs italic">
                        None
                      </div>
                    )}
                  </div>
                </div>

                {/* Allergies Column - Always rendered for consistent layout */}
                <div className="flex-shrink-0 min-w-[180px]">
                  <h3 className="text-sm font-semibold text-gray-300 mb-2">Allergies</h3>
                  <div className="flex flex-col gap-1.5">
                    {(pet.allergies || []).length > 0 ? (
                      (pet.allergies || []).map((allergy) => (
                        <div
                          key={allergy}
                          className="px-2 py-1 bg-orange-900/40 text-orange-200 border border-orange-700/50 text-xs rounded"
                        >
                          {allergy.replace(/-/g, ' ')}
                        </div>
                      ))
                    ) : (
                      <div className="px-2 py-1 text-gray-500 text-xs italic">
                        None
                      </div>
                    )}
                  </div>
                </div>
              </div>

              {engineError && (
                <p className="mt-4 text-sm text-amber-200 bg-amber-900/30 border border-amber-700/50 px-3 py-2 rounded-lg">
                  {engineError}
                </p>
              )}
            </div>

            {/* Far Right: Number of Meals Found (Larger) */}
            <div className="flex-shrink-0 text-right">
              <div className="text-5xl font-bold text-orange-500">
                {displayCount}{isCounting && <span className="text-3xl">+</span>}
              </div>
              <div className="text-sm text-gray-400 mt-1">
                meals found
                {isCounting && (
                  <span className="text-xs ml-2 text-gray-500">(still searching...)</span>
                )}
              </div>
              {countSubtext && !isCounting && (
                <div className="text-xs text-gray-500 mt-1 max-w-[120px]">
                  {countSubtext}
                </div>
              )}
            </div>
          </div>
        </div>

        {/* Show progress indicator while scoring */}
        {isScoring && (
          <ScoringProgress
            progress={progress}
            totalMeals={totalMealsToScore}
            scoredCount={scoredCount}
          />
        )}

        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {(() => {
            // FINAL SAFETY CHECK: Sort one more time right before rendering to ensure highest to lowest
            const finalRendered = [...sortedMealsToRender].sort((a: any, b: any) => {
              const aScore = ('score' in a && typeof a.score === 'number') ? a.score : 0;
              const bScore = ('score' in b && typeof b.score === 'number') ? b.score : 0;
              return bScore - aScore; // Descending order (highest first)
            });
            return finalRendered;
          })().map((meal) => {
            const recipe = meal.recipe;
            const explanation = meal.explanation;
            const recipeId = recipe.id;
            return (
            <div
              key={recipeId}
              className="relative group"
              onMouseEnter={() => setHoveredRecipe(recipeId)}
              onMouseLeave={() => setHoveredRecipe(null)}
            >
              <Link 
                href={`/recipe/${recipeId}?petId=${petId}`}
                onClick={() => {
                  // Store recipe in session storage for dynamically generated recipes
                  if (typeof window !== 'undefined') {
                    sessionStorage.setItem(`recipe_${recipeId}`, JSON.stringify(recipe));
                  }
                }}
              >
                <div className="bg-surface rounded-lg shadow-md border border-surface-highlight overflow-hidden cursor-pointer hover:shadow-xl hover:border-orange-500/30 hover:-translate-y-1 hover:scale-[1.02] transition-all duration-200 ease-out h-full flex flex-col">
                  <div className="p-6 flex-1 flex flex-col">
                    <div className="mb-3">
                      <h3 className="text-xl font-bold text-foreground text-center">
                        {recipe.name}
                      </h3>
                      {/* Compatibility Rating - Centered under meal name */}
                      {enhancedPet && (
                        <div className="mt-2 flex justify-center">
                          <CompatibilityBadge
                            score={
                              'score' in meal && typeof meal.score === 'number'
                                ? meal.score
                                : (() => {
                                    if (!enhancedPet) return 0;
                                    const enhanced = calculateEnhancedCompatibility(recipe, enhancedPet);
                                    return enhanced.overallScore;
                                  })()
                            }
                          />
                        </div>
                      )}
                    </div>
                    <p className="text-gray-300 text-sm mb-4 flex-1 text-center">
                      {recipe.description}
                    </p>
                    {explanation && (
                      <p className="text-sm text-gray-300 bg-surface-highlight rounded-lg p-3 mb-3 border border-white/5">
                        {explanation}
                      </p>
                    )}
                  </div>
                  <div className="px-6 pb-4 pt-2 border-t border-surface-highlight">
                    {(() => {
                      const isSaved = savedRecipeIds.has(recipeId);
                      return (
                        <button
                          onClick={(e) => {
                            e.preventDefault();
                            handleSaveRecipe(recipeId, recipe.name);
                          }}
                          disabled={isSaved}
                          className={`w-full px-4 py-2 rounded-md shadow-md transition-colors flex items-center justify-center gap-2 text-sm font-semibold ${
                            isSaved
                              ? 'bg-green-600 text-white cursor-not-allowed'
                              : 'bg-green-800 text-white hover:bg-green-900'
                          }`}
                        >
                          {isSaved ? '‚úì Added to Saved Meals' : (
                            <>
                              <Plus className="h-4 w-4" /> Add Meal
                            </>
                          )}
                        </button>
                      );
                    })()}
                  </div>
                </div>
              </Link>
            </div>
          )})}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/profile/pet/[id]/recipe-builder/page.tsx">
'use client';

import { useState, useEffect } from 'react';
import { useParams, useRouter } from 'next/navigation';
import Link from 'next/link';
import {
  ChevronLeft,
  X
} from 'lucide-react';
import { generateCustomMealAnalysis } from '@/lib/analyzeCustomMeal';
import { INGREDIENT_COMPOSITIONS } from '@/lib/data/ingredientCompositions';
import { type IngredientSelection, type MealAnalysis } from '@/lib/analyzeCustomMeal';
import { getIngredientsForSpecies, mapIngredientToCompositionKey, ALL_INGREDIENTS, getIngredientDisplayName } from '@/lib/utils/allIngredients';
import { generateIngredientSuggestions } from '@/lib/utils/ingredientSuggestions';
import { getWhitelistForSpecies, isWhitelisted, getSpeciesCoverageLevel, getBlacklistForSpecies } from '@/lib/utils/ingredientWhitelists';
import IngredientPicker from '@/components/IngredientPicker';
import MealCompositionList from '@/components/MealCompositionList';
import CompatibilityPanel from '@/components/CompatibilityPanel';
import SuggestedIngredients from '@/components/SuggestedIngredients';
import MealBuilderWizard from '@/components/MealBuilderWizard';
import MealCompleteView from '@/components/MealCompleteView';
import { getPets } from '@/lib/utils/petStorage'; // Import async storage

// Style mapping for severity levels
const severityStyles = {
  critical: 'bg-red-50 border-red-200 text-red-800',
  major: 'bg-red-50 border-red-200 text-red-700',
  moderate: 'bg-orange-50 border-orange-200 text-orange-700',
};

const getSeverityIcon = (severity: string) => {
  switch (severity) {
    case 'critical':
      return <span className="text-red-600">‚ö†Ô∏è</span>;
    case 'major':
      return <span className="text-red-600">‚ö†Ô∏è</span>;
    default:
      return <span className="text-orange-600">‚ÑπÔ∏è</span>;
  }
};

const getProgressGradientColor = (score: number) => {
  if (score === 0) return '#dc2626'; // red-600
  if (score <= 10) return '#dc2626'; // red-600
  if (score <= 20) return '#ea580c'; // orange-600
  if (score <= 30) return '#d97706'; // amber-600
  if (score <= 40) return '#ca8a04'; // yellow-600
  if (score <= 50) return '#a3a3a3'; // gray-400 (neutral)
  if (score <= 60) return '#84cc16'; // lime-500
  if (score <= 70) return '#65a30d'; // lime-700
  if (score <= 80) return '#16a34a'; // green-600
  if (score <= 90) return '#15803d'; // green-700
  return '#166534'; // green-800
};

interface Pet {
  id: string;
  names: string[];
  type: string;
  breed: string;
  age: string;
  weight: string;
  healthConcerns?: string[];
  dietaryRestrictions?: string[];
  allergies?: string[];
  dislikes?: string[];
  image?: string;
  savedRecipes?: string[];
  weightKg?: number;
}

// Species-appropriate ingredient categories
const SPECIES_INGREDIENT_FILTERS = {
  dogs: {
    allowed: ['chicken_breast', 'ground_turkey', 'chicken_thighs', 'turkey_breast', 'chicken_liver', 'chicken_hearts',
              'salmon_atlantic', 'sardines_water', 'tuna_water',
              'ground_beef_lean', 'beef_liver',
              'eggs_whole',
              'kale_raw', 'spinach_raw', 'carrots_raw', 'sweet_potato', 'broccoli_raw',
              'blueberries_raw', 'bananas_raw',
              'brown_rice_cooked', 'oats', 'quinoa_cooked',
              'fish_oil'], // Meat-focused with some veggies
    disallowed: ['taurine_powder'], // Dogs can synthesize taurine
  },
  cats: {
    allowed: ['chicken_breast', 'ground_turkey', 'turkey_breast', 'chicken_liver', 'chicken_hearts',
              'salmon_atlantic', 'sardines_water', 'tuna_water',
              'eggs_whole',
              'brown_rice_cooked', 'quinoa_cooked',
              'taurine_powder', 'fish_oil'], // Taurine essential for cats, very meat-focused
    disallowed: ['ground_beef_lean', 'beef_liver'], // Many cats allergic/intolerant to beef
  },
  reptiles: {
    allowed: ['kale_raw', 'spinach_raw', 'carrots_raw', 'sweet_potato', 'broccoli_raw', 'celery_raw',
              'blueberries_raw', 'bananas_raw', 'eggs_whole',
              'calcium_carbonate'], // Vegetables and calcium (reptiles are often herbivores/omnivores)
    // Reptiles should use insects like crickets, dubia, etc. but those aren't in our current DB
    disallowed: ['chicken_breast', 'ground_turkey', 'ground_beef_lean', 'beef_liver', 'chicken_liver'],
  },
  birds: {
    allowed: [
      // Protein sources
      'eggs_whole', 'egg (hard-boiled)',
      // Seeds (protein sources for birds)
      'millet (white/red)', 'canary seed', 'niger seed', 'hemp seeds', 'flaxseeds',
      'sesame seeds', 'chia seeds', 'sunflower seeds (small amounts)', 'pumpkin seeds',
      'safflower seeds', 'nyjer seeds', 'amaranth seeds', 'wild bird mix',
      // Insects (for some bird species)
      'crickets', 'mealworms', 'superworms', 'black soldier fly larvae', 'hornworms',
      'dubia roaches', 'pinhead crickets',
      // Cooked lean meats (small amounts for some birds)
      'turkey_breast', 'chicken_breast',
      // Fruits, grains, vegetables, calcium
      'blueberries_raw', 'bananas_raw',
      'brown_rice_cooked', 'oats', 'quinoa_cooked',
      'kale_raw', 'spinach_raw', 'carrots_raw', 'broccoli_raw',
      'calcium_carbonate'
    ],
    disallowed: ['ground_beef_lean', 'beef_liver', 'chicken_liver'], // Raw meat not ideal for birds
  },
  'pocket-pets': {
    allowed: ['oats', 'quinoa_cooked', 'brown_rice_cooked',
              'kale_raw', 'spinach_raw', 'carrots_raw', 'broccoli_raw', 'celery_raw',
              'blueberries_raw', 'bananas_raw',
              'calcium_carbonate'], // Hay/pellet substitutes, veggies, fruits, calcium
    disallowed: ['chicken_breast', 'ground_turkey', 'ground_beef_lean', 'beef_liver', 'salmon_atlantic'],
  },
};

// Normalize pet type to match ALL_INGREDIENTS keys
const normalizeSpecies = (species: string): string => {
  const mapping: Record<string, string> = {
    'dog': 'dogs',
    'cat': 'cats',
    'bird': 'birds',
    'reptile': 'reptiles',
    'pocket-pet': 'pocket-pets',
    'dogs': 'dogs',
    'cats': 'cats',
    'birds': 'birds',
    'reptiles': 'reptiles',
    'pocket-pets': 'pocket-pets'
  };
  return mapping[species.toLowerCase()] || species;
};

// Get filtered ingredients based on pet species - ONLY show species-specific ingredients
const getAvailableIngredients = (species: string, bannedIngredients?: string[]): string[] => {
  const normalizedSpecies = normalizeSpecies(species);
  const filters = SPECIES_INGREDIENT_FILTERS[normalizedSpecies as keyof typeof SPECIES_INGREDIENT_FILTERS];

  // Get species-specific ingredients from scraped data (generate-recipes.js INGREDIENTS object)
  // This contains all the AAFCO and research-based ingredients for this species
  const scrapedIngredients = getIngredientsForSpecies(normalizedSpecies);
  
  // Return ALL scraped ingredient names - don't filter by composition key mapping
  // The composition keys will be looked up when needed for nutritional analysis
  const allIngredientNames = new Set<string>(scrapedIngredients);
  
  // Also include composition keys that are commonly used across species (universal ingredients)
  // but only if they're not explicitly disallowed
  const universalIngredients = [
    'eggs_whole', 'carrots_raw', 'broccoli_raw', 'spinach_raw', 
    'kale_raw', 'celery_raw', 'blueberries_raw', 'bananas_raw',
    'brown_rice_cooked', 'quinoa_cooked', 'sweet_potato', 'oats',
    'fish_oil', 'calcium_carbonate'
  ];
  
  universalIngredients.forEach(key => {
    if (!filters?.disallowed?.includes(key)) {
      // Convert composition key to readable name and add
      const displayName = key.split('_').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
      allIngredientNames.add(displayName);
    }
  });
  
  // Return all ingredient names (scraped names + universal ingredients)
  const mappedKeys = Array.from(allIngredientNames);

  let filtered = mappedKeys;
  
  if (filters) {
    // Filter out disallowed items
    filtered = filtered.filter(ing => !filters.disallowed?.includes(ing));
  }
  
  // Filter out banned ingredients (case-insensitive partial match)
  if (bannedIngredients && bannedIngredients.length > 0) {
    const bannedLower = bannedIngredients.map(b => b.toLowerCase());
    filtered = filtered.filter(ing => {
      const ingLower = ing.toLowerCase();
      return !bannedLower.some(banned => ingLower.includes(banned) || banned.includes(ingLower));
    });
  }

  return Array.from(filtered).sort();
};

// Categorize ingredients
const getCategorizedIngredients = (availableIngredients: string[], species: string) => {
  const normalizedSpecies = normalizeSpecies(species);
  const categories = {
    proteins: {
      name: 'Proteins',
      description: 'Main protein source',
      maxSelections: 999, // No limit - let users experiment
      icon: 'ü•©',
      ingredients: [] as string[]
    },
    greens: {
      name: 'Greens & Veggies',
      description: 'Vitamins and fiber',
      maxSelections: 999,
      icon: 'ü•¨',
      ingredients: [] as string[]
    },
    fruits: {
      name: 'Fruits',
      description: 'Natural sweetness and nutrients',
      maxSelections: 999,
      icon: 'üçé',
      ingredients: [] as string[]
    },
    grains: {
      name: 'Grains & Carbs',
      description: 'Energy source',
      maxSelections: 999,
      icon: 'üåæ',
      ingredients: [] as string[]
    },
    supplements: {
      name: 'Supplements',
      description: 'Essential nutrients',
      maxSelections: 999,
      icon: 'üíä',
      ingredients: [] as string[]
    }
  };

  // Special handling for cats (taurine is specifically marked as essential but can be added to supplements)
  if (normalizedSpecies === 'cats') {
    categories.supplements.description = 'Essential nutrients (taurine recommended)';
  }

  // Special handling for reptiles/herbivores (calcium is essential)
  if (['reptiles', 'pocket-pets'].includes(normalizedSpecies)) {
    categories.supplements.description = 'Essential minerals (calcium recommended)';
  }

  // Get species-specific ingredient categories from scraped data
  const speciesData = ALL_INGREDIENTS[normalizedSpecies as keyof typeof ALL_INGREDIENTS];
  
  if (speciesData) {
    // Map scraped ingredients to composition keys and categorize by species-specific categories
    Object.entries(speciesData).forEach(([categoryName, ingredientList]) => {
      if (Array.isArray(ingredientList)) {
        ingredientList.forEach(ingName => {
          // Use the ingredient name directly (not the composition key) for display
          // Only add if it's in availableIngredients (species-filtered)
          if (availableIngredients.includes(ingName)) {
            // Map category names to our 5 categories based on species
            // Use ingredient name directly (not composition key) for display
            if (categoryName === 'proteins' || categoryName === 'insects' || 
                (normalizedSpecies === 'birds' && categoryName === 'seeds')) {
              // For birds, seeds are protein sources
              if (!categories.proteins.ingredients.includes(ingName)) {
                categories.proteins.ingredients.push(ingName);
              }
            } else if (categoryName === 'vegetables' || categoryName === 'hay') {
              if (!categories.greens.ingredients.includes(ingName)) {
                categories.greens.ingredients.push(ingName);
              }
            } else if (categoryName === 'fruits') {
              if (!categories.fruits.ingredients.includes(ingName)) {
                categories.fruits.ingredients.push(ingName);
              }
            } else if (categoryName === 'carbs' || categoryName === 'seeds' || categoryName === 'pellets' || categoryName === 'hamster_additions') {
              // Seeds go to grains for non-bird species
              if (!categories.grains.ingredients.includes(ingName)) {
                categories.grains.ingredients.push(ingName);
              }
            } else if (categoryName === 'fats' || categoryName === 'fiber_supplements' || categoryName === 'supplements') {
              if (!categories.supplements.ingredients.includes(ingName)) {
                categories.supplements.ingredients.push(ingName);
              }
            }
          }
        });
      }
    });
  }
  
  // Also categorize any remaining ingredients that weren't in scraped data
  availableIngredients.forEach(ingName => {
    // Skip if already categorized
    const allCategorized = [
      ...categories.proteins.ingredients,
      ...categories.greens.ingredients,
      ...categories.fruits.ingredients,
      ...categories.grains.ingredients,
      ...categories.supplements.ingredients
    ];
    if (allCategorized.includes(ingName)) return;
    
    const keyLower = ingName.toLowerCase();
    
    // Proteins: meat, fish, eggs, insects
    if (keyLower.includes('chicken') || keyLower.includes('turkey') || 
        keyLower.includes('beef') || keyLower.includes('liver') || 
        keyLower.includes('hearts') || keyLower.includes('salmon') || 
        keyLower.includes('tuna') || keyLower.includes('sardines') ||
        keyLower.includes('duck') || keyLower.includes('venison') ||
        keyLower.includes('rabbit') || keyLower.includes('quail') ||
        keyLower.includes('pork') || keyLower.includes('giblets') ||
        keyLower.includes('eggs') || keyLower.includes('egg') ||
        keyLower.includes('cricket') || keyLower.includes('roach') ||
        keyLower.includes('worm') || keyLower.includes('insect')) {
      categories.proteins.ingredients.push(ingName);
    } 
    // Greens & Vegetables
    else if (keyLower.includes('kale') || keyLower.includes('spinach') || 
             keyLower.includes('carrot') || keyLower.includes('broccoli') || 
             keyLower.includes('celery') || keyLower.includes('bok') ||
             keyLower.includes('choy') || keyLower.includes('green bean') ||
             keyLower.includes('peas') || keyLower.includes('zucchini') ||
             keyLower.includes('brussels') || keyLower.includes('asparagus') ||
             keyLower.includes('cucumber') || keyLower.includes('lettuce') ||
             keyLower.includes('cabbage') || keyLower.includes('cauliflower') ||
             keyLower.includes('hay')) {
      categories.greens.ingredients.push(ingName);
    } 
    // Fruits
    else if (keyLower.includes('blueberr') || keyLower.includes('banana') ||
             keyLower.includes('apple') || keyLower.includes('berry') ||
             keyLower.includes('mango') || keyLower.includes('papaya') ||
             keyLower.includes('strawberr') || keyLower.includes('grape')) {
      categories.fruits.ingredients.push(ingName);
    } 
    // Grains & Carbs
    else if (keyLower.includes('rice') || keyLower.includes('quinoa') || 
             keyLower.includes('oats') || keyLower.includes('barley') ||
             keyLower.includes('sweet potato') || keyLower.includes('potato') ||
             keyLower.includes('pumpkin') || keyLower.includes('squash') ||
             keyLower.includes('lentil') || keyLower.includes('bean') ||
             keyLower.includes('chickpea') || keyLower.includes('grain') ||
             keyLower.includes('amaranth') || keyLower.includes('buckwheat') ||
             keyLower.includes('millet') || keyLower.includes('sorghum') ||
             keyLower.includes('farro') || keyLower.includes('bulgur') ||
             keyLower.includes('seed') || keyLower.includes('pellet')) {
      categories.grains.ingredients.push(ingName);
    } 
    // Supplements
    else if (keyLower.includes('oil') || keyLower.includes('calcium') || 
             keyLower.includes('taurine') || keyLower.includes('supplement') ||
             keyLower.includes('vitamin') || keyLower.includes('probiotic') ||
             keyLower.includes('psyllium') || keyLower.includes('joint')) {
      categories.supplements.ingredients.push(ingName);
    }
    // Default: add to greens if not categorized
    else {
      categories.greens.ingredients.push(ingName);
    }
  });

  return categories;
};

export default function RecipeBuilderPage() {
  const params = useParams();
  const router = useRouter();
  const petId = params.id as string;

  const [pet, setPet] = useState<Pet | null>(null);
  const [selectedIngredients, setSelectedIngredients] = useState<IngredientSelection[]>([]);
  const [analysis, setAnalysis] = useState<MealAnalysis | null>(null);
  const [isAnalyzing, setIsAnalyzing] = useState(false);
  const [showWizard, setShowWizard] = useState(false);
  const [wizardCompleted, setWizardCompleted] = useState(false);
  const [showAddMore, setShowAddMore] = useState(false);
  const [hasAppliedRecommended, setHasAppliedRecommended] = useState(false);
  const [isFirstCreation, setIsFirstCreation] = useState(false); // Track if this is the first creation
  const [recommendedMeals, setRecommendedMeals] = useState<any[]>([]); // Store recommended meals

  // Get species-appropriate ingredients and categories
  const normalizedSpeciesType = pet ? normalizeSpecies(pet.type) : null;
  const speciesCoverageLevel = normalizedSpeciesType ? getSpeciesCoverageLevel(normalizedSpeciesType as any) : 'limited';
  const blacklist = normalizedSpeciesType ? getBlacklistForSpecies(normalizedSpeciesType as any) : [];
  
  // Filter available ingredients through whitelist
  const allAvailableIngredients = pet ? getAvailableIngredients(pet.type, (pet as any).bannedIngredients) : [];
  const whitelist = normalizedSpeciesType ? getWhitelistForSpecies(normalizedSpeciesType as any) : [];
  const availableIngredients = whitelist.length > 0 
    ? allAvailableIngredients.filter(ing => isWhitelisted(ing, normalizedSpeciesType as any))
    : allAvailableIngredients; // Fallback to all if no whitelist data
  
  const categorizedIngredients = pet ? getCategorizedIngredients(availableIngredients, pet.type) : null;
  
  // Generate base suggestions from static rules
  const baseSuggestedIngredients = pet ? generateIngredientSuggestions({
    type: pet.type,
    age: pet.age,
    healthConcerns: pet.healthConcerns || [],
    breed: pet.breed
  }) : [];
  
  // Extract ingredients from recommended meals and merge with base suggestions
  const suggestedIngredients = (() => {
    if (!pet || recommendedMeals.length === 0) {
      return baseSuggestedIngredients;
    }
    
    // Extract unique ingredients from top 5 recommended meals
    const ingredientsFromMeals = new Map<string, { name: string; reason: string; category: string; fromMeal: boolean }>();
    
    recommendedMeals.slice(0, 5).forEach((meal: any) => {
      const mealIngredients = meal.recipe?.ingredients || meal.adjustedIngredients || [];
      mealIngredients.forEach((ing: any) => {
        const ingName = ing.name || ing.productName || '';
        if (ingName && !ingredientsFromMeals.has(ingName)) {
          // Try to categorize the ingredient
          const nameLower = ingName.toLowerCase();
          let category = 'Other';
          if (nameLower.includes('liver') || nameLower.includes('heart') || nameLower.includes('chicken') || 
              nameLower.includes('turkey') || nameLower.includes('duck') || nameLower.includes('salmon') ||
              nameLower.includes('beef') || nameLower.includes('fish') || nameLower.includes('meat')) {
            category = 'Proteins';
          } else if (nameLower.includes('squash') || nameLower.includes('greens') || nameLower.includes('kale') ||
                     nameLower.includes('spinach') || nameLower.includes('carrot') || nameLower.includes('broccoli') ||
                     nameLower.includes('dandelion') || nameLower.includes('vegetable')) {
            category = 'Greens & Veggies';
          } else if (nameLower.includes('rice') || nameLower.includes('quinoa') || nameLower.includes('oats') ||
                     nameLower.includes('grain') || nameLower.includes('carb')) {
            category = 'Grains & Carbs';
          } else if (nameLower.includes('oil') || nameLower.includes('supplement') || nameLower.includes('powder') ||
                     nameLower.includes('currant') || nameLower.includes('vitamin')) {
            category = 'Supplements';
          } else if (nameLower.includes('berry') || nameLower.includes('apple') || nameLower.includes('banana') ||
                     nameLower.includes('fruit')) {
            category = 'Fruits';
          }
          
          ingredientsFromMeals.set(ingName, {
            name: ingName,
            reason: `Found in your top recommended meals - ${meal.recipe?.name || 'recommended meal'}`,
            category,
            fromMeal: true
          });
        }
      });
    });
    
    // Merge with base suggestions, prioritizing ingredients from meals
    const merged = new Map<string, { name: string; reason: string; category: string }>();
    
    // First add ingredients from recommended meals (higher priority)
    ingredientsFromMeals.forEach((ing) => {
      merged.set(ing.name, { name: ing.name, reason: ing.reason, category: ing.category });
    });
    
    // Then add base suggestions (if not already present)
    baseSuggestedIngredients.forEach((ing) => {
      if (!merged.has(ing.name)) {
        merged.set(ing.name, ing);
      }
    });
    
    return Array.from(merged.values()).slice(0, 12); // Limit to 12 total suggestions
  })();
  
  // Extract recommended ingredient names for wizard
  const recommendedIngredientNames = suggestedIngredients.map(s => s.name);
  
  // Debug logging (remove in production)
  useEffect(() => {
    if (pet && availableIngredients.length > 0) {
      // Debug logging removed for production
    }
  }, [pet, availableIngredients.length, categorizedIngredients]);

  // Load pet data and fetch recommended meals
  useEffect(() => {
    const loadPetData = async () => {
      if (typeof window !== 'undefined') {
        const userId = localStorage.getItem('last_user_id') || 'clerk_simulated_user_id_123';
        
        try {
          const pets = await getPets(userId);
          const foundPet = pets.find((p: any) => p.id === petId);
          
          if (foundPet) {
            setPet(foundPet as unknown as Pet);
            // Show wizard on initial load if no ingredients selected
            if (selectedIngredients.length === 0 && !wizardCompleted) {
              setShowWizard(true);
            }
            
            // Fetch recommended meals... (rest of logic)
            const concerns = (foundPet.healthConcerns || []).filter((concern: string) => concern !== 'none');
            const allergies = (foundPet as any).allergies?.filter((allergy: string) => allergy !== 'none') || [];
            // Use random name from pet's names array
            const petNames = Array.isArray(foundPet.names) ? foundPet.names.filter((n: string) => n && n.trim() !== '') : [];
            const petDisplayName = petNames.length > 0 
              ? petNames[Math.floor(Math.random() * petNames.length)]
              : 'Your Pet';
            
            try {
              const response = await fetch('/api/recommendations', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  profile: {
                    species: foundPet.type,
                    ageGroup: foundPet.age,
                    breed: foundPet.breed,
                    weightKg: parseFloat(foundPet.weight?.replace(/[^0-9.]/g, '') || '10'),
                    healthConcerns: concerns,
                    allergies,
                    petName: petDisplayName,
                  },
                  limit: 5, // Only need top 5 for ingredient extraction
                }),
              });

              if (response.ok) {
                const data = await response.json();
                if (data?.results && Array.isArray(data.results)) {
                  setRecommendedMeals(data.results);
                }
              }
            } catch (error) {
              // Failed to fetch recommended meals
            }
          }
        } catch (error) {
          console.error("Error loading pet:", error);
        }
      }
    };

    loadPetData();
  }, [petId]);

  // Handle wizard completion
  const handleWizardComplete = (selections: { [category: string]: string[] }) => {
    // Convert wizard selections to IngredientSelection format
    const ingredients: IngredientSelection[] = [];
    
    Object.entries(selections).forEach(([category, ingredientNames]) => {
      if (ingredientNames && ingredientNames.length > 0) {
        // Start with a reasonable default based on category
        let defaultGrams = 50;
        if (category === 'proteins') defaultGrams = 100; // More protein
        else if (category === 'grains') defaultGrams = 60;
        else if (category === 'greens') defaultGrams = 40;
        else if (category === 'fruits') defaultGrams = 20;
        else if (category === 'supplements') defaultGrams = 5;
        
        // Add all selected ingredients from this category
        ingredientNames.forEach(ingredientName => {
          ingredients.push({
            key: ingredientName,
            grams: defaultGrams
          });
        });
      }
    });

    setSelectedIngredients(ingredients);
    setWizardCompleted(true);
    setShowWizard(false);
    setIsFirstCreation(true); // Mark as first creation to show popup
    
    // Analysis will be triggered automatically by the useEffect when ingredients change
    // After analysis completes, we can update to recommended amounts
  };

  // Handle start over
  const handleStartOver = () => {
    setSelectedIngredients([]);
    setAnalysis(null);
    setWizardCompleted(false);
    setShowWizard(true);
    setShowAddMore(false);
    setHasAppliedRecommended(false);
    setIsFirstCreation(false); // Reset first creation flag
  };

  // Handle add more ingredients
  const handleAddMore = () => {
    setShowAddMore(true);
  };

  // Auto-analyze recipe when ingredients change
  useEffect(() => {
    const analyzeRecipe = async () => {
      if (selectedIngredients.length > 0 && pet) {
        setIsAnalyzing(true);
        try {
          const petProfile = {
            id: pet.id,
            name: pet.names[0] || 'Pet',
            species: pet.type as any,
            lifeStage: pet.age as any, // Maps to 'adult', 'juvenile', etc.
            weightKg: parseFloat(pet.weight?.replace(/[^0-9.]/g, '')) || 5,
            allergies: [],
            activity: 'moderate' as const, // Default activity level
          };

          // Map ingredient display names to composition keys for analysis
          const mappedIngredients = selectedIngredients.map(sel => {
            const compositionKey = mapIngredientToCompositionKey(sel.key) || sel.key.toLowerCase().replace(/\s+/g, '_').replace(/[^a-z0-9_]/g, '');
            return {
              key: compositionKey,
              grams: sel.grams
            };
          });
          
          const result = generateCustomMealAnalysis(petProfile, mappedIngredients);
          setAnalysis(result);
          
          // After first analysis from wizard, auto-apply recommended amounts once
          if (result.recommendedServingGrams > 0 && selectedIngredients.length > 0 && wizardCompleted && !hasAppliedRecommended) {
            const currentTotal = selectedIngredients.reduce((sum, s) => sum + s.grams, 0);
            if (currentTotal > 0) {
              const recommendedTotal = result.recommendedServingGrams;
              const updatedIngredients = selectedIngredients.map(ing => {
                const ratio = ing.grams / currentTotal;
                return {
                  ...ing,
                  grams: Math.round(recommendedTotal * ratio)
                };
              });
              setSelectedIngredients(updatedIngredients);
              setHasAppliedRecommended(true);
            }
          }
        } catch (error) {
          // Analysis error - handled by error state
        } finally {
          setIsAnalyzing(false);
        }
      } else {
        setAnalysis(null);
      }
    };

    const debounceTimer = setTimeout(analyzeRecipe, 500);
    return () => clearTimeout(debounceTimer);
  }, [selectedIngredients, pet]);

  const addIngredient = (ingredientKey: string) => {
    // Check if ingredient is whitelisted for this species
    if (normalizedSpeciesType && whitelist.length > 0) {
      // ingredientKey might be a display name already, try both
      const displayName = ingredientKey; // Assume it's already a display name from the picker
      if (!isWhitelisted(displayName, normalizedSpeciesType as any)) {
        // Show warning but allow (user can override with vet approval)
        const confirmed = window.confirm(
          `${displayName} is not in the recommended whitelist for ${pet?.type}.\n\n` +
          `This ingredient may not be safe for this species. Please check with your vet before using.\n\n` +
          `Do you want to add it anyway?`
        );
        if (!confirmed) return;
      }
    }
    
    const existing = selectedIngredients.find(s => s.key === ingredientKey);
    if (existing) {
      setSelectedIngredients(prev =>
        prev.map(s =>
          s.key === ingredientKey
            ? { ...s, grams: s.grams + 50 }
            : s
        )
      );
    } else {
      setSelectedIngredients(prev => [...prev, { key: ingredientKey, grams: 50 }]);
    }
  };

  const removeIngredient = (ingredientKey: string) => {
    setSelectedIngredients(prev => prev.filter(s => s.key !== ingredientKey));
  };

  const updateIngredientGrams = (ingredientKey: string, grams: number) => {
    if (grams <= 0) {
      removeIngredient(ingredientKey);
      return;
    }

    setSelectedIngredients(prev =>
      prev.map(s =>
        s.key === ingredientKey
          ? { ...s, grams: Math.round(grams) }
          : s
      )
    );
  };

  const totalGrams = selectedIngredients.reduce((sum, s) => sum + s.grams, 0);

  if (!pet) {
    return (
      <div className="min-h-screen flex items-center justify-center" style={{ backgroundColor: '#0f2c0f' }}>
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-green-400"></div>
        <span className="ml-3 text-gray-300">Loading pet data...</span>
      </div>
    );
  }

  // Prepare categories for wizard
  const proteinRequired = !['pocket-pets', 'reptiles'].includes((normalizedSpeciesType || '').toLowerCase());

  const wizardCategories = categorizedIngredients ? {
    proteins: {
      ...categorizedIngredients.proteins,
      required: proteinRequired && categorizedIngredients.proteins.ingredients.length > 0
    },
    grains: {
      ...categorizedIngredients.grains,
      required: false
    },
    greens: {
      ...categorizedIngredients.greens,
      required: false
    },
    fruits: {
      ...categorizedIngredients.fruits,
      required: false
    },
    supplements: {
      ...categorizedIngredients.supplements,
      required: false
    }
  } : null;

  // Show wizard if not completed and no ingredients
  if (showWizard && wizardCategories) {
    return (
      <>
        {/* Species Coverage Badge */}
        {normalizedSpeciesType && (
          <div className="border-b px-4 py-2" style={{ backgroundColor: '#1a3d2e', borderColor: '#2d5a47' }}>
            <div className="max-w-7xl mx-auto flex items-center justify-between">
              <div className="flex items-center gap-2">
                <span className="text-sm text-gray-300">Ingredient Coverage:</span>
                <span className={`px-2 py-1 rounded text-xs font-semibold ${
                  speciesCoverageLevel === 'full' ? 'bg-green-100 text-green-800' :
                  speciesCoverageLevel === 'beta' ? 'bg-yellow-100 text-yellow-800' :
                  'bg-gray-100 text-gray-800'
                }`}>
                  {speciesCoverageLevel === 'full' ? '‚úì Full Coverage' :
                   speciesCoverageLevel === 'beta' ? 'Œ≤ Beta (Expanding)' :
                   '‚ö† Limited Data'}
                </span>
                {blacklist.length > 0 && (
                  <span className="text-xs text-gray-500">
                    ({blacklist.length} ingredients to avoid)
                  </span>
                )}
              </div>
            </div>
          </div>
        )}
        <MealBuilderWizard
          isOpen={showWizard}
          onClose={() => setShowWizard(false)}
          onComplete={handleWizardComplete}
          categories={wizardCategories}
          petName={pet.names[0] || 'Pet'}
          petType={normalizedSpeciesType || pet.type}
          recommendedIngredients={recommendedIngredientNames}
        />
        <div className="min-h-screen" style={{ backgroundColor: '#0f2c0f' }} />
      </>
    );
  }

  // Show meal complete view after wizard or if ingredients exist
  if (wizardCompleted || selectedIngredients.length > 0) {
    return (
      <>
        <MealCompleteView
          petName={pet.names[0] || 'Pet'}
          petBreed={pet.breed}
          petAge={pet.age}
          petWeight={pet.weight}
          petId={petId}
          userId={localStorage.getItem('last_user_id') || 'clerk_simulated_user_id_123'}
          selectedIngredients={selectedIngredients}
          analysis={analysis}
          isAnalyzing={isAnalyzing}
          onUpdateAmount={updateIngredientGrams}
          onRemove={removeIngredient}
          onAddMore={handleAddMore}
          onStartOver={handleStartOver}
          petType={pet.type}
          getIngredientDisplayName={(key) => {
            // Normalize key to match vetted products
            const normalized = key
              .toLowerCase()
              .replace(/_/g, ' ')      // chicken_breast ‚Üí chicken breast
              .replace(/-/g, ' ')      // chicken-breast ‚Üí chicken breast
              .trim();
            
            // Try to find display name in vetted products
            const product = require('@/lib/data/vetted-products').getVettedProduct(normalized);
            return product?.productName || normalized;
          }}
          isFirstCreation={isFirstCreation}
          getCompatibilityIndicator={(key) => {
            if (!analysis) return null;
            const hasToxicityWarning = analysis.toxicityWarnings.some(w => 
              w.ingredientKey === key || (w.ingredientName && w.ingredientName.toLowerCase().includes(key.toLowerCase()))
            );
            if (hasToxicityWarning) return 'blocked';
            const hasAllergyWarning = analysis.allergyWarnings.some(w => 
              (typeof w === 'string' ? w : w.message).toLowerCase().includes(key.toLowerCase())
            );
            if (hasAllergyWarning) return 'warning';
            return 'safe';
          }}
        />

        {/* Add More Ingredients Modal/View */}
        {showAddMore && categorizedIngredients && (
          <div className="fixed inset-0 z-50 bg-black bg-opacity-50 flex items-center justify-center p-4">
            <div className="bg-white rounded-lg shadow-xl max-w-6xl w-full max-h-[95vh] overflow-y-auto">
              <div className="p-6 border-b border-gray-200 flex items-center justify-between sticky top-0 bg-white z-10">
                <h2 className="text-xl font-bold text-gray-100">Add More Ingredients</h2>
                <button
                  onClick={() => setShowAddMore(false)}
                  className="p-2 hover:opacity-80 rounded-full transition-colors"
                  style={{ backgroundColor: '#2d5a47' }}
                >
                  <X size={20} className="text-gray-200" />
                </button>
              </div>
              <div className="p-6">
                {/* Recommended Ingredients Quick Add */}
                {suggestedIngredients.length > 0 && (
                  <div className="mb-6">
                    <div className="flex items-center gap-2 mb-3">
                      <span className="text-sm font-semibold text-gray-200">Recommended Additions:</span>
                      <span className="text-xs text-gray-400">Click to add quickly</span>
                    </div>
                    <div className="flex flex-wrap gap-2">
                      {suggestedIngredients
                        .filter(sug => !selectedIngredients.some(sel => sel.key === sug.name))
                        .slice(0, 12)
                        .map((suggestion, idx) => {
                          // Check if this ingredient comes from recommended meals
                          const fromMeal = recommendedMeals.some((meal: any) => {
                            const mealIngredients = meal.recipe?.ingredients || meal.adjustedIngredients || [];
                            return mealIngredients.some((ing: any) => 
                              (ing.name || ing.productName || '').toLowerCase() === suggestion.name.toLowerCase()
                            );
                          });
                          
                          return (
                            <button
                              key={idx}
                              onClick={() => {
                                addIngredient(suggestion.name);
                              }}
                              className={`flex items-center gap-1.5 px-2.5 py-1 rounded-md text-xs font-medium transition-opacity ${
                                fromMeal
                                  ? 'bg-green-50 border border-green-300 text-green-900 hover:opacity-80'
                                  : 'bg-blue-50 border border-blue-200 text-blue-900 hover:opacity-80'
                              }`}
                              title={suggestion.reason}
                            >
                              <span>{fromMeal ? '‚ú®' : '‚≠ê'}</span>
                              <span>{suggestion.name}</span>
                              {fromMeal && (
                                <span className="text-xs opacity-75">(from meals)</span>
                              )}
                            </button>
                          );
                        })}
                    </div>
                    {suggestedIngredients.filter(sug => !selectedIngredients.some(sel => sel.key === sug.name)).length === 0 && (
                      <p className="text-xs text-gray-500 italic">All recommended ingredients have been added</p>
                    )}
                  </div>
                )}

                {/* Search Bar */}
                <div className="mb-4">
                  <IngredientPicker
                    ingredients={availableIngredients.map(name => {
                      let category = 'Other';
                      for (const [catKey, cat] of Object.entries(categorizedIngredients)) {
                        if (cat.ingredients.includes(name)) {
                          category = cat.name;
                          break;
                        }
                      }
                      return { name, category };
                    })}
                    categories={categorizedIngredients}
                    onSelect={(ingredientName) => {
                      addIngredient(ingredientName);
                    }}
                    disabled={isAnalyzing}
                  />
                </div>
              </div>
            </div>
          </div>
        )}
      </>
    );
  }

  // Fallback: show original builder (shouldn't reach here normally)
  return (
    <div className="min-h-screen flex items-center justify-center" style={{ backgroundColor: '#0f2c0f' }}>
      <div className="text-center">
        <p className="text-gray-300 mb-4">Starting meal builder...</p>
        <button
          onClick={() => setShowWizard(true)}
          className="px-4 py-2 text-white rounded-md hover:opacity-90"
          style={{ backgroundColor: '#16a34a' }}
        >
          Start Wizard
        </button>
      </div>
    </div>
  );
}
</file>

<file path="app/profile/pet/[id]/saved-recipes/page.tsx">
'use client';

import React, { useState, useEffect, useMemo } from 'react';
import { useParams, useRouter } from 'next/navigation';
import Link from 'next/link';
import { HeartOff, ArrowLeft, Utensils, Clock, Trash2 } from 'lucide-react';
import { getCustomMeals, deleteCustomMeal } from '@/lib/utils/customMealStorage';
import { getPets, savePet } from '@/lib/utils/petStorage'; // Import async storage
import type { CustomMeal, Pet } from '@/lib/types';

// Same simulated user ID setup as profile/page.tsx
const SIMULATED_USER_ID = 'clerk_simulated_user_id_123';

const getCurrentUserId = () => {
  if (typeof window === 'undefined') return SIMULATED_USER_ID;
  return localStorage.getItem('last_user_id') || SIMULATED_USER_ID;
};

export default function SavedRecipesPage() {
  const { id: petId } = useParams();
  const router = useRouter();
  const [pet, setPet] = useState<Pet | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [userId, setUserId] = useState<string | null>(null);
  const [customMeals, setCustomMeals] = useState<CustomMeal[]>([]);

  // Load pet and custom meals - async function
  const loadData = async () => {
    const uid = getCurrentUserId();
    setUserId(uid);

    if (!petId) {
      setIsLoading(false);
      return;
    }

    const resolvedPetId = Array.isArray(petId) ? petId[0] : petId;
    
    try {
      // Load pets and find the current pet
      const pets = await getPets(uid);
      const foundPet = pets.find((p) => p.id === resolvedPetId);
      setPet(foundPet || null);
      
      // Load custom meals for this pet
      const meals = await getCustomMeals(uid, resolvedPetId);
      setCustomMeals(meals);
    } catch (error) {
      console.error('Error loading pet data:', error);
    } finally {
      setIsLoading(false);
    }
  };

  // Load pet and custom meals from storage
  useEffect(() => {
    loadData();
  }, [petId]);

  // Listen for updates to pets and custom meals
  useEffect(() => {
    if (typeof window === 'undefined') return;

    const handlePetsUpdated = (e: CustomEvent) => {
      // Refresh if pets were updated
      if (e.detail?.userId === getCurrentUserId()) {
        loadData();
      }
    };

    const handleStorageChange = (e: StorageEvent) => {
      // Refresh if pets or custom meals storage was modified (cross-tab/window)
      const uid = getCurrentUserId();
      if (e.key === `pets_${uid}` || e.key?.startsWith(`custom_meals_${uid}_`)) {
        loadData();
      }
    };

    window.addEventListener('petsUpdated', handlePetsUpdated as EventListener);
    window.addEventListener('storage', handleStorageChange);

    return () => {
      window.removeEventListener('petsUpdated', handlePetsUpdated as EventListener);
      window.removeEventListener('storage', handleStorageChange);
    };
  }, [petId]);

  // Map saved recipe IDs and custom meals to display format
  const savedRecipeDetails = useMemo(() => {
    const allMeals: {
      id: string;
      name: string;
      dateAdded?: number;
      isCustom?: boolean;
      compatibilityScore?: number;
    }[] = [];
    
    // Add custom meals (with compatibility score)
    customMeals.forEach((meal) => {
      allMeals.push({
        id: meal.id,
        name: meal.name,
        dateAdded: meal.createdAt ? new Date(meal.createdAt).getTime() : undefined,
        isCustom: true,
        compatibilityScore: meal.analysis?.score,
      });
    });
    
    return allMeals;
  }, [pet, customMeals]);

  const handleRemoveRecipe = async (recipeIdToRemove: string, isCustom: boolean = false) => {
    if (!userId || !pet) return;

    if (isCustom) {
      // Remove custom meal
      await deleteCustomMeal(userId, pet.id, recipeIdToRemove);
      setCustomMeals(prev => prev.filter(m => m.id !== recipeIdToRemove));
    } else {
      // Update the pet's savedRecipes array
      const updatedPet: Pet = {
        ...pet,
        savedRecipes: (pet.savedRecipes || []).filter(id => id !== recipeIdToRemove),
      };

      await savePet(userId, updatedPet);
      setPet(updatedPet);
    }
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-screen bg-gray-50">
        <p className="text-xl text-green-800 font-medium">Loading pet profile...</p>
      </div>
    );
  }

  if (!pet) {
    return (
      <div className="max-w-4xl mx-auto py-12 px-4 text-center">
        <HeartOff className="w-16 h-16 text-red-500 mx-auto mb-4" />
        <h1 className="text-3xl font-bold text-gray-900 mb-2">Pet Not Found</h1>
        <p className="text-gray-600">
          We couldn't find a pet with the ID:{' '}
          <span className="font-mono bg-gray-100 p-1 rounded text-sm">{String(petId)}</span>.
        </p>
        <Link
          href="/profile"
          className="mt-6 inline-flex items-center text-green-800 hover:text-green-900 transition-colors font-medium"
        >
          <ArrowLeft className="w-5 h-5 mr-2" /> Back to Pet Profiles
        </Link>
      </div>
    );
  }

  const hasSaved = savedRecipeDetails.length > 0;

  // Get random name from pet's names array
  const petNames = Array.isArray((pet as any).names) ? (pet as any).names.filter((n: string) => n && n.trim() !== '') : [];
  const petDisplayName = petNames.length > 0 
    ? petNames[Math.floor(Math.random() * petNames.length)]
    : (pet.name || 'Your Pet');

  return (
    <div className="min-h-screen bg-gray-50 py-4">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <Link
          href="/profile"
          className="inline-flex items-center text-gray-500 hover:text-green-800 transition-colors mb-3 text-sm"
        >
          <ArrowLeft className="w-4 h-4 mr-1" /> Back to Pet Profiles
        </Link>

        <header className="mb-4 p-3 bg-white rounded-lg shadow border-l-4 border-primary-600">
          <h1 className="text-xl font-bold text-gray-900 flex items-center">
            <Utensils className="w-5 h-5 mr-2 text-primary-600" />
            Saved Meals for {petDisplayName}
          </h1>
          <p className="text-sm text-gray-600 mt-1">
            A curated collection for your <span className="capitalize font-medium">{pet.type}</span>, the {pet.breed}.
          </p>
        </header>

        {hasSaved && (
          <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3 mb-6">
            <p className="text-sm text-gray-600">
              {savedRecipeDetails.length} meals saved for {petDisplayName}.
            </p>
            <button
              onClick={() => router.push(`/profile/pet/${pet.id}/meal-plan`)}
              disabled={savedRecipeDetails.length < 2}
              className={`px-5 py-3 rounded-lg font-semibold transition-colors ${
                savedRecipeDetails.length < 2
                  ? 'bg-gray-200 text-gray-500 cursor-not-allowed'
                  : 'bg-green-800 text-white hover:bg-green-900'
              }`}
            >
              Create Meal Plan
            </button>
          </div>
        )}

        <div className="space-y-4">
          {hasSaved ? (
            savedRecipeDetails.map((recipe) => (
              <div
                key={recipe.id}
                className="flex items-center p-4 bg-white rounded-xl shadow hover:shadow-md transition-shadow justify-between"
              >
                <Link
                  href={`/recipe/${recipe.id}?petId=${pet.id}`}
                  className="flex items-center flex-grow group"
                >
                  <div className="ml-0 flex-1">
                    <div className="flex items-center gap-2 flex-wrap">
                      <p className="text-lg font-semibold text-gray-800 group-hover:text-primary-600 transition-colors">
                        {recipe.name}
                      </p>
                      {recipe.isCustom && (
                        <span className="text-xs bg-blue-100 text-blue-800 px-2 py-0.5 rounded-full font-medium">
                          Custom
                        </span>
                      )}
                      {recipe.isCustom && recipe.compatibilityScore !== undefined && (
                        <div className="flex items-center gap-1.5 px-2 py-0.5 rounded-full bg-gray-100">
                          <span className="text-xs font-medium text-gray-600">Score:</span>
                          <span className={`text-xs font-bold ${
                            recipe.compatibilityScore >= 80 ? 'text-green-600' :
                            recipe.compatibilityScore >= 60 ? 'text-yellow-600' :
                            'text-red-600'
                          }`}>
                            {recipe.compatibilityScore}
                          </span>
                        </div>
                      )}
                    </div>
                    {recipe.dateAdded && (
                      <div className="flex items-center text-sm text-gray-500 mt-1">
                        <Clock className="w-3 h-3 mr-1" />
                        <span>
                          Saved: {new Date(recipe.dateAdded).toLocaleDateString()}
                        </span>
                      </div>
                    )}
                  </div>
                </Link>

                <button
                  onClick={() => handleRemoveRecipe(recipe.id, recipe.isCustom)}
                  className="ml-4 p-2 text-red-500 hover:bg-red-50 rounded-full transition-colors"
                  aria-label={`Remove ${recipe.name}`}
                >
                  <Trash2 className="w-5 h-5" />
                </button>
              </div>
            ))
          ) : (
            <div className="text-center p-10 bg-white rounded-xl shadow-inner border border-gray-200">
              <HeartOff className="w-12 h-12 text-gray-400 mx-auto mb-3" />
              <p className="text-xl font-medium text-gray-700">No Saved Meals Yet!</p>
              <p className="text-gray-500 mt-2">
                Start by browsing our catalog to find the perfect meal for {petDisplayName}.
              </p>
              <Link
                href={`/profile/pet/${pet.id}`}
                className="mt-4 inline-block px-6 py-2 bg-green-800 text-white rounded-lg hover:bg-green-900 transition-colors font-medium shadow-md"
              >
                Find Meals
              </Link>
            </div>
          )}
        </div>
      </div>

      <p className="fixed bottom-4 right-4 text-xs text-gray-400">
        Current User ID: {userId || 'Unknown'} (Pet ID: {String(petId)})
      </p>
    </div>
  );
}
</file>

<file path="components/MealBuilderWizard.tsx">
'use client';

import { useState, useMemo } from 'react';
import { X, ChevronRight, ChevronLeft, Check, Star, ArrowUp } from 'lucide-react';
import { createPortal } from 'react-dom';
import Image from 'next/image';
import { INGREDIENT_COMPOSITIONS, getIngredientComposition, type IngredientComposition } from '@/lib/data/ingredientCompositions';
import { getFallbackNutrition } from '@/lib/utils/nutritionFallbacks';

interface Category {
  name: string;
  description: string;
  icon: string;
  ingredients: string[];
  required: boolean;
}

interface MealBuilderWizardProps {
  isOpen: boolean;
  onClose: () => void;
  onComplete: (selections: { [category: string]: string[] }) => void;
  categories: {
    proteins: Category;
    grains: Category;
    greens: Category;
    fruits: Category;
    supplements: Category;
  };
  petName: string;
  petType?: string; // Pet species type (dogs, cats, pocket-pets, etc.)
  recommendedIngredients?: string[]; // List of recommended ingredient names
}

const CATEGORY_ORDER = ['proteins', 'grains', 'greens', 'fruits', 'supplements'] as const;

/**
 * Get the highest nutrient value for an ingredient
 * Returns the nutrient name and a normalized value for comparison
 */
function getTopNutrients(ingredientName: string, count: number = 3): Array<{ name: string; value: number }> {
  // Normalize ingredient name
  const normalized = ingredientName.toLowerCase()
    .trim()
    .replace(/\s+/g, '_')
    .replace(/[^a-z0-9_]/g, '')
    .replace(/_+/g, '_');
  
  // Try to get composition
  let composition: IngredientComposition | null = INGREDIENT_COMPOSITIONS[normalized] || null;
  if (!composition) {
    composition = getIngredientComposition(ingredientName) || null;
  }
  if (!composition) {
    // Try fallback
    composition = getFallbackNutrition(ingredientName);
  }
  
  if (!composition) return [];
  
  // Define nutrients to check with their display names and normalization factors
  const nutrients = [
    { key: 'protein', name: 'Protein', value: composition.protein || 0, factor: 1 },
    { key: 'fat', name: 'Fat', value: composition.fat || 0, factor: 1 },
    { key: 'fiber', name: 'Fiber', value: composition.fiber || 0, factor: 1 },
    { key: 'calcium', name: 'Calcium', value: (composition.calcium || 0) / 100, factor: 100 }, // Convert mg to g for comparison
    { key: 'omega3', name: 'Omega-3', value: composition.omega3 || 0, factor: 1 },
    { key: 'taurine', name: 'Taurine', value: (composition.taurine || 0) / 100, factor: 100 }, // Convert mg to g
    { key: 'vitaminA', name: 'Vitamin A', value: (composition.vitaminA || 0) / 1000, factor: 1000 }, // Convert IU to thousands
    { key: 'vitaminC', name: 'Vitamin C', value: (composition.vitaminC || 0) / 100, factor: 100 }, // Convert mg to g
  ];
  
  // Calculate normalized values and filter out insignificant ones
  const nutrientsWithNormalized = nutrients
    .map(nutrient => ({
      ...nutrient,
      normalizedValue: nutrient.value * nutrient.factor
    }))
    .filter(nutrient => nutrient.normalizedValue > 0.1); // Only include significant values
  
  // Sort by normalized value (descending) and take top N
  const topNutrients = nutrientsWithNormalized
    .sort((a, b) => b.normalizedValue - a.normalizedValue)
    .slice(0, count)
    .map(nutrient => ({
      name: nutrient.name,
      value: nutrient.value
    }));
  
  return topNutrients;
}

export default function MealBuilderWizard({
  isOpen,
  onClose,
  onComplete,
  categories,
  petName,
  petType,
  recommendedIngredients = []
}: MealBuilderWizardProps) {
  const skipProteins = !categories.proteins.required || categories.proteins.ingredients.length === 0;
  const skipFruits = petType && ['dogs', 'cats', 'dog', 'cat'].includes(petType.toLowerCase());
  const stepOrder = CATEGORY_ORDER.filter((key) => {
    if (skipProteins && key === 'proteins') return false;
    if (skipFruits && key === 'fruits') return false;
    return true;
  });

  const [currentStep, setCurrentStep] = useState(0);
  const [selections, setSelections] = useState<{ [key: string]: string[] }>({
    proteins: [],
    grains: [],
    greens: [],
    fruits: [],
    supplements: []
  });

  if (!isOpen) return null;

  const currentCategoryKey = stepOrder[currentStep];
  const currentCategory = categories[currentCategoryKey];
  const isRequired = currentCategory.required;
  const currentSelections = selections[currentCategoryKey] || [];
  const hasSelection = currentSelections.length > 0;
  const hasIngredients = currentCategory.ingredients.length > 0;
  // Allow proceeding if: not required, OR has selection, OR required but no ingredients available
  const canProceed = !isRequired || hasSelection || !hasIngredients;
  const isLastStep = currentStep === stepOrder.length - 1;

  const handleSelect = (ingredient: string) => {
    setSelections(prev => {
      const current = prev[currentCategoryKey] || [];
      const isSelected = current.includes(ingredient);
      return {
        ...prev,
        [currentCategoryKey]: isSelected 
          ? current.filter(ing => ing !== ingredient)
          : [...current, ingredient]
      };
    });
  };

  const handleNext = () => {
    if (isLastStep) {
      onComplete(selections);
      handleClose();
    } else {
      setCurrentStep(prev => prev + 1);
    }
  };

  const handleBack = () => {
    if (currentStep > 0) {
      setCurrentStep(prev => prev - 1);
    }
  };

  const handleClose = () => {
    setCurrentStep(0);
    setSelections({
      proteins: [],
      grains: [],
      greens: [],
      fruits: [],
      supplements: []
    });
    onClose();
  };

  const wizardContent = (
    <div className="fixed inset-0 z-50 flex items-center justify-center p-4" style={{ backgroundColor: '#0f2c0f' }}>
      <div className="rounded-lg shadow-xl max-w-2xl w-full max-h-[90vh] flex flex-col" style={{ backgroundColor: '#143424' }}>
        {/* Header */}
        <div className="flex items-center justify-between p-6 border-b" style={{ borderColor: '#2d5a47' }}>
          <div>
            <h2 className="text-2xl font-bold text-gray-100">
              Create Meal for {petName}
            </h2>
            <p className="text-sm text-gray-300 mt-1">
              Step {currentStep + 1} of {stepOrder.length}
            </p>
          </div>
          <button
            onClick={handleClose}
            className="p-2 hover:opacity-80 rounded-full transition-colors"
            style={{ backgroundColor: '#2d5a47' }}
          >
            <X size={20} className="text-gray-200" />
          </button>
        </div>

        {/* Progress Bar */}
        <div className="px-6 py-4 border-b" style={{ backgroundColor: '#143424', borderColor: '#2d5a47' }}>
          <div className="flex gap-2">
            {stepOrder.map((key, index) => {
              const category = categories[key];
              const isActive = index === currentStep;
              const isCompleted = (selections[key] || []).length > 0;
              const isPast = index < currentStep;

              return (
                <div key={key} className="flex-1">
                  <div className="flex items-center gap-2">
                    <div
                      className={`flex-1 h-2 rounded-full transition-colors ${
                        isActive
                          ? 'bg-primary-600'
                          : isCompleted || isPast
                          ? 'bg-green-500'
                          : 'bg-gray-200'
                      }`}
                    />
                    {isCompleted && !isActive && (
                      <Check size={16} className="text-green-400 flex-shrink-0" />
                    )}
                  </div>
                  <div className="text-xs text-gray-300 mt-1 truncate">
                    {category.icon} {category.name}
                  </div>
                </div>
              );
            })}
          </div>
        </div>

        {/* Category Content */}
        <div className="flex-1 overflow-y-auto p-6">
          <div className="text-center mb-6">
            {currentStep === 0 && (
              <div className="mb-4 flex justify-center">
                <Image
                  src="/images/emojis/Mascots/PrepPuppy/PrepPuppyKitchen.jpg"
                  alt="Puppy Prepper"
                  width={240}
                  height={240}
                  className="w-[240px] h-[240px] object-contain"
                  unoptimized
                />
              </div>
            )}
            <div className="text-4xl mb-2">{currentCategory.icon}</div>
            <h3 className="text-xl font-semibold text-gray-100 mb-1">
              {currentCategory.name}
            </h3>
            <p className="text-sm text-gray-300">{currentCategory.description}</p>
            {isRequired && hasIngredients && (
              <p className="text-xs text-red-400 mt-2">* Required</p>
            )}
            {isRequired && !hasIngredients && (
              <p className="text-xs text-yellow-400 mt-2">‚ö† No ingredients available - you can skip this step</p>
            )}
          </div>

          {/* Ingredient List */}
          <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
            {currentCategory.ingredients.length === 0 ? (
              <div className="col-span-2 text-center py-8 text-gray-400">
                No ingredients available in this category for this pet.
              </div>
            ) : (() => {
              // Separate recommended and regular ingredients
              const recommended = currentCategory.ingredients.filter(ing => 
                recommendedIngredients.includes(ing)
              );
              const regular = currentCategory.ingredients.filter(ing => 
                !recommendedIngredients.includes(ing)
              );
              
              // Sort: recommended first, then regular
              const sortedIngredients = [...recommended, ...regular];
              
              return sortedIngredients.map(ingredient => {
                const isSelected = currentSelections.includes(ingredient);
                const isRecommended = recommendedIngredients.includes(ingredient);
                const topNutrients = getTopNutrients(ingredient, 3);
                
                return (
                  <button
                    key={ingredient}
                    onClick={() => handleSelect(ingredient)}
                    className="p-4 rounded-lg text-left transition-colors duration-200 relative"
                    style={{
                      border: isSelected ? '3px solid #f97316' : isRecommended ? '3px solid #fb923c' : '3px solid rgba(249, 115, 22, 0.5)',
                      backgroundColor: isSelected ? '#2d5a47' : isRecommended ? '#3d4a2e' : '#143424',
                      color: '#e5e7eb'
                    }}
                  >
                    <div className="flex items-center justify-between">
                      <div className="flex items-center gap-2 flex-1 min-w-0">
                        {isRecommended && (
                          <Star size={16} className="text-yellow-400 fill-yellow-400 flex-shrink-0" />
                        )}
                        <span className="text-sm font-medium truncate text-gray-100">
                          {ingredient}
                        </span>
                      </div>
                      {isSelected && (
                        <Check size={18} className="text-green-400 flex-shrink-0 ml-2" />
                      )}
                    </div>
                    <div className="flex items-center justify-between mt-2 flex-wrap gap-2">
                      {isRecommended && (
                        <div className="text-xs text-yellow-300">
                          Recommended
                        </div>
                      )}
                      {topNutrients.length > 0 && (
                        <div className="flex items-center gap-2 ml-auto flex-wrap">
                          {topNutrients.map((nutrient, idx) => (
                            <div key={idx} className="flex items-center gap-1 text-xs text-orange-300">
                              <ArrowUp size={12} className="text-orange-400" />
                              <span>{nutrient.name}</span>
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                  </button>
                );
              });
            })()}
          </div>
        </div>

        {/* Footer Actions */}
        <div className="flex items-center justify-between p-6 border-t" style={{ borderColor: '#2d5a47', backgroundColor: '#143424' }}>
          <button
            onClick={handleBack}
            disabled={currentStep === 0}
            className="flex items-center gap-2 px-4 py-2 text-sm font-medium rounded-md disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
            style={{
              backgroundColor: '#2d5a47',
              border: '3px solid #f97316',
              color: '#e5e7eb'
            }}
          >
            <ChevronLeft size={16} />
            Back
          </button>

          <div className="flex gap-3">
            <button
              onClick={handleNext}
              disabled={!canProceed}
              className="flex items-center gap-2 px-6 py-2 text-sm font-medium text-white rounded-md disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
              style={{
                backgroundColor: '#16a34a',
                border: '3px solid #f97316'
              }}
            >
              {isLastStep ? 'Complete' : 'Next'}
              {!isLastStep && <ChevronRight size={16} />}
            </button>
          </div>
        </div>
      </div>
    </div>
  );

  // Use portal to render modal at root level
  if (typeof window !== 'undefined') {
    return createPortal(wizardContent, document.body);
  }

  return null;
}
</file>

<file path="lib/generator/AmazonLinkAudit.ts">
// Amazon Affiliate Link Audit
// Checks all asinLink values in vetted-products for issues

import { VETTED_PRODUCTS } from '../data/vetted-products';

interface LinkIssue {
  ingredient: string;
  issue: string;
  asinLink?: string;
  productName?: string;
}

const issues: LinkIssue[] = [];
const stats = {
  total: 0,
  withLinks: 0,
  withoutLinks: 0,
  invalidFormat: 0,
  missingAsin: 0,
  suspiciousLinks: 0,
  duplicateAsins: new Map<string, string[]>(),
};

console.log('='.repeat(80));
console.log('AMAZON AFFILIATE LINK AUDIT');
console.log('='.repeat(80));
console.log();

// Check each product
for (const [ingredientName, product] of Object.entries(VETTED_PRODUCTS)) {
  stats.total++;
  
  const asinLink = product.asinLink;
  
  // Issue 1: Missing asinLink
  if (!asinLink || asinLink === '') {
    stats.withoutLinks++;
    issues.push({
      ingredient: ingredientName,
      issue: 'Missing asinLink',
      productName: product.productName,
    });
    continue;
  }
  
  stats.withLinks++;
  
  // Issue 2: Invalid format (should be Amazon URL)
  if (!asinLink.includes('amazon.com')) {
    stats.invalidFormat++;
    issues.push({
      ingredient: ingredientName,
      issue: 'Not an Amazon link',
      asinLink,
      productName: product.productName,
    });
    continue;
  }
  
  // Issue 3: Missing ASIN in URL
  const asinMatch = asinLink.match(/\/dp\/([A-Z0-9]{10})/i);
  if (!asinMatch) {
    stats.missingAsin++;
    issues.push({
      ingredient: ingredientName,
      issue: 'No valid ASIN found in URL',
      asinLink,
      productName: product.productName,
    });
    continue;
  }
  
  const asin = asinMatch[1];
  
  // Issue 4: Missing affiliate tag
  if (!asinLink.includes('tag=robinfrench-20')) {
    stats.suspiciousLinks++;
    issues.push({
      ingredient: ingredientName,
      issue: 'Missing affiliate tag (tag=robinfrench-20)',
      asinLink,
      productName: product.productName,
    });
  }
  
  // Track duplicate ASINs
  if (!stats.duplicateAsins.has(asin)) {
    stats.duplicateAsins.set(asin, []);
  }
  stats.duplicateAsins.get(asin)!.push(ingredientName);
}

// Find actual duplicates (same ASIN used for multiple ingredients)
const duplicates = Array.from(stats.duplicateAsins.entries())
  .filter(([_, ingredients]) => ingredients.length > 1);

// Print Summary
console.log('SUMMARY');
console.log('-'.repeat(80));
console.log(`Total products: ${stats.total}`);
console.log(`With links: ${stats.withLinks} (${((stats.withLinks / stats.total) * 100).toFixed(1)}%)`);
console.log(`Without links: ${stats.withoutLinks} (${((stats.withoutLinks / stats.total) * 100).toFixed(1)}%)`);
console.log();
console.log(`Issues found: ${issues.length}`);
console.log(`  - Invalid format: ${stats.invalidFormat}`);
console.log(`  - Missing ASIN: ${stats.missingAsin}`);
console.log(`  - Missing affiliate tag: ${stats.suspiciousLinks}`);
console.log(`  - Duplicate ASINs: ${duplicates.length} ASINs used for multiple ingredients`);
console.log();

// Print Issues
if (issues.length > 0) {
  console.log('='.repeat(80));
  console.log('ISSUES FOUND');
  console.log('='.repeat(80));
  console.log();
  
  // Group by issue type
  const byType = issues.reduce((acc, issue) => {
    if (!acc[issue.issue]) acc[issue.issue] = [];
    acc[issue.issue].push(issue);
    return acc;
  }, {} as Record<string, LinkIssue[]>);
  
  for (const [issueType, issueList] of Object.entries(byType)) {
    console.log(`${issueType} (${issueList.length}):`);
    console.log('-'.repeat(80));
    
    issueList.slice(0, 10).forEach(issue => {
      console.log(`  Ingredient: ${issue.ingredient}`);
      if (issue.productName) console.log(`  Product: ${issue.productName}`);
      if (issue.asinLink) console.log(`  Link: ${issue.asinLink}`);
      console.log();
    });
    
    if (issueList.length > 10) {
      console.log(`  ... and ${issueList.length - 10} more`);
      console.log();
    }
  }
}

// Print Duplicate ASINs
if (duplicates.length > 0) {
  console.log('='.repeat(80));
  console.log('DUPLICATE ASINs');
  console.log('='.repeat(80));
  console.log();
  console.log('Same ASIN used for multiple ingredients (may indicate incorrect mappings):');
  console.log();
  
  duplicates.slice(0, 20).forEach(([asin, ingredients]) => {
    console.log(`ASIN ${asin} used for ${ingredients.length} ingredients:`);
    ingredients.forEach(ing => console.log(`  - ${ing}`));
    console.log();
  });
  
  if (duplicates.length > 20) {
    console.log(`... and ${duplicates.length - 20} more duplicate ASINs`);
  }
}

// Print recommendations
console.log('='.repeat(80));
console.log('RECOMMENDATIONS');
console.log('='.repeat(80));
console.log();

if (stats.withoutLinks > 0) {
  console.log(`1. Add asinLink for ${stats.withoutLinks} products without links`);
}

if (stats.invalidFormat > 0) {
  console.log(`2. Fix ${stats.invalidFormat} products with invalid link format`);
}

if (stats.missingAsin > 0) {
  console.log(`3. Fix ${stats.missingAsin} products with missing/invalid ASIN`);
}

if (stats.suspiciousLinks > 0) {
  console.log(`4. Add affiliate tag to ${stats.suspiciousLinks} products`);
}

if (duplicates.length > 0) {
  console.log(`5. Review ${duplicates.length} duplicate ASINs - may indicate wrong products`);
}

if (issues.length === 0 && duplicates.length === 0) {
  console.log('‚úÖ All links look good! No issues found.');
}

console.log();
console.log('='.repeat(80));
</file>

<file path="lib/generator/AutoClassifyLinks.ts">
// Auto-classify all 94 items using spec-based validation
// Reduces manual review from 94 ‚Üí ~15-20 items

import { VETTED_PRODUCTS } from '../data/vetted-products';
import { RETAIL_SPECS } from '../validation/retailSpecDefinitions';
import { RetailValidator } from '../validation/retailValidator';
import * as fs from 'fs';
import * as path from 'path';

interface ClassificationResult {
  ingredient: string;
  productName: string;
  asin: string;
  link: string;
  status: 'auto-valid' | 'auto-invalid' | 'needs-review' | 'no-spec';
  confidence: 'high' | 'medium' | 'low';
  issues: string[];
  notes: string;
}

const validator = new RetailValidator();
const results: ClassificationResult[] = [];

console.log('='.repeat(80));
console.log('AUTO-CLASSIFYING AMAZON LINKS');
console.log('='.repeat(80));
console.log();

// Track duplicate ASINs
const asinMap = new Map<string, string[]>();
for (const [ingredientName, product] of Object.entries(VETTED_PRODUCTS)) {
  const asinMatch = product.asinLink.match(/\/dp\/([A-Z0-9]{10})/i);
  if (asinMatch) {
    const asin = asinMatch[1];
    if (!asinMap.has(asin)) {
      asinMap.set(asin, []);
    }
    asinMap.get(asin)!.push(ingredientName);
  }
}

// Known dead links
const deadLinks = new Set(['B0082C00P8', 'B0006L2XNK']);

// Process each ingredient
for (const [ingredientName, product] of Object.entries(VETTED_PRODUCTS)) {
  const asinMatch = product.asinLink.match(/\/dp\/([A-Z0-9]{10})/i);
  if (!asinMatch) continue;
  
  const asin = asinMatch[1];
  const spec = RETAIL_SPECS[ingredientName];
  
  let status: ClassificationResult['status'];
  let confidence: ClassificationResult['confidence'];
  let issues: string[] = [];
  let notes = '';
  
  // Dead link check
  if (deadLinks.has(asin)) {
    status = 'auto-invalid';
    confidence = 'high';
    issues.push('Dead link (HTTP 405)');
    notes = 'NEEDS REPLACEMENT - Link is dead';
  }
  // Has spec - validate it
  else if (spec) {
    const validationResult = validator.validateProductTitle(
      product.productName,
      spec,
      asin
    );
    
    confidence = validationResult.confidence;
    issues = validationResult.issues.map(i => `${i.severity.toUpperCase()}: ${i.message}`);
    
    if (validationResult.status === 'valid') {
      status = 'auto-valid';
      notes = '‚úÖ Passes all validation checks';
    } else if (validationResult.status === 'invalid') {
      status = 'auto-invalid';
      notes = '‚ùå Failed validation - likely wrong product';
    } else {
      status = 'needs-review';
      notes = '‚ö†Ô∏è Ambiguous - manual review needed';
    }
  }
  // No spec - check if duplicate ASIN
  else {
    const duplicates = asinMap.get(asin) || [];
    if (duplicates.length > 1) {
      status = 'needs-review';
      confidence = 'medium';
      issues.push(`Duplicate ASIN shared with: ${duplicates.filter(d => d !== ingredientName).join(', ')}`);
      notes = '‚ö†Ô∏è Duplicate ASIN - verify if appropriate';
    } else {
      status = 'no-spec';
      confidence = 'medium';
      notes = 'No validation spec defined - assumed OK';
    }
  }
  
  results.push({
    ingredient: ingredientName,
    productName: product.productName,
    asin,
    link: product.asinLink,
    status,
    confidence,
    issues,
    notes,
  });
}

// Generate statistics
const stats = {
  total: results.length,
  autoValid: results.filter(r => r.status === 'auto-valid').length,
  autoInvalid: results.filter(r => r.status === 'auto-invalid').length,
  needsReview: results.filter(r => r.status === 'needs-review').length,
  noSpec: results.filter(r => r.status === 'no-spec').length,
};

console.log('CLASSIFICATION RESULTS');
console.log('-'.repeat(80));
console.log(`Total items: ${stats.total}`);
console.log(`‚úÖ Auto-valid: ${stats.autoValid} (${((stats.autoValid / stats.total) * 100).toFixed(1)}%)`);
console.log(`‚ùå Auto-invalid: ${stats.autoInvalid} (${((stats.autoInvalid / stats.total) * 100).toFixed(1)}%)`);
console.log(`‚ö†Ô∏è  Needs review: ${stats.needsReview} (${((stats.needsReview / stats.total) * 100).toFixed(1)}%)`);
console.log(`üìã No spec: ${stats.noSpec} (${((stats.noSpec / stats.total) * 100).toFixed(1)}%)`);
console.log();
console.log(`Manual review reduced from 94 ‚Üí ${stats.needsReview + stats.autoInvalid} items`);
console.log();

// Show items needing review
const reviewItems = results.filter(r => r.status === 'needs-review' || r.status === 'auto-invalid');

if (reviewItems.length > 0) {
  console.log('='.repeat(80));
  console.log(`ITEMS REQUIRING MANUAL REVIEW (${reviewItems.length})`);
  console.log('='.repeat(80));
  console.log();
  
  reviewItems.forEach((item, idx) => {
    console.log(`${idx + 1}. ${item.ingredient}`);
    console.log(`   Product: ${item.productName}`);
    console.log(`   ASIN: ${item.asin}`);
    console.log(`   Status: ${item.status.toUpperCase()}`);
    console.log(`   Confidence: ${item.confidence.toUpperCase()}`);
    if (item.issues.length > 0) {
      console.log(`   Issues:`);
      item.issues.forEach(issue => console.log(`     - ${issue}`));
    }
    console.log(`   Notes: ${item.notes}`);
    console.log(`   Link: ${item.link}`);
    console.log();
  });
}

// Generate CSV for manual review
const csvHeader = 'Status,Ingredient,Product Name,ASIN,Confidence,Issues,Notes,Action Needed,Link\n';
const csvRows = reviewItems.map(item => {
  const escapeCsv = (str: string) => `"${str.replace(/"/g, '""')}"`;
  return [
    item.status.toUpperCase(),
    escapeCsv(item.ingredient),
    escapeCsv(item.productName),
    item.asin,
    item.confidence.toUpperCase(),
    escapeCsv(item.issues.join('; ')),
    escapeCsv(item.notes),
    item.status === 'auto-invalid' ? 'FIND NEW ASIN' : 'VERIFY',
    item.link,
  ].join(',');
}).join('\n');

const csv = csvHeader + csvRows;
const outputPath = path.join(process.cwd(), 'MANUAL_REVIEW_REQUIRED.csv');
fs.writeFileSync(outputPath, csv, 'utf-8');

console.log('='.repeat(80));
console.log('NEXT STEPS');
console.log('='.repeat(80));
console.log();
console.log(`1. Open MANUAL_REVIEW_REQUIRED.csv (${reviewItems.length} items)`);
console.log('2. Click each link and verify product matches ingredient');
console.log('3. For AUTO-INVALID items: Find replacement ASIN');
console.log('4. For NEEDS-REVIEW items: Confirm if product is correct');
console.log();
console.log(`CSV saved to: ${outputPath}`);
console.log();

// Generate summary report
const report = `# Auto-Classification Report

## Summary

**Total items processed:** ${stats.total}

- ‚úÖ **Auto-valid:** ${stats.autoValid} (${((stats.autoValid / stats.total) * 100).toFixed(1)}%)
- ‚ùå **Auto-invalid:** ${stats.autoInvalid} (${((stats.autoInvalid / stats.total) * 100).toFixed(1)}%)
- ‚ö†Ô∏è **Needs review:** ${stats.needsReview} (${((stats.needsReview / stats.total) * 100).toFixed(1)}%)
- üìã **No spec:** ${stats.noSpec} (${((stats.noSpec / stats.total) * 100).toFixed(1)}%)

**Manual review reduced:** 94 ‚Üí ${stats.needsReview + stats.autoInvalid} items (${Math.round((1 - (stats.needsReview + stats.autoInvalid) / 94) * 100)}% reduction)

---

## Auto-Invalid Items (${stats.autoInvalid})

These items failed validation and need replacement ASINs:

${results.filter(r => r.status === 'auto-invalid').map(item => 
  `### ${item.ingredient}
- **Product:** ${item.productName}
- **ASIN:** ${item.asin}
- **Issues:** ${item.issues.join(', ')}
- **Action:** Find correct product on Amazon
- **Link:** ${item.link}
`).join('\n')}

---

## Needs Review (${stats.needsReview})

These items are ambiguous and need human verification:

${results.filter(r => r.status === 'needs-review').slice(0, 10).map(item =>
  `### ${item.ingredient}
- **Product:** ${item.productName}
- **ASIN:** ${item.asin}
- **Issues:** ${item.issues.join(', ')}
- **Action:** Verify if product is correct
- **Link:** ${item.link}
`).join('\n')}

${stats.needsReview > 10 ? `\n... and ${stats.needsReview - 10} more (see CSV)\n` : ''}

---

## Auto-Valid Items (${stats.autoValid})

These items passed all validation checks and are assumed correct.

---

## Next Steps

1. **Review the ${reviewItems.length} flagged items** in MANUAL_REVIEW_REQUIRED.csv
2. **Find replacement ASINs** for auto-invalid items
3. **Verify ambiguous items** by clicking links
4. **Update vetted-products.ts** with corrections

---

## Phase 2: PA-API Integration

After manual review is complete, we'll implement:
- Automated metadata fetching from Amazon PA-API
- Price and availability tracking
- Automatic re-validation of stale links
- Confidence scoring and caching
`;

const reportPath = path.join(process.cwd(), 'AUTO_CLASSIFICATION_REPORT.md');
fs.writeFileSync(reportPath, report, 'utf-8');

console.log(`Report saved to: ${reportPath}`);
console.log();
console.log('='.repeat(80));
</file>

<file path="lib/generator/BirdDebug.ts">
// Detailed debug for bird recipe generation
import { RecipeBuilder, type GenerationConstraints } from './RecipeBuilder';
import { getIngredientsForSpecies } from '../data/ingredients';

const constraints: GenerationConstraints = {
  species: 'birds',
  lifeStage: 'adult',
  petWeightKg: 0.5,
  healthConcerns: ['digestive_issues'],
  targetCalories: 100,
};

console.log('=== BIRD RECIPE DEBUG ===\n');

// Check available ingredients
const allBirdIngredients = getIngredientsForSpecies('birds');
console.log(`Total bird ingredients available: ${allBirdIngredients.length}`);

const seeds = allBirdIngredients.filter(ing => ing.category === 'seed');
const nuts = allBirdIngredients.filter(ing => ing.category === 'nut');
const insects = allBirdIngredients.filter(ing => ing.category === 'insect');
const fruits = allBirdIngredients.filter(ing => ing.category === 'fruit');
const vegetables = allBirdIngredients.filter(ing => ing.category === 'vegetable');

console.log(`\nBy category:`);
console.log(`  Seeds: ${seeds.length}`);
console.log(`  Nuts: ${nuts.length}`);
console.log(`  Insects: ${insects.length}`);
console.log(`  Fruits: ${fruits.length}`);
console.log(`  Vegetables: ${vegetables.length}`);

console.log(`\nSample seeds:`);
seeds.slice(0, 5).forEach(s => console.log(`  - ${s.name} (id: ${s.id})`));

console.log(`\nSample nuts:`);
nuts.slice(0, 5).forEach(n => console.log(`  - ${n.name} (id: ${n.id})`));

console.log(`\n${'='.repeat(80)}`);
console.log('Attempting recipe generation...\n');

// Attempt generation with internal logging
const builder = new RecipeBuilder(constraints, 'standard', 'medium');

// Access private method via any cast to see what's happening
const builderAny = builder as any;

// Try to generate and see what happens
try {
  const recipe = builder.generate();
  
  if (recipe) {
    console.log('‚úÖ Recipe generated successfully!');
    console.log(`\nIngredients (${recipe.ingredients.length}):`);
    recipe.ingredients.forEach(p => {
      console.log(`  - ${p.ingredient.name} (${p.ingredient.category}): ${p.grams}g`);
    });
  } else {
    console.log('‚ùå Recipe generation returned null');
  }
} catch (error: any) {
  console.log('‚ùå Error during generation:', error.message);
  console.log(error.stack);
}
</file>

<file path="lib/generator/BirdDetailedDebug.ts">
// Very detailed debug - manually walk through the RecipeBuilder process
import { getIngredientsForSpecies } from '../data/ingredients';
import type { Ingredient } from '../data/ingredients';

const species = 'birds';
const healthConcerns = ['digestive_issues'];

console.log('=== DETAILED BIRD INGREDIENT DEBUG ===\n');

// Step 1: Get all bird ingredients
const allBirdIngredients = getIngredientsForSpecies(species);
console.log(`Step 1: Total bird ingredients: ${allBirdIngredients.length}\n`);

// Step 2: Check categories
const byCategory: Record<string, Ingredient[]> = {};
allBirdIngredients.forEach(ing => {
  if (!byCategory[ing.category]) byCategory[ing.category] = [];
  byCategory[ing.category].push(ing);
});

console.log('Step 2: Ingredients by category:');
Object.entries(byCategory).forEach(([cat, ings]) => {
  console.log(`  ${cat}: ${ings.length} ingredients`);
});

// Step 3: Check quality scores for seeds/nuts
console.log('\nStep 3: Quality scores for seeds:');
const seeds = byCategory['seed'] || [];
seeds.slice(0, 10).forEach(s => {
  console.log(`  ${s.name}: quality=${s.qualityScore}, feedingRole=${s.feedingRole}`);
});

console.log('\nStep 3b: Quality scores for nuts:');
const nuts = byCategory['nut'] || [];
nuts.slice(0, 10).forEach(n => {
  console.log(`  ${n.name}: quality=${n.qualityScore}, feedingRole=${n.feedingRole}`);
});

// Step 4: Filter by quality tier (standard = qualityScore >= 5)
const qualityTier = 'standard';
const minQuality = qualityTier === 'premium' ? 7 : qualityTier === 'standard' ? 5 : 0;

console.log(`\nStep 4: Filtering by quality tier '${qualityTier}' (min quality: ${minQuality})`);
const afterQualityFilter = allBirdIngredients.filter(ing => ing.qualityScore >= minQuality);
console.log(`  Remaining after quality filter: ${afterQualityFilter.length}`);

const seedsAfterFilter = afterQualityFilter.filter(ing => ing.category === 'seed');
const nutsAfterFilter = afterQualityFilter.filter(ing => ing.category === 'nut');
const insectsAfterFilter = afterQualityFilter.filter(ing => ing.category === 'insect');

console.log(`  Seeds after filter: ${seedsAfterFilter.length}`);
console.log(`  Nuts after filter: ${nutsAfterFilter.length}`);
console.log(`  Insects after filter: ${insectsAfterFilter.length}`);

if (seedsAfterFilter.length === 0) {
  console.log('\n‚ö†Ô∏è  WARNING: No seeds passed quality filter!');
  console.log('Seeds that failed:');
  seeds.forEach(s => {
    if (s.qualityScore < minQuality) {
      console.log(`  ‚ùå ${s.name}: quality=${s.qualityScore} (needs ${minQuality})`);
    }
  });
}

if (nutsAfterFilter.length === 0) {
  console.log('\n‚ö†Ô∏è  WARNING: No nuts passed quality filter!');
  console.log('Nuts that failed:');
  nuts.forEach(n => {
    if (n.qualityScore < minQuality) {
      console.log(`  ‚ùå ${n.name}: quality=${n.qualityScore} (needs ${minQuality})`);
    }
  });
}

// Step 5: Check what would be selected
console.log('\n=== SELECTION SIMULATION ===');
const requiredCategories = ['seed', 'nut', 'fruit', 'vegetable'];
console.log(`Required categories for birds: ${requiredCategories.join(', ')}\n`);

for (const category of requiredCategories) {
  const inCategory = afterQualityFilter.filter(ing => ing.category === category);
  console.log(`${category}: ${inCategory.length} available`);
  if (inCategory.length > 0) {
    console.log(`  Top 3:`);
    inCategory.slice(0, 3).forEach(ing => {
      console.log(`    - ${ing.name} (quality: ${ing.qualityScore})`);
    });
  } else {
    console.log(`  ‚ö†Ô∏è  NONE AVAILABLE - THIS WILL CAUSE ISSUES`);
  }
}
</file>

<file path="lib/generator/BirdTest.ts">
// Quick test for bird recipe generation
import { RecipeBuilder, type GenerationConstraints } from './RecipeBuilder';

const constraints: GenerationConstraints = {
  species: 'birds',
  lifeStage: 'adult',
  petWeightKg: 0.5, // Small bird
  healthConcerns: ['digestive_issues'],
  targetCalories: 100,
};

console.log('Testing bird recipe generation...');
console.log('Constraints:', constraints);
console.log('='.repeat(80));

for (let attempt = 1; attempt <= 3; attempt++) {
  console.log(`\nAttempt ${attempt}:`);
  try {
    const builder = new RecipeBuilder(constraints, 'standard', 'medium');
    const recipe = builder.generate();
    
    if (recipe) {
      console.log('‚úÖ SUCCESS!');
      console.log(`Ingredients (${recipe.ingredients.length}):`);
      recipe.ingredients.forEach(p => {
        console.log(`  - ${p.ingredient.name} (${p.ingredient.category}): ${p.grams}g`);
      });
      console.log(`Total: ${recipe.ingredients.reduce((sum, p) => sum + p.grams, 0)}g`);
      break;
    } else {
      console.log('‚ùå No recipe generated');
    }
  } catch (error: any) {
    console.log('‚ùå Error:', error.message);
  }
}
</file>

<file path="lib/generator/CheckBirdIngredients.ts">
// Check what bird ingredients are available
import { getIngredientsForSpecies } from '../data/ingredients';

console.log('Checking bird ingredients...\n');

const birdIngredients = getIngredientsForSpecies('birds');
console.log(`Total bird ingredients: ${birdIngredients.length}\n`);

// Group by category
const byCategory: Record<string, number> = {};
birdIngredients.forEach(ing => {
  byCategory[ing.category] = (byCategory[ing.category] || 0) + 1;
});

console.log('By category:');
Object.entries(byCategory).sort((a, b) => b[1] - a[1]).forEach(([cat, count]) => {
  console.log(`  ${cat}: ${count}`);
});

console.log('\n=== Seeds ===');
birdIngredients.filter(ing => ing.category === 'seed').slice(0, 10).forEach(ing => {
  console.log(`  - ${ing.name} (${ing.id})`);
});

console.log('\n=== Nuts ===');
birdIngredients.filter(ing => ing.category === 'nut').slice(0, 10).forEach(ing => {
  console.log(`  - ${ing.name} (${ing.id})`);
});

console.log('\n=== Insects ===');
birdIngredients.filter(ing => ing.category === 'insect').slice(0, 10).forEach(ing => {
  console.log(`  - ${ing.name} (${ing.id})`);
});

console.log('\n=== Fruits ===');
birdIngredients.filter(ing => ing.category === 'fruit').slice(0, 10).forEach(ing => {
  console.log(`  - ${ing.name} (${ing.id})`);
});

console.log('\n=== Vegetables ===');
birdIngredients.filter(ing => ing.category === 'vegetable').slice(0, 10).forEach(ing => {
  console.log(`  - ${ing.name} (${ing.id})`);
});
</file>

<file path="lib/generator/CombinatoricsPruning.ts">
/**
 * COMBINATORICS PRUNING
 * Pre-validation filtering to prevent micronutrient-toxic pairings
 * 
 * This runs BEFORE validation, teaching the generator what NOT to produce
 * instead of just rejecting finished recipes.
 */

import type { Ingredient } from '@/lib/data/ingredients';

// ============================================================================
// TOXIC PAIRINGS (Disallow these combinations)
// ============================================================================

interface ToxicPairing {
  ingredients: string[]; // ingredient names (lowercase, partial match)
  reason: string;
  maxAllowed?: number; // max of this pairing allowed (0 = never)
}

const TOXIC_PAIRINGS: ToxicPairing[] = [
  // Liver + high-iodine fish = vitamin A + iodine overload
  {
    ingredients: ['liver', 'salmon'],
    reason: 'Liver + salmon = vitamin A + iodine spike',
    maxAllowed: 0,
  },
  {
    ingredients: ['liver', 'cod'],
    reason: 'Liver + cod = vitamin A + iodine overload',
    maxAllowed: 0,
  },
  {
    ingredients: ['liver', 'sardine'],
    reason: 'Liver + sardine = vitamin A + iodine spike',
    maxAllowed: 0,
  },
  {
    ingredients: ['liver', 'mackerel'],
    reason: 'Liver + mackerel = vitamin A + iodine overload',
    maxAllowed: 0,
  },
  {
    ingredients: ['liver', 'herring'],
    reason: 'Liver + herring = vitamin A + iodine spike',
    maxAllowed: 0,
  },

  // Liver + high-iodine supplements = iodine bomb
  {
    ingredients: ['liver', 'kelp'],
    reason: 'Liver + kelp = iodine bomb',
    maxAllowed: 0,
  },
  {
    ingredients: ['liver', 'seaweed'],
    reason: 'Liver + seaweed = iodine overload',
    maxAllowed: 0,
  },

  // Multiple organ meats = mineral overload
  {
    ingredients: ['liver', 'kidney'],
    reason: 'Multiple organ meats = copper/mineral toxicity',
    maxAllowed: 0,
  },
  {
    ingredients: ['liver', 'heart'],
    reason: 'Multiple organ meats = mineral imbalance',
    maxAllowed: 0,
  },

  // High-copper sources together
  {
    ingredients: ['liver', 'sunflower_seed'],
    reason: 'Liver + sunflower seeds = copper overload',
    maxAllowed: 0,
  },
  {
    ingredients: ['liver', 'pumpkin_seed'],
    reason: 'Liver + pumpkin seeds = copper spike',
    maxAllowed: 0,
  },

  // Oxalate + calcium = absorption issues
  {
    ingredients: ['spinach', 'eggshell_powder'],
    reason: 'Spinach oxalates + calcium supplement = poor absorption',
    maxAllowed: 0,
  },
];

// ============================================================================
// INGREDIENT MICRONUTRIENT DENSITY PROFILE
// ============================================================================

interface MicronutrientProfile {
  vitaminA?: 'high' | 'medium' | 'low';
  copper?: 'high' | 'medium' | 'low';
  iodine?: 'high' | 'medium' | 'low';
  oxalates?: 'high' | 'medium' | 'low';
}

const MICRONUTRIENT_PROFILES: Record<string, MicronutrientProfile> = {
  // Organ meats (high in multiple micronutrients)
  liver: { vitaminA: 'high', copper: 'high', iodine: 'medium' },
  kidney: { copper: 'high', iodine: 'medium' },
  heart: { copper: 'medium' },

  // Fish (iodine-rich)
  salmon: { iodine: 'high', vitaminA: 'medium' },
  cod: { iodine: 'high' },
  sardine: { iodine: 'high' },
  mackerel: { iodine: 'high' },
  herring: { iodine: 'high' },

  // Supplements (concentrated)
  kelp: { iodine: 'high' },
  seaweed: { iodine: 'high' },
  fish_oil: { vitaminA: 'high' },
  cod_liver_oil: { vitaminA: 'high', iodine: 'high' },

  // Seeds (copper-rich)
  sunflower_seed: { copper: 'high' },
  pumpkin_seed: { copper: 'high' },
  sesame_seed: { copper: 'high' },

  // Vegetables (oxalate-rich)
  spinach: { oxalates: 'high' },
  beet_greens: { oxalates: 'high' },
  chard: { oxalates: 'high' },
};

// ============================================================================
// PRUNING FUNCTIONS
// ============================================================================

/**
 * Check if a pairing violates toxic combination rules
 */
export function hasToxicPairing(ingredients: Ingredient[]): boolean {
  const names = ingredients.map(ing => ing.name.toLowerCase());

  for (const pairing of TOXIC_PAIRINGS) {
    const matches = pairing.ingredients.filter(required =>
      names.some(name => name.includes(required))
    );

    if (matches.length === pairing.ingredients.length) {
      // All ingredients in this toxic pairing are present
      if (pairing.maxAllowed === 0) {
        return true; // Disallowed
      }
    }
  }

  return false;
}

/**
 * Get micronutrient density profile for an ingredient
 */
export function getMicronutrientProfile(ingredient: Ingredient): MicronutrientProfile {
  const name = ingredient.name.toLowerCase();

  for (const [key, profile] of Object.entries(MICRONUTRIENT_PROFILES)) {
    if (name.includes(key)) {
      return profile;
    }
  }

  return {}; // Unknown ingredient, assume low density
}

/**
 * Calculate cumulative micronutrient risk for a recipe
 * Returns a risk score (0-100) where 100 = definitely toxic
 * 
 * NOTE: This is SOFT pruning. Only flag truly dangerous combos.
 * Fish + liver is OK. Fish + fish oil + liver is risky.
 */
export function calculateMicronutrientRisk(ingredients: Ingredient[]): number {
  let risk = 0;

  // Check for specific dangerous combos
  const vitaminAHighCount = ingredients.filter(ing => {
    const profile = getMicronutrientProfile(ing);
    return profile.vitaminA === 'high';
  }).length;

  const iodineHighCount = ingredients.filter(ing => {
    const profile = getMicronutrientProfile(ing);
    return profile.iodine === 'high';
  }).length;

  const copperHighCount = ingredients.filter(ing => {
    const profile = getMicronutrientProfile(ing);
    return profile.copper === 'high';
  }).length;

  // Only flag if we have MULTIPLE high sources of the SAME nutrient
  // (not just any high-density ingredient)
  
  // Multiple vitamin A sources (e.g., liver + fish oil)
  if (vitaminAHighCount >= 2) risk += 50;

  // Multiple iodine sources (e.g., kelp + fish + fish oil)
  if (iodineHighCount >= 3) risk += 50;
  else if (iodineHighCount >= 2) risk += 20; // Mild risk for 2 iodine sources

  // Multiple copper sources (e.g., liver + seeds)
  if (copperHighCount >= 2) risk += 40;

  return Math.min(100, risk);
}

/**
 * Prune candidates that are likely to fail T6 (nutrient ceiling)
 * Returns true if candidate should be rejected
 */
export function shouldPruneCandidateForMicronutrients(ingredients: Ingredient[]): boolean {
  // Hard reject: toxic pairings
  if (hasToxicPairing(ingredients)) {
    return true;
  }

  // Soft reject: high micronutrient risk
  const risk = calculateMicronutrientRisk(ingredients);
  if (risk > 70) {
    return true; // Likely to fail T6
  }

  return false;
}

/**
 * Get a human-readable reason why a candidate was pruned
 */
export function getPruningReason(ingredients: Ingredient[]): string {
  if (hasToxicPairing(ingredients)) {
    const names = ingredients.map(ing => ing.name.toLowerCase());
    for (const pairing of TOXIC_PAIRINGS) {
      const matches = pairing.ingredients.filter(required =>
        names.some(name => name.includes(required))
      );
      if (matches.length === pairing.ingredients.length) {
        return pairing.reason;
      }
    }
  }

  const risk = calculateMicronutrientRisk(ingredients);
  if (risk > 70) {
    return `High micronutrient risk (${Math.round(risk)}/100)`;
  }

  return 'Unknown';
}
</file>

<file path="lib/generator/CommercialPriorEnforcement.test.ts">
/**
 * DETERMINISTIC TEST: Commercial Prior Enforcement
 * 
 * Tests that turkey + fish oil pairings are blocked based on commercial data
 */

import { describe, it, expect, beforeEach, vi } from 'vitest';
import {
  checkHardBlock,
  checkStrongPenalty,
  filterCandidatesByCommercialPriors,
  applyCommercialPriorScoring,
} from './CommercialPriorEnforcement';

describe('CommercialPriorEnforcement', () => {
  beforeEach(() => {
    // Spy on console.log to capture logging
    vi.spyOn(console, 'log').mockImplementation(() => {});
  });

  describe('Hard Block Detection', () => {
    it('should NOT block turkey + fish pairings (fish oil is common with poultry)', () => {
      // Arrange: turkey is selected
      const selected = ['turkey'];
      const species = 'dogs' as const;

      // Act: Check if fish/salmon/tuna are blocked
      const fishBlock = checkHardBlock('fish', selected, species);
      const salmonBlock = checkHardBlock('salmon', selected, species);
      const tunaBlock = checkHardBlock('tuna', selected, species);

      // Assert: Should NOT be blocked (fish oil is common supplement with poultry)
      // Data can't distinguish fish-as-protein from fish-oil-as-supplement
      expect(fishBlock).toBeNull();
      expect(salmonBlock).toBeNull();
      expect(tunaBlock).toBeNull();
    });

    it('should block beef + fish pairings (genuinely rare)', () => {
      // Arrange: beef is selected
      const selected = ['beef'];
      const species = 'dogs' as const;

      // Act: Check if fish/salmon are blocked
      const fishBlock = checkHardBlock('fish', selected, species);
      const salmonBlock = checkHardBlock('salmon', selected, species);

      // Assert: Should be blocked (beef + fish is genuinely rare in commercial products)
      expect(fishBlock).toBeTruthy();
      expect(salmonBlock).toBeTruthy();
    });

    it('should NOT block chicken + turkey pairing', () => {
      // Arrange: turkey is selected
      const selected = ['turkey'];
      const species = 'dogs' as const;

      // Act: Check if chicken is blocked
      const chickenBlock = checkHardBlock('chicken', selected, species);

      // Assert: Should NOT be blocked (they co-occur in commercial products)
      expect(chickenBlock).toBeNull();
    });

    it('should work with normalized pair keys regardless of order', () => {
      // Arrange: Use beef + fish (genuinely blocked)
      const species = 'dogs' as const;

      // Act: Check both orders
      const block1 = checkHardBlock('fish', ['beef'], species);
      const block2 = checkHardBlock('beef', ['fish'], species);

      // Assert: Both should detect the block
      expect(block1).toBeTruthy();
      expect(block2).toBeTruthy();
      expect(block1).toBe(block2); // Same normalized key
    });
  });

  describe('Candidate Filtering', () => {
    it('should filter out beef + fish pairings (genuinely rare)', () => {
      // Arrange: Beef is selected, candidates include fish proteins
      const candidates = [
        { id: 'fish', name: 'Fish' },
        { id: 'salmon', name: 'Salmon' },
        { id: 'chicken', name: 'Chicken' },
        { id: 'rice', name: 'Rice' },
      ];
      const selected = ['beef'];
      const species = 'dogs' as const;

      // Act: Filter candidates
      const filtered = filterCandidatesByCommercialPriors(candidates, selected, species);

      // Assert: Fish ingredients should be filtered out (beef + fish is rare)
      const filteredIds = filtered.map(c => c.id);
      expect(filteredIds).not.toContain('fish');
      expect(filteredIds).not.toContain('salmon');
      expect(filteredIds).toContain('chicken');
      expect(filteredIds).toContain('rice');
    });

    it('should NOT filter turkey + fish (fish oil is common)', () => {
      // Arrange: Turkey is selected, candidates include fish
      const candidates = [
        { id: 'fish', name: 'Fish' },
        { id: 'salmon', name: 'Salmon' },
        { id: 'chicken', name: 'Chicken' },
      ];
      const selected = ['turkey'];
      const species = 'dogs' as const;

      // Act: Filter candidates
      const filtered = filterCandidatesByCommercialPriors(candidates, selected, species);

      // Assert: Fish should NOT be filtered (fish oil is common with poultry)
      const filteredIds = filtered.map(c => c.id);
      expect(filteredIds).toContain('fish');
      expect(filteredIds).toContain('salmon');
      expect(filteredIds).toContain('chicken');
    });

    it('should log [PAIR BLOCK] messages when filtering', () => {
      // Arrange: Use beef + salmon (genuinely blocked)
      const candidates = [
        { id: 'salmon', name: 'Salmon' },
      ];
      const selected = ['beef'];
      const species = 'dogs' as const;

      // Act
      filterCandidatesByCommercialPriors(candidates, selected, species, '[TEST] ');

      // Assert: Should have logged the block
      expect(console.log).toHaveBeenCalledWith(
        expect.stringContaining('[PAIR BLOCK]')
      );
      expect(console.log).toHaveBeenCalledWith(
        expect.stringContaining('salmon')
      );
      expect(console.log).toHaveBeenCalledWith(
        expect.stringContaining('commercial data')
      );
    });
  });

  describe('Strong Penalty Detection', () => {
    it('should detect strong penalty pairs', () => {
      // Arrange: Select ingredients that have rare pairings
      const selected = ['beef'];
      const species = 'dogs' as const;

      // Act: Check for penalty pairs with grain
      const penaltyPairs = checkStrongPenalty('grain', selected, species);

      // Assert: Should detect penalty (beef + grain is rare with negative PMI)
      expect(penaltyPairs.length).toBeGreaterThan(0);
    });
  });

  describe('Scoring with Commercial Priors', () => {
    it('should apply harsh penalty (0.05x) to strong penalty pairs', () => {
      // Arrange
      const candidateId = 'grain';
      const baseScore = 100;
      const selected = ['beef'];
      const species = 'dogs' as const;

      // Act
      const penaltyPairs = checkStrongPenalty(candidateId, selected, species);
      
      // Only test if penalty pairs exist
      if (penaltyPairs.length > 0) {
        const finalScore = applyCommercialPriorScoring(candidateId, baseScore, selected, species);

        // Assert: Score should be heavily penalized
        expect(finalScore).toBeLessThan(baseScore * 0.1);
        expect(console.log).toHaveBeenCalledWith(
          expect.stringContaining('[PAIR PENALTY]')
        );
      }
    });

    it('should apply PMI boost to positive pairings', () => {
      // Arrange: chicken + peas is a common pairing with positive PMI
      const candidateId = 'peas';
      const baseScore = 100;
      const selected = ['chicken'];
      const species = 'dogs' as const;

      // Act
      const finalScore = applyCommercialPriorScoring(candidateId, baseScore, selected, species);

      // Assert: Score should be boosted (but not by much, max 1.15x)
      expect(finalScore).toBeGreaterThanOrEqual(baseScore);
      expect(finalScore).toBeLessThanOrEqual(baseScore * 1.15);
    });
  });

  describe('CRITICAL TEST: What We Actually Learned', () => {
    it('should BLOCK beef + fish pairings (genuinely rare)', () => {
      // Arrange: Beef is selected
      const selected = ['beef'];
      const candidates = [
        { id: 'fish', name: 'Fish' },
        { id: 'salmon', name: 'Salmon' },
        { id: 'chicken', name: 'Chicken' },
      ];
      const species = 'dogs' as const;

      // Act: Filter candidates
      const filtered = filterCandidatesByCommercialPriors(candidates, selected, species, '[CRITICAL] ');

      // Assert: Fish ingredients must be filtered out (beef + fish is genuinely rare)
      const filteredIds = filtered.map(c => c.id);
      expect(filteredIds).not.toContain('fish');
      expect(filteredIds).not.toContain('salmon');
      expect(filteredIds).toContain('chicken');

      // Assert: Logs must contain [PAIR BLOCK] messages
      expect(console.log).toHaveBeenCalledWith(
        expect.stringMatching(/\[CRITICAL\].*\[PAIR BLOCK\].*fish/)
      );
    });

    it('should NOT block turkey + fish (fish oil is common with poultry)', () => {
      // Arrange: Turkey is selected
      const selected = ['turkey'];
      const species = 'dogs' as const;

      // Act: Check hard block for fish types
      const fishBlock = checkHardBlock('fish', selected, species);
      const salmonBlock = checkHardBlock('salmon', selected, species);
      const tunaBlock = checkHardBlock('tuna', selected, species);

      // Assert: Should NOT be blocked (data can't distinguish fish-as-protein from fish-oil-as-supplement)
      // Fish oil is commonly used with poultry for omega-3
      expect(fishBlock).toBeNull();
      expect(salmonBlock).toBeNull();
      expect(tunaBlock).toBeNull();
    });

    it('should boost common pairings (chicken + peas, chicken + rice)', () => {
      // Arrange: Chicken is selected
      const candidateId = 'peas';
      const baseScore = 100;
      const selected = ['chicken'];
      const species = 'dogs' as const;

      // Act: Apply commercial prior scoring
      const finalScore = applyCommercialPriorScoring(candidateId, baseScore, selected, species);

      // Assert: Score should be boosted OR stay same (chicken + peas is common: 51 products)
      // Note: With conservative thresholds (minIng>=30), peas (60) qualifies
      // PMI might be positive or neutral depending on data
      expect(finalScore).toBeGreaterThanOrEqual(baseScore);
      expect(finalScore).toBeLessThanOrEqual(baseScore * 1.15); // Capped at 1.15x
    });
  });

  describe('Species-Specific Gating', () => {
    it('should only apply priors for dogs and cats', () => {
      // Arrange
      const selected = ['turkey'];
      const birdsSpecies = 'birds' as const;

      // Act: Check for birds (should have no priors)
      const block = checkHardBlock('fish', selected, birdsSpecies);

      // Assert: Should return null (no priors for birds yet)
      expect(block).toBeNull();
    });

    it('should apply same priors to both dogs and cats', () => {
      // Arrange: Use beef + fish (genuinely blocked)
      const selected = ['beef'];

      // Act: Check for both species
      const dogBlock = checkHardBlock('fish', selected, 'dogs');
      const catBlock = checkHardBlock('fish', selected, 'cats');

      // Assert: Both should block (using same commercial data)
      expect(dogBlock).toBeTruthy();
      expect(catBlock).toBeTruthy();
    });
  });
});
</file>

<file path="lib/generator/CommercialPriorEnforcement.ts">
/**
 * COMMERCIAL PRIOR ENFORCEMENT
 * 
 * Enforces learned commercial pairing rules:
 * - hardBlockPairs: Filter out candidates that never co-occur with selected ingredients
 * - strongPenaltyPairs: Apply harsh penalty (0.05x) to rare negative pairings
 * - Positive PMI: Apply soft boost (1.05-1.15x) to common pairings
 */

import recipePriors from '../data/recipePriors.json';
import type { Species } from '../types';

interface CommercialPriors {
  ingredientCounts: Record<string, number>;
  ingredientFreq: Record<string, number>;
  pairCounts: Record<string, number>;
  pairPMI: Record<string, number>;
  hardBlockPairs: string[];
  strongPenaltyPairs: string[];
}

/**
 * Normalize pair key to sorted format (a|b)
 */
function normalizePairKey(ing1: string, ing2: string): string {
  return [ing1, ing2].sort().join('|');
}

/**
 * Get commercial priors for a species
 */
function getCommercialPriors(species: Species): CommercialPriors | null {
  const priors = (recipePriors as any).commercialPriors;
  if (!priors) return null;
  
  // Map species to commercial priors key
  const speciesKey = species === 'dogs' || species === 'cats' ? species : null;
  if (!speciesKey) return null;
  
  return priors[speciesKey] as CommercialPriors;
}

/**
 * Check if a candidate ingredient is hard-blocked by any selected ingredient
 * Returns the blocking pair if found, null otherwise
 */
export function checkHardBlock(
  candidateId: string,
  selectedIngredientIds: string[],
  species: Species
): string | null {
  const priors = getCommercialPriors(species);
  if (!priors || !priors.hardBlockPairs) return null;
  
  const hardBlockSet = new Set(priors.hardBlockPairs);
  
  for (const selectedId of selectedIngredientIds) {
    const pairKey = normalizePairKey(candidateId, selectedId);
    if (hardBlockSet.has(pairKey)) {
      return pairKey;
    }
  }
  
  return null;
}

/**
 * Check if a candidate ingredient has strong penalty pairs with selected ingredients
 * Returns array of penalty pairs
 */
export function checkStrongPenalty(
  candidateId: string,
  selectedIngredientIds: string[],
  species: Species
): string[] {
  const priors = getCommercialPriors(species);
  if (!priors || !priors.strongPenaltyPairs) return [];
  
  const penaltySet = new Set(priors.strongPenaltyPairs);
  const penaltyPairs: string[] = [];
  
  for (const selectedId of selectedIngredientIds) {
    const pairKey = normalizePairKey(candidateId, selectedId);
    if (penaltySet.has(pairKey)) {
      penaltyPairs.push(pairKey);
    }
  }
  
  return penaltyPairs;
}

/**
 * Get PMI boost for a candidate ingredient paired with selected ingredients
 * Returns multiplier (1.0 = no change, >1.0 = boost, <1.0 = penalty)
 */
export function getPMIBoost(
  candidateId: string,
  selectedIngredientIds: string[],
  species: Species
): number {
  const priors = getCommercialPriors(species);
  if (!priors || !priors.pairPMI) return 1.0;
  
  let totalPMI = 0;
  let pairCount = 0;
  
  for (const selectedId of selectedIngredientIds) {
    const pairKey = normalizePairKey(candidateId, selectedId);
    const pmi = priors.pairPMI[pairKey];
    
    if (pmi !== undefined && pmi > 0) {
      totalPMI += pmi;
      pairCount++;
    }
  }
  
  if (pairCount === 0) return 1.0;
  
  // Average PMI across pairs
  const avgPMI = totalPMI / pairCount;
  
  // Convert to multiplier: PMI of 1.0 -> 1.05x boost, PMI of 2.0 -> 1.10x boost
  // Cap at 1.15x to avoid over-boosting
  const boost = 1.0 + Math.min(avgPMI * 0.05, 0.15);
  
  return boost;
}

/**
 * Filter candidates by commercial priors
 * Removes hard-blocked candidates and logs reasons
 */
export function filterCandidatesByCommercialPriors<T extends { id: string }>(
  candidates: T[],
  selectedIngredientIds: string[],
  species: Species,
  logPrefix: string = ''
): T[] {
  const priors = getCommercialPriors(species);
  if (!priors) return candidates;
  
  return candidates.filter(candidate => {
    const blockingPair = checkHardBlock(candidate.id, selectedIngredientIds, species);
    
    if (blockingPair) {
      const [ing1, ing2] = blockingPair.split('|');
      console.log(`${logPrefix}[PAIR BLOCK] ${candidate.id}: Never co-occurs with ${ing1 === candidate.id ? ing2 : ing1} (commercial data)`);
      return false;
    }
    
    return true;
  });
}

/**
 * Apply commercial prior scoring to a candidate
 * Returns modified score and logs reasons
 */
export function applyCommercialPriorScoring(
  candidateId: string,
  baseScore: number,
  selectedIngredientIds: string[],
  species: Species,
  logPrefix: string = ''
): number {
  const priors = getCommercialPriors(species);
  if (!priors) return baseScore;
  
  let score = baseScore;
  
  // Check for strong penalty pairs
  const penaltyPairs = checkStrongPenalty(candidateId, selectedIngredientIds, species);
  if (penaltyPairs.length > 0) {
    score *= 0.05; // Harsh penalty
    penaltyPairs.forEach(pair => {
      const [ing1, ing2] = pair.split('|');
      const otherIng = ing1 === candidateId ? ing2 : ing1;
      console.log(`${logPrefix}[PAIR PENALTY] ${candidateId}: Rare pairing with ${otherIng} (commercial data, PMI<-1.5)`);
    });
  }
  
  // Apply PMI boost for positive pairings
  const pmiBoost = getPMIBoost(candidateId, selectedIngredientIds, species);
  if (pmiBoost > 1.0) {
    score *= pmiBoost;
    console.log(`${logPrefix}[PMI BOOST] ${candidateId}: ${pmiBoost.toFixed(2)}x boost from commercial pairings`);
  }
  
  return score;
}

/**
 * Check if commercial priors are available for a species
 */
export function hasCommercialPriors(species: Species): boolean {
  return getCommercialPriors(species) !== null;
}
</file>

<file path="lib/generator/ComprehensiveAudit.ts">
// Comprehensive Audit: All Species + Health Concerns
// Tests recipe generation for every species with single and paired health concerns

import { RecipeBuilder, type GenerationConstraints } from './RecipeBuilder';

type Species = 'dogs' | 'cats' | 'birds' | 'reptiles' | 'pocket-pets';

const SPECIES: Species[] = ['dogs', 'cats', 'birds', 'reptiles', 'pocket-pets'];

const HEALTH_CONCERNS = [
  'allergies',
  'digestive_issues',
  'joint_health',
  'skin_health',
  'weight_management',
  'dental_health',
  'immune_support',
];

interface AuditResult {
  species: Species;
  healthConcerns: string[];
  success: boolean;
  attempts: number;
  totalGrams?: number;
  primaryProteins?: number;
  error?: string;
}

const results: AuditResult[] = [];

console.log('='.repeat(80));
console.log('COMPREHENSIVE RECIPE GENERATION AUDIT');
console.log('='.repeat(80));
console.log(`Testing ${SPECIES.length} species √ó ${HEALTH_CONCERNS.length} concerns + pairs`);
console.log(`Total combinations: ~${SPECIES.length * (HEALTH_CONCERNS.length + (HEALTH_CONCERNS.length * (HEALTH_CONCERNS.length - 1)) / 2)}`);
console.log('='.repeat(80));

let totalTests = 0;
let passedTests = 0;
let failedTests = 0;

// Test 1: Single health concerns
console.log('\nüìã PHASE 1: Single Health Concerns');
console.log('-'.repeat(80));

for (const species of SPECIES) {
  for (const concern of HEALTH_CONCERNS) {
    totalTests++;
    const constraints: GenerationConstraints = {
      species,
      lifeStage: 'adult',
      petWeightKg: species === 'dogs' ? 20 : species === 'cats' ? 5 : 2,
      healthConcerns: [concern],
      targetCalories: 500,
    };

    let attempts = 0;
    let success = false;
    let totalGrams = 0;
    let primaryProteins = 0;

    for (let i = 0; i < 3; i++) {
      attempts++;
      try {
        const builder = new RecipeBuilder(constraints, 'standard', 'medium');
        const recipe = builder.generate();

        if (recipe && recipe.ingredients.length > 0) {
          success = true;
          totalGrams = recipe.ingredients.reduce((sum, p) => sum + p.grams, 0);
          primaryProteins = recipe.ingredients.filter(
            p => p.ingredient.category === 'protein' && p.ingredient.proteinRole === 'primary'
          ).length;
          break;
        }
      } catch (error) {
        // Continue to next attempt
      }
    }

    const result: AuditResult = {
      species,
      healthConcerns: [concern],
      success,
      attempts,
      totalGrams,
      primaryProteins,
    };

    results.push(result);

    if (success) {
      passedTests++;
      console.log(`‚úÖ ${species.padEnd(12)} + ${concern.padEnd(20)} | ${totalGrams}g | ${primaryProteins} primary protein`);
    } else {
      failedTests++;
      console.log(`‚ùå ${species.padEnd(12)} + ${concern.padEnd(20)} | Failed after ${attempts} attempts`);
    }
  }
}

// Test 2: Paired health concerns (sample combinations)
console.log('\nüìã PHASE 2: Paired Health Concerns (Sample)');
console.log('-'.repeat(80));

const pairCombos = [
  ['allergies', 'digestive_issues'],
  ['joint_health', 'weight_management'],
  ['skin_health', 'immune_support'],
  ['digestive_issues', 'dental_health'],
  ['weight_management', 'immune_support'],
];

for (const species of SPECIES) {
  for (const [concern1, concern2] of pairCombos) {
    totalTests++;
    const constraints: GenerationConstraints = {
      species,
      lifeStage: 'adult',
      petWeightKg: species === 'dogs' ? 20 : species === 'cats' ? 5 : 2,
      healthConcerns: [concern1, concern2],
      targetCalories: 500,
    };

    let attempts = 0;
    let success = false;
    let totalGrams = 0;
    let primaryProteins = 0;

    for (let i = 0; i < 3; i++) {
      attempts++;
      try {
        const builder = new RecipeBuilder(constraints, 'standard', 'medium');
        const recipe = builder.generate();

        if (recipe && recipe.ingredients.length > 0) {
          success = true;
          totalGrams = recipe.ingredients.reduce((sum, p) => sum + p.grams, 0);
          primaryProteins = recipe.ingredients.filter(
            p => p.ingredient.category === 'protein' && p.ingredient.proteinRole === 'primary'
          ).length;
          break;
        }
      } catch (error) {
        // Continue to next attempt
      }
    }

    const result: AuditResult = {
      species,
      healthConcerns: [concern1, concern2],
      success,
      attempts,
      totalGrams,
      primaryProteins,
    };

    results.push(result);

    if (success) {
      passedTests++;
      console.log(
        `‚úÖ ${species.padEnd(12)} + ${(concern1 + ' + ' + concern2).padEnd(35)} | ${totalGrams}g | ${primaryProteins} primary protein`
      );
    } else {
      failedTests++;
      console.log(
        `‚ùå ${species.padEnd(12)} + ${(concern1 + ' + ' + concern2).padEnd(35)} | Failed after ${attempts} attempts`
      );
    }
  }
}

// Summary
console.log('\n' + '='.repeat(80));
console.log('AUDIT SUMMARY');
console.log('='.repeat(80));
console.log(`Total Tests: ${totalTests}`);
console.log(`‚úÖ Passed: ${passedTests} (${((passedTests / totalTests) * 100).toFixed(1)}%)`);
console.log(`‚ùå Failed: ${failedTests} (${((failedTests / totalTests) * 100).toFixed(1)}%)`);

// Breakdown by species
console.log('\nüìä Results by Species:');
for (const species of SPECIES) {
  const speciesResults = results.filter(r => r.species === species);
  const speciesPassed = speciesResults.filter(r => r.success).length;
  const speciesTotal = speciesResults.length;
  console.log(
    `  ${species.padEnd(12)}: ${speciesPassed}/${speciesTotal} (${((speciesPassed / speciesTotal) * 100).toFixed(1)}%)`
  );
}

// Breakdown by health concern
console.log('\nüìä Results by Health Concern (Single):');
for (const concern of HEALTH_CONCERNS) {
  const concernResults = results.filter(r => r.healthConcerns.length === 1 && r.healthConcerns[0] === concern);
  const concernPassed = concernResults.filter(r => r.success).length;
  const concernTotal = concernResults.length;
  console.log(
    `  ${concern.padEnd(20)}: ${concernPassed}/${concernTotal} (${((concernPassed / concernTotal) * 100).toFixed(1)}%)`
  );
}

// Failed combinations
const failedResults = results.filter(r => !r.success);
if (failedResults.length > 0) {
  console.log('\n‚ö†Ô∏è  Failed Combinations:');
  for (const result of failedResults.slice(0, 10)) {
    console.log(`  ${result.species} + ${result.healthConcerns.join(', ')}`);
  }
  if (failedResults.length > 10) {
    console.log(`  ... and ${failedResults.length - 10} more`);
  }
}

console.log('\n' + '='.repeat(80));
</file>

<file path="lib/generator/DebugProteinRole.ts">
// Quick debug to check proteinRole population
import { getIngredientsForSpecies } from '../data/ingredients';

const dogs = getIngredientsForSpecies('dogs');
const proteins = dogs.filter(i => i.category === 'protein').slice(0, 10);

console.log('=== Dog Proteins ===');
proteins.forEach(p => {
  console.log(`${p.name}: proteinRole=${p.proteinRole || 'undefined'}`);
});
</file>

<file path="lib/generator/GenerateVerificationList.ts">
// Generate a verification list for manual Amazon link checking
// Outputs CSV format for easy tracking in Excel/Sheets

import { VETTED_PRODUCTS } from '../data/vetted-products';
import * as fs from 'fs';
import * as path from 'path';

interface VerificationItem {
  ingredient: string;
  productName: string;
  asin: string;
  link: string;
  issue: string;
  priority: 'high' | 'medium' | 'low';
  verified: 'pending' | 'correct' | 'wrong' | 'dead';
  notes: string;
}

const items: VerificationItem[] = [];

// Track duplicate ASINs
const asinMap = new Map<string, string[]>();

for (const [ingredientName, product] of Object.entries(VETTED_PRODUCTS)) {
  const asinLink = product.asinLink;
  const asinMatch = asinLink.match(/\/dp\/([A-Z0-9]{10})/i);
  
  if (asinMatch) {
    const asin = asinMatch[1];
    if (!asinMap.has(asin)) {
      asinMap.set(asin, []);
    }
    asinMap.get(asin)!.push(ingredientName);
  }
}

// Known dead links from HTTP check
const deadLinks = new Set(['B0082C00P8', 'B0006L2XNK']);

// Known suspicious mappings
const suspiciousMapping: Record<string, { ingredients: string[]; issue: string }> = {
  'B07VHR2WNZ': { ingredients: ['ground beef (lean)', 'venison'], issue: 'Beef and venison are different meats' },
  'B0082C00P8': { ingredients: ['ground lamb', 'rabbit meat'], issue: 'Lamb and rabbit are different meats (DEAD LINK)' },
  'B0BXZ3JJL9': { ingredients: ['chicken hearts', 'turkey giblets'], issue: 'Chicken and turkey are different poultry' },
  'B01FUWYO2M': { ingredients: ['sardines (canned in water)', 'herring (canned)', 'sardines (in water)'], issue: 'Sardines and herring are different fish' },
  'B00WM6CHFQ': { ingredients: ['mango', 'chia seed oil'], issue: 'Mango and chia oil are completely different' },
  'B0BWBNT8JX': { ingredients: ['egg (hard-boiled)', 'duck hearts'], issue: 'Eggs and duck hearts are different' },
  'B00027ZVG4': { ingredients: ['canary seed', 'flaxseeds', 'rapeseed', 'sunflower seeds (small amounts)', 'pumpkin seeds', 'cuttlebone'], issue: 'Multiple seed types - verify if seed mix is appropriate' },
  'B086211R4H': { ingredients: ['niger seed', 'oat groats', 'hemp seeds', 'sesame seeds', 'chia seeds', 'pellets (fortified)'], issue: 'Multiple seed types - verify if seed mix is appropriate' },
};

// Generate verification items
for (const [ingredientName, product] of Object.entries(VETTED_PRODUCTS)) {
  const asinLink = product.asinLink;
  const asinMatch = asinLink.match(/\/dp\/([A-Z0-9]{10})/i);
  
  if (!asinMatch) continue;
  
  const asin = asinMatch[1];
  
  // Check if this needs verification
  let needsVerification = false;
  let issue = '';
  let priority: 'high' | 'medium' | 'low' = 'low';
  
  // Dead link
  if (deadLinks.has(asin)) {
    needsVerification = true;
    issue = 'Dead link (HTTP 405) - needs replacement';
    priority = 'high';
  }
  // Suspicious mapping
  else if (suspiciousMapping[asin]) {
    needsVerification = true;
    issue = suspiciousMapping[asin].issue;
    priority = 'high';
  }
  // Duplicate ASIN (but not in suspicious list)
  else if (asinMap.get(asin)!.length > 1) {
    needsVerification = true;
    issue = `Shared with: ${asinMap.get(asin)!.filter(i => i !== ingredientName).join(', ')}`;
    priority = 'medium';
  }
  
  if (needsVerification) {
    items.push({
      ingredient: ingredientName,
      productName: product.productName,
      asin,
      link: asinLink,
      issue,
      priority,
      verified: deadLinks.has(asin) ? 'dead' : 'pending',
      notes: '',
    });
  }
}

// Sort by priority
items.sort((a, b) => {
  const priorityOrder = { high: 0, medium: 1, low: 2 };
  return priorityOrder[a.priority] - priorityOrder[b.priority];
});

// Generate CSV
const csvHeader = 'Priority,Ingredient,Product Name,ASIN,Issue,Verified,Notes,Link\n';
const csvRows = items.map(item => {
  const escapeCsv = (str: string) => `"${str.replace(/"/g, '""')}"`;
  return [
    item.priority.toUpperCase(),
    escapeCsv(item.ingredient),
    escapeCsv(item.productName),
    item.asin,
    escapeCsv(item.issue),
    item.verified.toUpperCase(),
    '', // Empty notes column for manual entry
    item.link,
  ].join(',');
}).join('\n');

const csv = csvHeader + csvRows;

// Save to file
const outputPath = path.join(process.cwd(), 'AMAZON_LINK_VERIFICATION.csv');
fs.writeFileSync(outputPath, csv, 'utf-8');

console.log('='.repeat(80));
console.log('VERIFICATION LIST GENERATED');
console.log('='.repeat(80));
console.log();
console.log(`Total items needing verification: ${items.length}`);
console.log(`  High priority: ${items.filter(i => i.priority === 'high').length}`);
console.log(`  Medium priority: ${items.filter(i => i.priority === 'medium').length}`);
console.log(`  Low priority: ${items.filter(i => i.priority === 'low').length}`);
console.log();
console.log(`CSV file saved to: ${outputPath}`);
console.log();
console.log('HOW TO USE:');
console.log('1. Open AMAZON_LINK_VERIFICATION.csv in Excel/Google Sheets');
console.log('2. Click each link in the "Link" column');
console.log('3. Verify if the Amazon product matches the ingredient');
console.log('4. Update "Verified" column: CORRECT, WRONG, or DEAD');
console.log('5. Add notes in "Notes" column if needed');
console.log('6. For WRONG/DEAD items, find correct ASIN and add to notes');
console.log();
console.log('='.repeat(80));

// Also generate a markdown table for easy viewing
const mdTable = `# Amazon Link Verification List

Total items: ${items.length}

## High Priority (${items.filter(i => i.priority === 'high').length})

| Ingredient | Product | ASIN | Issue | Link |
|------------|---------|------|-------|------|
${items.filter(i => i.priority === 'high').map(item => 
  `| ${item.ingredient} | ${item.productName} | ${item.asin} | ${item.issue} | [Verify](${item.link}) |`
).join('\n')}

## Medium Priority (${items.filter(i => i.priority === 'medium').length})

| Ingredient | Product | ASIN | Issue | Link |
|------------|---------|------|-------|------|
${items.filter(i => i.priority === 'medium').slice(0, 10).map(item => 
  `| ${item.ingredient} | ${item.productName} | ${item.asin} | ${item.issue} | [Verify](${item.link}) |`
).join('\n')}

${items.filter(i => i.priority === 'medium').length > 10 ? `\n... and ${items.filter(i => i.priority === 'medium').length - 10} more medium priority items (see CSV)\n` : ''}

## Instructions

1. Click each "Verify" link
2. Check if Amazon product matches ingredient name
3. Mark in CSV: CORRECT, WRONG, or DEAD
4. For WRONG/DEAD: Find correct product and note new ASIN
`;

const mdPath = path.join(process.cwd(), 'AMAZON_LINK_VERIFICATION.md');
fs.writeFileSync(mdPath, mdTable, 'utf-8');

console.log(`Markdown file saved to: ${mdPath}`);
console.log();
</file>

<file path="lib/generator/Phase1_5_AutoClassify.ts">
// Phase 1.5: Enhanced auto-classification with clustering and token equivalence
// Reduces manual review from ~90 items to ~20 items

import { VETTED_PRODUCTS } from '../data/vetted-products';
import { RETAIL_SPECS } from '../validation/retailSpecDefinitions';
import { EnhancedRetailValidator } from '../validation/enhancedRetailValidator';
import { ASINClusterer } from '../validation/asinClusterer';
import * as fs from 'fs';
import * as path from 'path';

interface EnhancedClassificationResult {
  ingredient: string;
  productName: string;
  asin: string;
  link: string;
  status: 'auto-valid' | 'auto-structurally-valid' | 'auto-invalid' | 'needs-review' | 'no-spec';
  confidence: 'high' | 'medium' | 'low';
  issues: string[];
  notes: string;
  aliasGroup?: string;
  reasoning?: string;
}

const validator = new EnhancedRetailValidator();
const clusterer = new ASINClusterer();
const results: EnhancedClassificationResult[] = [];

console.log('='.repeat(80));
console.log('PHASE 1.5: ENHANCED AUTO-CLASSIFICATION');
console.log('With ASIN clustering + token equivalence + 4-state validation');
console.log('='.repeat(80));
console.log();

// Known dead links
const deadLinks = new Set(['B0082C00P8', 'B0006L2XNK']);

// STEP 1: Cluster duplicate ASINs
console.log('Step 1: Clustering duplicate ASINs...');
const productMap = new Map(Object.entries(VETTED_PRODUCTS));
const { aliasGroups, conflicts, singles } = clusterer.clusterByASIN(productMap);

console.log(`  Found ${aliasGroups.length} alias groups`);
console.log(`  Found ${conflicts.length} conflicts (wrong products)`);
console.log(`  Found ${singles.length} single-ASIN ingredients`);
console.log();

// STEP 2: Validate alias groups (once per group)
console.log('Step 2: Validating alias groups...');
const groupValidations = new Map<string, any>();

for (const group of aliasGroups) {
  const product = VETTED_PRODUCTS[group.canonicalName];
  if (!product) continue;
  
  const spec = RETAIL_SPECS[group.canonicalName];
  if (!spec) {
    // No spec for this group - mark as structurally valid by default
    groupValidations.set(group.groupId, {
      status: 'structurally-valid',
      confidence: 'medium',
      notes: 'No spec defined - assumed OK (alias group)',
    });
    continue;
  }
  
  const validationResult = validator.validateProductTitle(
    product.productName,
    spec,
    group.sharedASIN,
    group.canonicalName
  );
  
  groupValidations.set(group.groupId, validationResult);
}

console.log(`  Validated ${groupValidations.size} alias groups`);
console.log();

// STEP 3: Process all ingredients
console.log('Step 3: Classifying all ingredients...');

// Create reverse lookup: ingredient -> alias group
const ingredientToGroup = new Map<string, string>();
for (const group of aliasGroups) {
  for (const alias of group.aliases) {
    ingredientToGroup.set(alias, group.groupId);
  }
}

for (const [ingredientName, product] of Object.entries(VETTED_PRODUCTS)) {
  const asinMatch = product.asinLink.match(/\/dp\/([A-Z0-9]{10})/i);
  if (!asinMatch) continue;
  
  const asin = asinMatch[1];
  const spec = RETAIL_SPECS[ingredientName];
  
  let status: EnhancedClassificationResult['status'];
  let confidence: EnhancedClassificationResult['confidence'];
  let issues: string[] = [];
  let notes = '';
  let reasoning = '';
  let aliasGroup: string | undefined;
  
  // Check if dead link
  if (deadLinks.has(asin)) {
    status = 'auto-invalid';
    confidence = 'high';
    issues.push('Dead link (HTTP 405)');
    notes = '‚ùå NEEDS REPLACEMENT - Link is dead';
  }
  // Check if part of alias group
  else if (ingredientToGroup.has(ingredientName)) {
    const groupId = ingredientToGroup.get(ingredientName)!;
    const groupValidation = groupValidations.get(groupId);
    aliasGroup = groupId;
    
    if (groupValidation) {
      // Inherit validation from group
      if (groupValidation.status === 'valid') {
        status = 'auto-valid';
        confidence = groupValidation.confidence;
        notes = `‚úÖ Valid (alias group: ${groupId})`;
      } else if (groupValidation.status === 'structurally-valid') {
        status = 'auto-structurally-valid';
        confidence = groupValidation.confidence;
        notes = `‚úÖ Structurally valid (alias group: ${groupId})`;
        if (groupValidation.reasoning?.equivalentTokensUsed?.length > 0) {
          reasoning = `Uses equivalent tokens: ${groupValidation.reasoning.equivalentTokensUsed.map((e: any) => `${e.token}‚âà${e.synonym}`).join(', ')}`;
        }
      } else if (groupValidation.status === 'ambiguous') {
        status = 'needs-review';
        confidence = groupValidation.confidence;
        notes = `‚ö†Ô∏è Ambiguous (alias group: ${groupId})`;
      } else {
        status = 'auto-invalid';
        confidence = groupValidation.confidence;
        notes = `‚ùå Invalid (alias group: ${groupId})`;
      }
      
      if (groupValidation.structuralIssues) {
        issues.push(...groupValidation.structuralIssues.map((i: any) => `STRUCTURAL: ${i.message}`));
      }
      if (groupValidation.semanticIssues) {
        issues.push(...groupValidation.semanticIssues.map((i: any) => `SEMANTIC: ${i.message}`));
      }
    } else {
      status = 'no-spec';
      confidence = 'medium';
      notes = `No spec (alias group: ${groupId})`;
    }
  }
  // Check if conflict
  else if (conflicts.some(c => c.ingredients.includes(ingredientName))) {
    const conflict = conflicts.find(c => c.ingredients.includes(ingredientName))!;
    status = 'needs-review';
    confidence = 'low';
    issues.push(`CONFLICT: ${conflict.reason}`);
    notes = `‚ö†Ô∏è Conflict detected - likely wrong product`;
  }
  // Has spec - validate individually
  else if (spec) {
    const validationResult = validator.validateProductTitle(
      product.productName,
      spec,
      asin,
      ingredientName
    );
    
    confidence = validationResult.confidence;
    
    if (validationResult.structuralIssues) {
      issues.push(...validationResult.structuralIssues.map(i => `STRUCTURAL: ${i.message}`));
    }
    if (validationResult.semanticIssues) {
      issues.push(...validationResult.semanticIssues.map(i => `SEMANTIC: ${i.message}`));
    }
    
    if (validationResult.reasoning?.equivalentTokensUsed?.length > 0) {
      reasoning = `Uses equivalent tokens: ${validationResult.reasoning.equivalentTokensUsed.map(e => `${e.token}‚âà${e.synonym}`).join(', ')}`;
    }
    
    if (validationResult.status === 'valid') {
      status = 'auto-valid';
      notes = '‚úÖ Passes all validation checks';
    } else if (validationResult.status === 'structurally-valid') {
      status = 'auto-structurally-valid';
      notes = '‚úÖ Structurally valid - safe to use';
    } else if (validationResult.status === 'invalid') {
      status = 'auto-invalid';
      notes = '‚ùå Failed validation - likely wrong product';
    } else {
      status = 'needs-review';
      notes = '‚ö†Ô∏è Ambiguous - manual review needed';
    }
  }
  // No spec - assume OK
  else {
    status = 'no-spec';
    confidence = 'medium';
    notes = 'No validation spec defined - assumed OK';
  }
  
  results.push({
    ingredient: ingredientName,
    productName: product.productName,
    asin,
    link: product.asinLink,
    status,
    confidence,
    issues,
    notes,
    aliasGroup,
    reasoning,
  });
}

// Generate statistics
const stats = {
  total: results.length,
  autoValid: results.filter(r => r.status === 'auto-valid').length,
  autoStructurallyValid: results.filter(r => r.status === 'auto-structurally-valid').length,
  autoInvalid: results.filter(r => r.status === 'auto-invalid').length,
  needsReview: results.filter(r => r.status === 'needs-review').length,
  noSpec: results.filter(r => r.status === 'no-spec').length,
  inAliasGroups: results.filter(r => r.aliasGroup).length,
};

console.log();
console.log('='.repeat(80));
console.log('PHASE 1.5 RESULTS');
console.log('='.repeat(80));
console.log();
console.log(`Total items: ${stats.total}`);
console.log(`‚úÖ Auto-valid: ${stats.autoValid} (${((stats.autoValid / stats.total) * 100).toFixed(1)}%)`);
console.log(`‚úÖ Auto-structurally-valid: ${stats.autoStructurallyValid} (${((stats.autoStructurallyValid / stats.total) * 100).toFixed(1)}%)`);
console.log(`‚ùå Auto-invalid: ${stats.autoInvalid} (${((stats.autoInvalid / stats.total) * 100).toFixed(1)}%)`);
console.log(`‚ö†Ô∏è  Needs review: ${stats.needsReview} (${((stats.needsReview / stats.total) * 100).toFixed(1)}%)`);
console.log(`üìã No spec: ${stats.noSpec} (${((stats.noSpec / stats.total) * 100).toFixed(1)}%)`);
console.log();
console.log(`üîó In alias groups: ${stats.inAliasGroups} (${((stats.inAliasGroups / stats.total) * 100).toFixed(1)}%)`);
console.log();

const totalAccepted = stats.autoValid + stats.autoStructurallyValid + stats.noSpec;
const manualReviewNeeded = stats.needsReview + stats.autoInvalid;

console.log(`üìä SUMMARY:`);
console.log(`   Automatically accepted: ${totalAccepted} (${((totalAccepted / stats.total) * 100).toFixed(1)}%)`);
console.log(`   Manual review required: ${manualReviewNeeded} (${((manualReviewNeeded / stats.total) * 100).toFixed(1)}%)`);
console.log();
console.log(`üéØ Manual review reduced from 94 ‚Üí ${manualReviewNeeded} items`);
console.log(`   (${Math.round((1 - manualReviewNeeded / 94) * 100)}% reduction)`);
console.log();

// Show items needing review
const reviewItems = results.filter(r => r.status === 'needs-review' || r.status === 'auto-invalid');

if (reviewItems.length > 0) {
  console.log('='.repeat(80));
  console.log(`ITEMS REQUIRING MANUAL REVIEW (${reviewItems.length})`);
  console.log('='.repeat(80));
  console.log();
  
  reviewItems.forEach((item, idx) => {
    console.log(`${idx + 1}. ${item.ingredient}`);
    console.log(`   Product: ${item.productName}`);
    console.log(`   ASIN: ${item.asin}`);
    console.log(`   Status: ${item.status.toUpperCase()}`);
    if (item.aliasGroup) console.log(`   Alias Group: ${item.aliasGroup}`);
    if (item.issues.length > 0) {
      console.log(`   Issues:`);
      item.issues.forEach(issue => console.log(`     - ${issue}`));
    }
    if (item.reasoning) console.log(`   Reasoning: ${item.reasoning}`);
    console.log(`   Notes: ${item.notes}`);
    console.log(`   Link: ${item.link}`);
    console.log();
  });
}

// Generate CSV for manual review
const csvHeader = 'Status,Ingredient,Product Name,ASIN,Confidence,Alias Group,Issues,Notes,Action Needed,Link\n';
const csvRows = reviewItems.map(item => {
  const escapeCsv = (str: string) => `"${str.replace(/"/g, '""')}"`;
  return [
    item.status.toUpperCase(),
    escapeCsv(item.ingredient),
    escapeCsv(item.productName),
    item.asin,
    item.confidence.toUpperCase(),
    item.aliasGroup || '',
    escapeCsv(item.issues.join('; ')),
    escapeCsv(item.notes),
    item.status === 'auto-invalid' ? 'FIND NEW ASIN' : 'VERIFY',
    item.link,
  ].join(',');
}).join('\n');

const csv = csvHeader + csvRows;
const outputPath = path.join(process.cwd(), 'PHASE_1_5_MANUAL_REVIEW.csv');
fs.writeFileSync(outputPath, csv, 'utf-8');

console.log('='.repeat(80));
console.log('FILES GENERATED');
console.log('='.repeat(80));
console.log();
console.log(`CSV saved to: ${outputPath}`);
console.log();
console.log('='.repeat(80));
</file>

<file path="lib/generator/QuickTest.ts">
/**
 * Phase 1 Smoke Test - Verify critical fixes
 * Tests: S1 (1 primary protein), portion calc (petWeightKg), T1/T2/T3 hard fails
 */

import { RecipeBuilder } from './RecipeBuilder';

console.log('\n=== PHASE 1 SMOKE TEST ===\n');

// Test 1: Dog recipe with actual pet weight
console.log('TEST 1: Dog recipe with petWeightKg (10kg dog)');
const dogConstraints = {
  species: 'dogs' as const,
  lifeStage: 'adult' as const,
  petWeightKg: 10, // PHASE 1.4: Actual pet weight
  healthConcerns: [],
  budgetPerMeal: 4.0,
  targetCalories: undefined,
  allergies: [],
  bannedIngredients: [],
};

let successCount = 0;
let failCount = 0;

for (let i = 0; i < 3; i++) {
  const builder = new RecipeBuilder(dogConstraints, 'standard', 'medium');
  const recipe = builder.generate();

  if (recipe) {
    successCount++;
    console.log(`\n‚úÖ Dog Recipe ${i + 1}:`);
    
    // PHASE 1.2: Verify exactly 1 primary protein (PHASE 1.7: use proteinRole)
    const primaryProteins = recipe.ingredients.filter(ing => ing.ingredient.proteinRole === 'primary');
    console.log(`   Primary proteins: ${primaryProteins.map(p => p.ingredient.name).join(', ')} (count: ${primaryProteins.length})`);
    if (primaryProteins.length !== 1) {
      console.log(`   ‚ùå FAIL: Expected 1 primary protein, got ${primaryProteins.length}`);
    } else {
      console.log(`   ‚úÖ PASS: Exactly 1 primary protein`);
    }
    
    // PHASE 1.4: Check portion calculation uses pet weight
    const totalGrams = recipe.totalGrams;
    console.log(`   Total grams: ${totalGrams} (for 10kg dog)`);
    if (totalGrams < 200 || totalGrams > 1000) {
      console.log(`   ‚ö†Ô∏è  Portion seems off for 10kg dog`);
    }
    
    // Check organ meat percentage
    const organMeatGrams = recipe.ingredients
      .filter(ing =>
        ing.ingredient.feedingRole === 'supplement' &&
        (ing.ingredient.name.toLowerCase().includes('liver') ||
         ing.ingredient.name.toLowerCase().includes('kidney') ||
         ing.ingredient.name.toLowerCase().includes('heart'))
      )
      .reduce((sum, ing) => sum + ing.grams, 0);
    
    const organPercent = (organMeatGrams / recipe.totalGrams) * 100;
    console.log(`   Organ meat: ${organPercent.toFixed(1)}%`);
    if (organPercent > 10) {
      console.log(`   ‚ùå FAIL: Organ meat exceeds 10%`);
    } else {
      console.log(`   ‚úÖ PASS: Organ meat within 10% cap`);
    }
    
    // Check for toxic pairings
    const hasLiver = recipe.ingredients.some(ing => ing.ingredient.name.toLowerCase().includes('liver'));
    const hasSalmon = recipe.ingredients.some(ing => ing.ingredient.name.toLowerCase().includes('salmon'));
    const hasCod = recipe.ingredients.some(ing => ing.ingredient.name.toLowerCase().includes('cod'));
    
    if (hasLiver && (hasSalmon || hasCod)) {
      console.log(`   ‚ùå FAIL: TOXIC PAIRING - Liver + ${hasSalmon ? 'salmon' : 'cod'}`);
    } else {
      console.log(`   ‚úÖ PASS: No toxic pairings`);
    }
  } else {
    failCount++;
    console.log(`\n‚ùå Dog Recipe ${i + 1}: Failed to generate`);
  }
}

// Test 2: Cat recipe (salmon_atlantic should be primary)
console.log('\n\nTEST 2: Cat recipe (salmon_atlantic as primary protein)');
const catConstraints = {
  species: 'cats' as const,
  lifeStage: 'adult' as const,
  petWeightKg: 4, // PHASE 1.4: Typical cat weight
  healthConcerns: [],
  budgetPerMeal: 3.0,
  targetCalories: undefined,
  allergies: [],
  bannedIngredients: [],
};

for (let i = 0; i < 2; i++) {
  const builder = new RecipeBuilder(catConstraints, 'standard', 'medium');
  const recipe = builder.generate();

  if (recipe) {
    successCount++;
    console.log(`\n‚úÖ Cat Recipe ${i + 1}:`);
    
    const primaryProteins = recipe.ingredients.filter(ing => ing.ingredient.feedingRole === 'staple');
    console.log(`   Primary protein: ${primaryProteins.map(p => p.ingredient.name).join(', ')}`);
    if (primaryProteins.length !== 1) {
      console.log(`   ‚ùå FAIL: Expected 1 primary protein, got ${primaryProteins.length}`);
    } else {
      console.log(`   ‚úÖ PASS: Exactly 1 primary protein`);
    }
    
    console.log(`   Total grams: ${recipe.totalGrams} (for 4kg cat)`);
  } else {
    failCount++;
    console.log(`\n‚ùå Cat Recipe ${i + 1}: Failed to generate`);
  }
}

console.log(`\n\n=== PHASE 1 SMOKE TEST RESULTS ===`);
console.log(`‚úÖ Passed: ${successCount}`);
console.log(`‚ùå Failed: ${failCount}`);
console.log(`Total: ${successCount + failCount}\n`);
</file>

<file path="lib/generator/RecipeBuilder.integration.test.ts">
/**
 * RECIPE BUILDER INTEGRATION TESTS
 * Tests biological invariants using real recipe generation
 * 
 * Run with: npm test -- RecipeBuilder.integration.test.ts
 */

import { RecipeBuilder, type GenerationConstraints } from './RecipeBuilder';

// ============================================================================
// TEST UTILITIES
// ============================================================================

interface TestResult {
  passed: boolean;
  name: string;
  error?: string;
}

const results: TestResult[] = [];

function assert(condition: boolean, message: string) {
  if (!condition) {
    throw new Error(message);
  }
}

function test(name: string, fn: () => void): TestResult {
  try {
    fn();
    const result = { passed: true, name };
    results.push(result);
    console.log(`  ‚úÖ ${name}`);
    return result;
  } catch (error) {
    const result = {
      passed: false,
      name,
      error: error instanceof Error ? error.message : String(error),
    };
    results.push(result);
    console.log(`  ‚ùå ${name}: ${result.error}`);
    return result;
  }
}

// ============================================================================
// 1. GOLDEN-PATH TESTS
// ============================================================================

console.log('\nüìã Golden-Path Tests (System Succeeds)');

test('Perfect dog: generates recipe with good composition', () => {
  const constraints: GenerationConstraints = {
    species: 'dogs',
    lifeStage: 'adult',
    healthConcerns: [],
    budgetPerMeal: 4.0,
    targetCalories: 500,
    allergies: [],
    bannedIngredients: [],
  };

  const builder = new RecipeBuilder(constraints, 'standard', 'medium');
  const recipe = builder.generate();

  assert(recipe !== null, 'Recipe should be generated');
  assert(recipe!.debugInfo?.topScores[0].score >= 60, 'Top score should be ‚â•60');

  // Check composition (most important)
  const hasProtein = recipe!.ingredients.some(ing => ing.ingredient.category === 'protein');
  const hasCarb = recipe!.ingredients.some(ing => ing.ingredient.category === 'carb');
  const hasVeg = recipe!.ingredients.some(ing => ing.ingredient.category === 'vegetable');

  assert(hasProtein && hasCarb && hasVeg, 'Should have protein + carb + veg');
});

test('Perfect cat: high protein, low carb, ‚â•90 score', () => {
  const constraints: GenerationConstraints = {
    species: 'cats',
    lifeStage: 'adult',
    healthConcerns: [],
    budgetPerMeal: 5.0,
    targetCalories: 400,
    allergies: [],
    bannedIngredients: [],
  };

  const builder = new RecipeBuilder(constraints, 'standard', 'medium');
  const recipe = builder.generate();

  assert(recipe !== null, 'Recipe should be generated');
  assert(recipe!.debugInfo?.topScores[0].score >= 90, 'Top score should be ‚â•90');

  // Cats should have high protein, low/no carb
  const proteinCount = recipe!.ingredients.filter(
    ing => ing.ingredient.category === 'protein'
  ).length;
  const carbCount = recipe!.ingredients.filter(ing => ing.ingredient.category === 'carb').length;

  assert(proteinCount >= 1, 'Should have at least 1 protein');
  assert(carbCount <= 1, 'Cats should have 0-1 carbs');
});

// ============================================================================
// 2. REJECTION TESTS (Safety Gates)
// ============================================================================

console.log('\nüìã Rejection Tests (Safety Gates Work)');

test('Multiple primary proteins rejected (S1 rule)', () => {
  const constraints: GenerationConstraints = {
    species: 'dogs',
    lifeStage: 'adult',
    healthConcerns: [],
    budgetPerMeal: 4.0,
    targetCalories: 500,
    allergies: [],
    bannedIngredients: [],
  };

  // Generate 20 recipes and verify none have multiple primary proteins
  for (let i = 0; i < 20; i++) {
    const builder = new RecipeBuilder(constraints, 'standard', 'medium');
    const recipe = builder.generate();

    if (recipe) {
      const primaryProteins = recipe.ingredients.filter(
        ing => ing.ingredient.feedingRole === 'staple' && ing.ingredient.category === 'protein'
      );
      assert(primaryProteins.length === 1, `Recipe ${i}: should have exactly 1 primary protein`);
    }
  }
});

test('Missing carb for dog rejected (S4 rule)', () => {
  const constraints: GenerationConstraints = {
    species: 'dogs',
    lifeStage: 'adult',
    healthConcerns: [],
    budgetPerMeal: 4.0,
    targetCalories: 500,
    allergies: [],
    bannedIngredients: [],
  };

  // Generate 20 recipes and verify all have carbs
  for (let i = 0; i < 20; i++) {
    const builder = new RecipeBuilder(constraints, 'standard', 'medium');
    const recipe = builder.generate();

    if (recipe) {
      const hasCarb = recipe.ingredients.some(ing => ing.ingredient.category === 'carb');
      assert(hasCarb, `Recipe ${i}: dogs require carbs`);
    }
  }
});

// ============================================================================
// 3. NUTRIENT CEILING TESTS
// ============================================================================

console.log('\nüìã Nutrient Ceiling Tests');

test('Vitamin A ceiling enforced (T1 rule)', () => {
  const constraints: GenerationConstraints = {
    species: 'dogs',
    lifeStage: 'adult',
    healthConcerns: [],
    budgetPerMeal: 4.0,
    targetCalories: 500,
    allergies: [],
    bannedIngredients: [],
  };

  // Generate 20 recipes and verify vitamin A doesn't exceed ceiling (5000 IU for dogs)
  for (let i = 0; i < 20; i++) {
    const builder = new RecipeBuilder(constraints, 'standard', 'medium');
    const recipe = builder.generate();

    if (recipe) {
      const totalVitaminA = recipe.ingredients.reduce(
        (sum, ing) => sum + (ing.ingredient.composition.vitaminA || 0),
        0
      );
      assert(
        totalVitaminA <= 5000,
        `Recipe ${i}: vitamin A ${totalVitaminA} exceeds dog ceiling of 5000 IU`
      );
    }
  }
});

test('Calcium-phosphorus ratio in range (T6 rule)', () => {
  const constraints: GenerationConstraints = {
    species: 'dogs',
    lifeStage: 'adult',
    healthConcerns: [],
    budgetPerMeal: 4.0,
    targetCalories: 500,
    allergies: [],
    bannedIngredients: [],
  };

  // Dog Ca:P range is 1.2-2.0
  for (let i = 0; i < 20; i++) {
    const builder = new RecipeBuilder(constraints, 'standard', 'medium');
    const recipe = builder.generate();

    if (recipe) {
      const totalCalcium = recipe.ingredients.reduce(
        (sum, ing) => sum + (ing.ingredient.composition.calcium || 0),
        0
      );
      const totalPhosphorus = recipe.ingredients.reduce(
        (sum, ing) => sum + (ing.ingredient.composition.phosphorus || 0),
        0
      );

      if (totalPhosphorus > 0) {
        const ratio = totalCalcium / totalPhosphorus;
        assert(
          ratio >= 1.2 && ratio <= 2.0,
          `Recipe ${i}: Ca:P ratio ${ratio.toFixed(2)} outside dog range 1.2-2.0`
        );
      }
    }
  }
});

// ============================================================================
// 4. ALLERGEN & DERIVATIVE TESTS
// ============================================================================

console.log('\nüìã Allergen & Derivative Tests');

test('Allergen derivatives rejected (T5 rule)', () => {
  const constraints: GenerationConstraints = {
    species: 'dogs',
    lifeStage: 'adult',
    healthConcerns: [],
    budgetPerMeal: 4.0,
    targetCalories: 500,
    allergies: ['chicken'],
    bannedIngredients: [],
  };

  // Generate 20 recipes and verify no chicken or chicken derivatives
  for (let i = 0; i < 20; i++) {
    const builder = new RecipeBuilder(constraints, 'standard', 'medium');
    const recipe = builder.generate();

    if (recipe) {
      const hasChickenDerivative = recipe.ingredients.some(ing =>
        ing.ingredient.id.toLowerCase().includes('chicken') ||
        ing.ingredient.name.toLowerCase().includes('chicken')
      );
      assert(!hasChickenDerivative, `Recipe ${i}: should not contain chicken derivatives`);
    }
  }
});

// ============================================================================
// 5. DISTRIBUTION TESTS (Catch Clustering)
// ============================================================================

console.log('\nüìã Distribution Tests (No Clustering)');

test('Score spread: 50 recipes have variance', () => {
  const constraints: GenerationConstraints = {
    species: 'dogs',
    lifeStage: 'adult',
    healthConcerns: [],
    budgetPerMeal: 4.0,
    targetCalories: 500,
    allergies: [],
    bannedIngredients: [],
  };

  const scores: number[] = [];
  for (let i = 0; i < 50; i++) {
    const builder = new RecipeBuilder(constraints, 'standard', 'medium');
    const recipe = builder.generate();
    if (recipe?.debugInfo?.topScores[0]) {
      scores.push(recipe.debugInfo.topScores[0].score);
    }
  }

  assert(scores.length >= 40, 'Should generate at least 40 recipes');

  const max = Math.max(...scores);
  const min = Math.min(...scores);
  const mean = scores.reduce((a, b) => a + b, 0) / scores.length;
  const variance = scores.reduce((sum, s) => sum + Math.pow(s - mean, 2), 0) / scores.length;
  const stdDev = Math.sqrt(variance);

  assert(max >= 95, `Max score should be ‚â•95 (got ${max})`);
  assert(min >= 60, `Min score should be ‚â•60 (got ${min})`);
  assert(stdDev > 6, `Std dev should be >6 (got ${stdDev.toFixed(2)})`);

  // Check for clustering (no more than 20% identical scores)
  const scoreFreq = new Map<number, number>();
  scores.forEach(s => scoreFreq.set(s, (scoreFreq.get(s) || 0) + 1));
  const maxFreq = Math.max(...scoreFreq.values());
  const clusterPercent = (maxFreq / scores.length) * 100;

  assert(
    clusterPercent <= 20,
    `No single score should appear >20% (got ${clusterPercent.toFixed(1)}%)`
  );
});

// ============================================================================
// 6. REGRESSION TESTS (Never Break Again)
// ============================================================================

console.log('\nüìã Regression Tests (Biological Invariants)');

test('Salmon + liver never appears', () => {
  const constraints: GenerationConstraints = {
    species: 'dogs',
    lifeStage: 'adult',
    healthConcerns: [],
    budgetPerMeal: 4.0,
    targetCalories: 500,
    allergies: [],
    bannedIngredients: [],
  };

  for (let i = 0; i < 50; i++) {
    const builder = new RecipeBuilder(constraints, 'standard', 'medium');
    const recipe = builder.generate();

    if (recipe) {
      const ingredients = recipe.ingredients.map(ing => ing.ingredient.name.toLowerCase());
      const hasSalmon = ingredients.some(ing => ing.includes('salmon'));
      const hasLiver = ingredients.some(ing => ing.includes('liver'));

      assert(
        !(hasSalmon && hasLiver),
        `Salmon + liver should never appear together (found in recipe ${i})`
      );
    }
  }
});

test('Organ meat never exceeds 10%', () => {
  const constraints: GenerationConstraints = {
    species: 'dogs',
    lifeStage: 'adult',
    healthConcerns: [],
    budgetPerMeal: 4.0,
    targetCalories: 500,
    allergies: [],
    bannedIngredients: [],
  };

  for (let i = 0; i < 50; i++) {
    const builder = new RecipeBuilder(constraints, 'standard', 'medium');
    const recipe = builder.generate();

    if (recipe) {
      const organMeatGrams = recipe.ingredients
        .filter(ing =>
          ing.ingredient.name.toLowerCase().includes('liver') ||
          ing.ingredient.name.toLowerCase().includes('kidney') ||
          ing.ingredient.name.toLowerCase().includes('heart')
        )
        .reduce((sum, ing) => sum + ing.grams, 0);

      const organPercent = (organMeatGrams / recipe.totalGrams) * 100;
      assert(organPercent <= 10, `Organ meat should be ‚â§10% (got ${organPercent.toFixed(1)}%)`);
    }
  }
});

test('Exactly one primary protein per recipe', () => {
  const constraints: GenerationConstraints = {
    species: 'dogs',
    lifeStage: 'adult',
    healthConcerns: [],
    budgetPerMeal: 4.0,
    targetCalories: 500,
    allergies: [],
    bannedIngredients: [],
  };

  for (let i = 0; i < 50; i++) {
    const builder = new RecipeBuilder(constraints, 'standard', 'medium');
    const recipe = builder.generate();

    if (recipe) {
      const primaryProteins = recipe.ingredients.filter(
        ing => ing.ingredient.feedingRole === 'staple' && ing.ingredient.category === 'protein'
      );

      assert(
        primaryProteins.length === 1,
        `Should have exactly 1 primary protein (got ${primaryProteins.length})`
      );
    }
  }
});

// ============================================================================
// 7. PROPERTY-BASED FUZZER (1000 Random Recipes)
// ============================================================================

console.log('\nüìã Property-Based Fuzzer (1000 Random Recipes)');

test('No unsafe recipe reaches scoring (all 1000 pass validation)', () => {
  const constraints: GenerationConstraints = {
    species: 'dogs',
    lifeStage: 'adult',
    healthConcerns: [],
    budgetPerMeal: 4.0,
    targetCalories: 500,
    allergies: [],
    bannedIngredients: [],
  };

  let unsafeCount = 0;
  for (let i = 0; i < 1000; i++) {
    const builder = new RecipeBuilder(constraints, 'standard', 'medium');
    const recipe = builder.generate();

    if (recipe?.debugInfo?.validation && !recipe.debugInfo.validation.isValid) {
      unsafeCount++;
    }
  }

  assert(unsafeCount === 0, `No recipes should fail validation (${unsafeCount} failed out of 1000)`);
});

test('No nutrient ceiling violations survive (all 1000 pass T rules)', () => {
  const constraints: GenerationConstraints = {
    species: 'dogs',
    lifeStage: 'adult',
    healthConcerns: [],
    budgetPerMeal: 4.0,
    targetCalories: 500,
    allergies: [],
    bannedIngredients: [],
  };

  let violationCount = 0;
  for (let i = 0; i < 1000; i++) {
    const builder = new RecipeBuilder(constraints, 'standard', 'medium');
    const recipe = builder.generate();

    if (recipe?.debugInfo?.validation?.failedRules.some(r => r.startsWith('T'))) {
      violationCount++;
    }
  }

  assert(
    violationCount === 0,
    `No nutrient ceiling violations should survive (${violationCount} found out of 1000)`
  );
});

// ============================================================================
// TEST SUMMARY
// ============================================================================

console.log('\n' + '='.repeat(70));
console.log('TEST SUMMARY');
console.log('='.repeat(70));

const passed = results.filter(r => r.passed).length;
const failed = results.filter(r => !r.passed).length;

console.log(`\n‚úÖ Passed: ${passed}`);
console.log(`‚ùå Failed: ${failed}`);
console.log(`üìä Total: ${results.length}`);

if (failed > 0) {
  console.log('\n' + '='.repeat(70));
  console.log('FAILURES');
  console.log('='.repeat(70));
  results
    .filter(r => !r.passed)
    .forEach(r => {
      console.log(`\n‚ùå ${r.name}`);
      console.log(`   ${r.error}`);
    });
  process.exit(1);
} else {
  console.log('\nüéâ All tests passed!');
  process.exit(0);
}
</file>

<file path="lib/generator/RecipeBuilder.smoke.test.ts">
/**
 * RECIPE BUILDER SMOKE TESTS
 * Minimal viable tests that prove core fixes work with actual ingredient data
 * 
 * Focus: Verify the system generates diverse, safe recipes
 * Not: Perfect nutrient ratios (ingredient data is incomplete)
 */

import { RecipeBuilder, type GenerationConstraints } from './RecipeBuilder';

let passed = 0;
let failed = 0;

function test(name: string, fn: () => void) {
  try {
    fn();
    console.log(`‚úÖ ${name}`);
    passed++;
  } catch (error) {
    console.log(`‚ùå ${name}`);
    console.log(`   ${error instanceof Error ? error.message : String(error)}`);
    failed++;
  }
}

function assert(condition: boolean, message: string) {
  if (!condition) throw new Error(message);
}

// ============================================================================
// CORE FIXES VERIFICATION
// ============================================================================

console.log('\nüìã CORE FIXES VERIFICATION\n');

test('Weighted random selection: 10 recipes are different', () => {
  const constraints: GenerationConstraints = {
    species: 'dogs',
    lifeStage: 'adult',
    healthConcerns: [],
    budgetPerMeal: 4.0,
    targetCalories: 500,
    allergies: [],
    bannedIngredients: [],
  };

  const recipes = [];
  for (let i = 0; i < 10; i++) {
    const builder = new RecipeBuilder(constraints, 'standard', 'medium');
    const recipe = builder.generate();
    if (recipe) {
      recipes.push(recipe.ingredients.map(ing => ing.ingredient.id).sort().join(','));
    }
  }

  const uniqueRecipes = new Set(recipes);
  assert(
    uniqueRecipes.size >= 5,
    `Should have at least 5 different recipes (got ${uniqueRecipes.size})`
  );
});

test('Organ meat never exceeds 10%', () => {
  const constraints: GenerationConstraints = {
    species: 'dogs',
    lifeStage: 'adult',
    healthConcerns: [],
    budgetPerMeal: 4.0,
    targetCalories: 500,
    allergies: [],
    bannedIngredients: [],
  };

  for (let i = 0; i < 20; i++) {
    const builder = new RecipeBuilder(constraints, 'standard', 'medium');
    const recipe = builder.generate();

    if (recipe) {
      const organMeatGrams = recipe.ingredients
        .filter(ing =>
          ing.ingredient.name.toLowerCase().includes('liver') ||
          ing.ingredient.name.toLowerCase().includes('kidney') ||
          ing.ingredient.name.toLowerCase().includes('heart')
        )
        .reduce((sum, ing) => sum + ing.grams, 0);

      const organPercent = (organMeatGrams / recipe.totalGrams) * 100;
      assert(organPercent <= 10, `Organ meat ${organPercent.toFixed(1)}% exceeds 10%`);
    }
  }
});

test('Salmon + liver never co-occur', () => {
  const constraints: GenerationConstraints = {
    species: 'dogs',
    lifeStage: 'adult',
    healthConcerns: [],
    budgetPerMeal: 4.0,
    targetCalories: 500,
    allergies: [],
    bannedIngredients: [],
  };

  for (let i = 0; i < 30; i++) {
    const builder = new RecipeBuilder(constraints, 'standard', 'medium');
    const recipe = builder.generate();

    if (recipe) {
      const ingredients = recipe.ingredients.map(ing => ing.ingredient.name.toLowerCase());
      const hasSalmon = ingredients.some(ing => ing.includes('salmon'));
      const hasLiver = ingredients.some(ing => ing.includes('liver'));

      assert(!(hasSalmon && hasLiver), `Salmon + liver found together in recipe ${i}`);
    }
  }
});

test('Dogs always get carbs', () => {
  const constraints: GenerationConstraints = {
    species: 'dogs',
    lifeStage: 'adult',
    healthConcerns: [],
    budgetPerMeal: 4.0,
    targetCalories: 500,
    allergies: [],
    bannedIngredients: [],
  };

  for (let i = 0; i < 20; i++) {
    const builder = new RecipeBuilder(constraints, 'standard', 'medium');
    const recipe = builder.generate();

    if (recipe) {
      const hasCarb = recipe.ingredients.some(ing => ing.ingredient.category === 'carb');
      assert(hasCarb, `Recipe ${i} missing carbs`);
    }
  }
});

test('Cats can be carb-free', () => {
  const constraints: GenerationConstraints = {
    species: 'cats',
    lifeStage: 'adult',
    healthConcerns: [],
    budgetPerMeal: 5.0,
    targetCalories: 400,
    allergies: [],
    bannedIngredients: [],
  };

  let carbFreeCount = 0;
  for (let i = 0; i < 20; i++) {
    const builder = new RecipeBuilder(constraints, 'standard', 'medium');
    const recipe = builder.generate();

    if (recipe) {
      const hasCarb = recipe.ingredients.some(ing => ing.ingredient.category === 'carb');
      if (!hasCarb) carbFreeCount++;
    }
  }

  assert(carbFreeCount > 0, 'At least some cat recipes should be carb-free');
});

test('Allergen filtering works', () => {
  const constraints: GenerationConstraints = {
    species: 'dogs',
    lifeStage: 'adult',
    healthConcerns: [],
    budgetPerMeal: 4.0,
    targetCalories: 500,
    allergies: ['chicken'],
    bannedIngredients: [],
  };

  for (let i = 0; i < 20; i++) {
    const builder = new RecipeBuilder(constraints, 'standard', 'medium');
    const recipe = builder.generate();

    if (recipe) {
      const hasChicken = recipe.ingredients.some(ing =>
        ing.ingredient.id.toLowerCase().includes('chicken') ||
        ing.ingredient.name.toLowerCase().includes('chicken')
      );
      assert(!hasChicken, `Recipe ${i} contains chicken despite allergy`);
    }
  }
});

test('Diversity modes produce different results', () => {
  const constraints: GenerationConstraints = {
    species: 'dogs',
    lifeStage: 'adult',
    healthConcerns: [],
    budgetPerMeal: 4.0,
    targetCalories: 500,
    allergies: [],
    bannedIngredients: [],
  };

  const modes = ['high', 'medium', 'low', 'none'] as const;
  const results: Record<string, string[]> = {};

  for (const mode of modes) {
    results[mode] = [];
    for (let i = 0; i < 5; i++) {
      const builder = new RecipeBuilder(constraints, 'standard', mode);
      const recipe = builder.generate();
      if (recipe) {
        results[mode].push(recipe.ingredients.map(ing => ing.ingredient.id).sort().join(','));
      }
    }
  }

  // Each mode should produce some variation
  for (const mode of modes) {
    const unique = new Set(results[mode]).size;
    assert(unique >= 1, `Mode ${mode} should produce at least 1 unique recipe`);
  }
});

// ============================================================================
// SUMMARY
// ============================================================================

console.log('\n' + '='.repeat(70));
console.log('TEST SUMMARY');
console.log('='.repeat(70));
console.log(`‚úÖ Passed: ${passed}`);
console.log(`‚ùå Failed: ${failed}`);
console.log(`üìä Total: ${passed + failed}\n`);

if (failed === 0) {
  console.log('üéâ All smoke tests passed!');
  console.log('\nCore fixes verified:');
  console.log('  ‚úì Weighted random selection (recipes are diverse)');
  console.log('  ‚úì Organ meat cap (‚â§10%)');
  console.log('  ‚úì Salmon + liver prevention');
  console.log('  ‚úì Carb requirement for dogs');
  console.log('  ‚úì Carb-free allowed for cats');
  console.log('  ‚úì Allergen filtering');
  console.log('  ‚úì Diversity modes working');
  process.exit(0);
} else {
  console.log(`\n‚ö†Ô∏è  ${failed} test(s) failed`);
  process.exit(1);
}
</file>

<file path="lib/generator/RecipeBuilder.test.ts">
/**
 * RECIPE BUILDER TEST SUITE
 * Tests biological invariants, not scoring hacks
 * 
 * Categories:
 * 1. Golden-Path Tests (system succeeds on perfect inputs)
 * 2. Rejection Tests (safety gates work)
 * 3. Nutrient Ceiling Tests (micronutrient caps enforced)
 * 4. Allergen & Derivative Tests (cross-source safety)
 * 5. Distribution Tests (no clustering/repetition)
 * 6. Regression Tests (never break again)
 * 7. Property-Based Fuzzer (1000 random recipes)
 */

import { RecipeBuilder, type GenerationConstraints } from './RecipeBuilder';
import { validateRecipeComprehensive } from './RecipeConstraintRules';
import type { Ingredient } from '@/lib/data/ingredients';

// ============================================================================
// TEST UTILITIES
// ============================================================================

interface TestResult {
  passed: boolean;
  name: string;
  error?: string;
  details?: Record<string, any>;
}

const results: TestResult[] = [];

function assert(condition: boolean, message: string) {
  if (!condition) {
    throw new Error(message);
  }
}

function test(name: string, fn: () => void): TestResult {
  try {
    fn();
    const result = { passed: true, name };
    results.push(result);
    return result;
  } catch (error) {
    const result = {
      passed: false,
      name,
      error: error instanceof Error ? error.message : String(error),
    };
    results.push(result);
    return result;
  }
}

function describe(category: string, tests: Array<() => void>) {
  console.log(`\nüìã ${category}`);
  tests.forEach(t => t());
}

// ============================================================================
// 1. GOLDEN-PATH TESTS
// ============================================================================

describe('Golden-Path Tests (System Succeeds)', [
  () => {
    test('Perfect dog: scores ‚â•95, safe composition', () => {
      const constraints: GenerationConstraints = {
        species: 'dogs',
        lifeStage: 'adult',
        healthConcerns: [],
        budgetPerMeal: 4.0,
        targetCalories: 500,
        allergies: [],
        bannedIngredients: [],
      };

      const builder = new RecipeBuilder(constraints, 'standard', 'medium');
      const recipe = builder.generate();

      assert(recipe !== null, 'Recipe should be generated');
      assert(recipe!.debugInfo?.topScores[0].score >= 95, 'Top score should be ‚â•95');
      assert(recipe!.debugInfo?.validation?.isValid, 'Recipe should pass validation');

      // Check composition
      const hasProtein = recipe!.ingredients.some(
        ing => ing.ingredient.category === 'protein'
      );
      const hasCarb = recipe!.ingredients.some(ing => ing.ingredient.category === 'carb');
      const hasVeg = recipe!.ingredients.some(ing => ing.ingredient.category === 'vegetable');

      assert(hasProtein && hasCarb && hasVeg, 'Should have protein + carb + veg');
    });
  },

  () => {
    test('Perfect cat: high protein, low carb, ‚â•90 score', () => {
      const constraints: GenerationConstraints = {
        species: 'cats',
        lifeStage: 'adult',
        healthConcerns: [],
        budgetPerMeal: 5.0,
        targetCalories: 400,
        allergies: [],
        bannedIngredients: [],
      };

      const builder = new RecipeBuilder(constraints, 'standard', 'medium');
      const recipe = builder.generate();

      assert(recipe !== null, 'Recipe should be generated');
      assert(recipe!.debugInfo?.topScores[0].score >= 90, 'Top score should be ‚â•90');

      // Cats should have high protein, low/no carb
      const proteinCount = recipe!.ingredients.filter(
        ing => ing.ingredient.category === 'protein'
      ).length;
      const carbCount = recipe!.ingredients.filter(ing => ing.ingredient.category === 'carb')
        .length;

      assert(proteinCount >= 1, 'Should have at least 1 protein');
      assert(carbCount <= 1, 'Cats should have 0-1 carbs');
    });
  },
]);

// ============================================================================
// 2. REJECTION TESTS (Safety Gates)
// ============================================================================

describe('Rejection Tests (Safety Gates Work)', [
  () => {
    test('Organ overdose rejected: salmon + beef liver', () => {
      const constraints: GenerationConstraints = {
        species: 'dogs',
        lifeStage: 'adult',
        healthConcerns: [],
        budgetPerMeal: 4.0,
        targetCalories: 500,
        allergies: [],
        bannedIngredients: [],
      };

      // Simulate selecting salmon + beef liver
      const mockIngredients: Ingredient[] = [
        {
          id: 'salmon',
          name: 'salmon',
          category: 'protein',
          feedingRole: 'staple',
          composition: { protein: 25, fat: 13, kcal: 208, calcium: 12, phosphorus: 200 },
          speciesCompatibility: { dog: 'ok', cat: 'ok', bird: 'limit', reptile: 'limit', 'pocket-pet': 'avoid' },
          pricePerLb: 8.0,
        },
        {
          id: 'beef_liver',
          name: 'beef_liver',
          category: 'protein',
          feedingRole: 'supplement',
          composition: { protein: 20, fat: 3, kcal: 135, calcium: 6, phosphorus: 387, vitaminA: 30000 },
          speciesCompatibility: { dog: 'ok', cat: 'caution', bird: 'limit', reptile: 'limit', 'pocket-pet': 'avoid' },
          pricePerLb: 3.0,
        },
      ];

      const validation = validateRecipeComprehensive(
        mockIngredients,
        'dogs',
        'adult',
        4.0,
        []
      );

      assert(!validation.isValid, 'Should reject organ overdose');
      assert(
        validation.failedRules.includes('T1') || validation.failedRules.includes('S2'),
        'Should fail vitamin A or organ meat rule'
      );
    });
  },

  () => {
    test('Multiple primary proteins rejected', () => {
      const mockIngredients: Ingredient[] = [
        {
          id: 'chicken',
          name: 'chicken_breast',
          category: 'protein',
          feedingRole: 'staple',
          composition: { protein: 31, fat: 3, kcal: 165, calcium: 11, phosphorus: 196 },
          speciesCompatibility: { dog: 'ok', cat: 'ok', bird: 'limit', reptile: 'limit', 'pocket-pet': 'avoid' },
          pricePerLb: 3.0,
        },
        {
          id: 'salmon',
          name: 'salmon',
          category: 'protein',
          feedingRole: 'staple',
          composition: { protein: 25, fat: 13, kcal: 208, calcium: 12, phosphorus: 200 },
          speciesCompatibility: { dog: 'ok', cat: 'ok', bird: 'limit', reptile: 'limit', 'pocket-pet': 'avoid' },
          pricePerLb: 8.0,
        },
      ];

      const validation = validateRecipeComprehensive(
        mockIngredients,
        'dogs',
        'adult',
        4.0,
        []
      );

      assert(!validation.isValid, 'Should reject multiple primary proteins');
      assert(validation.failedRules.includes('S1'), 'Should fail S1 rule');
    });
  },

  () => {
    test('Missing carb for dog rejected', () => {
      const mockIngredients: Ingredient[] = [
        {
          id: 'beef',
          name: 'beef',
          category: 'protein',
          feedingRole: 'staple',
          composition: { protein: 26, fat: 15, kcal: 250, calcium: 10, phosphorus: 180 },
          speciesCompatibility: { dog: 'ok', cat: 'ok', bird: 'limit', reptile: 'limit', 'pocket-pet': 'avoid' },
          pricePerLb: 5.0,
        },
        {
          id: 'carrots',
          name: 'carrots',
          category: 'vegetable',
          feedingRole: 'staple',
          composition: { protein: 0.9, fat: 0.2, kcal: 41, calcium: 33, phosphorus: 35 },
          speciesCompatibility: { dog: 'ok', cat: 'ok', bird: 'ok', reptile: 'ok', 'pocket-pet': 'ok' },
          pricePerLb: 0.5,
        },
        {
          id: 'fish_oil',
          name: 'fish_oil',
          category: 'fat',
          feedingRole: 'supplement',
          composition: { protein: 0, fat: 100, kcal: 902, calcium: 0, phosphorus: 0 },
          speciesCompatibility: { dog: 'ok', cat: 'ok', bird: 'limit', reptile: 'limit', 'pocket-pet': 'avoid' },
          pricePerLb: 15.0,
        },
      ];

      const validation = validateRecipeComprehensive(
        mockIngredients,
        'dogs',
        'adult',
        4.0,
        []
      );

      assert(!validation.isValid, 'Should reject carb-free dog recipe');
      assert(validation.failedRules.includes('S4'), 'Should fail S4 rule');
    });
  },
]);

// ============================================================================
// 3. NUTRIENT CEILING TESTS
// ============================================================================

describe('Nutrient Ceiling Tests', [
  () => {
    test('Vitamin A ceiling enforced (dog)', () => {
      // Liver has ~30,000 IU per 100g
      // Dog ceiling is 5,000 IU
      // 20% liver would exceed ceiling
      const mockIngredients: Ingredient[] = [
        {
          id: 'chicken',
          name: 'chicken_breast',
          category: 'protein',
          feedingRole: 'staple',
          composition: { protein: 31, fat: 3, kcal: 165, calcium: 11, phosphorus: 196, vitaminA: 0 },
          speciesCompatibility: { dog: 'ok', cat: 'ok', bird: 'limit', reptile: 'limit', 'pocket-pet': 'avoid' },
          pricePerLb: 3.0,
        },
        {
          id: 'beef_liver',
          name: 'beef_liver',
          category: 'protein',
          feedingRole: 'supplement',
          composition: { protein: 20, fat: 3, kcal: 135, calcium: 6, phosphorus: 387, vitaminA: 30000 },
          speciesCompatibility: { dog: 'ok', cat: 'caution', bird: 'limit', reptile: 'limit', 'pocket-pet': 'avoid' },
          pricePerLb: 3.0,
        },
        {
          id: 'rice',
          name: 'rice',
          category: 'carb',
          feedingRole: 'staple',
          composition: { protein: 2.7, fat: 0.3, kcal: 130, calcium: 10, phosphorus: 68 },
          speciesCompatibility: { dog: 'ok', cat: 'ok', bird: 'ok', reptile: 'ok', 'pocket-pet': 'ok' },
          pricePerLb: 0.5,
        },
      ];

      const validation = validateRecipeComprehensive(
        mockIngredients,
        'dogs',
        'adult',
        4.0,
        []
      );

      assert(!validation.isValid, 'Should reject vitamin A overload');
      assert(validation.failedRules.includes('T1'), 'Should fail T1 rule');
    });
  },
]);

// ============================================================================
// 4. ALLERGEN & DERIVATIVE TESTS
// ============================================================================

describe('Allergen & Derivative Tests', [
  () => {
    test('Chicken fat rejected for chicken-allergic dog', () => {
      const mockIngredients: Ingredient[] = [
        {
          id: 'beef',
          name: 'beef',
          category: 'protein',
          feedingRole: 'staple',
          composition: { protein: 26, fat: 15, kcal: 250, calcium: 10, phosphorus: 180 },
          speciesCompatibility: { dog: 'ok', cat: 'ok', bird: 'limit', reptile: 'limit', 'pocket-pet': 'avoid' },
          pricePerLb: 5.0,
        },
        {
          id: 'chicken_fat',
          name: 'chicken_fat',
          category: 'fat',
          feedingRole: 'supplement',
          composition: { protein: 0, fat: 100, kcal: 884, calcium: 0, phosphorus: 0 },
          speciesCompatibility: { dog: 'ok', cat: 'ok', bird: 'limit', reptile: 'limit', 'pocket-pet': 'avoid' },
          pricePerLb: 2.0,
        },
      ];

      const validation = validateRecipeComprehensive(
        mockIngredients,
        'dogs',
        'adult',
        4.0,
        ['chicken'] // Pet allergic to chicken
      );

      assert(!validation.isValid, 'Should reject chicken derivative for chicken-allergic pet');
      assert(validation.failedRules.includes('T5'), 'Should fail T5 rule');
    });
  },
]);

// ============================================================================
// 5. DISTRIBUTION TESTS (Catch Clustering)
// ============================================================================

describe('Distribution Tests (No Clustering)', [
  () => {
    test('Score spread: 50 recipes have variance', () => {
      const constraints: GenerationConstraints = {
        species: 'dogs',
        lifeStage: 'adult',
        healthConcerns: [],
        budgetPerMeal: 4.0,
        targetCalories: 500,
        allergies: [],
        bannedIngredients: [],
      };

      const scores: number[] = [];
      for (let i = 0; i < 50; i++) {
        const builder = new RecipeBuilder(constraints, 'standard', 'medium');
        const recipe = builder.generate();
        if (recipe?.debugInfo?.topScores[0]) {
          scores.push(recipe.debugInfo.topScores[0].score);
        }
      }

      assert(scores.length >= 40, 'Should generate at least 40 recipes');

      const max = Math.max(...scores);
      const min = Math.min(...scores);
      const mean = scores.reduce((a, b) => a + b, 0) / scores.length;
      const variance = scores.reduce((sum, s) => sum + Math.pow(s - mean, 2), 0) / scores.length;
      const stdDev = Math.sqrt(variance);

      assert(max >= 95, `Max score should be ‚â•95 (got ${max})`);
      assert(min >= 60, `Min score should be ‚â•60 (got ${min})`);
      assert(stdDev > 6, `Std dev should be >6 (got ${stdDev.toFixed(2)})`);

      // Check for clustering (no more than 20% identical scores)
      const scoreFreq = new Map<number, number>();
      scores.forEach(s => scoreFreq.set(s, (scoreFreq.get(s) || 0) + 1));
      const maxFreq = Math.max(...scoreFreq.values());
      const clusterPercent = (maxFreq / scores.length) * 100;

      assert(
        clusterPercent <= 20,
        `No single score should appear >20% (got ${clusterPercent.toFixed(1)}%)`
      );
    });
  },
]);

// ============================================================================
// 6. REGRESSION TESTS (Never Break Again)
// ============================================================================

describe('Regression Tests (Biological Invariants)', [
  () => {
    test('Salmon + liver never appears', () => {
      const constraints: GenerationConstraints = {
        species: 'dogs',
        lifeStage: 'adult',
        healthConcerns: [],
        budgetPerMeal: 4.0,
        targetCalories: 500,
        allergies: [],
        bannedIngredients: [],
      };

      for (let i = 0; i < 20; i++) {
        const builder = new RecipeBuilder(constraints, 'standard', 'medium');
        const recipe = builder.generate();

        if (recipe) {
          const ingredients = recipe.ingredients.map(ing => ing.ingredient.name.toLowerCase());
          const hasSalmon = ingredients.some(ing => ing.includes('salmon'));
          const hasLiver = ingredients.some(ing => ing.includes('liver'));

          assert(
            !(hasSalmon && hasLiver),
            `Salmon + liver should never appear together (found in recipe ${i})`
          );
        }
      }
    });
  },

  () => {
    test('Organ meat never exceeds 10%', () => {
      const constraints: GenerationConstraints = {
        species: 'dogs',
        lifeStage: 'adult',
        healthConcerns: [],
        budgetPerMeal: 4.0,
        targetCalories: 500,
        allergies: [],
        bannedIngredients: [],
      };

      for (let i = 0; i < 20; i++) {
        const builder = new RecipeBuilder(constraints, 'standard', 'medium');
        const recipe = builder.generate();

        if (recipe) {
          const organMeatGrams = recipe.ingredients
            .filter(ing =>
              ing.ingredient.name.toLowerCase().includes('liver') ||
              ing.ingredient.name.toLowerCase().includes('kidney') ||
              ing.ingredient.name.toLowerCase().includes('heart')
            )
            .reduce((sum, ing) => sum + ing.grams, 0);

          const organPercent = (organMeatGrams / recipe.totalGrams) * 100;
          assert(organPercent <= 10, `Organ meat should be ‚â§10% (got ${organPercent.toFixed(1)}%)`);
        }
      }
    });
  },

  () => {
    test('Exactly one primary protein per recipe', () => {
      const constraints: GenerationConstraints = {
        species: 'dogs',
        lifeStage: 'adult',
        healthConcerns: [],
        budgetPerMeal: 4.0,
        targetCalories: 500,
        allergies: [],
        bannedIngredients: [],
      };

      for (let i = 0; i < 20; i++) {
        const builder = new RecipeBuilder(constraints, 'standard', 'medium');
        const recipe = builder.generate();

        if (recipe) {
          const primaryProteins = recipe.ingredients.filter(
            ing => ing.ingredient.feedingRole === 'staple' && ing.ingredient.category === 'protein'
          );

          assert(
            primaryProteins.length === 1,
            `Should have exactly 1 primary protein (got ${primaryProteins.length})`
          );
        }
      }
    });
  },
]);

// ============================================================================
// 7. PROPERTY-BASED FUZZER (1000 Random Recipes)
// ============================================================================

describe('Property-Based Fuzzer (1000 Random Recipes)', [
  () => {
    test('No unsafe recipe reaches scoring', () => {
      const constraints: GenerationConstraints = {
        species: 'dogs',
        lifeStage: 'adult',
        healthConcerns: [],
        budgetPerMeal: 4.0,
        targetCalories: 500,
        allergies: [],
        bannedIngredients: [],
      };

      let unsafeCount = 0;
      for (let i = 0; i < 1000; i++) {
        const builder = new RecipeBuilder(constraints, 'standard', 'medium');
        const recipe = builder.generate();

        if (recipe?.debugInfo?.validation && !recipe.debugInfo.validation.isValid) {
          unsafeCount++;
        }
      }

      assert(
        unsafeCount === 0,
        `No recipes should fail validation (${unsafeCount} failed out of 1000)`
      );
    });
  },

  () => {
    test('No nutrient ceiling violations survive', () => {
      const constraints: GenerationConstraints = {
        species: 'dogs',
        lifeStage: 'adult',
        healthConcerns: [],
        budgetPerMeal: 4.0,
        targetCalories: 500,
        allergies: [],
        bannedIngredients: [],
      };

      let violationCount = 0;
      for (let i = 0; i < 1000; i++) {
        const builder = new RecipeBuilder(constraints, 'standard', 'medium');
        const recipe = builder.generate();

        if (recipe?.debugInfo?.validation?.failedRules.some(r => r.startsWith('T'))) {
          violationCount++;
        }
      }

      assert(
        violationCount === 0,
        `No nutrient ceiling violations should survive (${violationCount} found out of 1000)`
      );
    });
  },
]);

// ============================================================================
// TEST SUMMARY
// ============================================================================

export function runAllTests() {
  console.log('\n' + '='.repeat(70));
  console.log('RECIPE BUILDER TEST SUITE');
  console.log('='.repeat(70));

  const passed = results.filter(r => r.passed).length;
  const failed = results.filter(r => !r.passed).length;

  console.log(`\n‚úÖ Passed: ${passed}`);
  console.log(`‚ùå Failed: ${failed}`);
  console.log(`üìä Total: ${results.length}`);

  if (failed > 0) {
    console.log('\n' + '='.repeat(70));
    console.log('FAILURES');
    console.log('='.repeat(70));
    results
      .filter(r => !r.passed)
      .forEach(r => {
        console.log(`\n‚ùå ${r.name}`);
        console.log(`   Error: ${r.error}`);
      });
  }

  return { passed, failed, total: results.length };
}

// Export for testing
export { test, describe, assert };
</file>

<file path="lib/generator/RecipeBuilder.ts">
/**
 * ENHANCED RECIPE BUILDER
 * Adds health-aware ingredient selection + palatability
 * 
 * Key improvements:
 * 1. Health concerns drive ingredient selection (40% weight)
 * 2. Contraindications filtered as hard constraints
 * 3. Palatability built into scoring (30% weight)
 * 4. Species-specific taste preferences
 * 5. Debug info for transparency
 */

import type { Species } from '@/lib/data/ingredients';
import { INGREDIENTS, getIngredientsForSpecies, type Ingredient, type IngredientCategory } from '@/lib/data/ingredients';

/**
 * Normalize ingredient category strings to canonical values.
 * Handles variations like 'fish', 'seafood', 'meat', 'poultry' ‚Üí 'protein'
 */
function canonicalCategory(cat: any): IngredientCategory | 'unknown' {
  const c = String(cat ?? '').toLowerCase().trim();

  // PROTEIN family (fish, meat, poultry, seafood, eggs)
  if (
    c === 'protein' ||
    c.includes('protein') ||
    c.includes('meat') ||
    c.includes('poultry') ||
    c.includes('fish') ||
    c.includes('seafood') ||
    c.includes('egg')
  ) return 'protein';

  // VEGETABLE family
  if (c === 'vegetable' || c.includes('veg')) return 'vegetable';

  // FAT family (oils)
  if (c === 'fat' || c.includes('oil')) return 'fat';

  // CARB family (grains, starches)
  if (c === 'carb' || c.includes('grain') || c.includes('starch')) return 'carb';

  // Keep specialized categories as-is
  if (['seed', 'nut', 'fruit', 'insect', 'hay', 'pellet', 'supplement'].includes(c)) {
    return c as IngredientCategory;
  }

  return 'unknown';
}
import { getNutritionalStandard } from '@/lib/data/aafco-standards';
import { HEALTH_BENEFIT_MAP, HEALTH_CONTRAINDICATIONS } from '@/lib/data/healthBenefitMap';
import { validateRecipeComprehensive } from './RecipeConstraintRules';
import { shouldPruneCandidateForMicronutrients, getPruningReason } from './CombinatoricsPruning';
import { isFatCompatibleWithProteins, calculatePairingScore, logPairingDecision } from './RecipePMIScoring';
import { applyPriorScoring } from './RecipePriorScoring';
import { filterCandidatesByCommercialPriors, applyCommercialPriorScoring, hasCommercialPriors } from './CommercialPriorEnforcement';

export interface GenerationConstraints {
  species: Species;
  lifeStage: 'puppy' | 'adult' | 'senior';
  petWeightKg?: number; // PHASE 1.3: Actual pet weight for portion calculation
  healthConcerns?: string[];
  budgetPerMeal?: number;
  targetCalories?: number;
  allergies?: string[];
  bannedIngredients?: string[];
  recentIngredients?: string[]; // Track recently used ingredients for variety
}

export interface PortionedIngredient {
  ingredient: Ingredient;
  grams: number;
}

export interface GeneratedRecipeRaw {
  ingredients: PortionedIngredient[];
  totalGrams: number;
  estimatedCost: number;
  micronutrientDataIncomplete?: boolean; // Flag for exotic pets (no AAFCO standards)
  debugInfo?: {
    candidateCount: number;
    topScores: Array<{ name: string; score: number; breakdown: any }>;
    validation?: {
      isValid: boolean;
      failedRules: string[];
      softPenalties: Array<{ ruleId: string; penalty: number; message: string }>;
    };
  };
}

interface ScoredIngredient {
  ingredient: Ingredient;
  totalScore: number;
  breakdown: {
    health: number;
    quality: number;
    nutritional: number;
    diversity?: number;
  };
}

export type DiversityMode = 'high' | 'medium' | 'low' | 'none';

export class RecipeBuilder {
  private constraints: GenerationConstraints;
  private qualityTier: 'premium' | 'standard' | 'budget';
  private diversityMode: DiversityMode;

  // Scoring weights (reflects priority order)
  private weights = {
    health: 0.40,
    nutritional: 0.50,
    quality: 0.10,
  };

  constructor(
    constraints: GenerationConstraints,
    qualityTier: 'premium' | 'standard' | 'budget' = 'standard',
    diversityMode: DiversityMode = 'medium'
  ) {
    this.constraints = constraints;
    this.qualityTier = qualityTier;
    this.diversityMode = diversityMode;
  }

  /**
   * Main generation method
   */
  generate(): GeneratedRecipeRaw | null {
    try {
      console.log(`\n========== RECIPE GENERATION START (${this.constraints.species}) ==========`);
      const maxRetries = 3;
      let attempt = 0;
      const failedIngredients = new Set<string>(); // Track ingredients that failed hard gates

      while (attempt < maxRetries) {
        attempt++;
        console.log(`\n--- Attempt ${attempt}/${maxRetries} ---`);

        // 1. Get candidate ingredients (hard filters)
        let candidates = this.getCandidateIngredients();
        console.log(`[Step 1] Candidates after filters: ${candidates.length}`);
        
        // üî• CRITICAL GUARDRAIL: Block small candidate pools (vetted-only path)
        const MIN_POOL = 200;
        if (this.constraints.species === 'cats' && candidates.length < MIN_POOL) {
          throw new Error(
            `[RecipeBuilder] Candidate pool collapsed to ${candidates.length}. ` +
            `Refusing to generate recipes from small pool (likely vetted-only/products-only path). ` +
            `Minimum required: ${MIN_POOL}`
          );
        }
        
        if (candidates.length === 0) {
          console.warn(`No candidate ingredients found for ${this.constraints.species}`);
          return null;
        }

        // üî• NEW: Exclude ingredients that failed hard gates in previous attempts
        if (failedIngredients.size > 0) {
          candidates = candidates.filter(ing => !failedIngredients.has(ing.name));
          if (candidates.length === 0) {
            console.warn('All candidates excluded due to previous failures');
            return null;
          }
        }

        // 2. Score all candidates
        const scored = this.scoreIngredients(candidates);
        console.log(`[Step 2] Scored ingredients: ${scored.length}`);
        console.log(`[Step 2] Top 5 scores:`, scored.slice(0, 5).map(s => `${s.ingredient.name} (${s.totalScore.toFixed(1)})`));

        // 3. Select best ingredients by category
        const selected = this.selectIngredients(scored);
        console.log(`[Step 3] Selected ingredients: ${selected.length}`);
        console.log(`[Step 3] Ingredients:`, selected.map(i => `${i.name} (${i.category})`));
        if (selected.length === 0) {
          console.warn('No ingredients selected');
          return null;
        }

        // üî• NEW: Prune micronutrient-toxic candidates BEFORE validation
        if (shouldPruneCandidateForMicronutrients(selected)) {
          if (attempt < maxRetries) {
            console.warn(
              `Attempt ${attempt} pruned (micronutrient risk): ${getPruningReason(selected)}`
            );
            continue; // Retry with different random selections
          }
        }

        // 4. Calculate portions
        const portioned = this.calculatePortions(selected);
        console.log(`[Step 4] Portioned ingredients: ${portioned.length}`);
        console.log(`[Step 4] Portions:`, portioned.map(p => `${p.ingredient.name}: ${p.grams}g`));
        if (portioned.length === 0) {
          console.warn('Failed to calculate portions');
          return null;
        }

        // 5. Calculate cost
        const estimatedCost = this.calculateCost(portioned);
        console.log(`[Step 5] Estimated cost: $${estimatedCost.toFixed(2)}`);

        // üî• NEW: Validate recipe composition (comprehensive)
        const comprehensiveValidation = validateRecipeComprehensive(
          selected,
          this.constraints.species,
          this.constraints.lifeStage,
          estimatedCost,
          this.constraints.allergies
        );

        console.log(`[Step 6] Validation result: ${comprehensiveValidation.isValid ? 'PASS' : 'FAIL'}`);
        if (!comprehensiveValidation.isValid) {
          console.warn(`[Step 6] Failed hard gates:`, comprehensiveValidation.failedRules);
          
          // üî• NEW: Track which ingredients to exclude next time
          // If S2 (organ meat) failed, exclude organ meats
          if (comprehensiveValidation.failedRules.includes('S2')) {
            selected.forEach(ing => {
              if (ing.name.toLowerCase().includes('liver') ||
                  ing.name.toLowerCase().includes('kidney') ||
                  ing.name.toLowerCase().includes('heart')) {
                failedIngredients.add(ing.name);
              }
            });
          }
          
          if (attempt < maxRetries) {
            continue; // Retry with different random selections
          }
          // Last attempt failed - do NOT return recipe
          console.error('Could not generate valid recipe after', maxRetries, 'attempts');
          continue; // Skip to next retry (which will exit loop)
        } else {
          console.log(`[Step 6] ‚úÖ Validation passed!`);
          if (comprehensiveValidation.totalPenalty > 0) {
            console.warn(
              `[Step 6] Recipe quality penalties: ${comprehensiveValidation.totalPenalty}`,
              comprehensiveValidation.softGates.map(g => `${g.ruleId}: -${g.penalty}`)
            );
          }
        }

        // üî• PHASE 1: Only return if validation passed
        const species = this.constraints.species;
        const isExoticPet = species === 'birds' || species === 'reptiles' || species === 'pocket-pets';
        
        return {
          ingredients: portioned,
          totalGrams: portioned.reduce((sum, p) => sum + p.grams, 0),
          estimatedCost,
          // Flag exotic pets: micronutrient data incomplete (no AAFCO standards)
          micronutrientDataIncomplete: isExoticPet,
          debugInfo: {
            candidateCount: candidates.length,
            topScores: scored.slice(0, 10).map(s => ({
              name: s.ingredient.name,
              score: Math.round(s.totalScore),
              breakdown: {
                health: Math.round(s.breakdown.health),
                quality: Math.round(s.breakdown.quality),
                nutrition: Math.round(s.breakdown.nutritional),
              },
            })),
            validation: {
              isValid: comprehensiveValidation.isValid,
              failedRules: comprehensiveValidation.failedRules,
              softPenalties: comprehensiveValidation.softGates.map(g => ({
                ruleId: g.ruleId,
                penalty: g.penalty,
                message: g.message,
              })),
            },
          },
        };
      }

      return null;
    } catch (error) {
      console.error('RecipeBuilder.generate() error:', error);
      return null;
    }
  }


  /**
   * STEP 1: HARD FILTERS
   * Get candidate ingredients filtered by species and hard constraints
   */
  private getCandidateIngredients(): Ingredient[] {
    let candidates = getIngredientsForSpecies(this.constraints.species);
    
    // üî• STACK TRACE: Identify source of small pools
    console.log(`[PoolSource] Initial candidates: ${candidates.length}`, {
      species: this.constraints.species,
      source: 'getIngredientsForSpecies'
    });
    if (candidates.length < 200) {
      console.trace('[PoolSource] Small pool detected - trace:');
    }
    
    // üî• INVARIANT: Full pool must be large enough for cats
    if (this.constraints.species === 'cats' && candidates.length < 200) {
      throw new Error(
        `[Invariant] Full ingredient pool too small (${candidates.length}). ` +
        `Registry/provider is wrong. Expected 400+. ` +
        `This means getIngredientsForSpecies is returning a subset (vetted-only? priced-only?).`
      );
    }

    // Apply each filter individually with logging
    candidates = candidates.filter(ing => {
      // Filter 1: Allergies (HARD)
      if (
        this.constraints.allergies?.some(a =>
          ing.name.toLowerCase().includes(a.toLowerCase())
        )
      ) {
        return false;
      }

      // Filter 2: Banned ingredients (HARD)
      if (
        this.constraints.bannedIngredients?.some(b =>
          ing.name.toLowerCase().includes(b.toLowerCase())
        )
      ) {
        return false;
      }

      // Filter 3: Health contraindications (HARD)
      if (this.constraints.healthConcerns?.length) {
        for (const concern of this.constraints.healthConcerns) {
          const contraindicated = HEALTH_CONTRAINDICATIONS[concern] || [];
          const isContraindicated = contraindicated.some(
            contra =>
              ing.name.toLowerCase().includes(contra.toLowerCase()) ||
              ing.id.includes(contra.toLowerCase())
          );
          if (isContraindicated) {
            return false; // Hard exclude
          }
        }
      }

      // Filter 4: Exclude supplements from base recipes (HARD)
      // Supplements should only appear in supplements tab as add-ons
      if (ing.category === 'supplement') {
        return false;
      }

      // Filter 4b: Explicitly exclude fish oils (HARD)
      // Fish oils should only be supplements, not base ingredients
      const lowerName = ing.name.toLowerCase();
      const lowerId = ing.id.toLowerCase();
      if (lowerName.includes('fish oil') || 
          lowerName.includes('salmon oil') || 
          lowerName.includes('anchovy oil') ||
          lowerName.includes('mackerel oil') ||
          lowerName.includes('krill oil') ||
          lowerName.includes('cod liver oil') ||
          lowerName.includes('sardine oil') ||
          lowerName.includes('tuna oil') ||
          lowerName.includes('herring oil') ||
          lowerId.includes('fish_oil') ||
          lowerId.includes('salmon_oil') ||
          lowerId.includes('anchovy_oil') ||
          lowerId.includes('mackerel_oil') ||
          lowerId.includes('krill_oil') ||
          lowerId.includes('cod_liver_oil') ||
          lowerId.includes('sardine_oil') ||
          lowerId.includes('tuna_oil') ||
          lowerId.includes('herring_oil')) {
        console.log(`[FILTER] Excluding fish oil: ${ing.name} (id: ${ing.id})`);
        return false;
      }

      // Filter 5: Budget constraint (SOFT - allow some flex)
      if (this.constraints.budgetPerMeal && ing.pricePerLb) {
        const maxPrice = this.constraints.budgetPerMeal * 3; // Allow 3x for high-value ingredients
        if (ing.pricePerLb > maxPrice) return false;
      }

      return true;
    });
    
    console.log(`[Filters] After all filters: ${candidates.length} candidates`);
    
    // üî• INVARIANT: Check category pools for cats
    if (this.constraints.species === 'cats') {
      const veg = candidates.filter(x => canonicalCategory(x.category) === 'vegetable');
      const fat = candidates.filter(x => canonicalCategory(x.category) === 'fat');
      // Allow all proteins (exotic proteins already filtered out earlier)
      const proteinPool = candidates.filter(x => canonicalCategory(x.category) === 'protein');
      
      console.log(`[CategoryPools] protein=${proteinPool.length}, veg=${veg.length}, fat=${fat.length}`);
      
      if (veg.length < 2 || fat.length < 1 || proteinPool.length < 1) {
        throw new Error(
          `[Invariant] Missing required ingredient categories for cats: ` +
          `protein=${proteinPool.length} (need 1+), veg=${veg.length} (need 2+), fat=${fat.length} (need 1+). ` +
          `Cannot generate valid recipes. Pool size: ${candidates.length}`
        );
      }
    }

    return candidates;
  }

  /**
   * STEP 2: SCORE ALL CANDIDATES
   * Multi-factor scoring: health + quality + nutrition + diversity penalty
   * CRITICAL FIX: For protein category, heavily prioritize protein density
   */
  private scoreIngredients(candidates: Ingredient[]): ScoredIngredient[] {
    const recentIngredients = this.constraints.recentIngredients || [];
    
    return candidates
      .map(ing => {
        const breakdown = {
          health: this.scoreHealth(ing),
          quality: this.scoreQuality(ing),
          nutritional: this.scoreNutritional(ing),
        };

        // CRITICAL FIX: For protein category, use special weights
        // USER REQUIREMENT: Nutrition ALWAYS wins - protein density must dominate
        let weights = this.weights;
        if (canonicalCategory(ing.category) === 'protein') {
          weights = {
            health: 0.20,
            nutritional: 0.75,  // NUTRITION ALWAYS WINS - protein density dominates
            quality: 0.05,      // Minimal influence from quality
          };
        }

        let totalScore =
          breakdown.health * weights.health +
          breakdown.quality * weights.quality +
          breakdown.nutritional * weights.nutritional;

        // Apply diversity penalty for recently used ingredients
        const ingNameLower = ing.name.toLowerCase();
        const timesUsedRecently = recentIngredients.filter(r => r === ingNameLower).length;
        
        if (timesUsedRecently > 0) {
          // Heavy penalty: 50% reduction per recent use
          const diversityPenalty = Math.pow(0.5, timesUsedRecently);
          totalScore *= diversityPenalty;
          
          if (timesUsedRecently >= 2) {
            console.log(`[Diversity] Penalizing ${ing.name}: used ${timesUsedRecently}x recently, score ${totalScore.toFixed(1)} ‚Üí ${(totalScore * diversityPenalty).toFixed(1)}`);
          }
        }

        return { ingredient: ing, totalScore, breakdown };
      })
      .sort((a, b) => b.totalScore - a.totalScore); // Sort by total score descending
  }

  /**
   * HEALTH SCORE (0-100)
   * Does this ingredient help with pet's health concerns?
   */
  private scoreHealth(ing: Ingredient): number {
    if (!this.constraints.healthConcerns?.length) return 50; // Neutral if no concerns

    let score = 0;
    const ingName = ing.name.toLowerCase();

    for (const concern of this.constraints.healthConcerns) {
      const beneficialIngredients = HEALTH_BENEFIT_MAP[concern] || [];

      // Check if this ingredient is explicitly beneficial
      const isBeneficial = beneficialIngredients.some(
        beneficial =>
          ingName.includes(beneficial.toLowerCase()) ||
          beneficial.toLowerCase().includes(ingName)
      );

      if (isBeneficial) {
        score += 35; // +35 per matched health concern (can exceed 100)
      }
    }

    return Math.min(100, score);
  }

  /**
   * QUALITY SCORE (0-100)
   * Ingredient quality rating
   */
  private scoreQuality(ing: Ingredient): number {
    return ing.qualityScore * 10; // Convert 1-10 to 0-100
  }

  /**
   * NUTRITIONAL SCORE (0-100)
   * CRITICAL FIX: Heavily prioritize protein density to meet AAFCO standards
   * Protein is now 60% of nutritional score (was ~30%)
   */
  private scoreNutritional(ing: Ingredient): number {
    const comp = ing.composition;
    let score = 0;

    // PROTEIN DENSITY - Now 70 points max
    // Prioritize actual protein content over omega-3 for protein ingredients
    if (comp.protein) {
      if (comp.protein >= 30) score += 70;        // Chicken breast, turkey breast
      else if (comp.protein >= 25) score += 55;   // Ground turkey, ground chicken, tuna
      else if (comp.protein >= 20) score += 40;   // Salmon, duck
      else if (comp.protein >= 15) score += 25;   // Eggs, some fish
      else if (comp.protein >= 10) score += 12;   // Legumes
      else if (comp.protein >= 5) score += 6;     // Some vegetables
    }

    // Healthy fats (omega-3) - 10 points max (reduced from 20)
    // Omega-3 is good but shouldn't make canned fish dominate every recipe
    if (comp.omega3 && comp.omega3 > 1) score += 10;
    else if (comp.omega3 && comp.omega3 > 0.5) score += 5;

    // Fiber (good for digestion) - 10 points max
    if (comp.fiber && comp.fiber > 5) score += 10;
    else if (comp.fiber && comp.fiber > 2) score += 5;

    // Micronutrients - 10 points max
    if (comp.calcium && comp.calcium > 100) score += 5;
    if (comp.vitaminA && comp.vitaminA > 500) score += 5;

    return Math.min(100, score);
  }

  /**
   * Get required categories for a given species
   */
  private getRequiredCategoriesForSpecies(): IngredientCategory[] {
    const species = this.constraints.species;
    
    switch (species) {
      case 'dogs':
        return ['protein', 'carb', 'vegetable'];
      case 'cats':
        return ['protein', 'vegetable'];
      
      case 'birds':
        // Birds need seeds/nuts as protein, fruits/veggies for vitamins
        return ['seed', 'nut', 'fruit', 'vegetable'];
      
      case 'reptiles':
        // Reptiles need insects as protein, veggies for fiber
        return ['insect', 'vegetable', 'fruit'];
      
      case 'pocket-pets':
        // Pocket-pets need hay as staple, veggies/fruits for variety
        return ['hay', 'vegetable', 'fruit', 'seed'];
      
      default:
        return ['protein', 'carb', 'vegetable'];
    }
  }

  /**
   * Get how many ingredients to select from each category
   * Some categories are more important than others
   */
  private getIngredientCountForCategory(category: IngredientCategory): number {
    const species = this.constraints.species;
    
    // Dogs/Cats
    if (species === 'dogs' || species === 'cats') {
      if (category === 'protein') {
        return 1; // S1: Exactly 1 primary protein (hard gate)
      }
      if (category === 'carb') {
        return species === 'cats' ? 0 : 1; // Cats don't need carbs (obligate carnivores)
      }
      if (category === 'vegetable') {
        return species === 'cats' ? 2 : 1; // Cats get 2 veggies for variety (min 3 ingredients)
      }
      if (category === 'fat') {
        return 1; // 1 fat
      }
      return 1; // Default
    }
    
    // Birds
    if (species === 'birds') {
      if (category === 'seed' || category === 'nut') {
        return 2; // 2 seeds/nuts for variety
      }
      if (category === 'fruit') {
        return 1; // 1 fruit
      }
      if (category === 'vegetable') {
        return 1; // 1 veggie
      }
    }
    
    // Reptiles
    if (species === 'reptiles') {
      if (category === 'insect') {
        return 2; // 2 insects for variety
      }
      if (category === 'vegetable') {
        return 1; // 1 veggie
      }
      if (category === 'fruit') {
        return 1; // 1 fruit (optional)
      }
    }
    
    // Pocket-pets
    if (species === 'pocket-pets') {
      if (category === 'hay') {
        return 1; // 1 hay type (essential)
      }
      if (category === 'vegetable') {
        return 2; // 2 veggies for variety
      }
      if (category === 'fruit') {
        return 1; // 1 fruit (treat)
      }
      if (category === 'seed') {
        return 1; // 1 seed type (optional)
      }
    }
    
    return 1; // Default
  }

  // REMOVED: Hardcoded fat-protein pairing logic
  // Now using PMI-based pairing intelligence from recipePriors.json
  // See RecipePMIScoring.ts for learned pairing logic

  /**
   * STEP 3: SELECT BEST INGREDIENTS
   * Pick ingredients with weighted randomization to ensure diversity
   * üî• FIX: Species-aware ingredient selection
   */
  private selectIngredients(scored: ScoredIngredient[]): Ingredient[] {
    const selected: Ingredient[] = [];
    const categories = this.getRequiredCategoriesForSpecies();

    // üî• PRECONDITION CHECK: For cats, ensure we have all required categories
    if (this.constraints.species === 'cats') {
      const vegPool = scored.filter(s => canonicalCategory(s.ingredient.category) === 'vegetable');
      const fatPool = scored.filter(s => canonicalCategory(s.ingredient.category) === 'fat');
      // Allow all proteins (exotic proteins already filtered out earlier)
      const proteinPool = scored.filter(s => canonicalCategory(s.ingredient.category) === 'protein');
      
      if (vegPool.length < 2 || fatPool.length < 1 || proteinPool.length < 1) {
        throw new Error(
          `[RecipeBuilder] Insufficient pools for cats: ` +
          `protein=${proteinPool.length}, veg=${vegPool.length}, fat=${fatPool.length}. ` +
          `Cannot generate valid recipe without all required categories.`
        );
      }
    }

    // DEBUG: Log what we're looking for
    if (this.constraints.species === 'birds') {
      console.log(`[BIRD DEBUG] Looking for categories: ${categories.join(', ')}`);
      console.log(`[BIRD DEBUG] Total scored ingredients: ${scored.length}`);
    }

    for (const category of categories) {
      let inCategory = scored.filter(s => canonicalCategory(s.ingredient.category) === category);
      
      // CRITICAL: For dogs/cats protein category, all proteins allowed (exotic already filtered)
      // No additional filtering needed here
      
      // üî• COMMERCIAL PRIORS: Filter candidates using learned commercial pairing rules
      if (hasCommercialPriors(this.constraints.species) && selected.length > 0) {
        const selectedIds = selected.map(ing => ing.id);
        const beforeCommercialFilter = inCategory.length;
        
        // Filter out hardBlockPairs (never co-occur in commercial products)
        inCategory = filterCandidatesByCommercialPriors(
          inCategory.map(s => s.ingredient),
          selectedIds,
          this.constraints.species,
          '[Commercial] '
        ).map(ing => {
          // Find the scored ingredient back
          return inCategory.find(s => s.ingredient.id === ing.id)!;
        }).filter(Boolean);
        
        const afterCommercialFilter = inCategory.length;
        if (beforeCommercialFilter !== afterCommercialFilter) {
          console.log(`[Commercial Filter] Removed ${beforeCommercialFilter - afterCommercialFilter} hard-blocked ingredients`);
        }
      }
      
      // üî• PMI-BASED: Filter fats using learned pairing intelligence
      if (category === 'fat') {
        const selectedProteins = selected.filter(ing => canonicalCategory(ing.category) === 'protein');
        if (selectedProteins.length > 0) {
          const beforeFilter = inCategory.length;
          inCategory = inCategory.filter(s => {
            const compat = isFatCompatibleWithProteins(s.ingredient, selectedProteins, this.constraints.species);
            if (!compat.compatible) {
              console.log(`[PMI Filter] ${s.ingredient.name}: ${compat.reason}`);
            }
            return compat.compatible;
          });
          const afterFilter = inCategory.length;
          if (beforeFilter !== afterFilter) {
            console.log(`[PMI Filter] Removed ${beforeFilter - afterFilter} incompatible fats based on learned priors`);
          }
        }
      }
      
      // üî• DEBUG: Log protein pool details for cats
      if (this.constraints.species === 'cats' && category === 'protein') {
        console.log(`[ProteinPool] Total proteins in scored: ${inCategory.length}`);
        console.log(`[ProteinPool] Top 10 proteins:`, inCategory.slice(0, 10).map(s => 
          `${s.ingredient.name} (score: ${s.totalScore.toFixed(1)}, role: ${s.ingredient.proteinRole || 'none'})`
        ));
      }
      
      if (inCategory.length === 0) {
        console.warn(`No ingredients found for category: ${category} (species: ${this.constraints.species})`);
        continue;
      }

      const count = this.getIngredientCountForCategory(category);
      
      // DEBUG: Log selection details for birds
      if (this.constraints.species === 'birds') {
        console.log(`[BIRD DEBUG] Category '${category}': ${inCategory.length} available, selecting ${count}`);
        if (inCategory.length > 0) {
          console.log(`[BIRD DEBUG]   Top 3 in ${category}:`, inCategory.slice(0, 3).map(s => 
            `${s.ingredient.name} (score: ${s.totalScore.toFixed(1)})`
          ));
        }
      }
      
      // Skip if count is 0 (e.g., cats don't need grains)
      if (count === 0) continue;

      // Pick randomly from top N
      for (let i = 0; i < count && inCategory.length > 0; i++) {
        let poolSize: number;
        switch (this.diversityMode) {
          case 'high':
            poolSize = Math.min(8, inCategory.length);
            break;
          case 'medium':
            poolSize = Math.min(5, inCategory.length);
            break;
          case 'low':
            poolSize = Math.min(3, inCategory.length);
            break;
          case 'none':
            poolSize = 1;
            break;
        }

        const randomIndex = this.weightedRandomSelection(inCategory.slice(0, poolSize));
        const selectedIng = inCategory[randomIndex].ingredient;
        selected.push(selectedIng);
        
        // üî• DEBUG: Log what was selected
        if (this.constraints.species === 'cats' && category === 'protein') {
          console.log(`[Selection] Picked protein: ${selectedIng.name} (from pool of ${poolSize})`);
        }
        
        // Remove selected to avoid duplicates
        inCategory.splice(randomIndex, 1);
      }
    }

    if (selected.length === 0) {
      console.error('No ingredients selected for species:', this.constraints.species);
      console.error('Available categories:', categories);
      console.error('Scored ingredients count:', scored.length);
    }

    // CRITICAL: Enforce minimum 3 ingredients for proper meal prep
    // 2-ingredient meals are just "putting ingredients in a bowl", not meal prep
    const MIN_INGREDIENTS = 3;
    if (selected.length < MIN_INGREDIENTS) {
      console.warn(`Only ${selected.length} ingredients selected, need at least ${MIN_INGREDIENTS}`);
      
      // üî• NEVER pad with proteins when vegetables/fats are missing
      // Check what categories we're missing
      const selectedCategories = new Set(selected.map(ing => ing.category));
      const missingCategories = categories.filter(cat => !selectedCategories.has(cat));
      
      if (missingCategories.length > 0) {
        console.error(`Missing required categories: ${missingCategories.join(', ')}`);
        console.error('Cannot pad with random ingredients - aborting recipe generation');
        throw new Error(
          `Recipe generation failed: missing required categories [${missingCategories.join(', ')}]. ` +
          `This indicates the ingredient pool is too small or filtered incorrectly.`
        );
      }
      
      // Only pad if we have all required categories but just need more variety
      const remainingNeeded = MIN_INGREDIENTS - selected.length;
      const alreadySelectedIds = new Set(selected.map(ing => ing.id));
      
      // Get top-scoring ingredients from EXISTING categories only (no proteins if we already have one)
      const availableToAdd = scored
        .filter(s => {
          // Don't add if already selected
          if (alreadySelectedIds.has(s.ingredient.id)) return false;
          
          // For cats: don't add more proteins (we already have 1)
          if (this.constraints.species === 'cats' && canonicalCategory(s.ingredient.category) === 'protein') {
            return false;
          }
          
          // Only add from categories we already have
          return selectedCategories.has(s.ingredient.category);
        })
        .slice(0, remainingNeeded * 3); // Get 3x needed for variety
      
      for (let i = 0; i < remainingNeeded && availableToAdd.length > 0; i++) {
        const randomIndex = Math.floor(Math.random() * Math.min(5, availableToAdd.length));
        selected.push(availableToAdd[randomIndex].ingredient);
        availableToAdd.splice(randomIndex, 1);
      }
      
      console.log(`Added ${remainingNeeded} ingredients to reach minimum. Total: ${selected.length}`);
    }

    // DEBUG: Log final selection for birds
    if (this.constraints.species === 'birds') {
      console.log(`[BIRD DEBUG] Final selection: ${selected.length} ingredients`);
      selected.forEach(ing => console.log(`[BIRD DEBUG]   - ${ing.name} (${ing.category})`));
    }

    return selected;
  }

  /**
   * Weighted random selection
   * Higher-scoring ingredients have higher probability of being selected
   */
  private weightedRandomSelection(pool: ScoredIngredient[]): number {
    if (pool.length === 1) return 0;

    // Calculate weights (score^2 gives exponential preference to higher scores)
    const weights = pool.map(s => Math.pow(Math.max(0, s.totalScore), 2));
    const totalWeight = weights.reduce((sum, w) => sum + w, 0);

    if (totalWeight === 0) {
      // Fallback to uniform random if all scores are 0 or negative
      return Math.floor(Math.random() * pool.length);
    }

    // Pick random value in [0, totalWeight)
    let random = Math.random() * totalWeight;

    // Find which ingredient this corresponds to
    for (let i = 0; i < weights.length; i++) {
      random -= weights[i];
      if (random <= 0) return i;
    }

    return pool.length - 1; // Fallback
  }

  /**
   * Calculate portions based on NUTRIENT TARGETS (not category weights)
   * CRITICAL FIX: Calculate protein/fat needs UPFRONT, then allocate portions to meet targets
   * This ensures recipes meet AAFCO standards for all species
   */
  private calculatePortions(ingredients: Ingredient[]): PortionedIngredient[] {
    const petWeightKg = this.constraints.petWeightKg || 5;
    const species = this.constraints.species;
    
    // Step 1: Calculate total meal size
    const totalMealGrams = this.calculateTotalMealSize(petWeightKg, species);
    
    // Step 2: Get nutritional targets for this species
    const targets = this.getNutritionalTargets(species);
    
    // Step 3: Calculate required nutrient grams
    const targetProteinGrams = totalMealGrams * targets.proteinPercent;
    const targetFatGrams = totalMealGrams * targets.fatPercent;
    
    // Step 4: Allocate portions to meet nutrient targets
    return this.allocateNutrientTargetedPortions(
      ingredients,
      totalMealGrams,
      targetProteinGrams,
      targetFatGrams,
      petWeightKg
    );
  }
  
  /**
   * Calculate total meal size based on species and pet weight
   */
  private calculateTotalMealSize(petWeightKg: number, species: Species): number {
    if (species === 'dogs' || species === 'cats') {
      const mealMultiplier = this.qualityTier === 'premium' ? 80 : this.qualityTier === 'standard' ? 65 : 50;
      return petWeightKg * mealMultiplier;
    } else if (species === 'birds') {
      return petWeightKg * 40;
    } else if (species === 'reptiles') {
      return petWeightKg * 30;
    } else if (species === 'pocket-pets') {
      return petWeightKg * 100;
    }
    return petWeightKg * 65;
  }
  
  /**
   * Get nutritional targets (protein %, fat %) for each species
   * Based on AAFCO standards
   */
  private getNutritionalTargets(species: Species): { proteinPercent: number; fatPercent: number } {
    switch (species) {
      case 'dogs':
        return { proteinPercent: 0.20, fatPercent: 0.08 }; // 20% protein, 8% fat (above 18% minimum)
      case 'cats':
        return { proteinPercent: 0.23, fatPercent: 0.10 }; // 23% protein, 10% fat (allows diverse protein sources)
      case 'birds':
        // Target 15% but accept 13-17% range (natural fluctuation in seed diets)
        return { proteinPercent: 0.15, fatPercent: 0.08 };
      case 'reptiles':
        // Target 15% but accept 13-17% range (natural fluctuation in insect diets)
        return { proteinPercent: 0.15, fatPercent: 0.07 };
      case 'pocket-pets':
        // Target 14% but accept 12-16% range (natural fluctuation in hay diets)
        return { proteinPercent: 0.14, fatPercent: 0.06 };
      default:
        return { proteinPercent: 0.20, fatPercent: 0.08 };
    }
  }
  
  /**
   * Allocate portions to meet nutrient targets
   * Uses iterative approach: start with base allocation, then adjust to hit targets
   */
  private allocateNutrientTargetedPortions(
    ingredients: Ingredient[],
    totalMealGrams: number,
    targetProteinGrams: number,
    targetFatGrams: number,
    petWeightKg: number
  ): PortionedIngredient[] {
    const species = this.constraints.species;
    
    // Note: highProtein used later for boosting portions if needed
    const highProtein = ingredients.filter(ing => (ing.composition.protein || 0) >= 15);
    
    const portioned: PortionedIngredient[] = [];
    let allocatedGrams = 0;
    let allocatedProtein = 0;
    let allocatedFat = 0;
    
    // USER REQUIREMENT: Distribute portions across ALL selected ingredients
    // Don't allocate 90% to one ingredient - spread it out for variety
    
    // For dogs/cats: Use SELECTED protein (whatever was chosen by scoring)
    if (species === 'dogs' || species === 'cats') {
      // Get ANY protein that was selected (no primary/secondary distinction)
      const proteinIngredients = ingredients.filter(ing => canonicalCategory(ing.category) === 'protein');
      
      if (proteinIngredients.length === 0) {
        console.warn('No protein ingredients available for dogs/cats!');
        console.warn('Selected ingredients:', ingredients.map(i => `${i.name} (cat: ${i.category})`));
        return [];
      }
      
      // Use whichever protein was selected (chicken, sardines, mackerel, turkey, etc.)
      const primaryProtein = proteinIngredients[0];
      
      // Calculate portion needed to hit protein target with THIS protein
      const proteinDensity = (primaryProtein.composition.protein || 20) / 100;
      const requiredIngredientGrams = targetProteinGrams / proteinDensity;
      
      let proteinPortion = requiredIngredientGrams;
      
      // ARCHITECTURAL RULE: Hard upper bound to prevent crowding out micronutrients/fats
      // Cats: 90% max (obligate carnivores, need high protein even with diverse sources)
      // Dogs: 85% max (leaves 15% for variety & micronutrient carriers)
      const maxProteinPercent = species === 'cats' ? 0.90 : 0.85;
      proteinPortion = Math.min(proteinPortion, totalMealGrams * maxProteinPercent);
      
      // ARCHITECTURAL RULE: Never override max-inclusion constraints
      const maxGrams = petWeightKg * 1000 * primaryProtein.maxInclusionPercent[species];
      proteinPortion = Math.min(proteinPortion, maxGrams);
      
      proteinPortion = Math.round(proteinPortion);
      
      if (proteinPortion > 0) {
        portioned.push({ ingredient: primaryProtein, grams: proteinPortion });
        allocatedGrams += proteinPortion;
        allocatedProtein += (primaryProtein.composition.protein || 0) * proteinPortion / 100;
        allocatedFat += (primaryProtein.composition.fat || 0) * proteinPortion / 100;
      }
      
      // Allocate remaining grams to other ingredients
      const remainingGrams = totalMealGrams - allocatedGrams;
      const otherIngredients = ingredients.filter(ing => ing.id !== primaryProtein.id);
      
      if (remainingGrams > 0 && otherIngredients.length > 0) {
        const gramsPerIngredient = remainingGrams / otherIngredients.length;
        
        for (const ing of otherIngredients) {
          let grams = gramsPerIngredient;
          grams *= (0.85 + Math.random() * 0.3);
          
          const maxGrams = petWeightKg * 1000 * ing.maxInclusionPercent[species];
          grams = Math.min(grams, maxGrams);
          grams = Math.round(grams);
          
          if (grams > 0) {
            portioned.push({ ingredient: ing, grams });
            allocatedGrams += grams;
            allocatedProtein += (ing.composition.protein || 0) * grams / 100;
            allocatedFat += (ing.composition.fat || 0) * grams / 100;
          }
        }
      }
    } else {
      // For exotic pets: Distribute with bias toward higher-protein items
      // Equal grams ‚â† equal nutrition - bias toward protein-dense natural foods
      
      // Calculate protein density weights for each ingredient
      const totalProteinDensity = ingredients.reduce((sum, ing) => 
        sum + (ing.composition.protein || 0), 0);
      
      for (const ing of ingredients) {
        const proteinDensity = ing.composition.protein || 0;
        
        // Base allocation: equal distribution
        const baseGrams = totalMealGrams / ingredients.length;
        
        // Protein bias: allocate more to higher-protein ingredients
        // Weight = 70% equal + 30% protein-density-weighted
        const proteinWeight = totalProteinDensity > 0 
          ? proteinDensity / totalProteinDensity 
          : 1 / ingredients.length;
        
        let grams = (baseGrams * 0.70) + (totalMealGrams * proteinWeight * 0.30);
        
        // Add variation (¬±15%)
        grams *= (0.85 + Math.random() * 0.3);
        
        // ARCHITECTURAL RULE: Never override max-inclusion constraints
        const maxGrams = petWeightKg * 1000 * ing.maxInclusionPercent[species];
        grams = Math.min(grams, maxGrams);
        grams = Math.round(grams);
        
        if (grams > 0) {
          portioned.push({ ingredient: ing, grams });
          allocatedGrams += grams;
          allocatedProtein += (ing.composition.protein || 0) * grams / 100;
          allocatedFat += (ing.composition.fat || 0) * grams / 100;
        }
      }
    }
    
    // Step 4: Adjust if we're still below protein target
    const currentProteinPercent = allocatedGrams > 0 ? (allocatedProtein / allocatedGrams) : 0;
    const targetProteinPercent = targetProteinGrams / totalMealGrams;
    
    if (currentProteinPercent < targetProteinPercent * 0.95 && highProtein.length > 0) {
      // Boost high-protein portions by 20%
      for (const portioned_ing of portioned) {
        if ((portioned_ing.ingredient.composition.protein || 0) >= 15) {
          const boost = Math.round(portioned_ing.grams * 0.2);
          const maxGrams = petWeightKg * 1000 * portioned_ing.ingredient.maxInclusionPercent[species];
          portioned_ing.grams = Math.min(portioned_ing.grams + boost, maxGrams);
        }
      }
    }
    
    return portioned;
  }


  /**
   * Calculate estimated cost
   */
  private calculateCost(portioned: PortionedIngredient[]): number {
    return portioned.reduce((sum, p) => {
      if (!p.ingredient.pricePerLb) return sum;
      const lbs = p.grams / 453.592;
      return sum + lbs * p.ingredient.pricePerLb;
    }, 0);
  }
}
</file>

<file path="lib/generator/RecipeCompositionValidator.ts">
/**
 * RECIPE COMPOSITION VALIDATOR
 * Ensures recipes follow safe ingredient combination rules
 * Prevents unsafe combinations like multiple organ meats or unbalanced macros
 */

import type { Ingredient, Species } from '@/lib/data/ingredients';

// ============================================================================
// INGREDIENT ROLE DEFINITIONS
// ============================================================================

export const INGREDIENT_ROLES = {
  // Main proteins - can be primary ingredient (30-40% of recipe)
  mainProtein: [
    'chicken', 'turkey', 'beef', 'lamb', 'duck', 'venison',
    'salmon', 'whitefish', 'cod', 'sardine', 'tuna', 'egg'
  ],

  // Organ meats - MUST be limited to <10% of recipe
  organMeat: [
    'liver', 'kidney', 'heart', 'tripe', 'lung', 'spleen'
  ],

  // Carbohydrates - should be 30-40% of recipe
  carbs: [
    'rice', 'oats', 'quinoa', 'barley', 'potato', 'sweet potato',
    'pumpkin', 'squash', 'lentils', 'chickpeas', 'beans'
  ],

  // Vegetables - should be 10-20% of recipe
  vegetables: [
    'carrots', 'green beans', 'broccoli', 'spinach', 'kale',
    'zucchini', 'celery', 'peas', 'asparagus', 'lettuce'
  ],

  // Fats/oils - should be <5% of recipe
  fats: [
    'fish oil', 'coconut oil', 'olive oil', 'salmon oil', 'flaxseed', 'oil'
  ],
};

// ============================================================================
// UNSAFE COMBINATIONS
// ============================================================================

export const UNSAFE_COMBINATIONS = [
  {
    name: 'Multiple Organ Meats',
    ingredients: ['liver', 'kidney', 'heart'],
    maxCombined: 1, // Can only have 1 organ meat per recipe
    reason: 'Risk of vitamin A toxicity and mineral imbalance',
  },
  {
    name: 'High-Fat Proteins Together',
    ingredients: ['salmon', 'sardine', 'duck', 'lamb', 'mackerel'],
    maxCombined: 1, // Only 1 high-fat protein per recipe
    reason: 'Too much fat can cause pancreatitis',
  },
  {
    name: 'Multiple Fish Sources',
    ingredients: ['salmon', 'sardine', 'tuna', 'mackerel', 'whitefish', 'cod'],
    maxCombined: 1, // Only 1 fish per recipe
    reason: 'Risk of mercury accumulation and thiamine deficiency',
  },
];

// ============================================================================
// REQUIRED RECIPE STRUCTURE BY SPECIES
// ============================================================================

export const REQUIRED_RECIPE_STRUCTURE: Record<Species, {
  mustHave: string[];
  shouldHave: string[];
  optional: string[];
  minIngredients: number;
  maxIngredients: number;
}> = {
  dogs: {
    mustHave: ['mainProtein', 'carbs'], // REQUIRED
    shouldHave: ['vegetables'], // RECOMMENDED
    optional: ['fats', 'organMeat'], // OPTIONAL
    minIngredients: 3, // At least protein + carb + veggie
    maxIngredients: 6, // Don't overcomplicate
  },
  cats: {
    mustHave: ['mainProtein'], // Obligate carnivores - protein is essential
    shouldHave: ['fats'], // Cats need higher fat
    optional: ['carbs', 'vegetables'], // Cats don't need carbs, but tolerate some
    minIngredients: 2, // Can be simpler (protein + fat)
    maxIngredients: 5,
  },
  birds: {
    mustHave: ['vegetables', 'seed'], // Birds need seeds/veggies
    shouldHave: ['fruit'], // Birds love fruits
    optional: ['protein', 'carbs'],
    minIngredients: 2,
    maxIngredients: 5,
  },
  reptiles: {
    mustHave: ['protein'], // Carnivorous reptiles need protein
    shouldHave: ['vegetable'], // Some herbivorous/omnivorous reptiles
    optional: ['carbs', 'fruit'],
    minIngredients: 1,
    maxIngredients: 4,
  },
  'pocket-pets': {
    mustHave: ['hay', 'vegetable'], // Herbivores need hay and veggies
    shouldHave: ['fruit'], // Optional treats
    optional: ['carbs', 'seed'],
    minIngredients: 2,
    maxIngredients: 5,
  },
};

// ============================================================================
// VALIDATION RESULT
// ============================================================================

export interface ValidationResult {
  isValid: boolean;
  issues: string[];
  warnings: string[];
}

// ============================================================================
// MAIN VALIDATION FUNCTION
// ============================================================================

/**
 * Validate recipe composition for safety and balance
 */
export function validateRecipeComposition(
  selectedIngredients: Ingredient[],
  species: Species
): ValidationResult {
  const issues: string[] = [];
  const warnings: string[] = [];

  const ingredientNames = selectedIngredients.map(ing => ing.name.toLowerCase());

  // ========================================================================
  // CHECK 1: Required structure
  // ========================================================================
  const structure = REQUIRED_RECIPE_STRUCTURE[species];
  if (structure) {
    // Check mustHave categories
    for (const category of structure.mustHave) {
      const hasCategory = ingredientNames.some(name =>
        INGREDIENT_ROLES[category as keyof typeof INGREDIENT_ROLES]?.some(role =>
          name.includes(role)
        )
      );
      if (!hasCategory) {
        issues.push(`Missing required ingredient type: ${category}`);
      }
    }

    // Check shouldHave categories
    for (const category of structure.shouldHave) {
      const hasCategory = ingredientNames.some(name =>
        INGREDIENT_ROLES[category as keyof typeof INGREDIENT_ROLES]?.some(role =>
          name.includes(role)
        )
      );
      if (!hasCategory) {
        warnings.push(`Recommended ingredient type missing: ${category}`);
      }
    }

    // Check ingredient count
    if (selectedIngredients.length < structure.minIngredients) {
      issues.push(
        `Too few ingredients (${selectedIngredients.length}, need ${structure.minIngredients}+)`
      );
    }
    if (selectedIngredients.length > structure.maxIngredients) {
      warnings.push(
        `Too many ingredients (${selectedIngredients.length}, recommended max ${structure.maxIngredients})`
      );
    }
  }

  // ========================================================================
  // CHECK 2: Unsafe combinations
  // ========================================================================
  for (const combo of UNSAFE_COMBINATIONS) {
    const matchedIngredients = ingredientNames.filter(name =>
      combo.ingredients.some(unsafe => name.includes(unsafe))
    );

    if (matchedIngredients.length > combo.maxCombined) {
      issues.push(
        `Unsafe combination: ${matchedIngredients.join(' + ')}. ` +
        `${combo.reason}. Max ${combo.maxCombined} allowed.`
      );
    }
  }

  // ========================================================================
  // CHECK 3: Organ meat percentage (if present)
  // ========================================================================
  const hasOrganMeat = ingredientNames.some(name =>
    INGREDIENT_ROLES.organMeat.some(organ => name.includes(organ))
  );

  if (hasOrganMeat) {
    const organMeats = selectedIngredients.filter(ing =>
      INGREDIENT_ROLES.organMeat.some(organ => ing.name.toLowerCase().includes(organ))
    );

    // Check if organ meat has proper role
    const organMeatRole = organMeats[0]?.feedingRole;
    if (organMeatRole === 'staple') {
      issues.push(
        `${organMeats[0].name} is marked as staple but should be supplement. ` +
        `Organ meats must be limited to <10% of recipe.`
      );
    }

    // If multiple ingredients, warn if organ meat portion is too large
    if (selectedIngredients.length <= 2 && hasOrganMeat) {
      issues.push(
        `Recipe has too few ingredients with organ meat present. ` +
        `Add carbs/vegetables to dilute organ meat concentration.`
      );
    }
  }

  // ========================================================================
  // CHECK 4: No double proteins without carbs (for dogs)
  // ========================================================================
  if (species === 'dogs') {
    const proteinCount = ingredientNames.filter(name =>
      INGREDIENT_ROLES.mainProtein.some(p => name.includes(p)) ||
      INGREDIENT_ROLES.organMeat.some(o => name.includes(o))
    ).length;

    const hasCarbs = ingredientNames.some(name =>
      INGREDIENT_ROLES.carbs.some(c => name.includes(c))
    );

    if (proteinCount >= 2 && !hasCarbs) {
      issues.push(
        `Recipe has ${proteinCount} protein sources but no carbohydrates. ` +
        `This is unbalanced and too protein-heavy.`
      );
    }
  }

  return {
    isValid: issues.length === 0,
    issues,
    warnings,
  };
}

/**
 * Check if an ingredient should be categorized as a supplement (organ meat)
 */
export function isOrganMeat(ingredient: Ingredient): boolean {
  const name = ingredient.name.toLowerCase();
  return INGREDIENT_ROLES.organMeat.some(organ => name.includes(organ));
}

/**
 * Get ingredient category role
 */
export function getIngredientRole(ingredient: Ingredient): string {
  const name = ingredient.name.toLowerCase();

  if (INGREDIENT_ROLES.mainProtein.some(p => name.includes(p))) return 'mainProtein';
  if (INGREDIENT_ROLES.organMeat.some(o => name.includes(o))) return 'organMeat';
  if (INGREDIENT_ROLES.carbs.some(c => name.includes(c))) return 'carbs';
  if (INGREDIENT_ROLES.vegetables.some(v => name.includes(v))) return 'vegetables';
  if (INGREDIENT_ROLES.fats.some(f => name.includes(f))) return 'fats';

  return 'unknown';
}
</file>

<file path="lib/generator/RecipeConstraintRules.ts">
/**
 * RECIPE CONSTRAINT RULES
 * Pre-scoring validation gates that reject unsafe/invalid recipes before optimization
 * 
 * Pipeline:
 * 1. Constraint Gate (hard rejections)
 * 2. Composition Validator (structure + balance)
 * 3. Nutrient Ceiling Validator (micronutrient caps)
 * 4. Optimizer (cost + nutrition)
 * 5. Scorer (quality + fit)
 */

import type { Ingredient, Species } from '@/lib/data/ingredients';

// ============================================================================
// NUTRIENT CEILING TABLE (Species-Aware)
// Absolute caps per day equivalent, not scoring targets
// ============================================================================

export const NUTRIENT_CEILINGS: Record<Species, {
  vitaminA_IU: number;
  copper_mg: number;
  iodine_mcg: number;
  fat_percent: number;
  calcium_g: number;
  calcium_phosphorus_min: number;
  calcium_phosphorus_max: number;
}> = {
  dogs: {
    vitaminA_IU: 30000,       // PHASE 2: Per recipe (realistic with organs)
    copper_mg: 5.0,           // PHASE 2: Per recipe ceiling (realistic with organs)
    iodine_mcg: 1000,         // PHASE 2: Per recipe ceiling (realistic)
    fat_percent: 30,
    calcium_g: 2.5,
    calcium_phosphorus_min: 1.2,
    calcium_phosphorus_max: 2.0,
  },
  cats: {
    vitaminA_IU: 25000,       // PHASE 2: Per recipe (realistic with organs)
    copper_mg: 4.0,           // PHASE 2: Per recipe ceiling (realistic with organs)
    iodine_mcg: 800,          // PHASE 2: Per recipe ceiling (realistic)
    fat_percent: 45,
    calcium_g: 2.0,
    calcium_phosphorus_min: 1.1,
    calcium_phosphorus_max: 1.5,
  },
  birds: {
    vitaminA_IU: 4000, // Species-dependent, conservative estimate
    copper_mg: 0.3,
    iodine_mcg: 150,
    fat_percent: 15,
    calcium_g: 1.5,
    calcium_phosphorus_min: 1.0,
    calcium_phosphorus_max: 2.0,
  },
  reptiles: {
    vitaminA_IU: 3000, // Highly species-dependent
    copper_mg: 0.2,
    iodine_mcg: 100,
    fat_percent: 20,
    calcium_g: 2.0,
    calcium_phosphorus_min: 1.5,
    calcium_phosphorus_max: 2.5,
  },
  'pocket-pets': {
    vitaminA_IU: 4000,
    copper_mg: 0.3,
    iodine_mcg: 150,
    fat_percent: 20,
    calcium_g: 1.8,
    calcium_phosphorus_min: 1.0,
    calcium_phosphorus_max: 2.0,
  },
};

// ============================================================================
// INGREDIENT ROLE MATRIX
// Prevents "two mains in disguise" and organ stacking
// ============================================================================

export const INGREDIENT_ROLE_MATRIX = {
  'primary-protein': {
    allowedAsPrimary: true,
    percentCap: 0.60,
    maxPerRecipe: 1, // Exactly one primary protein
    examples: ['chicken_breast', 'beef', 'salmon', 'turkey_breast'],
  },
  'carb-base': {
    allowedAsPrimary: false,
    percentCap: 0.40,
    maxPerRecipe: 2,
    examples: ['rice', 'sweet_potato', 'oats', 'barley'],
  },
  'vegetable': {
    allowedAsPrimary: false,
    percentCap: 0.25,
    maxPerRecipe: 3,
    examples: ['carrots', 'green_beans', 'spinach', 'broccoli'],
  },
  'organ-meat': {
    allowedAsPrimary: false,
    percentCap: 0.10, // Hard cap for organ meats
    maxPerRecipe: 1, // Only one organ meat per recipe
    examples: ['chicken_liver', 'beef_liver', 'chicken_hearts'],
  },
  'fat-supplement': {
    allowedAsPrimary: false,
    percentCap: 0.05,
    maxPerRecipe: 1, // Only one added fat source
    examples: ['fish_oil', 'coconut_oil', 'olive_oil'],
  },
  'micronutrient': {
    allowedAsPrimary: false,
    percentCap: 0.01,
    maxPerRecipe: 1,
    examples: ['kelp', 'eggshell_powder', 'vitamin_premix'],
  },
};

// ============================================================================
// STRUCTURAL COMPOSITION RULES (Hard Gates)
// ============================================================================

export interface CompositionRuleResult {
  passed: boolean;
  ruleId: string;
  message: string;
}

export function validateStructuralComposition(
  ingredients: Ingredient[],
  species: Species,
  lifeStage: 'puppy' | 'adult' | 'senior'
): CompositionRuleResult[] {
  const results: CompositionRuleResult[] = [];

  // S1: Exactly 1 protein source (STRICT) - Species-aware
  // Dogs/cats: Must have 1 'protein' category (any protein, not just "primary")
  // Birds: Can have seeds/nuts as protein
  // Reptiles: Can have insects as protein
  // Pocket-pets: Can have hay/seeds as protein
  
  // Helper to normalize categories
  const canonicalCategory = (cat: any): string => {
    const c = String(cat ?? '').toLowerCase().trim();
    if (c === 'protein' || c.includes('protein') || c.includes('meat') || 
        c.includes('poultry') || c.includes('fish') || c.includes('seafood') || c.includes('egg')) {
      return 'protein';
    }
    return c;
  };
  
  let primaryProteins: Ingredient[];
  if (species === 'dogs' || species === 'cats') {
    // Accept ANY protein ingredient (chicken, turkey, sardines, mackerel, etc.)
    primaryProteins = ingredients.filter(ing => canonicalCategory(ing.category) === 'protein');
  } else if (species === 'birds') {
    // Birds: seeds/nuts/insects, but exclude oils (they're fats, not protein sources)
    primaryProteins = ingredients.filter(ing =>
      ['seed', 'nut', 'insect'].includes(ing.category) &&
      !ing.name.toLowerCase().includes('oil')
    );
  } else if (species === 'reptiles') {
    primaryProteins = ingredients.filter(ing =>
      ['insect', 'protein'].includes(ing.category)
    );
  } else if (species === 'pocket-pets') {
    primaryProteins = ingredients.filter(ing =>
      ['hay', 'seed'].includes(ing.category)
    );
  } else {
    // Default: accept any protein
    primaryProteins = ingredients.filter(ing => canonicalCategory(ing.category) === 'protein');
  }
  
  // Dogs/cats need exactly 1, exotic species can have 1-2 for variety
  const minRequired = (species === 'dogs' || species === 'cats') ? 1 : 1;
  const maxAllowed = (species === 'dogs' || species === 'cats') ? 1 : 3;
  
  results.push({
    passed: primaryProteins.length >= minRequired && primaryProteins.length <= maxAllowed,
    ruleId: 'S1',
    message: `Primary protein sources: ${primaryProteins.length} (species: ${species}, range: ${minRequired}-${maxAllowed})`,
  });

  // S2: Organ meats ‚â§ 1 per recipe (count-based, not weight)
  // NOTE: Weight-based cap moved to quality scoring as soft gate
  const organMeatNames = ['liver', 'kidney', 'heart'];
  const organMeats = ingredients.filter(ing => {
    const name = ing.name.toLowerCase();
    return ing.feedingRole === 'supplement' && organMeatNames.some(organ => name.includes(organ));
  });
  
  results.push({
    passed: organMeats.length <= 1,
    ruleId: 'S2',
    message: `Organ meats ‚â§ 1 per recipe (found ${organMeats.length})`,
  });

  // S3: Organ meats cannot be primary protein
  const organAsPrimary = ingredients.filter(ing =>
    ing.feedingRole === 'staple' &&
    (ing.name.toLowerCase().includes('liver') ||
      ing.name.toLowerCase().includes('kidney') ||
      ing.name.toLowerCase().includes('heart'))
  );
  results.push({
    passed: organAsPrimary.length === 0,
    ruleId: 'S3',
    message: `Organ meats cannot be primary protein (found ${organAsPrimary.length})`,
  });

  // S4: Must include carb/energy source (species-aware)
  // Dogs: need 'carb' (grains)
  // Birds: need 'seed' or 'nut' (energy-dense)
  // Pocket-pets: need 'hay' (fiber/energy)
  // Cats/reptiles: optional carbs
  let hasEnergySource = false;
  if (species === 'dogs') {
    hasEnergySource = ingredients.some(ing => ing.category === 'carb');
  } else if (species === 'birds') {
    hasEnergySource = ingredients.some(ing => ['seed', 'nut', 'carb'].includes(ing.category));
  } else if (species === 'pocket-pets') {
    hasEnergySource = ingredients.some(ing => ['hay', 'seed', 'carb'].includes(ing.category));
  } else {
    hasEnergySource = true; // Cats/reptiles don't require carbs
  }
  
  results.push({
    passed: hasEnergySource,
    ruleId: 'S4',
    message: `${species} energy source requirement met: ${hasEnergySource}`,
  });

  // S5: Carnivores may be carb-free (informational, not a gate)
  const isCarnivore = ['cats', 'reptiles'].includes(species);
  results.push({
    passed: true, // Always pass - this is permissive
    ruleId: 'S5',
    message: `${species} may be carb-free (allowed)`,
  });

  // S6: Minimum ingredient categories
  // All species need at least 2 different categories for nutritional balance
  const categories = new Set(ingredients.map(ing => ing.category));
  results.push({
    passed: categories.size >= 2,
    ruleId: 'S6',
    message: `Minimum 2 ingredient categories required (found ${categories.size})`,
  });

  // S7: Added fat sources ‚â§ 1
  const addedFats = ingredients.filter(ing => ing.category === 'fat');
  results.push({
    passed: addedFats.length <= 1,
    ruleId: 'S7',
    message: `Maximum 1 added fat source (found ${addedFats.length})`,
  });

  // S8: Ingredient diversity ‚â• 3 unique foods
  const uniqueIngredients = new Set(ingredients.map(ing => ing.id));
  results.push({
    passed: uniqueIngredients.size >= 3,
    ruleId: 'S8',
    message: `Minimum 3 unique ingredients required (found ${uniqueIngredients.size})`,
  });

  return results;
}

// ============================================================================
// SAFETY & TOXICITY RULES (Hard Gates)
// ============================================================================

export interface SafetyRuleResult {
  passed: boolean;
  ruleId: string;
  message: string;
  value?: number;
  ceiling?: number;
}

export function validateSafetyAndToxicity(
  ingredients: Ingredient[],
  species: Species,
  allergies?: string[]
): SafetyRuleResult[] {
  const results: SafetyRuleResult[] = [];
  const ceilings = NUTRIENT_CEILINGS[species];

  // T1: Vitamin A ceiling (HARD for dogs/cats, SOFT for exotic pets)
  const proteinAndOrganMeats = ingredients.filter(ing => 
    ing.category === 'protein' || 
    ing.name.toLowerCase().includes('liver') ||
    ing.name.toLowerCase().includes('kidney') ||
    ing.name.toLowerCase().includes('heart')
  );
  
  const totalVitaminA = ingredients.reduce((sum, ing) => sum + (ing.composition.vitaminA || 0), 0);
  const hasVitaminAData = proteinAndOrganMeats.every(ing => ing.composition.vitaminA !== undefined);
  
  // Only enforce for dogs/cats (AAFCO standards exist)
  const enforceT1 = species === 'dogs' || species === 'cats';
  results.push({
    passed: enforceT1 ? (hasVitaminAData && totalVitaminA <= ceilings.vitaminA_IU) : true,
    ruleId: 'T1',
    message: hasVitaminAData 
      ? `Vitamin A: ${totalVitaminA} IU (ceiling: ${ceilings.vitaminA_IU})`
      : enforceT1 
        ? `Vitamin A data incomplete for proteins/organs - cannot validate`
        : `Vitamin A data incomplete (soft warning for ${species})`,
    value: totalVitaminA,
    ceiling: ceilings.vitaminA_IU,
  });

  // T2: Copper ceiling (HARD for dogs/cats, SOFT for exotic pets)
  const totalCopper = ingredients.reduce((sum, ing) => sum + (ing.composition.copper_mg_per_100g || 0), 0);
  const hasAllCopperData = ingredients.every(ing => ing.composition.copper_mg_per_100g !== undefined);
  
  // Only enforce for dogs/cats
  const enforceT2 = species === 'dogs' || species === 'cats';
  results.push({
    passed: enforceT2 ? (hasAllCopperData && totalCopper <= ceilings.copper_mg) : true,
    ruleId: 'T2',
    message: hasAllCopperData 
      ? `Copper: ${totalCopper.toFixed(2)} mg (ceiling: ${ceilings.copper_mg})`
      : enforceT2
        ? `Copper data incomplete - cannot validate`
        : `Copper data incomplete (soft warning for ${species})`,
    value: totalCopper,
    ceiling: ceilings.copper_mg,
  });

  // T3: Iodine ceiling (PHASE 2: Now using class-based defaults + measured overrides)
  const totalIodine = ingredients.reduce((sum, ing) => sum + (ing.composition.iodine_mcg_per_100g || 0), 0);
  const hasAllIodineData = ingredients.every(ing => ing.composition.iodine_mcg_per_100g !== undefined);
  results.push({
    passed: hasAllIodineData && totalIodine <= ceilings.iodine_mcg,
    ruleId: 'T3',
    message: hasAllIodineData 
      ? `Iodine: ${totalIodine.toFixed(1)} mcg (ceiling: ${ceilings.iodine_mcg})`
      : `Iodine data incomplete - cannot validate`,
    value: totalIodine,
    ceiling: ceilings.iodine_mcg,
  });

  // T4: Known toxic ingredient present
  const toxicIngredients = ['grape', 'raisin', 'onion', 'garlic', 'chocolate', 'xylitol'];
  const hasToxic = ingredients.some(ing =>
    toxicIngredients.some(toxic => ing.name.toLowerCase().includes(toxic))
  );
  results.push({
    passed: !hasToxic,
    ruleId: 'T4',
    message: `No known toxic ingredients (found: ${hasToxic})`,
  });

  // T5: Allergen or derivative present
  const hasAllergen =
    allergies && allergies.length > 0
      ? ingredients.some(ing =>
          allergies.some(allergen =>
            ing.name.toLowerCase().includes(allergen.toLowerCase()) ||
            ing.id.includes(allergen.toLowerCase())
          )
        )
      : false;
  results.push({
    passed: !hasAllergen,
    ruleId: 'T5',
    message: `No allergens present (found: ${hasAllergen})`,
  });

  // T6: Ca:P ratio (SOFT WARNING - hard gate disabled until supplements available)
  // Phase 1: Just track it. Phase 2: Apply soft penalties if out of range.
  // Real fix: Add calcium supplement ingredients (eggshell powder, bone meal, etc.)
  const totalCalcium = ingredients.reduce((sum, ing) => sum + (ing.composition.calcium || 0), 0);
  const totalPhosphorus = ingredients.reduce((sum, ing) => sum + (ing.composition.phosphorus || 0), 0);
  const caPRatio = totalPhosphorus > 0 ? totalCalcium / totalPhosphorus : 1;
  const hasCalciumSupplement = ingredients.some(ing =>
    ing.name.toLowerCase().includes('eggshell') ||
    ing.name.toLowerCase().includes('bone meal') ||
    ing.name.toLowerCase().includes('calcium')
  );
  
  // Pass if: naturally in range OR has calcium supplement
  const caPValid = (caPRatio >= 1.0 && caPRatio <= 2.0) || hasCalciumSupplement;
  
  results.push({
    passed: true, // Always pass - this is now a soft warning, not hard gate
    ruleId: 'T6',
    message: `Ca:P ratio: ${Math.round(caPRatio * 100) / 100} ${hasCalciumSupplement ? '(supplement present)' : '(natural)'}`,
    value: Math.round(caPRatio * 100) / 100,
    ceiling: 2.0,
  });

  return results;
}

// ============================================================================
// LIFE STAGE RULES (Hard Gates)
// ============================================================================

export interface LifeStageRuleResult {
  passed: boolean;
  ruleId: string;
  message: string;
}

export function validateLifeStage(
  ingredients: Ingredient[],
  species: Species,
  lifeStage: 'puppy' | 'adult' | 'senior'
): LifeStageRuleResult[] {
  const results: LifeStageRuleResult[] = [];

  if (lifeStage === 'puppy') {
    // L1: Puppy calcium upper limit (prevent skeletal issues)
    const totalCalcium = ingredients.reduce((sum, ing) => sum + (ing.composition.calcium || 0), 0);
    const puppyCalciumMax = 2.0; // g per day
    results.push({
      passed: totalCalcium <= puppyCalciumMax,
      ruleId: 'L1',
      message: `Puppy calcium ‚â§ ${puppyCalciumMax}g (found ${totalCalcium}g)`,
    });

    // L4: Growth diets require higher protein
    const totalProtein = ingredients.reduce((sum, ing) => sum + (ing.composition.protein || 0), 0);
    const puppyProteinMin = 18; // % of calories
    results.push({
      passed: totalProtein >= puppyProteinMin,
      ruleId: 'L4',
      message: `Puppy protein ‚â• ${puppyProteinMin}% (found ${totalProtein}%)`,
    });
  }

  if (lifeStage === 'senior' && species === 'dogs') {
    // L3: Senior kidney load (reduce phosphorus)
    const totalPhosphorus = ingredients.reduce((sum, ing) => sum + (ing.composition.phosphorus || 0), 0);
    const seniorPhosphorusMax = 1.0; // g per day
    results.push({
      passed: totalPhosphorus <= seniorPhosphorusMax,
      ruleId: 'L3',
      message: `Senior phosphorus ‚â§ ${seniorPhosphorusMax}g (found ${totalPhosphorus}g)`,
    });
  }

  return results;
}

// ============================================================================
// QUALITY / PLAUSIBILITY RULES (Soft Gates ‚Üí Penalty)
// ============================================================================

export interface QualityRuleResult {
  passed: boolean;
  ruleId: string;
  message: string;
  penalty: number; // 0-100, applied to score
}

export function validateQualityAndPlausibility(
  ingredients: Ingredient[],
  estimatedCost: number
): QualityRuleResult[] {
  const results: QualityRuleResult[] = [];

  // Q1: "Two mains in disguise" (multiple high-protein ingredients)
  const highProteinCount = ingredients.filter(ing =>
    ing.composition.protein && ing.composition.protein > 20
  ).length;
  const twoMainsPenalty = highProteinCount > 1 ? 30 : 0;
  results.push({
    passed: highProteinCount <= 1,
    ruleId: 'Q1',
    message: `Multiple high-protein ingredients detected (${highProteinCount})`,
    penalty: twoMainsPenalty,
  });

  // Q2: Excessive powders / oils (low ingredient diversity)
  const powderOilCount = ingredients.filter(ing =>
    ing.name.toLowerCase().includes('oil') ||
    ing.name.toLowerCase().includes('powder') ||
    ing.name.toLowerCase().includes('premix')
  ).length;
  const excessivePowderPenalty = powderOilCount > 2 ? 25 : 0;
  results.push({
    passed: powderOilCount <= 2,
    ruleId: 'Q2',
    message: `Excessive powders/oils (${powderOilCount})`,
    penalty: excessivePowderPenalty,
  });

  // Q3: Human implausibility heuristic
  // Recipes that are technically complete but no one would actually make
  const implausiblePatterns = [
    ingredients.length === 2, // Too simple
    estimatedCost < 0.50, // Suspiciously cheap
    ingredients.every(ing => ing.category === 'supplement'), // All supplements
  ];
  const implausiblePenalty = implausiblePatterns.filter(p => p).length > 0 ? 20 : 0;
  results.push({
    passed: implausiblePenalty === 0,
    ruleId: 'Q3',
    message: `Recipe may be implausible (${implausiblePatterns.filter(p => p).length} flags)`,
    penalty: implausiblePenalty,
  });

  // Q4: Repetitive cheap filler pattern
  const cheapFillers = ingredients.filter(ing =>
    (ing.name.toLowerCase().includes('rice') ||
      ing.name.toLowerCase().includes('corn') ||
      ing.name.toLowerCase().includes('wheat')) &&
    (ing.pricePerLb || 1) < 0.50
  ).length;
  const fillerPenalty = cheapFillers >= 2 ? 15 : 0;
  results.push({
    passed: cheapFillers < 2,
    ruleId: 'Q4',
    message: `Repetitive cheap filler pattern (${cheapFillers})`,
    penalty: fillerPenalty,
  });

  // Q5: Organ meat weight cap (soft gate - penalize if >10%)
  const organMeatNames = ['liver', 'kidney', 'heart'];
  const organMeats = ingredients.filter(ing => {
    const name = ing.name.toLowerCase();
    return ing.feedingRole === 'supplement' && organMeatNames.some(organ => name.includes(organ));
  });
  
  const totalWeight = ingredients.reduce((sum, ing) => sum + (ing.composition.protein || 1), 0);
  const organMeatWeight = organMeats.reduce((sum, ing) => sum + (ing.composition.protein || 1), 0);
  const organMeatPercent = totalWeight > 0 ? (organMeatWeight / totalWeight) * 100 : 0;
  
  let organMeatPenalty = 0;
  if (organMeatPercent > 15) organMeatPenalty = 30; // Way over
  else if (organMeatPercent > 10) organMeatPenalty = 15; // Slightly over
  
  results.push({
    passed: organMeatPercent <= 10,
    ruleId: 'Q5',
    message: `Organ meat weight: ${organMeatPercent.toFixed(1)}% (soft cap 10%)`,
    penalty: organMeatPenalty,
  });

  return results;
}

// ============================================================================
// MASTER VALIDATION FUNCTION
// ============================================================================

export interface RecipeValidationResult {
  isValid: boolean;
  hardGates: {
    structural: CompositionRuleResult[];
    safety: SafetyRuleResult[];
    lifeStage: LifeStageRuleResult[];
  };
  softGates: QualityRuleResult[];
  totalPenalty: number;
  failedRules: string[];
}

export function validateRecipeComprehensive(
  ingredients: Ingredient[],
  species: Species,
  lifeStage: 'puppy' | 'adult' | 'senior',
  estimatedCost: number,
  allergies?: string[]
): RecipeValidationResult {
  const structural = validateStructuralComposition(ingredients, species, lifeStage);
  const safety = validateSafetyAndToxicity(ingredients, species, allergies);
  const lifeStageRules = validateLifeStage(ingredients, species, lifeStage);
  const quality = validateQualityAndPlausibility(ingredients, estimatedCost);

  const hardGateFailed = [
    ...structural,
    ...safety,
    ...lifeStageRules,
  ].filter(r => !r.passed);

  const totalPenalty = quality.reduce((sum, q) => sum + q.penalty, 0);

  return {
    isValid: hardGateFailed.length === 0,
    hardGates: {
      structural,
      safety,
      lifeStage: lifeStageRules,
    },
    softGates: quality,
    totalPenalty,
    failedRules: hardGateFailed.map(r => r.ruleId),
  };
}
</file>

<file path="lib/generator/RecipePMIScoring.ts">
/**
 * PMI-BASED PAIRING INTELLIGENCE
 * Uses learned statistical priors from BOTH recipe scraping AND commercial products
 * NOT hardcoded rules - behavior changes when recipePriors.json changes
 */

import type { Ingredient } from '@/lib/data/ingredients';
import priors from '@/lib/data/recipePriors.json';

interface PairingScore {
  score: number;
  reason: string;
  pmiValue?: number;
  source?: 'recipe' | 'commercial' | 'both';
}

/**
 * Calculate PMI-based pairing score for an ingredient given already-selected ingredients
 * Combines recipe priors AND commercial priors for stronger signal
 * Returns both the score and an explanation
 */
export function calculatePairingScore(
  ingredient: Ingredient,
  selectedIngredients: Ingredient[],
  species: string
): PairingScore {
  if (selectedIngredients.length === 0) {
    return { score: 0, reason: 'No selected ingredients' };
  }

  const ingName = ingredient.name;
  let totalPMI = 0;
  let pairCount = 0;
  let negativePenalty = 0;
  const reasons: string[] = [];
  let hasRecipePriors = false;
  let hasCommercialPriors = false;

  // Check recipe priors (homemade recipes)
  const recipePriors = priors.coOccurrence?.[species];
  if (recipePriors) {
    for (const selected of selectedIngredients) {
      const selName = selected.name;
      const pair = [ingName, selName].sort().join('+');
      
      const pmi = recipePriors.pairPMI?.[pair];
      if (pmi !== undefined && pmi > 0) {
        totalPMI += pmi;
        pairCount++;
        hasRecipePriors = true;
        reasons.push(`+${pmi.toFixed(2)} recipe PMI with ${selName}`);
      }
      
      const negativePMI = recipePriors.negativePairs?.[pair];
      if (negativePMI !== undefined) {
        negativePenalty += Math.abs(negativePMI) * 10;
        hasRecipePriors = true;
        reasons.push(`-${Math.abs(negativePMI).toFixed(2)} NEGATIVE recipe pair with ${selName}`);
      }
    }
  }

  // Check commercial priors (pet food products)
  const commercialPriors = (priors as any).commercial?.[species];
  if (commercialPriors) {
    for (const selected of selectedIngredients) {
      const selName = selected.name;
      const pair = [ingName, selName].sort().join('|'); // Commercial uses | separator
      
      const pmi = commercialPriors.pairPMI?.[pair];
      if (pmi !== undefined && pmi > 0) {
        totalPMI += pmi * 1.2; // Boost commercial data slightly (more products = stronger signal)
        pairCount++;
        hasCommercialPriors = true;
        reasons.push(`+${pmi.toFixed(2)} commercial PMI with ${selName}`);
      }
      
      const rarePMI = commercialPriors.rarePairs?.[pair];
      if (rarePMI !== undefined) {
        negativePenalty += Math.abs(rarePMI) * 15; // Strong penalty for commercial rare pairs
        hasCommercialPriors = true;
        reasons.push(`-${Math.abs(rarePMI).toFixed(2)} RARE commercial pair with ${selName}`);
      }
    }
  }

  // Average PMI across all pairs
  const avgPMI = pairCount > 0 ? totalPMI / pairCount : 0;
  const finalScore = avgPMI - negativePenalty;

  const source = hasRecipePriors && hasCommercialPriors ? 'both' 
    : hasCommercialPriors ? 'commercial' 
    : hasRecipePriors ? 'recipe' 
    : undefined;

  const reason = reasons.length > 0 
    ? reasons.join(', ')
    : 'No learned pairings';

  return {
    score: finalScore,
    reason,
    pmiValue: avgPMI,
    source
  };
}

/**
 * Check if a fat is compatible with selected proteins based on PMI
 * Checks BOTH recipe and commercial priors for hard blocks
 * Returns true if fat should be ALLOWED
 */
export function isFatCompatibleWithProteins(
  fat: Ingredient,
  proteins: Ingredient[],
  species: string
): { compatible: boolean; reason: string; pmiScore?: number } {
  if (proteins.length === 0) {
    return { compatible: true, reason: 'No proteins selected yet' };
  }

  const fatName = fat.name;
  let totalPMI = 0;
  let pmiCount = 0;
  let hasNegativePair = false;
  let negativePairWith = '';
  let negativeSource = '';

  // Check recipe priors
  const recipePriors = priors.coOccurrence?.[species];
  if (recipePriors) {
    for (const protein of proteins) {
      const proteinName = protein.name;
      const pair = [fatName, proteinName].sort().join('+');
      
      const negativePMI = recipePriors.negativePairs?.[pair];
      if (negativePMI !== undefined && negativePMI < -1.0) {
        hasNegativePair = true;
        negativePairWith = proteinName;
        negativeSource = 'recipes';
        break;
      }
      
      const pmi = recipePriors.pairPMI?.[pair];
      if (pmi !== undefined) {
        totalPMI += pmi;
        pmiCount++;
      }
    }
  }

  // Check commercial priors (stronger signal)
  const commercialPriors = (priors as any).commercial?.[species];
  if (commercialPriors && !hasNegativePair) {
    for (const protein of proteins) {
      const proteinName = protein.name;
      const pair = [fatName, proteinName].sort().join('|');
      
      const rarePMI = commercialPriors.rarePairs?.[pair];
      if (rarePMI !== undefined && rarePMI < -1.5) {
        hasNegativePair = true;
        negativePairWith = proteinName;
        negativeSource = 'commercial products';
        break;
      }
      
      const pmi = commercialPriors.pairPMI?.[pair];
      if (pmi !== undefined) {
        totalPMI += pmi * 1.2; // Weight commercial data higher
        pmiCount++;
      }
    }
  }

  // Hard block if negative pairing detected
  if (hasNegativePair) {
    return {
      compatible: false,
      reason: `Negative pairing with ${negativePairWith} (learned from ${negativeSource})`,
      pmiScore: undefined
    };
  }

  // Allow if positive PMI or no learned relationship
  const avgPMI = pmiCount > 0 ? totalPMI / pmiCount : 0;
  
  if (avgPMI > 0.3) {
    return {
      compatible: true,
      reason: `Strong positive pairing (PMI: ${avgPMI.toFixed(2)})`,
      pmiScore: avgPMI
    };
  } else if (avgPMI > 0) {
    return {
      compatible: true,
      reason: `Weak positive pairing (PMI: ${avgPMI.toFixed(2)})`,
      pmiScore: avgPMI
    };
  } else {
    // No learned relationship - allow by default (species-appropriate fats)
    return {
      compatible: true,
      reason: 'No learned pairing (species-default allowed)',
      pmiScore: 0
    };
  }
}

/**
 * Get top-N fats that pair well with selected proteins
 * Uses PMI to rank fats, not hardcoded rules
 */
export function getTopPairedFats(
  availableFats: Ingredient[],
  proteins: Ingredient[],
  species: string,
  topN: number = 5
): Array<{ fat: Ingredient; pmiScore: number; reason: string }> {
  const scored = availableFats.map(fat => {
    const compat = isFatCompatibleWithProteins(fat, proteins, species);
    return {
      fat,
      pmiScore: compat.pmiScore || 0,
      reason: compat.reason,
      compatible: compat.compatible
    };
  });

  // Filter to compatible only, then sort by PMI
  return scored
    .filter(s => s.compatible)
    .sort((a, b) => b.pmiScore - a.pmiScore)
    .slice(0, topN);
}

/**
 * Log pairing decision for debugging
 */
export function logPairingDecision(
  ingredient: Ingredient,
  selectedIngredients: Ingredient[],
  species: string,
  action: 'selected' | 'rejected'
): void {
  const pairingScore = calculatePairingScore(ingredient, selectedIngredients, species);
  const prefix = action === 'selected' ? '‚úì' : '‚úó';
  console.log(
    `[PMI ${prefix}] ${ingredient.name}: score=${pairingScore.score.toFixed(2)} | ${pairingScore.reason}`
  );
}
</file>

<file path="lib/generator/RecipePriorScoring.ts">
/**
 * RECIPE PRIOR SCORING
 * Soft scoring boosts based on learned patterns from scraped recipes
 * Integrates with RecipeBuilder to improve realism and variety
 */

import recipePriors from '../data/recipePriors.json';
import { Ingredient } from '../data/ingredients';

interface RecipePriors {
  coOccurrence: {
    [species: string]: {
      pairs: Record<string, number>;
      triples: Record<string, number>;
    };
  };
  categoryRatios: {
    [species: string]: {
      protein: { mean: number; stdDev: number };
      vegetable: { mean: number; stdDev: number };
      fat: { mean: number; stdDev: number };
      carbohydrate: { mean: number; stdDev: number };
    };
  };
  ingredientCounts: {
    [species: string]: {
      mean: number;
      median: number;
      min: number;
      max: number;
    };
  };
}

const priors = recipePriors as RecipePriors;

/**
 * Calculate co-occurrence boost for an ingredient based on already-selected ingredients
 * Returns a score boost (0-1) based on how often this ingredient appears with the selected ones
 */
export function calculateCoOccurrenceBoost(
  candidateIngredient: Ingredient,
  selectedIngredients: Ingredient[],
  species: string
): number {
  if (selectedIngredients.length === 0) return 0;
  
  const speciesPriors = priors.coOccurrence[species];
  if (!speciesPriors) return 0;

  let totalBoost = 0;
  let pairCount = 0;

  // Check pairs with each selected ingredient
  for (const selected of selectedIngredients) {
    const pair1 = `${candidateIngredient.name}+${selected.name}`;
    const pair2 = `${selected.name}+${candidateIngredient.name}`;
    
    const count = speciesPriors.pairs[pair1] || speciesPriors.pairs[pair2] || 0;
    if (count > 0) {
      totalBoost += Math.log(count + 1) / 10; // Logarithmic scaling
      pairCount++;
    }
  }

  // Check triples if we have 2+ selected ingredients
  if (selectedIngredients.length >= 2) {
    for (let i = 0; i < selectedIngredients.length - 1; i++) {
      for (let j = i + 1; j < selectedIngredients.length; j++) {
        const ingredients = [
          candidateIngredient.name,
          selectedIngredients[i].name,
          selectedIngredients[j].name,
        ].sort();
        
        const triple = ingredients.join('+');
        const count = speciesPriors.triples[triple] || 0;
        
        if (count > 0) {
          totalBoost += Math.log(count + 1) / 5; // Higher weight for triples
        }
      }
    }
  }

  // Normalize to 0-1 range
  return Math.min(totalBoost, 1.0);
}

/**
 * Calculate category ratio penalty based on deviation from learned distributions
 * Returns a penalty (0-1) where 0 = perfect match, 1 = very far from typical
 */
export function calculateCategoryRatioPenalty(
  categoryRatios: Record<string, number>,
  species: string
): number {
  const speciesPriors = priors.categoryRatios[species];
  if (!speciesPriors) return 0;

  let totalDeviation = 0;
  let categoryCount = 0;

  for (const [category, ratio] of Object.entries(categoryRatios)) {
    const prior = speciesPriors[category as keyof typeof speciesPriors];
    if (!prior) continue;

    // Calculate z-score (how many standard deviations away)
    const zScore = Math.abs(ratio - prior.mean) / prior.stdDev;
    
    // Convert to penalty (0-1)
    // z-score of 0 = 0 penalty, z-score of 3+ = 1 penalty
    const penalty = Math.min(zScore / 3, 1.0);
    
    totalDeviation += penalty;
    categoryCount++;
  }

  return categoryCount > 0 ? totalDeviation / categoryCount : 0;
}

/**
 * Calculate ingredient count penalty based on deviation from typical recipe sizes
 * Returns a penalty (0-1) where 0 = typical count, 1 = very unusual count
 */
export function calculateIngredientCountPenalty(
  ingredientCount: number,
  species: string
): number {
  const speciesPriors = priors.ingredientCounts[species];
  if (!speciesPriors) return 0;

  const { mean, min, max } = speciesPriors;

  // Within typical range = no penalty
  if (ingredientCount >= min && ingredientCount <= max) {
    // Small penalty for being far from mean
    const deviation = Math.abs(ingredientCount - mean);
    return Math.min(deviation / (max - min), 0.3);
  }

  // Outside typical range = higher penalty
  if (ingredientCount < min) {
    const deficit = min - ingredientCount;
    return Math.min(0.5 + (deficit / min) * 0.5, 1.0);
  }

  // Too many ingredients
  const excess = ingredientCount - max;
  return Math.min(0.5 + (excess / max) * 0.5, 1.0);
}

/**
 * Get typical ingredient count range for a species
 */
export function getTypicalIngredientCount(species: string): { min: number; max: number; median: number } {
  const speciesPriors = priors.ingredientCounts[species];
  if (!speciesPriors) {
    return { min: 3, max: 10, median: 6 };
  }
  return {
    min: speciesPriors.min,
    max: speciesPriors.max,
    median: speciesPriors.median,
  };
}

/**
 * Check if an ingredient is commonly paired with a protein for this species
 * Used to boost vegetables/fats that commonly appear with the selected protein
 */
export function isCommonProteinPairing(
  ingredient: Ingredient,
  protein: Ingredient,
  species: string,
  pairingType: 'fat' | 'vegetable'
): boolean {
  const speciesPriors = priors.categoryPairs?.[species];
  if (!speciesPriors) return false;

  const pairings = pairingType === 'fat' 
    ? speciesPriors.proteinWithFat 
    : speciesPriors.proteinWithVeg;

  const commonPairs = pairings?.[protein.name] || [];
  return commonPairs.includes(ingredient.name);
}

/**
 * Apply all prior-based scoring adjustments to a base score
 * This is the main integration point for RecipeBuilder
 */
export function applyPriorScoring(
  ingredient: Ingredient,
  baseScore: number,
  selectedIngredients: Ingredient[],
  species: string,
  options: {
    coOccurrenceWeight?: number;
    proteinPairingWeight?: number;
  } = {}
): number {
  const {
    coOccurrenceWeight = 0.15,
    proteinPairingWeight = 0.1,
  } = options;

  let adjustedScore = baseScore;

  // 1. Co-occurrence boost
  const coOccurrenceBoost = calculateCoOccurrenceBoost(
    ingredient,
    selectedIngredients,
    species
  );
  adjustedScore += coOccurrenceBoost * coOccurrenceWeight;

  // 2. Protein pairing boost
  const selectedProtein = selectedIngredients.find(i => i.category === 'protein');
  if (selectedProtein) {
    if (ingredient.category === 'fat') {
      const isCommon = isCommonProteinPairing(ingredient, selectedProtein, species, 'fat');
      if (isCommon) {
        adjustedScore += proteinPairingWeight;
      }
    } else if (ingredient.category === 'vegetable') {
      const isCommon = isCommonProteinPairing(ingredient, selectedProtein, species, 'vegetable');
      if (isCommon) {
        adjustedScore += proteinPairingWeight;
      }
    }
  }

  return adjustedScore;
}
</file>

<file path="lib/generator/VerifyAmazonLinks.ts">
// Verify Amazon Links - Check if links are live and accessible
// Note: This checks HTTP status, but can't verify product details without scraping

import { VETTED_PRODUCTS } from '../data/vetted-products';

interface VerificationResult {
  ingredient: string;
  productName: string;
  asinLink: string;
  asin: string;
  status: 'checking' | 'live' | 'dead' | 'redirect' | 'error';
  httpStatus?: number;
  error?: string;
}

const results: VerificationResult[] = [];

console.log('='.repeat(80));
console.log('AMAZON LINK VERIFICATION - HTTP Status Check');
console.log('='.repeat(80));
console.log();
console.log('‚ö†Ô∏è  Note: This checks if links are accessible, but cannot verify');
console.log('    if the product matches the ingredient without manual review.');
console.log();
console.log('Checking links...');
console.log();

// Sample a subset of links to check (checking all 292 would take too long)
const entries = Object.entries(VETTED_PRODUCTS);
const sampleSize = 50; // Check first 50 products
const sampled = entries.slice(0, sampleSize);

async function checkLink(url: string): Promise<{ status: number; ok: boolean }> {
  try {
    const response = await fetch(url, {
      method: 'HEAD', // Just check headers, don't download content
      redirect: 'follow',
    });
    return { status: response.status, ok: response.ok };
  } catch (error: any) {
    throw new Error(error.message);
  }
}

async function verifyLinks() {
  let checked = 0;
  let live = 0;
  let dead = 0;
  let errors = 0;

  for (const [ingredientName, product] of sampled) {
    const asinLink = product.asinLink;
    const asinMatch = asinLink.match(/\/dp\/([A-Z0-9]{10})/i);
    const asin = asinMatch ? asinMatch[1] : 'unknown';

    const result: VerificationResult = {
      ingredient: ingredientName,
      productName: product.productName,
      asinLink,
      asin,
      status: 'checking',
    };

    try {
      const { status, ok } = await checkLink(asinLink);
      result.httpStatus = status;
      
      if (ok && status === 200) {
        result.status = 'live';
        live++;
      } else if (status >= 300 && status < 400) {
        result.status = 'redirect';
        live++; // Redirects are usually fine
      } else {
        result.status = 'dead';
        dead++;
      }
    } catch (error: any) {
      result.status = 'error';
      result.error = error.message;
      errors++;
    }

    results.push(result);
    checked++;

    // Progress indicator
    if (checked % 10 === 0) {
      console.log(`Checked ${checked}/${sampleSize}...`);
    }
  }

  console.log();
  console.log('='.repeat(80));
  console.log('VERIFICATION RESULTS');
  console.log('='.repeat(80));
  console.log();
  console.log(`Sample size: ${sampleSize} products (out of ${entries.length} total)`);
  console.log(`Live links: ${live} (${((live / checked) * 100).toFixed(1)}%)`);
  console.log(`Dead links: ${dead} (${((dead / checked) * 100).toFixed(1)}%)`);
  console.log(`Errors: ${errors} (${((errors / checked) * 100).toFixed(1)}%)`);
  console.log();

  // Show dead links
  const deadLinks = results.filter(r => r.status === 'dead');
  if (deadLinks.length > 0) {
    console.log('DEAD LINKS FOUND:');
    console.log('-'.repeat(80));
    deadLinks.forEach(r => {
      console.log(`‚ùå ${r.ingredient}`);
      console.log(`   Product: ${r.productName}`);
      console.log(`   ASIN: ${r.asin}`);
      console.log(`   Status: ${r.httpStatus}`);
      console.log(`   Link: ${r.asinLink}`);
      console.log();
    });
  }

  // Show errors
  const errorLinks = results.filter(r => r.status === 'error');
  if (errorLinks.length > 0) {
    console.log('ERRORS ENCOUNTERED:');
    console.log('-'.repeat(80));
    errorLinks.forEach(r => {
      console.log(`‚ö†Ô∏è  ${r.ingredient}`);
      console.log(`   Product: ${r.productName}`);
      console.log(`   Error: ${r.error}`);
      console.log(`   Link: ${r.asinLink}`);
      console.log();
    });
  }

  console.log('='.repeat(80));
  console.log('IMPORTANT NOTES');
  console.log('='.repeat(80));
  console.log();
  console.log('1. This script only checks if links are accessible (HTTP 200)');
  console.log('2. It CANNOT verify if the product actually matches the ingredient');
  console.log('3. Manual review is needed to confirm product accuracy');
  console.log();
  console.log('RECOMMENDED MANUAL CHECKS:');
  console.log('- Verify "venison" ASIN actually links to venison (not beef)');
  console.log('- Verify "rabbit meat" ASIN actually links to rabbit (not lamb)');
  console.log('- Verify "turkey giblets" ASIN actually links to turkey (not chicken)');
  console.log('- Verify seed products link to correct seed types');
  console.log();
  console.log('To manually verify, visit the links and check product titles/descriptions.');
  console.log('='.repeat(80));
}

// Run verification
verifyLinks().catch(console.error);
</file>

</files>
