This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: app/profile/pet/**, app/api/recipes/**, lib/generator/**, lib/utils/**, components/MealBuilderWizard.tsx
- Files matching these patterns are excluded: **/*.xml, **/*.json, **/*.md, **/*.txt, **/lib/data/**, **/data/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
app/api/recipes/generate/route.ts
app/profile/pet/[id]/custom-meals/[mealId]/page.tsx
app/profile/pet/[id]/custom-meals/page.tsx
app/profile/pet/[id]/meal-plan/page.tsx
app/profile/pet/[id]/page.tsx
app/profile/pet/[id]/recipe-builder/page.tsx
app/profile/pet/[id]/saved-recipes/page.tsx
components/MealBuilderWizard.tsx
lib/generator/AmazonLinkAudit.ts
lib/generator/AutoClassifyLinks.ts
lib/generator/BirdDebug.ts
lib/generator/BirdDetailedDebug.ts
lib/generator/BirdTest.ts
lib/generator/CheckBirdIngredients.ts
lib/generator/CombinatoricsPruning.ts
lib/generator/CommercialPriorEnforcement.test.ts
lib/generator/CommercialPriorEnforcement.ts
lib/generator/ComprehensiveAudit.ts
lib/generator/DebugProteinRole.ts
lib/generator/GenerateVerificationList.ts
lib/generator/Phase1_5_AutoClassify.ts
lib/generator/QuickTest.ts
lib/generator/RecipeBuilder.integration.test.ts
lib/generator/RecipeBuilder.smoke.test.ts
lib/generator/RecipeBuilder.test.ts
lib/generator/RecipeBuilder.ts
lib/generator/RecipeCompositionValidator.ts
lib/generator/RecipeConstraintRules.ts
lib/generator/RecipePMIScoring.ts
lib/generator/RecipePriorScoring.ts
lib/generator/VerifyAmazonLinks.ts
lib/utils/__tests__/affiliateLinks.test.ts
lib/utils/__tests__/getAmazonBuyLink.test.ts
lib/utils/abTesting.ts
lib/utils/affiliateLinks.ts
lib/utils/allIngredients.ts
lib/utils/auth.ts
lib/utils/badgeChecker.ts
lib/utils/badgeStorage.ts
lib/utils/beep.ts
lib/utils/buyLinkValidation.ts
lib/utils/convertCustomMealToRecipe.ts
lib/utils/customMealStorage.ts
lib/utils/customMealStorageFirebase.ts
lib/utils/diversityTracker.ts
lib/utils/emojiMapping.ts
lib/utils/enhancedCompatibilityScoring.ts
lib/utils/errorHandler.ts
lib/utils/firebaseConfig.ts
lib/utils/getAmazonBuyLink.ts
lib/utils/healthConcernMatching.ts
lib/utils/imageMapping.ts
lib/utils/improvedCompatibilityScoring.ts
lib/utils/ingredientCompatibility.ts
lib/utils/ingredientNameNormalizer.ts
lib/utils/ingredientRegistry.ts
lib/utils/ingredientSuggestions.ts
lib/utils/ingredientWhitelists.ts
lib/utils/localStorageSafe.ts
lib/utils/logger.ts
lib/utils/mascotImageMapping.ts
lib/utils/mealCalculator.ts
lib/utils/mealCountCalculator.ts
lib/utils/mealEstimation.ts
lib/utils/mealImageAssignment.ts
lib/utils/mealNameGenerator.ts
lib/utils/nutritionalRecommendations.ts
lib/utils/nutritionFallbacks.ts
lib/utils/organicCount.ts
lib/utils/petPurchaseTracking.ts
lib/utils/petRatingSystem.ts
lib/utils/petStorage.ts
lib/utils/petUtils.ts
lib/utils/priceValidation.ts
lib/utils/purchaseLinks.ts
lib/utils/purchaseTracking.ts
lib/utils/ratings.ts
lib/utils/recipeIngredients.ts
lib/utils/recipeRecommendations.ts
lib/utils/recipeScoring.ts
lib/utils/scoringDiagnostics.ts
lib/utils/scoringTransparency.ts
lib/utils/telemetry.ts
lib/utils/validation.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/api/recipes/generate/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { generateRecipesForPet } from '@/lib/recipe-generator-v3';
import type { Pet } from '@/lib/types';

export const runtime = 'nodejs';

interface RecipeRequest {
  species?: string;
  count?: number;
  petProfile?: {
    name?: string;
    weight?: string;
    weightKg?: number;
    age?: string;
    allergies?: string[];
    healthConcerns?: string[];
  };
}

/**
 * Generate recipes dynamically based on pet species
 * POST /api/recipes/generate
 * Body: { species: 'dogs' | 'cats' | 'birds' | 'reptiles' | 'pocket-pets', count?: number, petProfile?: {...} }
 */
export async function POST(request: NextRequest) {
  try {
    const body: RecipeRequest = await request.json();
    const { species = 'dogs', count = 50, petProfile } = body;

    // Create a mock pet for recipe generation
    const mockPet: any = {
      id: `mock-${species}-${Date.now()}`,
      name: petProfile?.name || 'Your Pet',
      type: species,
      breed: 'Mixed',
      age: petProfile?.age || 'adult',
      weight: petProfile?.weight || '10',
      weightKg: petProfile?.weightKg || 10,
      allergies: petProfile?.allergies || [],
      healthConcerns: petProfile?.healthConcerns || [],
    };

    // Generate recipes using pragmatic system
    console.log('[API] Generating recipes for pet:', {
      name: mockPet.name,
      type: mockPet.type,
      healthConcerns: mockPet.healthConcerns,
      allergies: mockPet.allergies,
    });
    
    const recipes = generateRecipesForPet(
      {
        pet: mockPet as Pet,
      },
      count
    );

    console.log('[API] Generated recipes count:', recipes?.length || 0);

    const generatedRecipes = recipes.map((recipe: any, index: number) => ({
      ...recipe,
      id: recipe.id || `generated-${species}-${index}-${Date.now()}`,
      generatedAt: new Date().toISOString(),
    }));

    if (generatedRecipes.length === 0) {
      console.error('[API] No recipes generated - returning 500');
      return NextResponse.json(
        { error: 'Failed to generate any recipes', species, attemptedCount: count, petProfile: mockPet },
        { status: 500 }
      );
    }

    // Sort by overall score (best first)
    generatedRecipes.sort((a: any, b: any) => (b.scores?.overall || 0) - (a.scores?.overall || 0));

    return NextResponse.json({
      success: true,
      recipes: generatedRecipes,
      stats: {
        total: generatedRecipes.length,
        avgScore: (generatedRecipes.reduce((sum: number, r: any) => sum + (r.scores?.overall || 0), 0) / generatedRecipes.length).toFixed(1),
      },
    });
  } catch (error) {
    console.error('Recipe generation error:', error);
    return NextResponse.json(
      { error: 'Failed to generate recipes', details: String(error) },
      { status: 500 }
    );
  }
}
</file>

<file path="app/profile/pet/[id]/custom-meals/[mealId]/page.tsx">
'use client';

import { useEffect } from 'react';
import { useParams, useRouter } from 'next/navigation';

export default function CustomMealDetailPage() {
  const params = useParams();
  const router = useRouter();
  const petId = params.id as string;
  const mealId = params.mealId as string;

  useEffect(() => {
    // Redirect to recipe detail page with petId query parameter
    if (mealId && petId) {
      router.replace(`/recipe/${mealId}?petId=${petId}`);
    }
  }, [mealId, petId, router]);

  return (
    <div className="min-h-screen bg-background flex items-center justify-center">
      <p className="text-gray-400">Redirecting...</p>
    </div>
  );
}
</file>

<file path="app/profile/pet/[id]/custom-meals/page.tsx">
'use client';

import { useState, useEffect } from 'react';
import { useParams, useRouter } from 'next/navigation';
import Link from 'next/link';
import { ArrowLeft, Trash2, Edit, Calendar, ChefHat } from 'lucide-react';
import { getCustomMeals, deleteCustomMeal } from '@/lib/utils/customMealStorage';
import { getPets } from '@/lib/utils/petStorage'; // Import async storage
import type { CustomMeal, Pet } from '@/lib/types';

const getCurrentUserId = () => {
  if (typeof window === 'undefined') return 'clerk_simulated_user_id_123';
  return localStorage.getItem('last_user_id') || 'clerk_simulated_user_id_123';
};

const getPetsFromLocalStorage = (userId: string): Pet[] => {
  if (typeof window === 'undefined') return [];
  const stored = localStorage.getItem(`pets_${userId}`);
  if (!stored) return [];
  try {
    return JSON.parse(stored);
  } catch {
    return [];
  }
};

export default function CustomMealsHistoryPage() {
  const params = useParams();
  const router = useRouter();
  const petId = params.id as string;
  
  const [pet, setPet] = useState<Pet | null>(null);
  const [customMeals, setCustomMeals] = useState<CustomMeal[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const loadData = async () => {
      const userId = getCurrentUserId();
      try {
        const pets = await getPets(userId);
        const foundPet = pets.find(p => p.id === petId) || null;
        setPet(foundPet);
        
        if (foundPet) {
          const meals = await getCustomMeals(userId, petId);
          // Sort by most recent first
          meals.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
          setCustomMeals(meals);
        }
      } catch (error) {
        console.error('Error loading custom meals:', error);
      }
      setLoading(false);
    };
    loadData();
  }, [petId]);

  const handleDelete = async (mealId: string) => {
    if (!confirm('Are you sure you want to delete this custom meal?')) return;
    
    const userId = getCurrentUserId();
    await deleteCustomMeal(userId, petId, mealId);
    
    // Refresh the list
    const meals = await getCustomMeals(userId, petId);
    meals.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
    setCustomMeals(meals);
  };

  const formatDate = (dateString: string) => {
    const date = new Date(dateString);
    return date.toLocaleDateString('en-US', { 
      year: 'numeric', 
      month: 'short', 
      day: 'numeric' 
    });
  };

  const getScoreColor = (score: number) => {
    if (score >= 80) return 'text-green-600 bg-green-50 border-green-200';
    if (score >= 60) return 'text-yellow-600 bg-yellow-50 border-yellow-200';
    return 'text-red-600 bg-red-50 border-red-200';
  };

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <p className="text-gray-600">Loading custom meals...</p>
      </div>
    );
  }

  if (!pet) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <div className="bg-white p-8 rounded-xl shadow text-center space-y-4">
          <p className="text-xl font-semibold text-gray-800">Pet not found.</p>
          <Link href="/profile" className="text-green-800 font-semibold">
            Back to Profiles
          </Link>
        </div>
      </div>
    );
  }

  // Get random name from pet's names array
  const petNames = Array.isArray(pet.names) ? pet.names.filter(n => n && n.trim() !== '') : [];
  const petDisplayName = petNames.length > 0 
    ? petNames[Math.floor(Math.random() * petNames.length)]
    : 'Pet';

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Header */}
      <div className="bg-white border-b border-gray-200 sticky top-0 z-10">
        <div className="max-w-7xl mx-auto px-4 py-2">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-3">
              <Link
                href={`/profile/pet/${petId}`}
                className="p-1.5 hover:bg-gray-100 rounded-md transition-colors"
              >
                <ArrowLeft size={18} className="text-gray-600" />
              </Link>
              <div>
                <h1 className="text-lg font-bold text-gray-900">
                  Custom Meals for {petDisplayName}
                </h1>
                <p className="text-xs text-gray-600 mt-0.5">
                  {pet.breed} ‚Ä¢ {pet.age} ‚Ä¢ {pet.weight}
                </p>
              </div>
            </div>
            <Link
              href={`/profile/pet/${petId}/recipe-builder`}
              className="flex items-center gap-2 px-4 py-2 text-sm font-medium text-white bg-green-800 rounded-md hover:bg-green-900 transition-colors"
            >
              <ChefHat size={16} />
              Create New Meal
            </Link>
          </div>
        </div>
      </div>

      <div className="max-w-7xl mx-auto px-4 py-3">
        {customMeals.length === 0 ? (
          <div className="bg-white rounded-lg border border-gray-200 p-12 text-center">
            <ChefHat size={48} className="mx-auto text-gray-400 mb-4" />
            <h2 className="text-xl font-semibold text-gray-900 mb-2">No custom meals yet</h2>
            <p className="text-gray-600 mb-6">
              Create your first custom meal to get started!
            </p>
            <Link
              href={`/profile/pet/${petId}/recipe-builder`}
              className="inline-flex items-center gap-2 px-4 py-2 text-sm font-medium text-white bg-primary-600 rounded-md hover:bg-primary-700 transition-colors"
            >
              <ChefHat size={16} />
              Create Your First Meal
            </Link>
          </div>
        ) : (
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            {customMeals.map((meal) => (
              <div
                key={meal.id}
                className="bg-white rounded-lg border border-gray-200 p-6 hover:shadow-lg transition-shadow"
              >
                {/* Meal Header */}
                <div className="flex items-start justify-between mb-4">
                  <div className="flex-1">
                    <h3 className="text-lg font-semibold text-gray-900 mb-1">
                      {meal.name}
                    </h3>
                    <div className="flex items-center gap-2 text-sm text-gray-500">
                      <Calendar size={14} />
                      {formatDate(meal.createdAt)}
                    </div>
                  </div>
                  <button
                    onClick={() => handleDelete(meal.id)}
                    className="p-2 text-red-600 hover:bg-red-50 rounded-md transition-colors"
                    title="Delete meal"
                  >
                    <Trash2 size={16} />
                  </button>
                </div>

                {/* Compatibility Score */}
                <div className={`mb-4 p-3 rounded-lg border ${getScoreColor(meal.analysis.score)}`}>
                  <div className="flex items-center justify-between">
                    <span className="text-sm font-medium">Compatibility Score</span>
                    <span className="text-2xl font-bold">{meal.analysis.score}</span>
                  </div>
                  <div className="w-full bg-white/50 rounded-full h-2 mt-2">
                    <div
                      className={`h-2 rounded-full ${
                        meal.analysis.score >= 80 ? 'bg-green-600' :
                        meal.analysis.score >= 60 ? 'bg-yellow-600' :
                        'bg-red-600'
                      }`}
                      style={{ width: `${meal.analysis.score}%` }}
                    />
                  </div>
                </div>

                {/* Ingredients Summary */}
                <div className="mb-4">
                  <h4 className="text-sm font-medium text-gray-700 mb-2">Ingredients</h4>
                  <div className="space-y-1">
                    {meal.ingredients.slice(0, 3).map((ing, idx) => (
                      <div key={idx} className="text-sm text-gray-600">
                        ‚Ä¢ {ing.key.replace(/_/g, ' ')} ({ing.grams}g)
                      </div>
                    ))}
                    {meal.ingredients.length > 3 && (
                      <div className="text-sm text-gray-500">
                        + {meal.ingredients.length - 3} more
                      </div>
                    )}
                  </div>
                </div>

                {/* Nutritional Summary */}
                <div className="mb-4 text-sm">
                  <div className="flex justify-between mb-1">
                    <span className="text-gray-600">Total Weight:</span>
                    <span className="font-medium">{meal.analysis.totalRecipeGrams}g</span>
                  </div>
                  <div className="flex justify-between mb-1">
                    <span className="text-gray-600">Recommended Serving:</span>
                    <span className="font-medium text-green-800">
                      {meal.analysis.recommendedServingGrams}g
                    </span>
                  </div>
                </div>

                {/* Warnings Summary */}
                {meal.analysis.toxicityWarnings.length > 0 && (
                  <div className="mb-4 p-2 bg-red-50 border border-red-200 rounded text-xs text-red-800">
                    ‚ö†Ô∏è {meal.analysis.toxicityWarnings.length} safety warning(s)
                  </div>
                )}

                {/* Actions */}
                <div className="flex gap-2 pt-4 border-t border-gray-200">
                  <button
                    onClick={() => {
                      // TODO: Implement edit functionality (load meal into builder)
                      router.push(`/profile/pet/${petId}/recipe-builder?mealId=${meal.id}`);
                    }}
                    className="flex-1 flex items-center justify-center gap-2 px-3 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50 transition-colors"
                  >
                    <Edit size={14} />
                    Edit
                  </button>
                  <button
                    onClick={() => {
                      router.push(`/recipe/${meal.id}?petId=${petId}`);
                    }}
                    className="flex-1 px-3 py-2 text-sm font-medium text-green-800 bg-green-900/10 border border-green-800/30 rounded-md hover:bg-green-900/20 transition-colors"
                  >
                    View Details
                  </button>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="app/profile/pet/[id]/meal-plan/page.tsx">
'use client';

import { useEffect, useMemo, useState } from 'react';
import { useParams, useRouter } from 'next/navigation';
import Link from 'next/link';
import { ArrowLeft, ShoppingCart } from 'lucide-react';
import type { Recipe, CustomMeal } from '@/lib/types';
import { getProductPrice } from '@/lib/data/product-prices';
import { VETTED_PRODUCTS, getVettedProduct, getVettedProductByAnyIdentifier } from '@/lib/data/vetted-products';
import { getCustomMeals } from '@/lib/utils/customMealStorage';
import { getPets } from '@/lib/utils/petStorage'; // Import async storage
import { ensureCartUrlSellerId } from '@/lib/utils/affiliateLinks';

// Format price for display
const formatPrice = (price: number) => {
  return `$${price.toFixed(2)}`;
};

const DAYS = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
const SIMULATED_USER_ID = 'clerk_simulated_user_id_123';

interface PetProfile {
  id: string;
  name: string;
  savedRecipes: string[];
}

const getCurrentUserId = () => {
  if (typeof window === 'undefined') return SIMULATED_USER_ID;
  return localStorage.getItem('last_user_id') || SIMULATED_USER_ID;
};

const getPetsFromLocalStorage = (userId: string): PetProfile[] => {
  if (typeof window === 'undefined') return [];
  const stored = localStorage.getItem(`pets_${userId}`);
  if (!stored) return [];
  try {
    const parsed = JSON.parse(stored);
    return Array.isArray(parsed)
      ? parsed.map((pet: any) => ({
          id: pet.id,
          name: pet.name,
          savedRecipes: pet.savedRecipes || [],
        }))
      : [];
  } catch {
    return [];
  }
};

const buildEvenPlan = (meals: Recipe[]) => {
  const totalSlots = DAYS.length * 2;
  const rotation: Recipe[] = [];
  while (rotation.length < totalSlots) {
    rotation.push(...meals);
  }
  return rotation.slice(0, totalSlots);
};

const shuffleMealsNoRepeats = (meals: Recipe[], totalSlots: number) => {
  if (meals.length === 0) return [];
  const poolBase = [...meals];
  const rotation: Recipe[] = [];

  const shuffle = (arr: Recipe[]) => {
    for (let i = arr.length - 1; i > 0; i -= 1) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  };

  let pool = shuffle([...poolBase]);

  while (rotation.length < totalSlots) {
    if (pool.length === 0) {
      pool = shuffle([...poolBase]);
    }
    const next = pool.pop() as Recipe;
    // Avoid duplicate within the same day (pair of two)
    if (rotation.length % 2 === 1 && rotation[rotation.length - 1].id === next.id) {
      // Put it back to the front and try another
      pool.unshift(next);
      continue;
    }
    rotation.push(next);
  }

  return rotation;
};

export default function MealPlanPage() {
  const params = useParams();
  const router = useRouter();
  const petId = params.id as string;

  const [pet, setPet] = useState<PetProfile | null>(null);
  const [savedMeals, setSavedMeals] = useState<Recipe[]>([]);
  const [customMeals, setCustomMeals] = useState<CustomMeal[]>([]);
  const [weeklyPlan, setWeeklyPlan] = useState<{ day: string; meals: Recipe[] }[]>([]);
  const [loading, setLoading] = useState(true);
  const [swapTarget, setSwapTarget] = useState<{ dayIdx: number; mealIdx: number } | null>(null);

  // Convert custom meal to Recipe format for meal plan
  const convertCustomMealToRecipe = (customMeal: CustomMeal): Recipe => {
    return {
      id: customMeal.id,
      name: customMeal.name,
      category: 'custom', // Mark as custom meal
      ageGroup: ['adult'], // Default, could be enhanced
      healthConcerns: [],
      description: `Custom meal created on ${new Date(customMeal.createdAt).toLocaleDateString()}`,
      ingredients: customMeal.ingredients.map((ing, idx) => ({
        id: `${idx + 1}`,
        name: ing.key.replace(/_/g, ' '),
        amount: `${ing.grams}g`,
      })),
      instructions: [
        'Mix all ingredients according to saved recipe',
        'Serve at recommended portion size',
        `Recommended serving: ${customMeal.analysis.recommendedServingGrams}g`,
      ],
      nutritionalInfo: {
        protein: {
          min: (customMeal.analysis.nutrients.protein_g || 0) / (customMeal.analysis.totalRecipeGrams / 100),
          max: (customMeal.analysis.nutrients.protein_g || 0) / (customMeal.analysis.totalRecipeGrams / 100),
          unit: '%',
        },
        fat: {
          min: (customMeal.analysis.nutrients.fat_g || 0) / (customMeal.analysis.totalRecipeGrams / 100),
          max: (customMeal.analysis.nutrients.fat_g || 0) / (customMeal.analysis.totalRecipeGrams / 100),
          unit: '%',
        },
        calories: {
          min: customMeal.analysis.nutrients.kcal || customMeal.analysis.nutrients.calories_kcal || 0,
          max: customMeal.analysis.nutrients.kcal || customMeal.analysis.nutrients.calories_kcal || 0,
          unit: 'kcal',
        },
      },
      rating: 0,
      reviews: 0,
      tags: ['custom', 'user-created'],
    };
  };

  useEffect(() => {
    const loadData = async () => {
      const userId = getCurrentUserId();
      try {
        const pets = await getPets(userId);
        const foundPet = pets.find((p: any) => p.id === petId) || null;
        
        if (foundPet) {
          // Normalize pet profile
          setPet({
            id: foundPet.id,
            name: foundPet.name || foundPet.names?.[0] || 'Pet',
            savedRecipes: foundPet.savedRecipes || [],
          });

          // Saved recipes are no longer stored statically
          setSavedMeals([]);
          
          // Load custom meals
          const customMealsList = await getCustomMeals(userId, petId);
          setCustomMeals(customMealsList);
        } else {
          setPet(null);
        }
      } catch (error) {
        console.error('Error loading meal plan data:', error);
      }
      setLoading(false);
    };
    loadData();
  }, [petId]);

  const generatePlan = (meals: Recipe[]) => {
    const rotation = buildEvenPlan(meals);
    const plan: { day: string; meals: Recipe[] }[] = [];
    for (let i = 0; i < DAYS.length; i += 1) {
      const breakfastIndex = i * 2;
      const dinnerIndex = breakfastIndex + 1;
      const breakfast = rotation[breakfastIndex];
      let dinner = rotation[dinnerIndex];
      if (dinner.id === breakfast.id) {
        const swapIndex = rotation.findIndex(
          (entry, idx) => idx > dinnerIndex && entry.id !== breakfast.id
        );
        if (swapIndex !== -1) {
          [rotation[dinnerIndex], rotation[swapIndex]] = [
            rotation[swapIndex],
            rotation[dinnerIndex],
          ];
          dinner = rotation[dinnerIndex];
        } else {
          dinner = meals.find((meal) => meal.id !== breakfast.id) || dinner;
        }
      }
      plan.push({ day: DAYS[i], meals: [breakfast, dinner] });
    }
    return plan;
  };

  const allMeals = useMemo<Recipe[]>(() => {
    return [
      ...savedMeals,
      ...customMeals.map(convertCustomMealToRecipe),
    ];
  }, [savedMeals, customMeals]);

  useEffect(() => {
    if (allMeals.length > 0) {
      setWeeklyPlan(generatePlan(allMeals));
    }
  }, [allMeals]);

  const handleRegenerate = () => {
    setWeeklyPlan(generatePlan(allMeals));
  };

  const handleRandomize = () => {
    const totalSlots = DAYS.length * 2;
    const rotation = shuffleMealsNoRepeats(allMeals, totalSlots);
    const plan: { day: string; meals: Recipe[] }[] = [];
    for (let i = 0; i < DAYS.length; i += 1) {
      const breakfastIndex = i * 2;
      const dinnerIndex = breakfastIndex + 1;
      const breakfast = rotation[breakfastIndex];
      const dinner = rotation[dinnerIndex];
      plan.push({ day: DAYS[i], meals: [breakfast, dinner] });
    }
    setWeeklyPlan(plan);
  };

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <p className="text-gray-600">Loading meal plan...</p>
      </div>
    );
  }

  if (!pet) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <div className="bg-white p-8 rounded-xl shadow text-center space-y-4">
          <p className="text-xl font-semibold text-gray-800">Pet not found.</p>
          <Link href="/profile" className="text-green-800 font-semibold">
            Back to Profiles
          </Link>
        </div>
      </div>
    );
  }

  const allMealsCount = savedMeals.length + customMeals.length;
  
  if (allMealsCount < 1) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center px-4">
        <div className="max-w-lg bg-white rounded-xl shadow p-8 text-center space-y-4">
          <div className="text-5xl">üçΩÔ∏è</div>
          <h1 className="text-2xl font-bold text-gray-900">Add more meals first</h1>
          <p className="text-gray-600">
            Save at least two meals (recipes or custom meals) for {pet.name} to build a balanced weekly rotation.
          </p>
          <div className="flex flex-col gap-2">
            <button
              onClick={() => router.push(`/recipes/recommended/${pet.id}`)}
              className="bg-green-800 text-white font-semibold px-6 py-3 rounded-lg hover:bg-green-900 transition-colors"
            >
              See Recommended Meals
            </button>
            <button
              onClick={() => router.push(`/profile/pet/${pet.id}/recipe-builder`)}
              className="bg-green-800 text-white font-semibold px-6 py-3 rounded-lg hover:bg-green-900 transition-colors"
            >
              Create Custom Meal
            </button>
            <button
              onClick={() => router.push(`/profile/pet/${pet.id}`)}
              className="text-green-800 font-semibold"
            >
              Find More Meals for {pet.name}
            </button>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50 py-10 px-4">
      <div className="max-w-6xl mx-auto space-y-8">
        <div className="bg-white rounded-xl shadow p-6 flex flex-col gap-4">
          <div className="flex items-center gap-3 text-green-800">
            <button
              onClick={() => router.push('/profile')}
              className="inline-flex items-center gap-2 font-semibold"
            >
              <ArrowLeft size={20} />
              Back to pets
            </button>
          </div>
            <div>
              <p className="text-sm uppercase tracking-wide text-gray-500 font-semibold">
                Weekly Meal Prep
              </p>
              <h1 className="text-3xl font-bold text-gray-900">
                7-Day Meal Plan for {pet.name}
              </h1>
              <p className="text-gray-600 mt-1">
                Two meals per day. No repeats on the same day. Each saved meal gets equal play.
              </p>
            </div>
          </div>
        

        <div className="grid grid-cols-7 gap-2">
          {weeklyPlan.map((dayPlan, index) => (
            <div key={dayPlan.day} className="bg-white rounded-lg shadow p-2">
              <div className="text-center mb-2">
                <p className="text-xs uppercase tracking-wide text-gray-500 font-semibold">
                  {dayPlan.day.slice(0, 3)}
                </p>
              </div>
              <div className="space-y-2">
                {dayPlan.meals.map((meal, mealIndex) => (
                  <div key={meal.id + mealIndex} className="text-center">
                    <Link
                      href={`/recipe/${meal.id}?petId=${petId}`}
                      className="block hover:text-primary-600 transition-colors mb-1"
                    >
                      <p className="font-medium text-gray-900 text-xs leading-tight">
                        {meal.name}
                        {meal.category === 'custom' && (
                          <span className="ml-1 text-xs text-green-800">(Custom)</span>
                        )}
                      </p>
                    </Link>
                    <div className="flex flex-col items-center gap-1">
                      <button
                        onClick={(e) => {
                          e.preventDefault();
                          const cartItems = meal.ingredients
                            .map((ing, index) => {
                              const genericName = ing.name.toLowerCase().trim();
                              const vettedProduct = VETTED_PRODUCTS[genericName];
                              const link = vettedProduct ? vettedProduct.purchaseLink : ing.asinLink;
                              if (link) {
                                // Extract ASIN from /dp/ASIN format
                                const asinMatch = link.match(/\/dp\/([A-Z0-9]{10})/);
                                if (asinMatch) {
                                  return `ASIN.${index + 1}=${asinMatch[1]}&Quantity.${index + 1}=1`;
                                }
                              }
                              return null;
                            })
                            .filter(Boolean);

                          if (cartItems.length > 0) {
                            const cartUrl = ensureCartUrlSellerId(`https://www.amazon.com/gp/aws/cart/add.html?${cartItems.join('&')}`);
                            window.open(cartUrl, '_blank');
                          } else {
                            alert('No ingredient links available for this recipe.');
                          }
                        }}
                        className="inline-flex items-center gap-1 text-xs bg-green-600 text-black px-1 py-0.5 rounded hover:bg-green-700 transition-colors"
                        title="Add all vetted ingredients to your Amazon cart"
                      >
                        <ShoppingCart size={8} />
                        Buy
                      </button>
                      {/* Price Display */}
                      {(() => {
                        const mealTotalPrice = meal.ingredients?.reduce((sum, ing) => {
                          const price = getProductPrice(ing.name);
                          if (typeof price === 'number') return sum + price;
                          return sum;
                        }, 0) || 0;
                        return mealTotalPrice > 0 ? (
                          <span className="text-[10px] text-green-700 font-semibold">
                            {formatPrice(mealTotalPrice)}
                          </span>
                        ) : null;
                      })()}
                    </div>
                    <button
                      onClick={(e) => {
                        e.preventDefault();
                        setSwapTarget({ dayIdx: index, mealIdx: mealIndex });
                      }}
                    className="mt-2 w-full inline-flex items-center justify-center gap-1 text-xs px-2 py-1 rounded border border-primary-500 text-primary-700 bg-white hover:bg-primary-50 transition-colors"
                      title="Edit this slot"
                    >
                    Edit
                    </button>
                  </div>
                ))}
              </div>
            </div>
          ))}
        </div>

        {swapTarget && (
          <div className="fixed inset-0 z-50 bg-black/60 flex items-center justify-center px-4">
            <div className="bg-white rounded-xl shadow-2xl max-w-lg w-full p-5 border border-gray-200">
              <div className="flex items-center justify-between mb-3">
                <h3 className="text-lg font-bold text-gray-900">Swap Meal</h3>
                <button
                  onClick={() => setSwapTarget(null)}
                  className="text-gray-500 hover:text-gray-700"
                  aria-label="Close swap dialog"
                >
                  ‚úï
                </button>
              </div>
              <p className="text-sm text-gray-600 mb-3">Choose a saved meal to place into this slot.</p>
              <div className="max-h-72 overflow-y-auto space-y-2">
                {allMeals.map((meal) => (
                  <button
                    key={meal.id}
                    onClick={() => {
                      if (!swapTarget) return;
                      const planCopy = weeklyPlan.map((d) => ({ ...d, meals: [...d.meals] }));
                      planCopy[swapTarget.dayIdx].meals[swapTarget.mealIdx] = meal;
                      setWeeklyPlan(planCopy);
                      setSwapTarget(null);
                    }}
                    className="w-full text-left p-3 rounded-lg border border-gray-200 hover:border-green-600 hover:bg-green-50 transition-colors"
                  >
                    <div className="flex justify-between items-center">
                      <span className="font-semibold text-gray-900">{meal.name}</span>
                      {meal.category === 'custom' && (
                        <span className="text-xs text-green-700 bg-green-100 px-2 py-0.5 rounded-full">Custom</span>
                      )}
                    </div>
                  </button>
                ))}
                {allMeals.length === 0 && (
                  <p className="text-sm text-gray-500">No saved meals available.</p>
                )}
              </div>
              <div className="mt-4 flex justify-end gap-2">
                <button
                  onClick={() => setSwapTarget(null)}
                  className="px-4 py-2 text-sm text-gray-700 border border-gray-300 rounded-lg hover:bg-gray-50"
                >
                  Cancel
                </button>
              </div>
            </div>
          </div>
        )}

        <div className="bg-white rounded-xl shadow p-6">
          <h3 className="text-lg font-bold text-gray-900 mb-2">How rotation works</h3>
          <p className="text-gray-600 text-sm mb-2">
            We loop through every saved meal (recipes and custom meals) equally, then shuffle lightly to keep variety.
            Each day uses two different meals so {pet.name} never sees a repeat on the same day.
          </p>
          <div className="mt-3 pt-3 border-t border-gray-200">
            <p className="text-xs text-gray-500">
              <strong>Meals included:</strong> {savedMeals.length} saved recipe{savedMeals.length !== 1 ? 's' : ''} 
              {customMeals.length > 0 && ` + ${customMeals.length} custom meal${customMeals.length !== 1 ? 's' : ''}`}
            </p>
          </div>
        </div>

        <div className="flex flex-wrap gap-2 mt-4">
          <button
            onClick={handleRandomize}
            className="btn btn-success btn-sm"
          >
            Randomize Week
          </button>
          <Link
            href={`/pets/${petId}/nutrition`}
            className="btn btn-success btn-sm"
          >
            View Nutrition Dashboard
          </Link>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/profile/pet/[id]/page.tsx">
'use client';

import { useState, useEffect, useMemo, useRef } from 'react';
import { useParams } from 'next/navigation';
import Link from 'next/link';
import Image from 'next/image';
import { ArrowLeft, Plus } from 'lucide-react';
import type { ModifiedRecipeResult, Recipe } from '@/lib/types';
import { calculateEnhancedCompatibility, type Pet as EnhancedPet, getGrade } from '@/lib/utils/enhancedCompatibilityScoring';
import { CompatibilityBadge } from '@/components/CompatibilityBadge';
import { getRandomName } from '@/lib/utils/petUtils';
import EmojiIcon from '@/components/EmojiIcon';
import { getPets, savePet } from '@/lib/utils/petStorage'; // Import from storage util
import { useChunkedRecipeScoring } from '@/lib/hooks/useChunkedRecipeScoring';
import ScoringProgress from '@/components/ScoringProgress';
import { calculateMealCountVariation } from '@/lib/utils/mealCountCalculator';
import { makeCountOrganic, getCountMessage, getSubtext } from '@/lib/utils/organicCount';
import { useProgressiveMealCount } from '@/hooks/useProgressiveMealCount';


type PetCategory = 'dogs' | 'cats' | 'birds' | 'reptiles' | 'pocket-pets';
type AgeGroup = 'baby' | 'young' | 'adult' | 'senior';

interface Pet {
  id: string;
  name?: string; // Legacy field, prefer names array
  names?: string[]; // Array of names
  type: PetCategory;
  breed: string;
  age: AgeGroup;
  healthConcerns?: string[];
  dietaryRestrictions?: string[];
  savedRecipes?: string[];
  allergies?: string[];
  weightKg?: number;
  weight?: string;
  dislikes?: string[];
}

// Same simulated user ID setup as profile and saved-recipes pages
const SIMULATED_USER_ID = 'clerk_simulated_user_id_123';

const getCurrentUserId = () => {
  if (typeof window === 'undefined') return SIMULATED_USER_ID;
  return localStorage.getItem('last_user_id') || SIMULATED_USER_ID;
};

// Get custom recipes from localStorage
const getCombinedRecipes = (): Recipe[] => {
  if (typeof window !== 'undefined') {
    try {
      const customRecipes = JSON.parse(localStorage.getItem('custom_recipes') || '[]');
      return customRecipes;
    } catch (error) {
      console.error('Error loading custom recipes:', error);
    }
  }

  return [];
};

export default function RecommendedRecipesPage() {
  const params = useParams();
  const [pet, setPet] = useState<Pet | null>(null);
  const [hoveredRecipe, setHoveredRecipe] = useState<string | null>(null);
  const [engineMeals, setEngineMeals] = useState<ModifiedRecipeResult[] | null>(null);
  const [engineError, setEngineError] = useState<string | null>(null);
  const [loadingMeals, setLoadingMeals] = useState(true);
  const [cardMessage, setCardMessage] = useState<{ id: string; text: string } | null>(null);
  const petId = params.id as string;

  // Get pet display name (use names array if available, fallback to name field) - memoized for stability
  const petDisplayName = useMemo(() => {
    if (!pet) return 'Pet';
    return getRandomName(pet.names || (pet.name ? [pet.name] : ['Unnamed Pet']));
  }, [pet?.id, pet?.names, pet?.name]);

  // Convert pet data to rating system format - memoized to prevent recalculation when only savedRecipes changes
  // Use JSON.stringify for arrays to ensure stable comparison
  const healthConcernsKey = pet ? JSON.stringify(pet.healthConcerns || []) : '';
  const allergiesKey = pet ? JSON.stringify(pet.allergies || []) : '';
  const dislikesKey = pet ? JSON.stringify(pet.dislikes || []) : '';
  
  // Convert pet data to enhanced compatibility format
  const enhancedPet: EnhancedPet | null = useMemo(() => {
    if (!pet) return null;
    const petAge = pet.age === 'baby' ? 0.5 : pet.age === 'young' ? 2 : pet.age === 'adult' ? 5 : 10;
    return {
      id: pet.id,
      name: petDisplayName,
      type: (pet.type === 'dogs' ? 'dog' : pet.type === 'cats' ? 'cat' : pet.type === 'birds' ? 'bird' : pet.type === 'reptiles' ? 'reptile' : 'pocket-pet') as 'dog' | 'cat' | 'bird' | 'reptile' | 'pocket-pet',
      breed: pet.breed,
      age: petAge,
      weight: pet.weightKg || (pet.type === 'dogs' ? 25 : pet.type === 'cats' ? 10 : 5),
      activityLevel: 'moderate' as const,
      healthConcerns: pet.healthConcerns || [],
      dietaryRestrictions: pet.dietaryRestrictions || [],
      allergies: pet.allergies || [],
    };
  }, [pet?.id, pet?.type, pet?.breed, pet?.age, pet?.weightKg, healthConcernsKey, allergiesKey, petDisplayName, pet?.dietaryRestrictions]);


  useEffect(() => {
    const userId = getCurrentUserId();
    if (!userId || !petId) return;

    const loadPet = async () => {
      try {
        // Add 5 second timeout to prevent hanging
        const timeoutPromise = new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Timeout loading pets')), 5000)
        );
        
        const pets = await Promise.race([
          getPets(userId),
          timeoutPromise
        ]) as any[];
        
        // Normalize names when loading
        const normalizedPets = pets.map((p: any) => ({
          ...p,
          names: p.names || (p.name ? [p.name] : []),
          savedRecipes: p.savedRecipes || [],
          healthConcerns: p.healthConcerns || [],
        }));
        
        const foundPet = normalizedPets.find((p: any) => p.id === petId) || null;
        setPet(foundPet);
        
        if (!foundPet) {
          console.warn('Pet not found with id:', petId);
          setLoadingMeals(false); // Stop loading if pet not found
        }
      } catch (error) {
        console.error('Failed to load pet data:', error);
        setPet(null);
        setLoadingMeals(false); // CRITICAL: Stop loading on error
      }
    };
    loadPet();
  }, [petId]); // petId is the only dependency needed

useEffect(() => {
  if (!pet) return;
  let isMounted = true;
  setLoadingMeals(true);
  setEngineError(null);

  (async () => {
    try {
      // First try the new cost-optimized recipe generation API
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
      
      const response = await fetch('/api/recipes/generate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        signal: controller.signal,
        body: JSON.stringify({
          species: pet.type,
          count: 50,
          petProfile: {
            name: petDisplayName,
            weight: pet.weight,
            weightKg: pet.weightKg,
            age: pet.age,
            allergies: pet.allergies || [],
            healthConcerns: pet.healthConcerns || [],
          },
        }),
      });
      
      clearTimeout(timeoutId);

      if (!response.ok) {
        throw new Error(`Recipe generation failed (${response.status})`);
      }

      const data = await response.json();
      if (!isMounted) return;
      
      if (data?.recipes && data.recipes.length > 0) {
        // Convert generated recipes to ModifiedRecipeResult format
        const generatedMeals = data.recipes.map((recipe: any) => ({
          recipe,
          explanation: `Cost-optimized meal: $${recipe.estimatedCostPerMeal?.toFixed(2) || 'N/A'} per meal`,
        }));
        setEngineMeals(generatedMeals as ModifiedRecipeResult[]);
      } else {
        throw new Error('No recipes generated');
      }
    } catch (error) {
      if (!isMounted) return;
      console.error('Recipe generation error:', error);
      // Fall back to recommendations API if generation fails
      try {
        const concerns = (pet.healthConcerns || []).filter((concern) => concern !== 'none');
        const allergies = pet.allergies?.filter((allergy) => allergy !== 'none') || [];
        
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000);
        
        const response = await fetch('/api/recommendations', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          signal: controller.signal,
          body: JSON.stringify({
            profile: {
              species: pet.type,
              ageGroup: pet.age,
              breed: pet.breed,
              weightKg: pet.weightKg || 10,
              healthConcerns: concerns,
              allergies,
              petName: petDisplayName,
            },
            limit: 50,
          }),
        });
        
        clearTimeout(timeoutId);

        if (!response.ok) {
          throw new Error(`Recommendations failed (${response.status})`);
        }

        const data = await response.json();
        if (!isMounted) return;
        
        setEngineMeals((data?.results as ModifiedRecipeResult[]) || []);
      } catch (fallbackError) {
        if (!isMounted) return;
        setEngineMeals(null);
        setEngineError('Unable to load meals‚Äîshowing standard matches.');
      }
    } finally {
      if (isMounted) {
        setLoadingMeals(false);
      }
    }
  })();

  return () => {
    isMounted = false;
  };
}, [pet]);

  // Debug logging (as suggested by DeepSeek) - MUST be after all useState hooks, before early returns
  useEffect(() => {
    // Only log state variables, not computed values
    if (pet) {
      const { getRecommendedRecipes } = require('@/lib/utils/recipeRecommendations');
      const tieredRecommendations = getRecommendedRecipes(pet, 20, true);
      const fallbackCount = tieredRecommendations.length;
      
      // Using engine meals or fallback
    }
  }, [engineMeals, pet]);

  // Import subtype matching
  const { normalizeToSubtype } = require('@/lib/utils/ingredientWhitelists');
  
  // Helper to check species/subtype match
  const matchesSpecies = (recipe: Recipe, currentPet: Pet): boolean => {
    if (recipe.category === currentPet.type) return true;
    
    // Subtype matching for exotics
    const subtype = normalizeToSubtype(currentPet.type as any, currentPet.breed);
    
    if (currentPet.type === 'birds') {
      if (recipe.category === 'birds' || recipe.category === 'bird') return true;
      if (recipe.category === subtype) return true;
    }
    
    if (currentPet.type === 'reptiles') {
      if (recipe.category === 'reptiles' || recipe.category === 'reptile') return true;
      if (recipe.category === subtype) return true;
    }
    
    if (currentPet.type === 'pocket-pets') {
      if (recipe.category === 'pocket-pets' || recipe.category === 'pocket-pet') return true;
      if (recipe.category === subtype) return true;
    }
    
    return false;
  };

  // Use tiered recommendation system to ensure we always have results
  // Only depend on properties that affect recommendations, NOT savedRecipes
  // Use JSON.stringify for arrays to ensure stable comparison
  const tieredHealthConcernsKey = pet ? JSON.stringify(pet.healthConcerns || []) : '';
  const tieredAllergiesKey = pet ? JSON.stringify(pet.allergies || []) : '';

  const tieredRecommendations = useMemo(() => {
    if (!pet) return [];
    const { getRecommendedRecipes } = require('@/lib/utils/recipeRecommendations');
    // Pass combined recipes (base + custom) to the recommendation system
    const combinedRecipes = getCombinedRecipes();
    return getRecommendedRecipes(pet, 20, true, combinedRecipes);
  }, [pet?.id, pet?.type, pet?.breed, pet?.age, tieredHealthConcernsKey, pet?.weightKg, tieredAllergiesKey]);
  
  const buildFallbackExplanation = (recipe: Recipe, currentPet: Pet, tierLabel?: string, warning?: string) => {
    if (warning) {
      return warning;
    }
    if (tierLabel && tierLabel !== 'Best Match') {
      return `${recipe.name} - ${tierLabel}`;
    }
    const concern = (currentPet.healthConcerns || [])[0]?.replace(/-/g, ' ') || 'overall wellness';
    const highlight = recipe.tags?.[0] || (recipe.description || '').split('. ')[0] || recipe.name;
    return `${recipe.name} keeps ${currentPet.name || 'pet'}'s ${concern} on track with ${highlight?.toLowerCase()}.`;
  };

  // Convert tiered recommendations to format expected by UI
  // Only depend on properties that affect meal recommendations, NOT savedRecipes
  const fallbackHealthConcernsKey = pet ? JSON.stringify(pet.healthConcerns || []) : '';
  const fallbackPetName = pet?.name || '';
  
  const fallbackMeals = useMemo(() => {
    if (!pet) return [];
    return tieredRecommendations.map((rec: any) => ({
      recipe: rec.recipe,
      explanation: buildFallbackExplanation(rec.recipe, pet, rec.tierLabel, rec.warning),
      _tierLabel: rec.tierLabel,
      _warning: rec.warning,
      _healthMatch: rec.healthConcernMatch,
      _tier: rec.tier
    }));
  }, [pet?.id, pet?.type, pet?.breed, pet?.age, fallbackHealthConcernsKey, fallbackPetName, tieredRecommendations]);

  // Fix: Properly check for empty array - use fallback if engineMeals is null, undefined, empty, or has too few results
  // Use fallback if API returns fewer than 15 meals (threshold to ensure we get a good selection)
  const MIN_MEALS_THRESHOLD = 15;
  // Memoize mealsToRender to prevent recalculation when only savedRecipes changes
  const mealsToRender: (ModifiedRecipeResult | { recipe: Recipe; explanation: string })[] = useMemo(() => {
    const hasEnoughFromAPI = engineMeals && Array.isArray(engineMeals) && engineMeals.length >= MIN_MEALS_THRESHOLD;
    return hasEnoughFromAPI ? engineMeals : fallbackMeals;
  }, [engineMeals, fallbackMeals]);

  // Use chunked scoring hook for non-blocking performance
  const { scoredMeals, isLoading: isScoring, progress, totalMeals: totalMealsToScore, scoredCount } = useChunkedRecipeScoring(
    mealsToRender,
    null, // ratingPet deprecated - using enhancedPet only
    enhancedPet
  );

  // Store sorted meals (already sorted by the hook, but ensure final sort)
  const sortedMealsToRender = useMemo(() => {
    return [...scoredMeals].sort((a: any, b: any) => {
      const aScore = ('score' in a && typeof a.score === 'number') ? a.score : 0;
      const bScore = ('score' in b && typeof b.score === 'number') ? b.score : 0;
      const scoreDiff = bScore - aScore;
      // If scores differ, sort by score (descending)
      if (Math.abs(scoreDiff) > 0.001) {
        return scoreDiff;
      }
      // If scores are equal, use recipe ID as tiebreaker
      const aId = a.recipe?.id || '';
      const bId = b.recipe?.id || '';
      return aId.localeCompare(bId);
    });
  }, [scoredMeals]);

  // Calculate base meal count (before early returns to ensure hooks are always called)
  const baseTotalMeals = sortedMealsToRender.length;
  
  // Memoize the count calculation - use actual count with minimal organic tweaking
  // Only recalculate when pet profile or base count changes
  const { countMessage, countSubtext, targetDisplayCount } = useMemo(() => {
    // Use the actual count as the base
    const message = getCountMessage(baseTotalMeals, pet?.type);
    const subtext = getSubtext(baseTotalMeals, pet?.type);
    // Use actual count
    const target = baseTotalMeals;
    
    return {
      countMessage: message,
      countSubtext: subtext,
      targetDisplayCount: target,
    };
  }, [baseTotalMeals, pet?.type]);
  
  // Progressive count animation - MUST be called before any early returns
  const { displayCount, isCounting } = useProgressiveMealCount({
    target: targetDisplayCount,
    duration: 1000,
    steps: 20,
  });

  // Track saved recipes separately to avoid triggering meal recalculation
  const [savedRecipeIds, setSavedRecipeIds] = useState<Set<string>>(new Set());

  // Initialize savedRecipeIds from pet when pet loads
  useEffect(() => {
    if (pet?.savedRecipes) {
      setSavedRecipeIds(new Set(pet.savedRecipes));
    }
  }, [pet?.id]); // Only update when pet ID changes, not when savedRecipes changes

  const handleSaveRecipe = async (recipeId: string, recipeName: string) => {
    const userId = getCurrentUserId();
    if (!userId || !pet) return;

    // Check if already saved (using local state)
    if (savedRecipeIds.has(recipeId)) {
      setCardMessage({ id: recipeId, text: 'Already saved for this pet.' });
      setTimeout(() => setCardMessage(null), 2500);
      return;
    }

    // Update via storage util
    const updatedPet = {
      ...pet,
      savedRecipes: [...(pet.savedRecipes || []), recipeId]
    };
    
    await savePet(userId, updatedPet);

    // Update local state to reflect the change immediately
    setPet(updatedPet);
    setSavedRecipeIds(new Set([...savedRecipeIds, recipeId]));
    setCardMessage({ id: recipeId, text: `${recipeName} added to ${petDisplayName}'s meals.` });
    setTimeout(() => setCardMessage(null), 2500);
  };

  if (!pet) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-background text-foreground">
        <p>Loading...</p>
      </div>
    );
  }

  const usingEngine = Boolean(engineMeals && engineMeals.length > 0);

  const getPetEmoji = (type: PetCategory) => {
    const emojis = {
      dogs: 'üêï',
      cats: 'üêà',
      birds: 'ü¶ú',
      reptiles: 'ü¶é',
      'pocket-pets': 'üê∞',
    };
    return emojis[type];
  };
  
  // Component to render pet emoji as image
  const PetEmojiIcon = ({ type, size = 24 }: { type: PetCategory; size?: number }) => {
    const emoji = getPetEmoji(type);
    return <EmojiIcon emoji={emoji} size={size} />;
  };

  const getHealthCompatibilityScore = (recipe: any, pet: Pet): number => {
    const concerns = pet.healthConcerns || [];
    if (!concerns.length) return 0;
    const overlaps = concerns.filter((c) => (recipe.healthConcerns || []).includes(c));
    if (!overlaps.length) return 0;
    return overlaps.length / concerns.length; // 0..1
  };

  const getHealthMatchBadge = (score: number) => {
    if (score >= 0.67)
      return {
        label: 'Great health match',
        className: 'bg-green-900/50 text-green-200 border border-green-700/50',
      };
    if (score >= 0.34)
      return {
        label: 'Good health match',
        className: 'bg-yellow-900/50 text-yellow-200 border border-yellow-700/50',
      };
    if (score > 0)
      return {
        label: 'Some health benefit',
        className: 'bg-blue-900/50 text-blue-200 border border-blue-700/50',
      };
    return null;
  };

  const getStarStates = (rating: number): boolean[] => {
    const fullStars = Math.round(rating); // 0..5
    return Array.from({ length: 5 }, (_, i) => i < fullStars);
  };

  return (
    <div className="min-h-screen bg-background text-foreground py-4">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <Link
          href="/profile"
          className="inline-flex items-center gap-2 text-gray-400 hover:text-primary-400 mb-6"
        >
          <ArrowLeft className="h-5 w-5" />
          Back to Profile
        </Link>

        <div 
          className="bg-surface rounded-lg shadow-md border border-surface-highlight p-4 mb-3"
        >
          <div className="flex items-start gap-4">
            {/* Left: Turtle Image (twice as large) */}
            <div className="flex-shrink-0">
              <Image
                src="/images/emojis/Mascots/Sherlock Shells/Shell4.jpg"
                alt="Sherlock Shells Detective"
                width={288}
                height={288}
                className="w-72 h-72 object-contain mascot-icon mascot-sherlock-shells"
                unoptimized
              />
            </div>

            {/* Left-Middle: Title and Bio Info in Grid */}
            <div className="flex-1 min-w-0">
              <h1 className="text-2xl font-bold text-foreground mb-6 mt-8">
                Sherlock Shells is detecting meals...
              </h1>
              
              {/* Three Column Layout: Bio, Health Concerns, Allergies */}
              <div className="flex gap-6 mt-8">
                {/* Bio Column */}
                <div className="flex-1 min-w-0">
                  <h3 className="text-sm font-semibold text-gray-300 mb-2">Bio</h3>
                  <div className="grid grid-cols-1 gap-y-1 text-sm text-gray-300">
                    {pet.breed && (
                      <div className="flex items-start gap-1.5">
                        <span className="text-orange-400 mt-0.5">‚Ä¢</span>
                        <span><strong className="text-gray-200">Breed:</strong> {pet.breed}</span>
                      </div>
                    )}
                    {pet.age && (
                      <div className="flex items-start gap-1.5">
                        <span className="text-orange-400 mt-0.5">‚Ä¢</span>
                        <span><strong className="text-gray-200">Age:</strong> {pet.age}</span>
                      </div>
                    )}
                    {(pet.weightKg || pet.weight) && (
                      <div className="flex items-start gap-1.5">
                        <span className="text-orange-400 mt-0.5">‚Ä¢</span>
                        <span><strong className="text-gray-200">Weight:</strong> {pet.weightKg ? `${pet.weightKg}kg` : pet.weight}</span>
                      </div>
                    )}
                    {pet.type && (
                      <div className="flex items-start gap-1.5">
                        <span className="text-orange-400 mt-0.5">‚Ä¢</span>
                        <span><strong className="text-gray-200">Type:</strong> {pet.type}</span>
                      </div>
                    )}
                    {pet.savedRecipes && pet.savedRecipes.length > 0 && (
                      <div className="flex items-start gap-1.5">
                        <span className="text-orange-400 mt-0.5">‚Ä¢</span>
                        <span><strong className="text-gray-200">Total Meals:</strong> {pet.savedRecipes.length}</span>
                      </div>
                    )}
                    {(pet.dietaryRestrictions || []).length > 0 && (
                      <div className="flex items-start gap-1.5">
                        <span className="text-orange-400 mt-0.5">‚Ä¢</span>
                        <span><strong className="text-gray-200">Dietary Restrictions:</strong> {(pet.dietaryRestrictions || []).join(', ')}</span>
                      </div>
                    )}
                    {(pet.dislikes || []).length > 0 && (
                      <div className="flex items-start gap-1.5">
                        <span className="text-orange-400 mt-0.5">‚Ä¢</span>
                        <span><strong className="text-gray-200">Dislikes:</strong> {(pet.dislikes || []).join(', ')}</span>
                      </div>
                    )}
                  </div>
                </div>

                {/* Health Concerns Column - Always rendered for consistent layout */}
                <div className="flex-shrink-0 min-w-[180px]">
                  <h3 className="text-sm font-semibold text-gray-300 mb-2">Health Concerns</h3>
                  <div className="flex flex-col gap-1.5">
                    {(pet.healthConcerns || []).length > 0 ? (
                      (pet.healthConcerns || []).map((concern) => (
                        <div
                          key={concern}
                          className="px-2 py-1 bg-orange-900/40 text-orange-200 border border-orange-700/50 text-xs rounded"
                        >
                          {concern.replace(/-/g, ' ')}
                        </div>
                      ))
                    ) : (
                      <div className="px-2 py-1 text-gray-500 text-xs italic">
                        None
                      </div>
                    )}
                  </div>
                </div>

                {/* Allergies Column - Always rendered for consistent layout */}
                <div className="flex-shrink-0 min-w-[180px]">
                  <h3 className="text-sm font-semibold text-gray-300 mb-2">Allergies</h3>
                  <div className="flex flex-col gap-1.5">
                    {(pet.allergies || []).length > 0 ? (
                      (pet.allergies || []).map((allergy) => (
                        <div
                          key={allergy}
                          className="px-2 py-1 bg-orange-900/40 text-orange-200 border border-orange-700/50 text-xs rounded"
                        >
                          {allergy.replace(/-/g, ' ')}
                        </div>
                      ))
                    ) : (
                      <div className="px-2 py-1 text-gray-500 text-xs italic">
                        None
                      </div>
                    )}
                  </div>
                </div>
              </div>

              {engineError && (
                <p className="mt-4 text-sm text-amber-200 bg-amber-900/30 border border-amber-700/50 px-3 py-2 rounded-lg">
                  {engineError}
                </p>
              )}
            </div>

            {/* Far Right: Number of Meals Found (Larger) */}
            <div className="flex-shrink-0 text-right">
              <div className="text-5xl font-bold text-orange-500">
                {displayCount}{isCounting && <span className="text-3xl">+</span>}
              </div>
              <div className="text-sm text-gray-400 mt-1">
                meals found
                {isCounting && (
                  <span className="text-xs ml-2 text-gray-500">(still searching...)</span>
                )}
              </div>
              {countSubtext && !isCounting && (
                <div className="text-xs text-gray-500 mt-1 max-w-[120px]">
                  {countSubtext}
                </div>
              )}
            </div>
          </div>
        </div>

        {/* Show progress indicator while scoring */}
        {isScoring && (
          <ScoringProgress
            progress={progress}
            totalMeals={totalMealsToScore}
            scoredCount={scoredCount}
          />
        )}

        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {(() => {
            // FINAL SAFETY CHECK: Sort one more time right before rendering to ensure highest to lowest
            const finalRendered = [...sortedMealsToRender].sort((a: any, b: any) => {
              const aScore = ('score' in a && typeof a.score === 'number') ? a.score : 0;
              const bScore = ('score' in b && typeof b.score === 'number') ? b.score : 0;
              return bScore - aScore; // Descending order (highest first)
            });
            return finalRendered;
          })().map((meal) => {
            const recipe = meal.recipe;
            const explanation = meal.explanation;
            const recipeId = recipe.id;
            return (
            <div
              key={recipeId}
              className="relative group"
              onMouseEnter={() => setHoveredRecipe(recipeId)}
              onMouseLeave={() => setHoveredRecipe(null)}
            >
              <Link 
                href={`/recipe/${recipeId}?petId=${petId}`}
                onClick={() => {
                  // Store recipe in session storage for dynamically generated recipes
                  if (typeof window !== 'undefined') {
                    sessionStorage.setItem(`recipe_${recipeId}`, JSON.stringify(recipe));
                  }
                }}
              >
                <div className="bg-surface rounded-lg shadow-md border border-surface-highlight overflow-hidden cursor-pointer hover:shadow-xl hover:border-orange-500/30 hover:-translate-y-1 hover:scale-[1.02] transition-all duration-200 ease-out h-full flex flex-col">
                  <div className="p-6 flex-1 flex flex-col">
                    <div className="mb-3">
                      <h3 className="text-xl font-bold text-foreground text-center">
                        {recipe.name}
                      </h3>
                      {/* Compatibility Rating - Centered under meal name */}
                      {enhancedPet && (
                        <div className="mt-2 flex justify-center">
                          <CompatibilityBadge
                            score={
                              'score' in meal && typeof meal.score === 'number'
                                ? meal.score
                                : (() => {
                                    if (!enhancedPet) return 0;
                                    const enhanced = calculateEnhancedCompatibility(recipe, enhancedPet);
                                    return enhanced.overallScore;
                                  })()
                            }
                          />
                        </div>
                      )}
                    </div>
                    <p className="text-gray-300 text-sm mb-4 flex-1 text-center">
                      {recipe.description}
                    </p>
                    {explanation && (
                      <p className="text-sm text-gray-300 bg-surface-highlight rounded-lg p-3 mb-3 border border-white/5">
                        {explanation}
                      </p>
                    )}
                  </div>
                  <div className="px-6 pb-4 pt-2 border-t border-surface-highlight">
                    {(() => {
                      const isSaved = savedRecipeIds.has(recipeId);
                      return (
                        <button
                          onClick={(e) => {
                            e.preventDefault();
                            handleSaveRecipe(recipeId, recipe.name);
                          }}
                          disabled={isSaved}
                          className={`w-full px-4 py-2 rounded-md shadow-md transition-colors flex items-center justify-center gap-2 text-sm font-semibold ${
                            isSaved
                              ? 'bg-green-600 text-white cursor-not-allowed'
                              : 'bg-green-800 text-white hover:bg-green-900'
                          }`}
                        >
                          {isSaved ? '‚úì Added to Saved Meals' : (
                            <>
                              <Plus className="h-4 w-4" /> Add Meal
                            </>
                          )}
                        </button>
                      );
                    })()}
                  </div>
                </div>
              </Link>
            </div>
          )})}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/profile/pet/[id]/recipe-builder/page.tsx">
'use client';

import { useState, useEffect } from 'react';
import { useParams, useRouter } from 'next/navigation';
import Link from 'next/link';
import {
  ChevronLeft,
  X
} from 'lucide-react';
import { generateCustomMealAnalysis } from '@/lib/analyzeCustomMeal';
import { INGREDIENT_COMPOSITIONS } from '@/lib/data/ingredientCompositions';
import { type IngredientSelection, type MealAnalysis } from '@/lib/analyzeCustomMeal';
import { getIngredientsForSpecies, mapIngredientToCompositionKey, ALL_INGREDIENTS, getIngredientDisplayName } from '@/lib/utils/allIngredients';
import { generateIngredientSuggestions } from '@/lib/utils/ingredientSuggestions';
import { getWhitelistForSpecies, isWhitelisted, getSpeciesCoverageLevel, getBlacklistForSpecies } from '@/lib/utils/ingredientWhitelists';
import IngredientPicker from '@/components/IngredientPicker';
import MealCompositionList from '@/components/MealCompositionList';
import CompatibilityPanel from '@/components/CompatibilityPanel';
import SuggestedIngredients from '@/components/SuggestedIngredients';
import MealBuilderWizard from '@/components/MealBuilderWizard';
import MealCompleteView from '@/components/MealCompleteView';
import { getPets } from '@/lib/utils/petStorage'; // Import async storage

// Style mapping for severity levels
const severityStyles = {
  critical: 'bg-red-50 border-red-200 text-red-800',
  major: 'bg-red-50 border-red-200 text-red-700',
  moderate: 'bg-orange-50 border-orange-200 text-orange-700',
};

const getSeverityIcon = (severity: string) => {
  switch (severity) {
    case 'critical':
      return <span className="text-red-600">‚ö†Ô∏è</span>;
    case 'major':
      return <span className="text-red-600">‚ö†Ô∏è</span>;
    default:
      return <span className="text-orange-600">‚ÑπÔ∏è</span>;
  }
};

const getProgressGradientColor = (score: number) => {
  if (score === 0) return '#dc2626'; // red-600
  if (score <= 10) return '#dc2626'; // red-600
  if (score <= 20) return '#ea580c'; // orange-600
  if (score <= 30) return '#d97706'; // amber-600
  if (score <= 40) return '#ca8a04'; // yellow-600
  if (score <= 50) return '#a3a3a3'; // gray-400 (neutral)
  if (score <= 60) return '#84cc16'; // lime-500
  if (score <= 70) return '#65a30d'; // lime-700
  if (score <= 80) return '#16a34a'; // green-600
  if (score <= 90) return '#15803d'; // green-700
  return '#166534'; // green-800
};

interface Pet {
  id: string;
  names: string[];
  type: string;
  breed: string;
  age: string;
  weight: string;
  healthConcerns?: string[];
  dietaryRestrictions?: string[];
  allergies?: string[];
  dislikes?: string[];
  image?: string;
  savedRecipes?: string[];
  weightKg?: number;
}

// Species-appropriate ingredient categories
const SPECIES_INGREDIENT_FILTERS = {
  dogs: {
    allowed: ['chicken_breast', 'ground_turkey', 'chicken_thighs', 'turkey_breast', 'chicken_liver', 'chicken_hearts',
              'salmon_atlantic', 'sardines_water', 'tuna_water',
              'ground_beef_lean', 'beef_liver',
              'eggs_whole',
              'kale_raw', 'spinach_raw', 'carrots_raw', 'sweet_potato', 'broccoli_raw',
              'blueberries_raw', 'bananas_raw',
              'brown_rice_cooked', 'oats', 'quinoa_cooked',
              'fish_oil'], // Meat-focused with some veggies
    disallowed: ['taurine_powder'], // Dogs can synthesize taurine
  },
  cats: {
    allowed: ['chicken_breast', 'ground_turkey', 'turkey_breast', 'chicken_liver', 'chicken_hearts',
              'salmon_atlantic', 'sardines_water', 'tuna_water',
              'eggs_whole',
              'brown_rice_cooked', 'quinoa_cooked',
              'taurine_powder', 'fish_oil'], // Taurine essential for cats, very meat-focused
    disallowed: ['ground_beef_lean', 'beef_liver'], // Many cats allergic/intolerant to beef
  },
  reptiles: {
    allowed: ['kale_raw', 'spinach_raw', 'carrots_raw', 'sweet_potato', 'broccoli_raw', 'celery_raw',
              'blueberries_raw', 'bananas_raw', 'eggs_whole',
              'calcium_carbonate'], // Vegetables and calcium (reptiles are often herbivores/omnivores)
    // Reptiles should use insects like crickets, dubia, etc. but those aren't in our current DB
    disallowed: ['chicken_breast', 'ground_turkey', 'ground_beef_lean', 'beef_liver', 'chicken_liver'],
  },
  birds: {
    allowed: [
      // Protein sources
      'eggs_whole', 'egg (hard-boiled)',
      // Seeds (protein sources for birds)
      'millet (white/red)', 'canary seed', 'niger seed', 'hemp seeds', 'flaxseeds',
      'sesame seeds', 'chia seeds', 'sunflower seeds (small amounts)', 'pumpkin seeds',
      'safflower seeds', 'nyjer seeds', 'amaranth seeds', 'wild bird mix',
      // Insects (for some bird species)
      'crickets', 'mealworms', 'superworms', 'black soldier fly larvae', 'hornworms',
      'dubia roaches', 'pinhead crickets',
      // Cooked lean meats (small amounts for some birds)
      'turkey_breast', 'chicken_breast',
      // Fruits, grains, vegetables, calcium
      'blueberries_raw', 'bananas_raw',
      'brown_rice_cooked', 'oats', 'quinoa_cooked',
      'kale_raw', 'spinach_raw', 'carrots_raw', 'broccoli_raw',
      'calcium_carbonate'
    ],
    disallowed: ['ground_beef_lean', 'beef_liver', 'chicken_liver'], // Raw meat not ideal for birds
  },
  'pocket-pets': {
    allowed: ['oats', 'quinoa_cooked', 'brown_rice_cooked',
              'kale_raw', 'spinach_raw', 'carrots_raw', 'broccoli_raw', 'celery_raw',
              'blueberries_raw', 'bananas_raw',
              'calcium_carbonate'], // Hay/pellet substitutes, veggies, fruits, calcium
    disallowed: ['chicken_breast', 'ground_turkey', 'ground_beef_lean', 'beef_liver', 'salmon_atlantic'],
  },
};

// Normalize pet type to match ALL_INGREDIENTS keys
const normalizeSpecies = (species: string): string => {
  const mapping: Record<string, string> = {
    'dog': 'dogs',
    'cat': 'cats',
    'bird': 'birds',
    'reptile': 'reptiles',
    'pocket-pet': 'pocket-pets',
    'dogs': 'dogs',
    'cats': 'cats',
    'birds': 'birds',
    'reptiles': 'reptiles',
    'pocket-pets': 'pocket-pets'
  };
  return mapping[species.toLowerCase()] || species;
};

// Get filtered ingredients based on pet species - ONLY show species-specific ingredients
const getAvailableIngredients = (species: string, bannedIngredients?: string[]): string[] => {
  const normalizedSpecies = normalizeSpecies(species);
  const filters = SPECIES_INGREDIENT_FILTERS[normalizedSpecies as keyof typeof SPECIES_INGREDIENT_FILTERS];

  // Get species-specific ingredients from scraped data (generate-recipes.js INGREDIENTS object)
  // This contains all the AAFCO and research-based ingredients for this species
  const scrapedIngredients = getIngredientsForSpecies(normalizedSpecies);
  
  // Return ALL scraped ingredient names - don't filter by composition key mapping
  // The composition keys will be looked up when needed for nutritional analysis
  const allIngredientNames = new Set<string>(scrapedIngredients);
  
  // Also include composition keys that are commonly used across species (universal ingredients)
  // but only if they're not explicitly disallowed
  const universalIngredients = [
    'eggs_whole', 'carrots_raw', 'broccoli_raw', 'spinach_raw', 
    'kale_raw', 'celery_raw', 'blueberries_raw', 'bananas_raw',
    'brown_rice_cooked', 'quinoa_cooked', 'sweet_potato', 'oats',
    'fish_oil', 'calcium_carbonate'
  ];
  
  universalIngredients.forEach(key => {
    if (!filters?.disallowed?.includes(key)) {
      // Convert composition key to readable name and add
      const displayName = key.split('_').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
      allIngredientNames.add(displayName);
    }
  });
  
  // Return all ingredient names (scraped names + universal ingredients)
  const mappedKeys = Array.from(allIngredientNames);

  let filtered = mappedKeys;
  
  if (filters) {
    // Filter out disallowed items
    filtered = filtered.filter(ing => !filters.disallowed?.includes(ing));
  }
  
  // Filter out banned ingredients (case-insensitive partial match)
  if (bannedIngredients && bannedIngredients.length > 0) {
    const bannedLower = bannedIngredients.map(b => b.toLowerCase());
    filtered = filtered.filter(ing => {
      const ingLower = ing.toLowerCase();
      return !bannedLower.some(banned => ingLower.includes(banned) || banned.includes(ingLower));
    });
  }

  return Array.from(filtered).sort();
};

// Categorize ingredients
const getCategorizedIngredients = (availableIngredients: string[], species: string) => {
  const normalizedSpecies = normalizeSpecies(species);
  const categories = {
    proteins: {
      name: 'Proteins',
      description: 'Main protein source',
      maxSelections: 999, // No limit - let users experiment
      icon: 'ü•©',
      ingredients: [] as string[]
    },
    greens: {
      name: 'Greens & Veggies',
      description: 'Vitamins and fiber',
      maxSelections: 999,
      icon: 'ü•¨',
      ingredients: [] as string[]
    },
    fruits: {
      name: 'Fruits',
      description: 'Natural sweetness and nutrients',
      maxSelections: 999,
      icon: 'üçé',
      ingredients: [] as string[]
    },
    grains: {
      name: 'Grains & Carbs',
      description: 'Energy source',
      maxSelections: 999,
      icon: 'üåæ',
      ingredients: [] as string[]
    },
    supplements: {
      name: 'Supplements',
      description: 'Essential nutrients',
      maxSelections: 999,
      icon: 'üíä',
      ingredients: [] as string[]
    }
  };

  // Special handling for cats (taurine is specifically marked as essential but can be added to supplements)
  if (normalizedSpecies === 'cats') {
    categories.supplements.description = 'Essential nutrients (taurine recommended)';
  }

  // Special handling for reptiles/herbivores (calcium is essential)
  if (['reptiles', 'pocket-pets'].includes(normalizedSpecies)) {
    categories.supplements.description = 'Essential minerals (calcium recommended)';
  }

  // Get species-specific ingredient categories from scraped data
  const speciesData = ALL_INGREDIENTS[normalizedSpecies as keyof typeof ALL_INGREDIENTS];
  
  if (speciesData) {
    // Map scraped ingredients to composition keys and categorize by species-specific categories
    Object.entries(speciesData).forEach(([categoryName, ingredientList]) => {
      if (Array.isArray(ingredientList)) {
        ingredientList.forEach(ingName => {
          // Use the ingredient name directly (not the composition key) for display
          // Only add if it's in availableIngredients (species-filtered)
          if (availableIngredients.includes(ingName)) {
            // Map category names to our 5 categories based on species
            // Use ingredient name directly (not composition key) for display
            if (categoryName === 'proteins' || categoryName === 'insects' || 
                (normalizedSpecies === 'birds' && categoryName === 'seeds')) {
              // For birds, seeds are protein sources
              if (!categories.proteins.ingredients.includes(ingName)) {
                categories.proteins.ingredients.push(ingName);
              }
            } else if (categoryName === 'vegetables' || categoryName === 'hay') {
              if (!categories.greens.ingredients.includes(ingName)) {
                categories.greens.ingredients.push(ingName);
              }
            } else if (categoryName === 'fruits') {
              if (!categories.fruits.ingredients.includes(ingName)) {
                categories.fruits.ingredients.push(ingName);
              }
            } else if (categoryName === 'carbs' || categoryName === 'seeds' || categoryName === 'pellets' || categoryName === 'hamster_additions') {
              // Seeds go to grains for non-bird species
              if (!categories.grains.ingredients.includes(ingName)) {
                categories.grains.ingredients.push(ingName);
              }
            } else if (categoryName === 'fats' || categoryName === 'fiber_supplements' || categoryName === 'supplements') {
              if (!categories.supplements.ingredients.includes(ingName)) {
                categories.supplements.ingredients.push(ingName);
              }
            }
          }
        });
      }
    });
  }
  
  // Also categorize any remaining ingredients that weren't in scraped data
  availableIngredients.forEach(ingName => {
    // Skip if already categorized
    const allCategorized = [
      ...categories.proteins.ingredients,
      ...categories.greens.ingredients,
      ...categories.fruits.ingredients,
      ...categories.grains.ingredients,
      ...categories.supplements.ingredients
    ];
    if (allCategorized.includes(ingName)) return;
    
    const keyLower = ingName.toLowerCase();
    
    // Proteins: meat, fish, eggs, insects
    if (keyLower.includes('chicken') || keyLower.includes('turkey') || 
        keyLower.includes('beef') || keyLower.includes('liver') || 
        keyLower.includes('hearts') || keyLower.includes('salmon') || 
        keyLower.includes('tuna') || keyLower.includes('sardines') ||
        keyLower.includes('duck') || keyLower.includes('venison') ||
        keyLower.includes('rabbit') || keyLower.includes('quail') ||
        keyLower.includes('pork') || keyLower.includes('giblets') ||
        keyLower.includes('eggs') || keyLower.includes('egg') ||
        keyLower.includes('cricket') || keyLower.includes('roach') ||
        keyLower.includes('worm') || keyLower.includes('insect')) {
      categories.proteins.ingredients.push(ingName);
    } 
    // Greens & Vegetables
    else if (keyLower.includes('kale') || keyLower.includes('spinach') || 
             keyLower.includes('carrot') || keyLower.includes('broccoli') || 
             keyLower.includes('celery') || keyLower.includes('bok') ||
             keyLower.includes('choy') || keyLower.includes('green bean') ||
             keyLower.includes('peas') || keyLower.includes('zucchini') ||
             keyLower.includes('brussels') || keyLower.includes('asparagus') ||
             keyLower.includes('cucumber') || keyLower.includes('lettuce') ||
             keyLower.includes('cabbage') || keyLower.includes('cauliflower') ||
             keyLower.includes('hay')) {
      categories.greens.ingredients.push(ingName);
    } 
    // Fruits
    else if (keyLower.includes('blueberr') || keyLower.includes('banana') ||
             keyLower.includes('apple') || keyLower.includes('berry') ||
             keyLower.includes('mango') || keyLower.includes('papaya') ||
             keyLower.includes('strawberr') || keyLower.includes('grape')) {
      categories.fruits.ingredients.push(ingName);
    } 
    // Grains & Carbs
    else if (keyLower.includes('rice') || keyLower.includes('quinoa') || 
             keyLower.includes('oats') || keyLower.includes('barley') ||
             keyLower.includes('sweet potato') || keyLower.includes('potato') ||
             keyLower.includes('pumpkin') || keyLower.includes('squash') ||
             keyLower.includes('lentil') || keyLower.includes('bean') ||
             keyLower.includes('chickpea') || keyLower.includes('grain') ||
             keyLower.includes('amaranth') || keyLower.includes('buckwheat') ||
             keyLower.includes('millet') || keyLower.includes('sorghum') ||
             keyLower.includes('farro') || keyLower.includes('bulgur') ||
             keyLower.includes('seed') || keyLower.includes('pellet')) {
      categories.grains.ingredients.push(ingName);
    } 
    // Supplements
    else if (keyLower.includes('oil') || keyLower.includes('calcium') || 
             keyLower.includes('taurine') || keyLower.includes('supplement') ||
             keyLower.includes('vitamin') || keyLower.includes('probiotic') ||
             keyLower.includes('psyllium') || keyLower.includes('joint')) {
      categories.supplements.ingredients.push(ingName);
    }
    // Default: add to greens if not categorized
    else {
      categories.greens.ingredients.push(ingName);
    }
  });

  return categories;
};

export default function RecipeBuilderPage() {
  const params = useParams();
  const router = useRouter();
  const petId = params.id as string;

  const [pet, setPet] = useState<Pet | null>(null);
  const [selectedIngredients, setSelectedIngredients] = useState<IngredientSelection[]>([]);
  const [analysis, setAnalysis] = useState<MealAnalysis | null>(null);
  const [isAnalyzing, setIsAnalyzing] = useState(false);
  const [showWizard, setShowWizard] = useState(false);
  const [wizardCompleted, setWizardCompleted] = useState(false);
  const [showAddMore, setShowAddMore] = useState(false);
  const [hasAppliedRecommended, setHasAppliedRecommended] = useState(false);
  const [isFirstCreation, setIsFirstCreation] = useState(false); // Track if this is the first creation
  const [recommendedMeals, setRecommendedMeals] = useState<any[]>([]); // Store recommended meals

  // Get species-appropriate ingredients and categories
  const normalizedSpeciesType = pet ? normalizeSpecies(pet.type) : null;
  const speciesCoverageLevel = normalizedSpeciesType ? getSpeciesCoverageLevel(normalizedSpeciesType as any) : 'limited';
  const blacklist = normalizedSpeciesType ? getBlacklistForSpecies(normalizedSpeciesType as any) : [];
  
  // Filter available ingredients through whitelist
  const allAvailableIngredients = pet ? getAvailableIngredients(pet.type, (pet as any).bannedIngredients) : [];
  const whitelist = normalizedSpeciesType ? getWhitelistForSpecies(normalizedSpeciesType as any) : [];
  const availableIngredients = whitelist.length > 0 
    ? allAvailableIngredients.filter(ing => isWhitelisted(ing, normalizedSpeciesType as any))
    : allAvailableIngredients; // Fallback to all if no whitelist data
  
  const categorizedIngredients = pet ? getCategorizedIngredients(availableIngredients, pet.type) : null;
  
  // Generate base suggestions from static rules
  const baseSuggestedIngredients = pet ? generateIngredientSuggestions({
    type: pet.type,
    age: pet.age,
    healthConcerns: pet.healthConcerns || [],
    breed: pet.breed
  }) : [];
  
  // Extract ingredients from recommended meals and merge with base suggestions
  const suggestedIngredients = (() => {
    if (!pet || recommendedMeals.length === 0) {
      return baseSuggestedIngredients;
    }
    
    // Extract unique ingredients from top 5 recommended meals
    const ingredientsFromMeals = new Map<string, { name: string; reason: string; category: string; fromMeal: boolean }>();
    
    recommendedMeals.slice(0, 5).forEach((meal: any) => {
      const mealIngredients = meal.recipe?.ingredients || meal.adjustedIngredients || [];
      mealIngredients.forEach((ing: any) => {
        const ingName = ing.name || ing.productName || '';
        if (ingName && !ingredientsFromMeals.has(ingName)) {
          // Try to categorize the ingredient
          const nameLower = ingName.toLowerCase();
          let category = 'Other';
          if (nameLower.includes('liver') || nameLower.includes('heart') || nameLower.includes('chicken') || 
              nameLower.includes('turkey') || nameLower.includes('duck') || nameLower.includes('salmon') ||
              nameLower.includes('beef') || nameLower.includes('fish') || nameLower.includes('meat')) {
            category = 'Proteins';
          } else if (nameLower.includes('squash') || nameLower.includes('greens') || nameLower.includes('kale') ||
                     nameLower.includes('spinach') || nameLower.includes('carrot') || nameLower.includes('broccoli') ||
                     nameLower.includes('dandelion') || nameLower.includes('vegetable')) {
            category = 'Greens & Veggies';
          } else if (nameLower.includes('rice') || nameLower.includes('quinoa') || nameLower.includes('oats') ||
                     nameLower.includes('grain') || nameLower.includes('carb')) {
            category = 'Grains & Carbs';
          } else if (nameLower.includes('oil') || nameLower.includes('supplement') || nameLower.includes('powder') ||
                     nameLower.includes('currant') || nameLower.includes('vitamin')) {
            category = 'Supplements';
          } else if (nameLower.includes('berry') || nameLower.includes('apple') || nameLower.includes('banana') ||
                     nameLower.includes('fruit')) {
            category = 'Fruits';
          }
          
          ingredientsFromMeals.set(ingName, {
            name: ingName,
            reason: `Found in your top recommended meals - ${meal.recipe?.name || 'recommended meal'}`,
            category,
            fromMeal: true
          });
        }
      });
    });
    
    // Merge with base suggestions, prioritizing ingredients from meals
    const merged = new Map<string, { name: string; reason: string; category: string }>();
    
    // First add ingredients from recommended meals (higher priority)
    ingredientsFromMeals.forEach((ing) => {
      merged.set(ing.name, { name: ing.name, reason: ing.reason, category: ing.category });
    });
    
    // Then add base suggestions (if not already present)
    baseSuggestedIngredients.forEach((ing) => {
      if (!merged.has(ing.name)) {
        merged.set(ing.name, ing);
      }
    });
    
    return Array.from(merged.values()).slice(0, 12); // Limit to 12 total suggestions
  })();
  
  // Extract recommended ingredient names for wizard
  const recommendedIngredientNames = suggestedIngredients.map(s => s.name);
  
  // Debug logging (remove in production)
  useEffect(() => {
    if (pet && availableIngredients.length > 0) {
      // Debug logging removed for production
    }
  }, [pet, availableIngredients.length, categorizedIngredients]);

  // Load pet data and fetch recommended meals
  useEffect(() => {
    const loadPetData = async () => {
      if (typeof window !== 'undefined') {
        const userId = localStorage.getItem('last_user_id') || 'clerk_simulated_user_id_123';
        
        try {
          const pets = await getPets(userId);
          const foundPet = pets.find((p: any) => p.id === petId);
          
          if (foundPet) {
            setPet(foundPet as unknown as Pet);
            // Show wizard on initial load if no ingredients selected
            if (selectedIngredients.length === 0 && !wizardCompleted) {
              setShowWizard(true);
            }
            
            // Fetch recommended meals... (rest of logic)
            const concerns = (foundPet.healthConcerns || []).filter((concern: string) => concern !== 'none');
            const allergies = (foundPet as any).allergies?.filter((allergy: string) => allergy !== 'none') || [];
            // Use random name from pet's names array
            const petNames = Array.isArray(foundPet.names) ? foundPet.names.filter((n: string) => n && n.trim() !== '') : [];
            const petDisplayName = petNames.length > 0 
              ? petNames[Math.floor(Math.random() * petNames.length)]
              : 'Your Pet';
            
            try {
              const response = await fetch('/api/recommendations', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  profile: {
                    species: foundPet.type,
                    ageGroup: foundPet.age,
                    breed: foundPet.breed,
                    weightKg: parseFloat(foundPet.weight?.replace(/[^0-9.]/g, '') || '10'),
                    healthConcerns: concerns,
                    allergies,
                    petName: petDisplayName,
                  },
                  limit: 5, // Only need top 5 for ingredient extraction
                }),
              });

              if (response.ok) {
                const data = await response.json();
                if (data?.results && Array.isArray(data.results)) {
                  setRecommendedMeals(data.results);
                }
              }
            } catch (error) {
              // Failed to fetch recommended meals
            }
          }
        } catch (error) {
          console.error("Error loading pet:", error);
        }
      }
    };

    loadPetData();
  }, [petId]);

  // Handle wizard completion
  const handleWizardComplete = (selections: { [category: string]: string[] }) => {
    // Convert wizard selections to IngredientSelection format
    const ingredients: IngredientSelection[] = [];
    
    Object.entries(selections).forEach(([category, ingredientNames]) => {
      if (ingredientNames && ingredientNames.length > 0) {
        // Start with a reasonable default based on category
        let defaultGrams = 50;
        if (category === 'proteins') defaultGrams = 100; // More protein
        else if (category === 'grains') defaultGrams = 60;
        else if (category === 'greens') defaultGrams = 40;
        else if (category === 'fruits') defaultGrams = 20;
        else if (category === 'supplements') defaultGrams = 5;
        
        // Add all selected ingredients from this category
        ingredientNames.forEach(ingredientName => {
          ingredients.push({
            key: ingredientName,
            grams: defaultGrams
          });
        });
      }
    });

    setSelectedIngredients(ingredients);
    setWizardCompleted(true);
    setShowWizard(false);
    setIsFirstCreation(true); // Mark as first creation to show popup
    
    // Analysis will be triggered automatically by the useEffect when ingredients change
    // After analysis completes, we can update to recommended amounts
  };

  // Handle start over
  const handleStartOver = () => {
    setSelectedIngredients([]);
    setAnalysis(null);
    setWizardCompleted(false);
    setShowWizard(true);
    setShowAddMore(false);
    setHasAppliedRecommended(false);
    setIsFirstCreation(false); // Reset first creation flag
  };

  // Handle add more ingredients
  const handleAddMore = () => {
    setShowAddMore(true);
  };

  // Auto-analyze recipe when ingredients change
  useEffect(() => {
    const analyzeRecipe = async () => {
      if (selectedIngredients.length > 0 && pet) {
        setIsAnalyzing(true);
        try {
          const petProfile = {
            id: pet.id,
            name: pet.names[0] || 'Pet',
            species: pet.type as any,
            lifeStage: pet.age as any, // Maps to 'adult', 'juvenile', etc.
            weightKg: parseFloat(pet.weight?.replace(/[^0-9.]/g, '')) || 5,
            allergies: [],
            activity: 'moderate' as const, // Default activity level
          };

          // Map ingredient display names to composition keys for analysis
          const mappedIngredients = selectedIngredients.map(sel => {
            const compositionKey = mapIngredientToCompositionKey(sel.key) || sel.key.toLowerCase().replace(/\s+/g, '_').replace(/[^a-z0-9_]/g, '');
            return {
              key: compositionKey,
              grams: sel.grams
            };
          });
          
          const result = generateCustomMealAnalysis(petProfile, mappedIngredients);
          setAnalysis(result);
          
          // After first analysis from wizard, auto-apply recommended amounts once
          if (result.recommendedServingGrams > 0 && selectedIngredients.length > 0 && wizardCompleted && !hasAppliedRecommended) {
            const currentTotal = selectedIngredients.reduce((sum, s) => sum + s.grams, 0);
            if (currentTotal > 0) {
              const recommendedTotal = result.recommendedServingGrams;
              const updatedIngredients = selectedIngredients.map(ing => {
                const ratio = ing.grams / currentTotal;
                return {
                  ...ing,
                  grams: Math.round(recommendedTotal * ratio)
                };
              });
              setSelectedIngredients(updatedIngredients);
              setHasAppliedRecommended(true);
            }
          }
        } catch (error) {
          // Analysis error - handled by error state
        } finally {
          setIsAnalyzing(false);
        }
      } else {
        setAnalysis(null);
      }
    };

    const debounceTimer = setTimeout(analyzeRecipe, 500);
    return () => clearTimeout(debounceTimer);
  }, [selectedIngredients, pet]);

  const addIngredient = (ingredientKey: string) => {
    // Check if ingredient is whitelisted for this species
    if (normalizedSpeciesType && whitelist.length > 0) {
      // ingredientKey might be a display name already, try both
      const displayName = ingredientKey; // Assume it's already a display name from the picker
      if (!isWhitelisted(displayName, normalizedSpeciesType as any)) {
        // Show warning but allow (user can override with vet approval)
        const confirmed = window.confirm(
          `${displayName} is not in the recommended whitelist for ${pet?.type}.\n\n` +
          `This ingredient may not be safe for this species. Please check with your vet before using.\n\n` +
          `Do you want to add it anyway?`
        );
        if (!confirmed) return;
      }
    }
    
    const existing = selectedIngredients.find(s => s.key === ingredientKey);
    if (existing) {
      setSelectedIngredients(prev =>
        prev.map(s =>
          s.key === ingredientKey
            ? { ...s, grams: s.grams + 50 }
            : s
        )
      );
    } else {
      setSelectedIngredients(prev => [...prev, { key: ingredientKey, grams: 50 }]);
    }
  };

  const removeIngredient = (ingredientKey: string) => {
    setSelectedIngredients(prev => prev.filter(s => s.key !== ingredientKey));
  };

  const updateIngredientGrams = (ingredientKey: string, grams: number) => {
    if (grams <= 0) {
      removeIngredient(ingredientKey);
      return;
    }

    setSelectedIngredients(prev =>
      prev.map(s =>
        s.key === ingredientKey
          ? { ...s, grams: Math.round(grams) }
          : s
      )
    );
  };

  const totalGrams = selectedIngredients.reduce((sum, s) => sum + s.grams, 0);

  if (!pet) {
    return (
      <div className="min-h-screen flex items-center justify-center" style={{ backgroundColor: '#0f2c0f' }}>
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-green-400"></div>
        <span className="ml-3 text-gray-300">Loading pet data...</span>
      </div>
    );
  }

  // Prepare categories for wizard
  const proteinRequired = !['pocket-pets', 'reptiles'].includes((normalizedSpeciesType || '').toLowerCase());

  const wizardCategories = categorizedIngredients ? {
    proteins: {
      ...categorizedIngredients.proteins,
      required: proteinRequired && categorizedIngredients.proteins.ingredients.length > 0
    },
    grains: {
      ...categorizedIngredients.grains,
      required: false
    },
    greens: {
      ...categorizedIngredients.greens,
      required: false
    },
    fruits: {
      ...categorizedIngredients.fruits,
      required: false
    },
    supplements: {
      ...categorizedIngredients.supplements,
      required: false
    }
  } : null;

  // Show wizard if not completed and no ingredients
  if (showWizard && wizardCategories) {
    return (
      <>
        {/* Species Coverage Badge */}
        {normalizedSpeciesType && (
          <div className="border-b px-4 py-2" style={{ backgroundColor: '#1a3d2e', borderColor: '#2d5a47' }}>
            <div className="max-w-7xl mx-auto flex items-center justify-between">
              <div className="flex items-center gap-2">
                <span className="text-sm text-gray-300">Ingredient Coverage:</span>
                <span className={`px-2 py-1 rounded text-xs font-semibold ${
                  speciesCoverageLevel === 'full' ? 'bg-green-100 text-green-800' :
                  speciesCoverageLevel === 'beta' ? 'bg-yellow-100 text-yellow-800' :
                  'bg-gray-100 text-gray-800'
                }`}>
                  {speciesCoverageLevel === 'full' ? '‚úì Full Coverage' :
                   speciesCoverageLevel === 'beta' ? 'Œ≤ Beta (Expanding)' :
                   '‚ö† Limited Data'}
                </span>
                {blacklist.length > 0 && (
                  <span className="text-xs text-gray-500">
                    ({blacklist.length} ingredients to avoid)
                  </span>
                )}
              </div>
            </div>
          </div>
        )}
        <MealBuilderWizard
          isOpen={showWizard}
          onClose={() => setShowWizard(false)}
          onComplete={handleWizardComplete}
          categories={wizardCategories}
          petName={pet.names[0] || 'Pet'}
          petType={normalizedSpeciesType || pet.type}
          recommendedIngredients={recommendedIngredientNames}
        />
        <div className="min-h-screen" style={{ backgroundColor: '#0f2c0f' }} />
      </>
    );
  }

  // Show meal complete view after wizard or if ingredients exist
  if (wizardCompleted || selectedIngredients.length > 0) {
    return (
      <>
        <MealCompleteView
          petName={pet.names[0] || 'Pet'}
          petBreed={pet.breed}
          petAge={pet.age}
          petWeight={pet.weight}
          petId={petId}
          userId={localStorage.getItem('last_user_id') || 'clerk_simulated_user_id_123'}
          selectedIngredients={selectedIngredients}
          analysis={analysis}
          isAnalyzing={isAnalyzing}
          onUpdateAmount={updateIngredientGrams}
          onRemove={removeIngredient}
          onAddMore={handleAddMore}
          onStartOver={handleStartOver}
          petType={pet.type}
          getIngredientDisplayName={(key) => {
            // Normalize key to match vetted products
            const normalized = key
              .toLowerCase()
              .replace(/_/g, ' ')      // chicken_breast ‚Üí chicken breast
              .replace(/-/g, ' ')      // chicken-breast ‚Üí chicken breast
              .trim();
            
            // Try to find display name in vetted products
            const product = require('@/lib/data/vetted-products').getVettedProduct(normalized);
            return product?.productName || normalized;
          }}
          isFirstCreation={isFirstCreation}
          getCompatibilityIndicator={(key) => {
            if (!analysis) return null;
            const hasToxicityWarning = analysis.toxicityWarnings.some(w => 
              w.ingredientKey === key || (w.ingredientName && w.ingredientName.toLowerCase().includes(key.toLowerCase()))
            );
            if (hasToxicityWarning) return 'blocked';
            const hasAllergyWarning = analysis.allergyWarnings.some(w => 
              (typeof w === 'string' ? w : w.message).toLowerCase().includes(key.toLowerCase())
            );
            if (hasAllergyWarning) return 'warning';
            return 'safe';
          }}
        />

        {/* Add More Ingredients Modal/View */}
        {showAddMore && categorizedIngredients && (
          <div className="fixed inset-0 z-50 bg-black bg-opacity-50 flex items-center justify-center p-4">
            <div className="bg-white rounded-lg shadow-xl max-w-6xl w-full max-h-[95vh] overflow-y-auto">
              <div className="p-6 border-b border-gray-200 flex items-center justify-between sticky top-0 bg-white z-10">
                <h2 className="text-xl font-bold text-gray-100">Add More Ingredients</h2>
                <button
                  onClick={() => setShowAddMore(false)}
                  className="p-2 hover:opacity-80 rounded-full transition-colors"
                  style={{ backgroundColor: '#2d5a47' }}
                >
                  <X size={20} className="text-gray-200" />
                </button>
              </div>
              <div className="p-6">
                {/* Recommended Ingredients Quick Add */}
                {suggestedIngredients.length > 0 && (
                  <div className="mb-6">
                    <div className="flex items-center gap-2 mb-3">
                      <span className="text-sm font-semibold text-gray-200">Recommended Additions:</span>
                      <span className="text-xs text-gray-400">Click to add quickly</span>
                    </div>
                    <div className="flex flex-wrap gap-2">
                      {suggestedIngredients
                        .filter(sug => !selectedIngredients.some(sel => sel.key === sug.name))
                        .slice(0, 12)
                        .map((suggestion, idx) => {
                          // Check if this ingredient comes from recommended meals
                          const fromMeal = recommendedMeals.some((meal: any) => {
                            const mealIngredients = meal.recipe?.ingredients || meal.adjustedIngredients || [];
                            return mealIngredients.some((ing: any) => 
                              (ing.name || ing.productName || '').toLowerCase() === suggestion.name.toLowerCase()
                            );
                          });
                          
                          return (
                            <button
                              key={idx}
                              onClick={() => {
                                addIngredient(suggestion.name);
                              }}
                              className={`flex items-center gap-1.5 px-2.5 py-1 rounded-md text-xs font-medium transition-opacity ${
                                fromMeal
                                  ? 'bg-green-50 border border-green-300 text-green-900 hover:opacity-80'
                                  : 'bg-blue-50 border border-blue-200 text-blue-900 hover:opacity-80'
                              }`}
                              title={suggestion.reason}
                            >
                              <span>{fromMeal ? '‚ú®' : '‚≠ê'}</span>
                              <span>{suggestion.name}</span>
                              {fromMeal && (
                                <span className="text-xs opacity-75">(from meals)</span>
                              )}
                            </button>
                          );
                        })}
                    </div>
                    {suggestedIngredients.filter(sug => !selectedIngredients.some(sel => sel.key === sug.name)).length === 0 && (
                      <p className="text-xs text-gray-500 italic">All recommended ingredients have been added</p>
                    )}
                  </div>
                )}

                {/* Search Bar */}
                <div className="mb-4">
                  <IngredientPicker
                    ingredients={availableIngredients.map(name => {
                      let category = 'Other';
                      for (const [catKey, cat] of Object.entries(categorizedIngredients)) {
                        if (cat.ingredients.includes(name)) {
                          category = cat.name;
                          break;
                        }
                      }
                      return { name, category };
                    })}
                    categories={categorizedIngredients}
                    onSelect={(ingredientName) => {
                      addIngredient(ingredientName);
                    }}
                    disabled={isAnalyzing}
                  />
                </div>
              </div>
            </div>
          </div>
        )}
      </>
    );
  }

  // Fallback: show original builder (shouldn't reach here normally)
  return (
    <div className="min-h-screen flex items-center justify-center" style={{ backgroundColor: '#0f2c0f' }}>
      <div className="text-center">
        <p className="text-gray-300 mb-4">Starting meal builder...</p>
        <button
          onClick={() => setShowWizard(true)}
          className="px-4 py-2 text-white rounded-md hover:opacity-90"
          style={{ backgroundColor: '#16a34a' }}
        >
          Start Wizard
        </button>
      </div>
    </div>
  );
}
</file>

<file path="app/profile/pet/[id]/saved-recipes/page.tsx">
'use client';

import React, { useState, useEffect, useMemo } from 'react';
import { useParams, useRouter } from 'next/navigation';
import Link from 'next/link';
import { HeartOff, ArrowLeft, Utensils, Clock, Trash2 } from 'lucide-react';
import { getCustomMeals, deleteCustomMeal } from '@/lib/utils/customMealStorage';
import { getPets, savePet } from '@/lib/utils/petStorage'; // Import async storage
import type { CustomMeal, Pet } from '@/lib/types';

// Same simulated user ID setup as profile/page.tsx
const SIMULATED_USER_ID = 'clerk_simulated_user_id_123';

const getCurrentUserId = () => {
  if (typeof window === 'undefined') return SIMULATED_USER_ID;
  return localStorage.getItem('last_user_id') || SIMULATED_USER_ID;
};

export default function SavedRecipesPage() {
  const { id: petId } = useParams();
  const router = useRouter();
  const [pet, setPet] = useState<Pet | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [userId, setUserId] = useState<string | null>(null);
  const [customMeals, setCustomMeals] = useState<CustomMeal[]>([]);

  // Load pet and custom meals - async function
  const loadData = async () => {
    const uid = getCurrentUserId();
    setUserId(uid);

    if (!petId) {
      setIsLoading(false);
      return;
    }

    const resolvedPetId = Array.isArray(petId) ? petId[0] : petId;
    
    try {
      // Load pets and find the current pet
      const pets = await getPets(uid);
      const foundPet = pets.find((p) => p.id === resolvedPetId);
      setPet(foundPet || null);
      
      // Load custom meals for this pet
      const meals = await getCustomMeals(uid, resolvedPetId);
      setCustomMeals(meals);
    } catch (error) {
      console.error('Error loading pet data:', error);
    } finally {
      setIsLoading(false);
    }
  };

  // Load pet and custom meals from storage
  useEffect(() => {
    loadData();
  }, [petId]);

  // Listen for updates to pets and custom meals
  useEffect(() => {
    if (typeof window === 'undefined') return;

    const handlePetsUpdated = (e: CustomEvent) => {
      // Refresh if pets were updated
      if (e.detail?.userId === getCurrentUserId()) {
        loadData();
      }
    };

    const handleStorageChange = (e: StorageEvent) => {
      // Refresh if pets or custom meals storage was modified (cross-tab/window)
      const uid = getCurrentUserId();
      if (e.key === `pets_${uid}` || e.key?.startsWith(`custom_meals_${uid}_`)) {
        loadData();
      }
    };

    window.addEventListener('petsUpdated', handlePetsUpdated as EventListener);
    window.addEventListener('storage', handleStorageChange);

    return () => {
      window.removeEventListener('petsUpdated', handlePetsUpdated as EventListener);
      window.removeEventListener('storage', handleStorageChange);
    };
  }, [petId]);

  // Map saved recipe IDs and custom meals to display format
  const savedRecipeDetails = useMemo(() => {
    const allMeals: {
      id: string;
      name: string;
      dateAdded?: number;
      isCustom?: boolean;
      compatibilityScore?: number;
    }[] = [];
    
    // Add custom meals (with compatibility score)
    customMeals.forEach((meal) => {
      allMeals.push({
        id: meal.id,
        name: meal.name,
        dateAdded: meal.createdAt ? new Date(meal.createdAt).getTime() : undefined,
        isCustom: true,
        compatibilityScore: meal.analysis?.score,
      });
    });
    
    return allMeals;
  }, [pet, customMeals]);

  const handleRemoveRecipe = async (recipeIdToRemove: string, isCustom: boolean = false) => {
    if (!userId || !pet) return;

    if (isCustom) {
      // Remove custom meal
      await deleteCustomMeal(userId, pet.id, recipeIdToRemove);
      setCustomMeals(prev => prev.filter(m => m.id !== recipeIdToRemove));
    } else {
      // Update the pet's savedRecipes array
      const updatedPet: Pet = {
        ...pet,
        savedRecipes: (pet.savedRecipes || []).filter(id => id !== recipeIdToRemove),
      };

      await savePet(userId, updatedPet);
      setPet(updatedPet);
    }
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-screen bg-gray-50">
        <p className="text-xl text-green-800 font-medium">Loading pet profile...</p>
      </div>
    );
  }

  if (!pet) {
    return (
      <div className="max-w-4xl mx-auto py-12 px-4 text-center">
        <HeartOff className="w-16 h-16 text-red-500 mx-auto mb-4" />
        <h1 className="text-3xl font-bold text-gray-900 mb-2">Pet Not Found</h1>
        <p className="text-gray-600">
          We couldn't find a pet with the ID:{' '}
          <span className="font-mono bg-gray-100 p-1 rounded text-sm">{String(petId)}</span>.
        </p>
        <Link
          href="/profile"
          className="mt-6 inline-flex items-center text-green-800 hover:text-green-900 transition-colors font-medium"
        >
          <ArrowLeft className="w-5 h-5 mr-2" /> Back to Pet Profiles
        </Link>
      </div>
    );
  }

  const hasSaved = savedRecipeDetails.length > 0;

  // Get random name from pet's names array
  const petNames = Array.isArray((pet as any).names) ? (pet as any).names.filter((n: string) => n && n.trim() !== '') : [];
  const petDisplayName = petNames.length > 0 
    ? petNames[Math.floor(Math.random() * petNames.length)]
    : (pet.name || 'Your Pet');

  return (
    <div className="min-h-screen bg-gray-50 py-4">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <Link
          href="/profile"
          className="inline-flex items-center text-gray-500 hover:text-green-800 transition-colors mb-3 text-sm"
        >
          <ArrowLeft className="w-4 h-4 mr-1" /> Back to Pet Profiles
        </Link>

        <header className="mb-4 p-3 bg-white rounded-lg shadow border-l-4 border-primary-600">
          <h1 className="text-xl font-bold text-gray-900 flex items-center">
            <Utensils className="w-5 h-5 mr-2 text-primary-600" />
            Saved Meals for {petDisplayName}
          </h1>
          <p className="text-sm text-gray-600 mt-1">
            A curated collection for your <span className="capitalize font-medium">{pet.type}</span>, the {pet.breed}.
          </p>
        </header>

        {hasSaved && (
          <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3 mb-6">
            <p className="text-sm text-gray-600">
              {savedRecipeDetails.length} meals saved for {petDisplayName}.
            </p>
            <button
              onClick={() => router.push(`/profile/pet/${pet.id}/meal-plan`)}
              disabled={savedRecipeDetails.length < 2}
              className={`px-5 py-3 rounded-lg font-semibold transition-colors ${
                savedRecipeDetails.length < 2
                  ? 'bg-gray-200 text-gray-500 cursor-not-allowed'
                  : 'bg-green-800 text-white hover:bg-green-900'
              }`}
            >
              Create Meal Plan
            </button>
          </div>
        )}

        <div className="space-y-4">
          {hasSaved ? (
            savedRecipeDetails.map((recipe) => (
              <div
                key={recipe.id}
                className="flex items-center p-4 bg-white rounded-xl shadow hover:shadow-md transition-shadow justify-between"
              >
                <Link
                  href={`/recipe/${recipe.id}?petId=${pet.id}`}
                  className="flex items-center flex-grow group"
                >
                  <div className="ml-0 flex-1">
                    <div className="flex items-center gap-2 flex-wrap">
                      <p className="text-lg font-semibold text-gray-800 group-hover:text-primary-600 transition-colors">
                        {recipe.name}
                      </p>
                      {recipe.isCustom && (
                        <span className="text-xs bg-blue-100 text-blue-800 px-2 py-0.5 rounded-full font-medium">
                          Custom
                        </span>
                      )}
                      {recipe.isCustom && recipe.compatibilityScore !== undefined && (
                        <div className="flex items-center gap-1.5 px-2 py-0.5 rounded-full bg-gray-100">
                          <span className="text-xs font-medium text-gray-600">Score:</span>
                          <span className={`text-xs font-bold ${
                            recipe.compatibilityScore >= 80 ? 'text-green-600' :
                            recipe.compatibilityScore >= 60 ? 'text-yellow-600' :
                            'text-red-600'
                          }`}>
                            {recipe.compatibilityScore}
                          </span>
                        </div>
                      )}
                    </div>
                    {recipe.dateAdded && (
                      <div className="flex items-center text-sm text-gray-500 mt-1">
                        <Clock className="w-3 h-3 mr-1" />
                        <span>
                          Saved: {new Date(recipe.dateAdded).toLocaleDateString()}
                        </span>
                      </div>
                    )}
                  </div>
                </Link>

                <button
                  onClick={() => handleRemoveRecipe(recipe.id, recipe.isCustom)}
                  className="ml-4 p-2 text-red-500 hover:bg-red-50 rounded-full transition-colors"
                  aria-label={`Remove ${recipe.name}`}
                >
                  <Trash2 className="w-5 h-5" />
                </button>
              </div>
            ))
          ) : (
            <div className="text-center p-10 bg-white rounded-xl shadow-inner border border-gray-200">
              <HeartOff className="w-12 h-12 text-gray-400 mx-auto mb-3" />
              <p className="text-xl font-medium text-gray-700">No Saved Meals Yet!</p>
              <p className="text-gray-500 mt-2">
                Start by browsing our catalog to find the perfect meal for {petDisplayName}.
              </p>
              <Link
                href={`/profile/pet/${pet.id}`}
                className="mt-4 inline-block px-6 py-2 bg-green-800 text-white rounded-lg hover:bg-green-900 transition-colors font-medium shadow-md"
              >
                Find Meals
              </Link>
            </div>
          )}
        </div>
      </div>

      <p className="fixed bottom-4 right-4 text-xs text-gray-400">
        Current User ID: {userId || 'Unknown'} (Pet ID: {String(petId)})
      </p>
    </div>
  );
}
</file>

<file path="components/MealBuilderWizard.tsx">
'use client';

import { useState, useMemo } from 'react';
import { X, ChevronRight, ChevronLeft, Check, Star, ArrowUp } from 'lucide-react';
import { createPortal } from 'react-dom';
import Image from 'next/image';
import { INGREDIENT_COMPOSITIONS, getIngredientComposition, type IngredientComposition } from '@/lib/data/ingredientCompositions';
import { getFallbackNutrition } from '@/lib/utils/nutritionFallbacks';

interface Category {
  name: string;
  description: string;
  icon: string;
  ingredients: string[];
  required: boolean;
}

interface MealBuilderWizardProps {
  isOpen: boolean;
  onClose: () => void;
  onComplete: (selections: { [category: string]: string[] }) => void;
  categories: {
    proteins: Category;
    grains: Category;
    greens: Category;
    fruits: Category;
    supplements: Category;
  };
  petName: string;
  petType?: string; // Pet species type (dogs, cats, pocket-pets, etc.)
  recommendedIngredients?: string[]; // List of recommended ingredient names
}

const CATEGORY_ORDER = ['proteins', 'grains', 'greens', 'fruits', 'supplements'] as const;

/**
 * Get the highest nutrient value for an ingredient
 * Returns the nutrient name and a normalized value for comparison
 */
function getTopNutrients(ingredientName: string, count: number = 3): Array<{ name: string; value: number }> {
  // Normalize ingredient name
  const normalized = ingredientName.toLowerCase()
    .trim()
    .replace(/\s+/g, '_')
    .replace(/[^a-z0-9_]/g, '')
    .replace(/_+/g, '_');
  
  // Try to get composition
  let composition: IngredientComposition | null = INGREDIENT_COMPOSITIONS[normalized] || null;
  if (!composition) {
    composition = getIngredientComposition(ingredientName) || null;
  }
  if (!composition) {
    // Try fallback
    composition = getFallbackNutrition(ingredientName);
  }
  
  if (!composition) return [];
  
  // Define nutrients to check with their display names and normalization factors
  const nutrients = [
    { key: 'protein', name: 'Protein', value: composition.protein || 0, factor: 1 },
    { key: 'fat', name: 'Fat', value: composition.fat || 0, factor: 1 },
    { key: 'fiber', name: 'Fiber', value: composition.fiber || 0, factor: 1 },
    { key: 'calcium', name: 'Calcium', value: (composition.calcium || 0) / 100, factor: 100 }, // Convert mg to g for comparison
    { key: 'omega3', name: 'Omega-3', value: composition.omega3 || 0, factor: 1 },
    { key: 'taurine', name: 'Taurine', value: (composition.taurine || 0) / 100, factor: 100 }, // Convert mg to g
    { key: 'vitaminA', name: 'Vitamin A', value: (composition.vitaminA || 0) / 1000, factor: 1000 }, // Convert IU to thousands
    { key: 'vitaminC', name: 'Vitamin C', value: (composition.vitaminC || 0) / 100, factor: 100 }, // Convert mg to g
  ];
  
  // Calculate normalized values and filter out insignificant ones
  const nutrientsWithNormalized = nutrients
    .map(nutrient => ({
      ...nutrient,
      normalizedValue: nutrient.value * nutrient.factor
    }))
    .filter(nutrient => nutrient.normalizedValue > 0.1); // Only include significant values
  
  // Sort by normalized value (descending) and take top N
  const topNutrients = nutrientsWithNormalized
    .sort((a, b) => b.normalizedValue - a.normalizedValue)
    .slice(0, count)
    .map(nutrient => ({
      name: nutrient.name,
      value: nutrient.value
    }));
  
  return topNutrients;
}

export default function MealBuilderWizard({
  isOpen,
  onClose,
  onComplete,
  categories,
  petName,
  petType,
  recommendedIngredients = []
}: MealBuilderWizardProps) {
  const skipProteins = !categories.proteins.required || categories.proteins.ingredients.length === 0;
  const skipFruits = petType && ['dogs', 'cats', 'dog', 'cat'].includes(petType.toLowerCase());
  const stepOrder = CATEGORY_ORDER.filter((key) => {
    if (skipProteins && key === 'proteins') return false;
    if (skipFruits && key === 'fruits') return false;
    return true;
  });

  const [currentStep, setCurrentStep] = useState(0);
  const [selections, setSelections] = useState<{ [key: string]: string[] }>({
    proteins: [],
    grains: [],
    greens: [],
    fruits: [],
    supplements: []
  });

  if (!isOpen) return null;

  const currentCategoryKey = stepOrder[currentStep];
  const currentCategory = categories[currentCategoryKey];
  const isRequired = currentCategory.required;
  const currentSelections = selections[currentCategoryKey] || [];
  const hasSelection = currentSelections.length > 0;
  const hasIngredients = currentCategory.ingredients.length > 0;
  // Allow proceeding if: not required, OR has selection, OR required but no ingredients available
  const canProceed = !isRequired || hasSelection || !hasIngredients;
  const isLastStep = currentStep === stepOrder.length - 1;

  const handleSelect = (ingredient: string) => {
    setSelections(prev => {
      const current = prev[currentCategoryKey] || [];
      const isSelected = current.includes(ingredient);
      return {
        ...prev,
        [currentCategoryKey]: isSelected 
          ? current.filter(ing => ing !== ingredient)
          : [...current, ingredient]
      };
    });
  };

  const handleNext = () => {
    if (isLastStep) {
      onComplete(selections);
      handleClose();
    } else {
      setCurrentStep(prev => prev + 1);
    }
  };

  const handleBack = () => {
    if (currentStep > 0) {
      setCurrentStep(prev => prev - 1);
    }
  };

  const handleClose = () => {
    setCurrentStep(0);
    setSelections({
      proteins: [],
      grains: [],
      greens: [],
      fruits: [],
      supplements: []
    });
    onClose();
  };

  const wizardContent = (
    <div className="fixed inset-0 z-50 flex items-center justify-center p-4" style={{ backgroundColor: '#0f2c0f' }}>
      <div className="rounded-lg shadow-xl max-w-2xl w-full max-h-[90vh] flex flex-col" style={{ backgroundColor: '#143424' }}>
        {/* Header */}
        <div className="flex items-center justify-between p-6 border-b" style={{ borderColor: '#2d5a47' }}>
          <div>
            <h2 className="text-2xl font-bold text-gray-100">
              Create Meal for {petName}
            </h2>
            <p className="text-sm text-gray-300 mt-1">
              Step {currentStep + 1} of {stepOrder.length}
            </p>
          </div>
          <button
            onClick={handleClose}
            className="p-2 hover:opacity-80 rounded-full transition-colors"
            style={{ backgroundColor: '#2d5a47' }}
          >
            <X size={20} className="text-gray-200" />
          </button>
        </div>

        {/* Progress Bar */}
        <div className="px-6 py-4 border-b" style={{ backgroundColor: '#143424', borderColor: '#2d5a47' }}>
          <div className="flex gap-2">
            {stepOrder.map((key, index) => {
              const category = categories[key];
              const isActive = index === currentStep;
              const isCompleted = (selections[key] || []).length > 0;
              const isPast = index < currentStep;

              return (
                <div key={key} className="flex-1">
                  <div className="flex items-center gap-2">
                    <div
                      className={`flex-1 h-2 rounded-full transition-colors ${
                        isActive
                          ? 'bg-primary-600'
                          : isCompleted || isPast
                          ? 'bg-green-500'
                          : 'bg-gray-200'
                      }`}
                    />
                    {isCompleted && !isActive && (
                      <Check size={16} className="text-green-400 flex-shrink-0" />
                    )}
                  </div>
                  <div className="text-xs text-gray-300 mt-1 truncate">
                    {category.icon} {category.name}
                  </div>
                </div>
              );
            })}
          </div>
        </div>

        {/* Category Content */}
        <div className="flex-1 overflow-y-auto p-6">
          <div className="text-center mb-6">
            {currentStep === 0 && (
              <div className="mb-4 flex justify-center">
                <Image
                  src="/images/emojis/Mascots/PrepPuppy/PrepPuppyKitchen.jpg"
                  alt="Puppy Prepper"
                  width={240}
                  height={240}
                  className="w-[240px] h-[240px] object-contain"
                  unoptimized
                />
              </div>
            )}
            <div className="text-4xl mb-2">{currentCategory.icon}</div>
            <h3 className="text-xl font-semibold text-gray-100 mb-1">
              {currentCategory.name}
            </h3>
            <p className="text-sm text-gray-300">{currentCategory.description}</p>
            {isRequired && hasIngredients && (
              <p className="text-xs text-red-400 mt-2">* Required</p>
            )}
            {isRequired && !hasIngredients && (
              <p className="text-xs text-yellow-400 mt-2">‚ö† No ingredients available - you can skip this step</p>
            )}
          </div>

          {/* Ingredient List */}
          <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
            {currentCategory.ingredients.length === 0 ? (
              <div className="col-span-2 text-center py-8 text-gray-400">
                No ingredients available in this category for this pet.
              </div>
            ) : (() => {
              // Separate recommended and regular ingredients
              const recommended = currentCategory.ingredients.filter(ing => 
                recommendedIngredients.includes(ing)
              );
              const regular = currentCategory.ingredients.filter(ing => 
                !recommendedIngredients.includes(ing)
              );
              
              // Sort: recommended first, then regular
              const sortedIngredients = [...recommended, ...regular];
              
              return sortedIngredients.map(ingredient => {
                const isSelected = currentSelections.includes(ingredient);
                const isRecommended = recommendedIngredients.includes(ingredient);
                const topNutrients = getTopNutrients(ingredient, 3);
                
                return (
                  <button
                    key={ingredient}
                    onClick={() => handleSelect(ingredient)}
                    className="p-4 rounded-lg text-left transition-colors duration-200 relative"
                    style={{
                      border: isSelected ? '3px solid #f97316' : isRecommended ? '3px solid #fb923c' : '3px solid rgba(249, 115, 22, 0.5)',
                      backgroundColor: isSelected ? '#2d5a47' : isRecommended ? '#3d4a2e' : '#143424',
                      color: '#e5e7eb'
                    }}
                  >
                    <div className="flex items-center justify-between">
                      <div className="flex items-center gap-2 flex-1 min-w-0">
                        {isRecommended && (
                          <Star size={16} className="text-yellow-400 fill-yellow-400 flex-shrink-0" />
                        )}
                        <span className="text-sm font-medium truncate text-gray-100">
                          {ingredient}
                        </span>
                      </div>
                      {isSelected && (
                        <Check size={18} className="text-green-400 flex-shrink-0 ml-2" />
                      )}
                    </div>
                    <div className="flex items-center justify-between mt-2 flex-wrap gap-2">
                      {isRecommended && (
                        <div className="text-xs text-yellow-300">
                          Recommended
                        </div>
                      )}
                      {topNutrients.length > 0 && (
                        <div className="flex items-center gap-2 ml-auto flex-wrap">
                          {topNutrients.map((nutrient, idx) => (
                            <div key={idx} className="flex items-center gap-1 text-xs text-orange-300">
                              <ArrowUp size={12} className="text-orange-400" />
                              <span>{nutrient.name}</span>
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                  </button>
                );
              });
            })()}
          </div>
        </div>

        {/* Footer Actions */}
        <div className="flex items-center justify-between p-6 border-t" style={{ borderColor: '#2d5a47', backgroundColor: '#143424' }}>
          <button
            onClick={handleBack}
            disabled={currentStep === 0}
            className="flex items-center gap-2 px-4 py-2 text-sm font-medium rounded-md disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
            style={{
              backgroundColor: '#2d5a47',
              border: '3px solid #f97316',
              color: '#e5e7eb'
            }}
          >
            <ChevronLeft size={16} />
            Back
          </button>

          <div className="flex gap-3">
            <button
              onClick={handleNext}
              disabled={!canProceed}
              className="flex items-center gap-2 px-6 py-2 text-sm font-medium text-white rounded-md disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
              style={{
                backgroundColor: '#16a34a',
                border: '3px solid #f97316'
              }}
            >
              {isLastStep ? 'Complete' : 'Next'}
              {!isLastStep && <ChevronRight size={16} />}
            </button>
          </div>
        </div>
      </div>
    </div>
  );

  // Use portal to render modal at root level
  if (typeof window !== 'undefined') {
    return createPortal(wizardContent, document.body);
  }

  return null;
}
</file>

<file path="lib/generator/AmazonLinkAudit.ts">
// Amazon Affiliate Link Audit
// Checks all asinLink values in vetted-products for issues

import { VETTED_PRODUCTS } from '../data/vetted-products';

interface LinkIssue {
  ingredient: string;
  issue: string;
  asinLink?: string;
  productName?: string;
}

const issues: LinkIssue[] = [];
const stats = {
  total: 0,
  withLinks: 0,
  withoutLinks: 0,
  invalidFormat: 0,
  missingAsin: 0,
  suspiciousLinks: 0,
  duplicateAsins: new Map<string, string[]>(),
};

console.log('='.repeat(80));
console.log('AMAZON AFFILIATE LINK AUDIT');
console.log('='.repeat(80));
console.log();

// Check each product
for (const [ingredientName, product] of Object.entries(VETTED_PRODUCTS)) {
  stats.total++;
  
  const asinLink = product.asinLink;
  
  // Issue 1: Missing asinLink
  if (!asinLink || asinLink === '') {
    stats.withoutLinks++;
    issues.push({
      ingredient: ingredientName,
      issue: 'Missing asinLink',
      productName: product.productName,
    });
    continue;
  }
  
  stats.withLinks++;
  
  // Issue 2: Invalid format (should be Amazon URL)
  if (!asinLink.includes('amazon.com')) {
    stats.invalidFormat++;
    issues.push({
      ingredient: ingredientName,
      issue: 'Not an Amazon link',
      asinLink,
      productName: product.productName,
    });
    continue;
  }
  
  // Issue 3: Missing ASIN in URL
  const asinMatch = asinLink.match(/\/dp\/([A-Z0-9]{10})/i);
  if (!asinMatch) {
    stats.missingAsin++;
    issues.push({
      ingredient: ingredientName,
      issue: 'No valid ASIN found in URL',
      asinLink,
      productName: product.productName,
    });
    continue;
  }
  
  const asin = asinMatch[1];
  
  // Issue 4: Missing affiliate tag
  if (!asinLink.includes('tag=robinfrench-20')) {
    stats.suspiciousLinks++;
    issues.push({
      ingredient: ingredientName,
      issue: 'Missing affiliate tag (tag=robinfrench-20)',
      asinLink,
      productName: product.productName,
    });
  }
  
  // Track duplicate ASINs
  if (!stats.duplicateAsins.has(asin)) {
    stats.duplicateAsins.set(asin, []);
  }
  stats.duplicateAsins.get(asin)!.push(ingredientName);
}

// Find actual duplicates (same ASIN used for multiple ingredients)
const duplicates = Array.from(stats.duplicateAsins.entries())
  .filter(([_, ingredients]) => ingredients.length > 1);

// Print Summary
console.log('SUMMARY');
console.log('-'.repeat(80));
console.log(`Total products: ${stats.total}`);
console.log(`With links: ${stats.withLinks} (${((stats.withLinks / stats.total) * 100).toFixed(1)}%)`);
console.log(`Without links: ${stats.withoutLinks} (${((stats.withoutLinks / stats.total) * 100).toFixed(1)}%)`);
console.log();
console.log(`Issues found: ${issues.length}`);
console.log(`  - Invalid format: ${stats.invalidFormat}`);
console.log(`  - Missing ASIN: ${stats.missingAsin}`);
console.log(`  - Missing affiliate tag: ${stats.suspiciousLinks}`);
console.log(`  - Duplicate ASINs: ${duplicates.length} ASINs used for multiple ingredients`);
console.log();

// Print Issues
if (issues.length > 0) {
  console.log('='.repeat(80));
  console.log('ISSUES FOUND');
  console.log('='.repeat(80));
  console.log();
  
  // Group by issue type
  const byType = issues.reduce((acc, issue) => {
    if (!acc[issue.issue]) acc[issue.issue] = [];
    acc[issue.issue].push(issue);
    return acc;
  }, {} as Record<string, LinkIssue[]>);
  
  for (const [issueType, issueList] of Object.entries(byType)) {
    console.log(`${issueType} (${issueList.length}):`);
    console.log('-'.repeat(80));
    
    issueList.slice(0, 10).forEach(issue => {
      console.log(`  Ingredient: ${issue.ingredient}`);
      if (issue.productName) console.log(`  Product: ${issue.productName}`);
      if (issue.asinLink) console.log(`  Link: ${issue.asinLink}`);
      console.log();
    });
    
    if (issueList.length > 10) {
      console.log(`  ... and ${issueList.length - 10} more`);
      console.log();
    }
  }
}

// Print Duplicate ASINs
if (duplicates.length > 0) {
  console.log('='.repeat(80));
  console.log('DUPLICATE ASINs');
  console.log('='.repeat(80));
  console.log();
  console.log('Same ASIN used for multiple ingredients (may indicate incorrect mappings):');
  console.log();
  
  duplicates.slice(0, 20).forEach(([asin, ingredients]) => {
    console.log(`ASIN ${asin} used for ${ingredients.length} ingredients:`);
    ingredients.forEach(ing => console.log(`  - ${ing}`));
    console.log();
  });
  
  if (duplicates.length > 20) {
    console.log(`... and ${duplicates.length - 20} more duplicate ASINs`);
  }
}

// Print recommendations
console.log('='.repeat(80));
console.log('RECOMMENDATIONS');
console.log('='.repeat(80));
console.log();

if (stats.withoutLinks > 0) {
  console.log(`1. Add asinLink for ${stats.withoutLinks} products without links`);
}

if (stats.invalidFormat > 0) {
  console.log(`2. Fix ${stats.invalidFormat} products with invalid link format`);
}

if (stats.missingAsin > 0) {
  console.log(`3. Fix ${stats.missingAsin} products with missing/invalid ASIN`);
}

if (stats.suspiciousLinks > 0) {
  console.log(`4. Add affiliate tag to ${stats.suspiciousLinks} products`);
}

if (duplicates.length > 0) {
  console.log(`5. Review ${duplicates.length} duplicate ASINs - may indicate wrong products`);
}

if (issues.length === 0 && duplicates.length === 0) {
  console.log('‚úÖ All links look good! No issues found.');
}

console.log();
console.log('='.repeat(80));
</file>

<file path="lib/generator/AutoClassifyLinks.ts">
// Auto-classify all 94 items using spec-based validation
// Reduces manual review from 94 ‚Üí ~15-20 items

import { VETTED_PRODUCTS } from '../data/vetted-products';
import { RETAIL_SPECS } from '../validation/retailSpecDefinitions';
import { RetailValidator } from '../validation/retailValidator';
import * as fs from 'fs';
import * as path from 'path';

interface ClassificationResult {
  ingredient: string;
  productName: string;
  asin: string;
  link: string;
  status: 'auto-valid' | 'auto-invalid' | 'needs-review' | 'no-spec';
  confidence: 'high' | 'medium' | 'low';
  issues: string[];
  notes: string;
}

const validator = new RetailValidator();
const results: ClassificationResult[] = [];

console.log('='.repeat(80));
console.log('AUTO-CLASSIFYING AMAZON LINKS');
console.log('='.repeat(80));
console.log();

// Track duplicate ASINs
const asinMap = new Map<string, string[]>();
for (const [ingredientName, product] of Object.entries(VETTED_PRODUCTS)) {
  const asinMatch = product.asinLink.match(/\/dp\/([A-Z0-9]{10})/i);
  if (asinMatch) {
    const asin = asinMatch[1];
    if (!asinMap.has(asin)) {
      asinMap.set(asin, []);
    }
    asinMap.get(asin)!.push(ingredientName);
  }
}

// Known dead links
const deadLinks = new Set(['B0082C00P8', 'B0006L2XNK']);

// Process each ingredient
for (const [ingredientName, product] of Object.entries(VETTED_PRODUCTS)) {
  const asinMatch = product.asinLink.match(/\/dp\/([A-Z0-9]{10})/i);
  if (!asinMatch) continue;
  
  const asin = asinMatch[1];
  const spec = RETAIL_SPECS[ingredientName];
  
  let status: ClassificationResult['status'];
  let confidence: ClassificationResult['confidence'];
  let issues: string[] = [];
  let notes = '';
  
  // Dead link check
  if (deadLinks.has(asin)) {
    status = 'auto-invalid';
    confidence = 'high';
    issues.push('Dead link (HTTP 405)');
    notes = 'NEEDS REPLACEMENT - Link is dead';
  }
  // Has spec - validate it
  else if (spec) {
    const validationResult = validator.validateProductTitle(
      product.productName,
      spec,
      asin
    );
    
    confidence = validationResult.confidence;
    issues = validationResult.issues.map(i => `${i.severity.toUpperCase()}: ${i.message}`);
    
    if (validationResult.status === 'valid') {
      status = 'auto-valid';
      notes = '‚úÖ Passes all validation checks';
    } else if (validationResult.status === 'invalid') {
      status = 'auto-invalid';
      notes = '‚ùå Failed validation - likely wrong product';
    } else {
      status = 'needs-review';
      notes = '‚ö†Ô∏è Ambiguous - manual review needed';
    }
  }
  // No spec - check if duplicate ASIN
  else {
    const duplicates = asinMap.get(asin) || [];
    if (duplicates.length > 1) {
      status = 'needs-review';
      confidence = 'medium';
      issues.push(`Duplicate ASIN shared with: ${duplicates.filter(d => d !== ingredientName).join(', ')}`);
      notes = '‚ö†Ô∏è Duplicate ASIN - verify if appropriate';
    } else {
      status = 'no-spec';
      confidence = 'medium';
      notes = 'No validation spec defined - assumed OK';
    }
  }
  
  results.push({
    ingredient: ingredientName,
    productName: product.productName,
    asin,
    link: product.asinLink,
    status,
    confidence,
    issues,
    notes,
  });
}

// Generate statistics
const stats = {
  total: results.length,
  autoValid: results.filter(r => r.status === 'auto-valid').length,
  autoInvalid: results.filter(r => r.status === 'auto-invalid').length,
  needsReview: results.filter(r => r.status === 'needs-review').length,
  noSpec: results.filter(r => r.status === 'no-spec').length,
};

console.log('CLASSIFICATION RESULTS');
console.log('-'.repeat(80));
console.log(`Total items: ${stats.total}`);
console.log(`‚úÖ Auto-valid: ${stats.autoValid} (${((stats.autoValid / stats.total) * 100).toFixed(1)}%)`);
console.log(`‚ùå Auto-invalid: ${stats.autoInvalid} (${((stats.autoInvalid / stats.total) * 100).toFixed(1)}%)`);
console.log(`‚ö†Ô∏è  Needs review: ${stats.needsReview} (${((stats.needsReview / stats.total) * 100).toFixed(1)}%)`);
console.log(`üìã No spec: ${stats.noSpec} (${((stats.noSpec / stats.total) * 100).toFixed(1)}%)`);
console.log();
console.log(`Manual review reduced from 94 ‚Üí ${stats.needsReview + stats.autoInvalid} items`);
console.log();

// Show items needing review
const reviewItems = results.filter(r => r.status === 'needs-review' || r.status === 'auto-invalid');

if (reviewItems.length > 0) {
  console.log('='.repeat(80));
  console.log(`ITEMS REQUIRING MANUAL REVIEW (${reviewItems.length})`);
  console.log('='.repeat(80));
  console.log();
  
  reviewItems.forEach((item, idx) => {
    console.log(`${idx + 1}. ${item.ingredient}`);
    console.log(`   Product: ${item.productName}`);
    console.log(`   ASIN: ${item.asin}`);
    console.log(`   Status: ${item.status.toUpperCase()}`);
    console.log(`   Confidence: ${item.confidence.toUpperCase()}`);
    if (item.issues.length > 0) {
      console.log(`   Issues:`);
      item.issues.forEach(issue => console.log(`     - ${issue}`));
    }
    console.log(`   Notes: ${item.notes}`);
    console.log(`   Link: ${item.link}`);
    console.log();
  });
}

// Generate CSV for manual review
const csvHeader = 'Status,Ingredient,Product Name,ASIN,Confidence,Issues,Notes,Action Needed,Link\n';
const csvRows = reviewItems.map(item => {
  const escapeCsv = (str: string) => `"${str.replace(/"/g, '""')}"`;
  return [
    item.status.toUpperCase(),
    escapeCsv(item.ingredient),
    escapeCsv(item.productName),
    item.asin,
    item.confidence.toUpperCase(),
    escapeCsv(item.issues.join('; ')),
    escapeCsv(item.notes),
    item.status === 'auto-invalid' ? 'FIND NEW ASIN' : 'VERIFY',
    item.link,
  ].join(',');
}).join('\n');

const csv = csvHeader + csvRows;
const outputPath = path.join(process.cwd(), 'MANUAL_REVIEW_REQUIRED.csv');
fs.writeFileSync(outputPath, csv, 'utf-8');

console.log('='.repeat(80));
console.log('NEXT STEPS');
console.log('='.repeat(80));
console.log();
console.log(`1. Open MANUAL_REVIEW_REQUIRED.csv (${reviewItems.length} items)`);
console.log('2. Click each link and verify product matches ingredient');
console.log('3. For AUTO-INVALID items: Find replacement ASIN');
console.log('4. For NEEDS-REVIEW items: Confirm if product is correct');
console.log();
console.log(`CSV saved to: ${outputPath}`);
console.log();

// Generate summary report
const report = `# Auto-Classification Report

## Summary

**Total items processed:** ${stats.total}

- ‚úÖ **Auto-valid:** ${stats.autoValid} (${((stats.autoValid / stats.total) * 100).toFixed(1)}%)
- ‚ùå **Auto-invalid:** ${stats.autoInvalid} (${((stats.autoInvalid / stats.total) * 100).toFixed(1)}%)
- ‚ö†Ô∏è **Needs review:** ${stats.needsReview} (${((stats.needsReview / stats.total) * 100).toFixed(1)}%)
- üìã **No spec:** ${stats.noSpec} (${((stats.noSpec / stats.total) * 100).toFixed(1)}%)

**Manual review reduced:** 94 ‚Üí ${stats.needsReview + stats.autoInvalid} items (${Math.round((1 - (stats.needsReview + stats.autoInvalid) / 94) * 100)}% reduction)

---

## Auto-Invalid Items (${stats.autoInvalid})

These items failed validation and need replacement ASINs:

${results.filter(r => r.status === 'auto-invalid').map(item => 
  `### ${item.ingredient}
- **Product:** ${item.productName}
- **ASIN:** ${item.asin}
- **Issues:** ${item.issues.join(', ')}
- **Action:** Find correct product on Amazon
- **Link:** ${item.link}
`).join('\n')}

---

## Needs Review (${stats.needsReview})

These items are ambiguous and need human verification:

${results.filter(r => r.status === 'needs-review').slice(0, 10).map(item =>
  `### ${item.ingredient}
- **Product:** ${item.productName}
- **ASIN:** ${item.asin}
- **Issues:** ${item.issues.join(', ')}
- **Action:** Verify if product is correct
- **Link:** ${item.link}
`).join('\n')}

${stats.needsReview > 10 ? `\n... and ${stats.needsReview - 10} more (see CSV)\n` : ''}

---

## Auto-Valid Items (${stats.autoValid})

These items passed all validation checks and are assumed correct.

---

## Next Steps

1. **Review the ${reviewItems.length} flagged items** in MANUAL_REVIEW_REQUIRED.csv
2. **Find replacement ASINs** for auto-invalid items
3. **Verify ambiguous items** by clicking links
4. **Update vetted-products.ts** with corrections

---

## Phase 2: PA-API Integration

After manual review is complete, we'll implement:
- Automated metadata fetching from Amazon PA-API
- Price and availability tracking
- Automatic re-validation of stale links
- Confidence scoring and caching
`;

const reportPath = path.join(process.cwd(), 'AUTO_CLASSIFICATION_REPORT.md');
fs.writeFileSync(reportPath, report, 'utf-8');

console.log(`Report saved to: ${reportPath}`);
console.log();
console.log('='.repeat(80));
</file>

<file path="lib/generator/BirdDebug.ts">
// Detailed debug for bird recipe generation
import { RecipeBuilder, type GenerationConstraints } from './RecipeBuilder';
import { getIngredientsForSpecies } from '../data/ingredients';

const constraints: GenerationConstraints = {
  species: 'birds',
  lifeStage: 'adult',
  petWeightKg: 0.5,
  healthConcerns: ['digestive_issues'],
  targetCalories: 100,
};

console.log('=== BIRD RECIPE DEBUG ===\n');

// Check available ingredients
const allBirdIngredients = getIngredientsForSpecies('birds');
console.log(`Total bird ingredients available: ${allBirdIngredients.length}`);

const seeds = allBirdIngredients.filter(ing => ing.category === 'seed');
const nuts = allBirdIngredients.filter(ing => ing.category === 'nut');
const insects = allBirdIngredients.filter(ing => ing.category === 'insect');
const fruits = allBirdIngredients.filter(ing => ing.category === 'fruit');
const vegetables = allBirdIngredients.filter(ing => ing.category === 'vegetable');

console.log(`\nBy category:`);
console.log(`  Seeds: ${seeds.length}`);
console.log(`  Nuts: ${nuts.length}`);
console.log(`  Insects: ${insects.length}`);
console.log(`  Fruits: ${fruits.length}`);
console.log(`  Vegetables: ${vegetables.length}`);

console.log(`\nSample seeds:`);
seeds.slice(0, 5).forEach(s => console.log(`  - ${s.name} (id: ${s.id})`));

console.log(`\nSample nuts:`);
nuts.slice(0, 5).forEach(n => console.log(`  - ${n.name} (id: ${n.id})`));

console.log(`\n${'='.repeat(80)}`);
console.log('Attempting recipe generation...\n');

// Attempt generation with internal logging
const builder = new RecipeBuilder(constraints, 'standard', 'medium');

// Access private method via any cast to see what's happening
const builderAny = builder as any;

// Try to generate and see what happens
try {
  const recipe = builder.generate();
  
  if (recipe) {
    console.log('‚úÖ Recipe generated successfully!');
    console.log(`\nIngredients (${recipe.ingredients.length}):`);
    recipe.ingredients.forEach(p => {
      console.log(`  - ${p.ingredient.name} (${p.ingredient.category}): ${p.grams}g`);
    });
  } else {
    console.log('‚ùå Recipe generation returned null');
  }
} catch (error: any) {
  console.log('‚ùå Error during generation:', error.message);
  console.log(error.stack);
}
</file>

<file path="lib/generator/BirdDetailedDebug.ts">
// Very detailed debug - manually walk through the RecipeBuilder process
import { getIngredientsForSpecies } from '../data/ingredients';
import type { Ingredient } from '../data/ingredients';

const species = 'birds';
const healthConcerns = ['digestive_issues'];

console.log('=== DETAILED BIRD INGREDIENT DEBUG ===\n');

// Step 1: Get all bird ingredients
const allBirdIngredients = getIngredientsForSpecies(species);
console.log(`Step 1: Total bird ingredients: ${allBirdIngredients.length}\n`);

// Step 2: Check categories
const byCategory: Record<string, Ingredient[]> = {};
allBirdIngredients.forEach(ing => {
  if (!byCategory[ing.category]) byCategory[ing.category] = [];
  byCategory[ing.category].push(ing);
});

console.log('Step 2: Ingredients by category:');
Object.entries(byCategory).forEach(([cat, ings]) => {
  console.log(`  ${cat}: ${ings.length} ingredients`);
});

// Step 3: Check quality scores for seeds/nuts
console.log('\nStep 3: Quality scores for seeds:');
const seeds = byCategory['seed'] || [];
seeds.slice(0, 10).forEach(s => {
  console.log(`  ${s.name}: quality=${s.qualityScore}, feedingRole=${s.feedingRole}`);
});

console.log('\nStep 3b: Quality scores for nuts:');
const nuts = byCategory['nut'] || [];
nuts.slice(0, 10).forEach(n => {
  console.log(`  ${n.name}: quality=${n.qualityScore}, feedingRole=${n.feedingRole}`);
});

// Step 4: Filter by quality tier (standard = qualityScore >= 5)
const qualityTier = 'standard';
const minQuality = qualityTier === 'premium' ? 7 : qualityTier === 'standard' ? 5 : 0;

console.log(`\nStep 4: Filtering by quality tier '${qualityTier}' (min quality: ${minQuality})`);
const afterQualityFilter = allBirdIngredients.filter(ing => ing.qualityScore >= minQuality);
console.log(`  Remaining after quality filter: ${afterQualityFilter.length}`);

const seedsAfterFilter = afterQualityFilter.filter(ing => ing.category === 'seed');
const nutsAfterFilter = afterQualityFilter.filter(ing => ing.category === 'nut');
const insectsAfterFilter = afterQualityFilter.filter(ing => ing.category === 'insect');

console.log(`  Seeds after filter: ${seedsAfterFilter.length}`);
console.log(`  Nuts after filter: ${nutsAfterFilter.length}`);
console.log(`  Insects after filter: ${insectsAfterFilter.length}`);

if (seedsAfterFilter.length === 0) {
  console.log('\n‚ö†Ô∏è  WARNING: No seeds passed quality filter!');
  console.log('Seeds that failed:');
  seeds.forEach(s => {
    if (s.qualityScore < minQuality) {
      console.log(`  ‚ùå ${s.name}: quality=${s.qualityScore} (needs ${minQuality})`);
    }
  });
}

if (nutsAfterFilter.length === 0) {
  console.log('\n‚ö†Ô∏è  WARNING: No nuts passed quality filter!');
  console.log('Nuts that failed:');
  nuts.forEach(n => {
    if (n.qualityScore < minQuality) {
      console.log(`  ‚ùå ${n.name}: quality=${n.qualityScore} (needs ${minQuality})`);
    }
  });
}

// Step 5: Check what would be selected
console.log('\n=== SELECTION SIMULATION ===');
const requiredCategories = ['seed', 'nut', 'fruit', 'vegetable'];
console.log(`Required categories for birds: ${requiredCategories.join(', ')}\n`);

for (const category of requiredCategories) {
  const inCategory = afterQualityFilter.filter(ing => ing.category === category);
  console.log(`${category}: ${inCategory.length} available`);
  if (inCategory.length > 0) {
    console.log(`  Top 3:`);
    inCategory.slice(0, 3).forEach(ing => {
      console.log(`    - ${ing.name} (quality: ${ing.qualityScore})`);
    });
  } else {
    console.log(`  ‚ö†Ô∏è  NONE AVAILABLE - THIS WILL CAUSE ISSUES`);
  }
}
</file>

<file path="lib/generator/BirdTest.ts">
// Quick test for bird recipe generation
import { RecipeBuilder, type GenerationConstraints } from './RecipeBuilder';

const constraints: GenerationConstraints = {
  species: 'birds',
  lifeStage: 'adult',
  petWeightKg: 0.5, // Small bird
  healthConcerns: ['digestive_issues'],
  targetCalories: 100,
};

console.log('Testing bird recipe generation...');
console.log('Constraints:', constraints);
console.log('='.repeat(80));

for (let attempt = 1; attempt <= 3; attempt++) {
  console.log(`\nAttempt ${attempt}:`);
  try {
    const builder = new RecipeBuilder(constraints, 'standard', 'medium');
    const recipe = builder.generate();
    
    if (recipe) {
      console.log('‚úÖ SUCCESS!');
      console.log(`Ingredients (${recipe.ingredients.length}):`);
      recipe.ingredients.forEach(p => {
        console.log(`  - ${p.ingredient.name} (${p.ingredient.category}): ${p.grams}g`);
      });
      console.log(`Total: ${recipe.ingredients.reduce((sum, p) => sum + p.grams, 0)}g`);
      break;
    } else {
      console.log('‚ùå No recipe generated');
    }
  } catch (error: any) {
    console.log('‚ùå Error:', error.message);
  }
}
</file>

<file path="lib/generator/CheckBirdIngredients.ts">
// Check what bird ingredients are available
import { getIngredientsForSpecies } from '../data/ingredients';

console.log('Checking bird ingredients...\n');

const birdIngredients = getIngredientsForSpecies('birds');
console.log(`Total bird ingredients: ${birdIngredients.length}\n`);

// Group by category
const byCategory: Record<string, number> = {};
birdIngredients.forEach(ing => {
  byCategory[ing.category] = (byCategory[ing.category] || 0) + 1;
});

console.log('By category:');
Object.entries(byCategory).sort((a, b) => b[1] - a[1]).forEach(([cat, count]) => {
  console.log(`  ${cat}: ${count}`);
});

console.log('\n=== Seeds ===');
birdIngredients.filter(ing => ing.category === 'seed').slice(0, 10).forEach(ing => {
  console.log(`  - ${ing.name} (${ing.id})`);
});

console.log('\n=== Nuts ===');
birdIngredients.filter(ing => ing.category === 'nut').slice(0, 10).forEach(ing => {
  console.log(`  - ${ing.name} (${ing.id})`);
});

console.log('\n=== Insects ===');
birdIngredients.filter(ing => ing.category === 'insect').slice(0, 10).forEach(ing => {
  console.log(`  - ${ing.name} (${ing.id})`);
});

console.log('\n=== Fruits ===');
birdIngredients.filter(ing => ing.category === 'fruit').slice(0, 10).forEach(ing => {
  console.log(`  - ${ing.name} (${ing.id})`);
});

console.log('\n=== Vegetables ===');
birdIngredients.filter(ing => ing.category === 'vegetable').slice(0, 10).forEach(ing => {
  console.log(`  - ${ing.name} (${ing.id})`);
});
</file>

<file path="lib/generator/CombinatoricsPruning.ts">
/**
 * COMBINATORICS PRUNING
 * Pre-validation filtering to prevent micronutrient-toxic pairings
 * 
 * This runs BEFORE validation, teaching the generator what NOT to produce
 * instead of just rejecting finished recipes.
 */

import type { Ingredient } from '@/lib/data/ingredients';

// ============================================================================
// TOXIC PAIRINGS (Disallow these combinations)
// ============================================================================

interface ToxicPairing {
  ingredients: string[]; // ingredient names (lowercase, partial match)
  reason: string;
  maxAllowed?: number; // max of this pairing allowed (0 = never)
}

const TOXIC_PAIRINGS: ToxicPairing[] = [
  // Liver + high-iodine fish = vitamin A + iodine overload
  {
    ingredients: ['liver', 'salmon'],
    reason: 'Liver + salmon = vitamin A + iodine spike',
    maxAllowed: 0,
  },
  {
    ingredients: ['liver', 'cod'],
    reason: 'Liver + cod = vitamin A + iodine overload',
    maxAllowed: 0,
  },
  {
    ingredients: ['liver', 'sardine'],
    reason: 'Liver + sardine = vitamin A + iodine spike',
    maxAllowed: 0,
  },
  {
    ingredients: ['liver', 'mackerel'],
    reason: 'Liver + mackerel = vitamin A + iodine overload',
    maxAllowed: 0,
  },
  {
    ingredients: ['liver', 'herring'],
    reason: 'Liver + herring = vitamin A + iodine spike',
    maxAllowed: 0,
  },

  // Liver + high-iodine supplements = iodine bomb
  {
    ingredients: ['liver', 'kelp'],
    reason: 'Liver + kelp = iodine bomb',
    maxAllowed: 0,
  },
  {
    ingredients: ['liver', 'seaweed'],
    reason: 'Liver + seaweed = iodine overload',
    maxAllowed: 0,
  },

  // Multiple organ meats = mineral overload
  {
    ingredients: ['liver', 'kidney'],
    reason: 'Multiple organ meats = copper/mineral toxicity',
    maxAllowed: 0,
  },
  {
    ingredients: ['liver', 'heart'],
    reason: 'Multiple organ meats = mineral imbalance',
    maxAllowed: 0,
  },

  // High-copper sources together
  {
    ingredients: ['liver', 'sunflower_seed'],
    reason: 'Liver + sunflower seeds = copper overload',
    maxAllowed: 0,
  },
  {
    ingredients: ['liver', 'pumpkin_seed'],
    reason: 'Liver + pumpkin seeds = copper spike',
    maxAllowed: 0,
  },

  // Oxalate + calcium = absorption issues
  {
    ingredients: ['spinach', 'eggshell_powder'],
    reason: 'Spinach oxalates + calcium supplement = poor absorption',
    maxAllowed: 0,
  },
];

// ============================================================================
// INGREDIENT MICRONUTRIENT DENSITY PROFILE
// ============================================================================

interface MicronutrientProfile {
  vitaminA?: 'high' | 'medium' | 'low';
  copper?: 'high' | 'medium' | 'low';
  iodine?: 'high' | 'medium' | 'low';
  oxalates?: 'high' | 'medium' | 'low';
}

const MICRONUTRIENT_PROFILES: Record<string, MicronutrientProfile> = {
  // Organ meats (high in multiple micronutrients)
  liver: { vitaminA: 'high', copper: 'high', iodine: 'medium' },
  kidney: { copper: 'high', iodine: 'medium' },
  heart: { copper: 'medium' },

  // Fish (iodine-rich)
  salmon: { iodine: 'high', vitaminA: 'medium' },
  cod: { iodine: 'high' },
  sardine: { iodine: 'high' },
  mackerel: { iodine: 'high' },
  herring: { iodine: 'high' },

  // Supplements (concentrated)
  kelp: { iodine: 'high' },
  seaweed: { iodine: 'high' },
  fish_oil: { vitaminA: 'high' },
  cod_liver_oil: { vitaminA: 'high', iodine: 'high' },

  // Seeds (copper-rich)
  sunflower_seed: { copper: 'high' },
  pumpkin_seed: { copper: 'high' },
  sesame_seed: { copper: 'high' },

  // Vegetables (oxalate-rich)
  spinach: { oxalates: 'high' },
  beet_greens: { oxalates: 'high' },
  chard: { oxalates: 'high' },
};

// ============================================================================
// PRUNING FUNCTIONS
// ============================================================================

/**
 * Check if a pairing violates toxic combination rules
 */
export function hasToxicPairing(ingredients: Ingredient[]): boolean {
  const names = ingredients.map(ing => ing.name.toLowerCase());

  for (const pairing of TOXIC_PAIRINGS) {
    const matches = pairing.ingredients.filter(required =>
      names.some(name => name.includes(required))
    );

    if (matches.length === pairing.ingredients.length) {
      // All ingredients in this toxic pairing are present
      if (pairing.maxAllowed === 0) {
        return true; // Disallowed
      }
    }
  }

  return false;
}

/**
 * Get micronutrient density profile for an ingredient
 */
export function getMicronutrientProfile(ingredient: Ingredient): MicronutrientProfile {
  const name = ingredient.name.toLowerCase();

  for (const [key, profile] of Object.entries(MICRONUTRIENT_PROFILES)) {
    if (name.includes(key)) {
      return profile;
    }
  }

  return {}; // Unknown ingredient, assume low density
}

/**
 * Calculate cumulative micronutrient risk for a recipe
 * Returns a risk score (0-100) where 100 = definitely toxic
 * 
 * NOTE: This is SOFT pruning. Only flag truly dangerous combos.
 * Fish + liver is OK. Fish + fish oil + liver is risky.
 */
export function calculateMicronutrientRisk(ingredients: Ingredient[]): number {
  let risk = 0;

  // Check for specific dangerous combos
  const vitaminAHighCount = ingredients.filter(ing => {
    const profile = getMicronutrientProfile(ing);
    return profile.vitaminA === 'high';
  }).length;

  const iodineHighCount = ingredients.filter(ing => {
    const profile = getMicronutrientProfile(ing);
    return profile.iodine === 'high';
  }).length;

  const copperHighCount = ingredients.filter(ing => {
    const profile = getMicronutrientProfile(ing);
    return profile.copper === 'high';
  }).length;

  // Only flag if we have MULTIPLE high sources of the SAME nutrient
  // (not just any high-density ingredient)
  
  // Multiple vitamin A sources (e.g., liver + fish oil)
  if (vitaminAHighCount >= 2) risk += 50;

  // Multiple iodine sources (e.g., kelp + fish + fish oil)
  if (iodineHighCount >= 3) risk += 50;
  else if (iodineHighCount >= 2) risk += 20; // Mild risk for 2 iodine sources

  // Multiple copper sources (e.g., liver + seeds)
  if (copperHighCount >= 2) risk += 40;

  return Math.min(100, risk);
}

/**
 * Prune candidates that are likely to fail T6 (nutrient ceiling)
 * Returns true if candidate should be rejected
 */
export function shouldPruneCandidateForMicronutrients(ingredients: Ingredient[]): boolean {
  // Hard reject: toxic pairings
  if (hasToxicPairing(ingredients)) {
    return true;
  }

  // Soft reject: high micronutrient risk
  const risk = calculateMicronutrientRisk(ingredients);
  if (risk > 70) {
    return true; // Likely to fail T6
  }

  return false;
}

/**
 * Get a human-readable reason why a candidate was pruned
 */
export function getPruningReason(ingredients: Ingredient[]): string {
  if (hasToxicPairing(ingredients)) {
    const names = ingredients.map(ing => ing.name.toLowerCase());
    for (const pairing of TOXIC_PAIRINGS) {
      const matches = pairing.ingredients.filter(required =>
        names.some(name => name.includes(required))
      );
      if (matches.length === pairing.ingredients.length) {
        return pairing.reason;
      }
    }
  }

  const risk = calculateMicronutrientRisk(ingredients);
  if (risk > 70) {
    return `High micronutrient risk (${Math.round(risk)}/100)`;
  }

  return 'Unknown';
}
</file>

<file path="lib/generator/CommercialPriorEnforcement.test.ts">
/**
 * DETERMINISTIC TEST: Commercial Prior Enforcement
 * 
 * Tests that turkey + fish oil pairings are blocked based on commercial data
 */

import { describe, it, expect, beforeEach, vi } from 'vitest';
import {
  checkHardBlock,
  checkStrongPenalty,
  filterCandidatesByCommercialPriors,
  applyCommercialPriorScoring,
} from './CommercialPriorEnforcement';

describe('CommercialPriorEnforcement', () => {
  beforeEach(() => {
    // Spy on console.log to capture logging
    vi.spyOn(console, 'log').mockImplementation(() => {});
  });

  describe('Hard Block Detection', () => {
    it('should NOT block turkey + fish pairings (fish oil is common with poultry)', () => {
      // Arrange: turkey is selected
      const selected = ['turkey'];
      const species = 'dogs' as const;

      // Act: Check if fish/salmon/tuna are blocked
      const fishBlock = checkHardBlock('fish', selected, species);
      const salmonBlock = checkHardBlock('salmon', selected, species);
      const tunaBlock = checkHardBlock('tuna', selected, species);

      // Assert: Should NOT be blocked (fish oil is common supplement with poultry)
      // Data can't distinguish fish-as-protein from fish-oil-as-supplement
      expect(fishBlock).toBeNull();
      expect(salmonBlock).toBeNull();
      expect(tunaBlock).toBeNull();
    });

    it('should block beef + fish pairings (genuinely rare)', () => {
      // Arrange: beef is selected
      const selected = ['beef'];
      const species = 'dogs' as const;

      // Act: Check if fish/salmon are blocked
      const fishBlock = checkHardBlock('fish', selected, species);
      const salmonBlock = checkHardBlock('salmon', selected, species);

      // Assert: Should be blocked (beef + fish is genuinely rare in commercial products)
      expect(fishBlock).toBeTruthy();
      expect(salmonBlock).toBeTruthy();
    });

    it('should NOT block chicken + turkey pairing', () => {
      // Arrange: turkey is selected
      const selected = ['turkey'];
      const species = 'dogs' as const;

      // Act: Check if chicken is blocked
      const chickenBlock = checkHardBlock('chicken', selected, species);

      // Assert: Should NOT be blocked (they co-occur in commercial products)
      expect(chickenBlock).toBeNull();
    });

    it('should work with normalized pair keys regardless of order', () => {
      // Arrange: Use beef + fish (genuinely blocked)
      const species = 'dogs' as const;

      // Act: Check both orders
      const block1 = checkHardBlock('fish', ['beef'], species);
      const block2 = checkHardBlock('beef', ['fish'], species);

      // Assert: Both should detect the block
      expect(block1).toBeTruthy();
      expect(block2).toBeTruthy();
      expect(block1).toBe(block2); // Same normalized key
    });
  });

  describe('Candidate Filtering', () => {
    it('should filter out beef + fish pairings (genuinely rare)', () => {
      // Arrange: Beef is selected, candidates include fish proteins
      const candidates = [
        { id: 'fish', name: 'Fish' },
        { id: 'salmon', name: 'Salmon' },
        { id: 'chicken', name: 'Chicken' },
        { id: 'rice', name: 'Rice' },
      ];
      const selected = ['beef'];
      const species = 'dogs' as const;

      // Act: Filter candidates
      const filtered = filterCandidatesByCommercialPriors(candidates, selected, species);

      // Assert: Fish ingredients should be filtered out (beef + fish is rare)
      const filteredIds = filtered.map(c => c.id);
      expect(filteredIds).not.toContain('fish');
      expect(filteredIds).not.toContain('salmon');
      expect(filteredIds).toContain('chicken');
      expect(filteredIds).toContain('rice');
    });

    it('should NOT filter turkey + fish (fish oil is common)', () => {
      // Arrange: Turkey is selected, candidates include fish
      const candidates = [
        { id: 'fish', name: 'Fish' },
        { id: 'salmon', name: 'Salmon' },
        { id: 'chicken', name: 'Chicken' },
      ];
      const selected = ['turkey'];
      const species = 'dogs' as const;

      // Act: Filter candidates
      const filtered = filterCandidatesByCommercialPriors(candidates, selected, species);

      // Assert: Fish should NOT be filtered (fish oil is common with poultry)
      const filteredIds = filtered.map(c => c.id);
      expect(filteredIds).toContain('fish');
      expect(filteredIds).toContain('salmon');
      expect(filteredIds).toContain('chicken');
    });

    it('should log [PAIR BLOCK] messages when filtering', () => {
      // Arrange: Use beef + salmon (genuinely blocked)
      const candidates = [
        { id: 'salmon', name: 'Salmon' },
      ];
      const selected = ['beef'];
      const species = 'dogs' as const;

      // Act
      filterCandidatesByCommercialPriors(candidates, selected, species, '[TEST] ');

      // Assert: Should have logged the block
      expect(console.log).toHaveBeenCalledWith(
        expect.stringContaining('[PAIR BLOCK]')
      );
      expect(console.log).toHaveBeenCalledWith(
        expect.stringContaining('salmon')
      );
      expect(console.log).toHaveBeenCalledWith(
        expect.stringContaining('commercial data')
      );
    });
  });

  describe('Strong Penalty Detection', () => {
    it('should detect strong penalty pairs', () => {
      // Arrange: Select ingredients that have rare pairings
      const selected = ['beef'];
      const species = 'dogs' as const;

      // Act: Check for penalty pairs with grain
      const penaltyPairs = checkStrongPenalty('grain', selected, species);

      // Assert: Should detect penalty (beef + grain is rare with negative PMI)
      expect(penaltyPairs.length).toBeGreaterThan(0);
    });
  });

  describe('Scoring with Commercial Priors', () => {
    it('should apply harsh penalty (0.05x) to strong penalty pairs', () => {
      // Arrange
      const candidateId = 'grain';
      const baseScore = 100;
      const selected = ['beef'];
      const species = 'dogs' as const;

      // Act
      const penaltyPairs = checkStrongPenalty(candidateId, selected, species);
      
      // Only test if penalty pairs exist
      if (penaltyPairs.length > 0) {
        const finalScore = applyCommercialPriorScoring(candidateId, baseScore, selected, species);

        // Assert: Score should be heavily penalized
        expect(finalScore).toBeLessThan(baseScore * 0.1);
        expect(console.log).toHaveBeenCalledWith(
          expect.stringContaining('[PAIR PENALTY]')
        );
      }
    });

    it('should apply PMI boost to positive pairings', () => {
      // Arrange: chicken + peas is a common pairing with positive PMI
      const candidateId = 'peas';
      const baseScore = 100;
      const selected = ['chicken'];
      const species = 'dogs' as const;

      // Act
      const finalScore = applyCommercialPriorScoring(candidateId, baseScore, selected, species);

      // Assert: Score should be boosted (but not by much, max 1.15x)
      expect(finalScore).toBeGreaterThanOrEqual(baseScore);
      expect(finalScore).toBeLessThanOrEqual(baseScore * 1.15);
    });
  });

  describe('CRITICAL TEST: What We Actually Learned', () => {
    it('should BLOCK beef + fish pairings (genuinely rare)', () => {
      // Arrange: Beef is selected
      const selected = ['beef'];
      const candidates = [
        { id: 'fish', name: 'Fish' },
        { id: 'salmon', name: 'Salmon' },
        { id: 'chicken', name: 'Chicken' },
      ];
      const species = 'dogs' as const;

      // Act: Filter candidates
      const filtered = filterCandidatesByCommercialPriors(candidates, selected, species, '[CRITICAL] ');

      // Assert: Fish ingredients must be filtered out (beef + fish is genuinely rare)
      const filteredIds = filtered.map(c => c.id);
      expect(filteredIds).not.toContain('fish');
      expect(filteredIds).not.toContain('salmon');
      expect(filteredIds).toContain('chicken');

      // Assert: Logs must contain [PAIR BLOCK] messages
      expect(console.log).toHaveBeenCalledWith(
        expect.stringMatching(/\[CRITICAL\].*\[PAIR BLOCK\].*fish/)
      );
    });

    it('should NOT block turkey + fish (fish oil is common with poultry)', () => {
      // Arrange: Turkey is selected
      const selected = ['turkey'];
      const species = 'dogs' as const;

      // Act: Check hard block for fish types
      const fishBlock = checkHardBlock('fish', selected, species);
      const salmonBlock = checkHardBlock('salmon', selected, species);
      const tunaBlock = checkHardBlock('tuna', selected, species);

      // Assert: Should NOT be blocked (data can't distinguish fish-as-protein from fish-oil-as-supplement)
      // Fish oil is commonly used with poultry for omega-3
      expect(fishBlock).toBeNull();
      expect(salmonBlock).toBeNull();
      expect(tunaBlock).toBeNull();
    });

    it('should boost common pairings (chicken + peas, chicken + rice)', () => {
      // Arrange: Chicken is selected
      const candidateId = 'peas';
      const baseScore = 100;
      const selected = ['chicken'];
      const species = 'dogs' as const;

      // Act: Apply commercial prior scoring
      const finalScore = applyCommercialPriorScoring(candidateId, baseScore, selected, species);

      // Assert: Score should be boosted OR stay same (chicken + peas is common: 51 products)
      // Note: With conservative thresholds (minIng>=30), peas (60) qualifies
      // PMI might be positive or neutral depending on data
      expect(finalScore).toBeGreaterThanOrEqual(baseScore);
      expect(finalScore).toBeLessThanOrEqual(baseScore * 1.15); // Capped at 1.15x
    });
  });

  describe('Species-Specific Gating', () => {
    it('should only apply priors for dogs and cats', () => {
      // Arrange
      const selected = ['turkey'];
      const birdsSpecies = 'birds' as const;

      // Act: Check for birds (should have no priors)
      const block = checkHardBlock('fish', selected, birdsSpecies);

      // Assert: Should return null (no priors for birds yet)
      expect(block).toBeNull();
    });

    it('should apply same priors to both dogs and cats', () => {
      // Arrange: Use beef + fish (genuinely blocked)
      const selected = ['beef'];

      // Act: Check for both species
      const dogBlock = checkHardBlock('fish', selected, 'dogs');
      const catBlock = checkHardBlock('fish', selected, 'cats');

      // Assert: Both should block (using same commercial data)
      expect(dogBlock).toBeTruthy();
      expect(catBlock).toBeTruthy();
    });
  });
});
</file>

<file path="lib/generator/CommercialPriorEnforcement.ts">
/**
 * COMMERCIAL PRIOR ENFORCEMENT
 * 
 * Enforces learned commercial pairing rules:
 * - hardBlockPairs: Filter out candidates that never co-occur with selected ingredients
 * - strongPenaltyPairs: Apply harsh penalty (0.05x) to rare negative pairings
 * - Positive PMI: Apply soft boost (1.05-1.15x) to common pairings
 */

import recipePriors from '../data/recipePriors.json';
import type { Species } from '../types';

interface CommercialPriors {
  ingredientCounts: Record<string, number>;
  ingredientFreq: Record<string, number>;
  pairCounts: Record<string, number>;
  pairPMI: Record<string, number>;
  hardBlockPairs: string[];
  strongPenaltyPairs: string[];
}

/**
 * Normalize pair key to sorted format (a|b)
 */
function normalizePairKey(ing1: string, ing2: string): string {
  return [ing1, ing2].sort().join('|');
}

/**
 * Get commercial priors for a species
 */
function getCommercialPriors(species: Species): CommercialPriors | null {
  const priors = (recipePriors as any).commercialPriors;
  if (!priors) return null;
  
  // Map species to commercial priors key
  const speciesKey = species === 'dogs' || species === 'cats' ? species : null;
  if (!speciesKey) return null;
  
  return priors[speciesKey] as CommercialPriors;
}

/**
 * Check if a candidate ingredient is hard-blocked by any selected ingredient
 * Returns the blocking pair if found, null otherwise
 */
export function checkHardBlock(
  candidateId: string,
  selectedIngredientIds: string[],
  species: Species
): string | null {
  const priors = getCommercialPriors(species);
  if (!priors || !priors.hardBlockPairs) return null;
  
  const hardBlockSet = new Set(priors.hardBlockPairs);
  
  for (const selectedId of selectedIngredientIds) {
    const pairKey = normalizePairKey(candidateId, selectedId);
    if (hardBlockSet.has(pairKey)) {
      return pairKey;
    }
  }
  
  return null;
}

/**
 * Check if a candidate ingredient has strong penalty pairs with selected ingredients
 * Returns array of penalty pairs
 */
export function checkStrongPenalty(
  candidateId: string,
  selectedIngredientIds: string[],
  species: Species
): string[] {
  const priors = getCommercialPriors(species);
  if (!priors || !priors.strongPenaltyPairs) return [];
  
  const penaltySet = new Set(priors.strongPenaltyPairs);
  const penaltyPairs: string[] = [];
  
  for (const selectedId of selectedIngredientIds) {
    const pairKey = normalizePairKey(candidateId, selectedId);
    if (penaltySet.has(pairKey)) {
      penaltyPairs.push(pairKey);
    }
  }
  
  return penaltyPairs;
}

/**
 * Get PMI boost for a candidate ingredient paired with selected ingredients
 * Returns multiplier (1.0 = no change, >1.0 = boost, <1.0 = penalty)
 */
export function getPMIBoost(
  candidateId: string,
  selectedIngredientIds: string[],
  species: Species
): number {
  const priors = getCommercialPriors(species);
  if (!priors || !priors.pairPMI) return 1.0;
  
  let totalPMI = 0;
  let pairCount = 0;
  
  for (const selectedId of selectedIngredientIds) {
    const pairKey = normalizePairKey(candidateId, selectedId);
    const pmi = priors.pairPMI[pairKey];
    
    if (pmi !== undefined && pmi > 0) {
      totalPMI += pmi;
      pairCount++;
    }
  }
  
  if (pairCount === 0) return 1.0;
  
  // Average PMI across pairs
  const avgPMI = totalPMI / pairCount;
  
  // Convert to multiplier: PMI of 1.0 -> 1.05x boost, PMI of 2.0 -> 1.10x boost
  // Cap at 1.15x to avoid over-boosting
  const boost = 1.0 + Math.min(avgPMI * 0.05, 0.15);
  
  return boost;
}

/**
 * Filter candidates by commercial priors
 * Removes hard-blocked candidates and logs reasons
 */
export function filterCandidatesByCommercialPriors<T extends { id: string }>(
  candidates: T[],
  selectedIngredientIds: string[],
  species: Species,
  logPrefix: string = ''
): T[] {
  const priors = getCommercialPriors(species);
  if (!priors) return candidates;
  
  return candidates.filter(candidate => {
    const blockingPair = checkHardBlock(candidate.id, selectedIngredientIds, species);
    
    if (blockingPair) {
      const [ing1, ing2] = blockingPair.split('|');
      console.log(`${logPrefix}[PAIR BLOCK] ${candidate.id}: Never co-occurs with ${ing1 === candidate.id ? ing2 : ing1} (commercial data)`);
      return false;
    }
    
    return true;
  });
}

/**
 * Apply commercial prior scoring to a candidate
 * Returns modified score and logs reasons
 */
export function applyCommercialPriorScoring(
  candidateId: string,
  baseScore: number,
  selectedIngredientIds: string[],
  species: Species,
  logPrefix: string = ''
): number {
  const priors = getCommercialPriors(species);
  if (!priors) return baseScore;
  
  let score = baseScore;
  
  // Check for strong penalty pairs
  const penaltyPairs = checkStrongPenalty(candidateId, selectedIngredientIds, species);
  if (penaltyPairs.length > 0) {
    score *= 0.05; // Harsh penalty
    penaltyPairs.forEach(pair => {
      const [ing1, ing2] = pair.split('|');
      const otherIng = ing1 === candidateId ? ing2 : ing1;
      console.log(`${logPrefix}[PAIR PENALTY] ${candidateId}: Rare pairing with ${otherIng} (commercial data, PMI<-1.5)`);
    });
  }
  
  // Apply PMI boost for positive pairings
  const pmiBoost = getPMIBoost(candidateId, selectedIngredientIds, species);
  if (pmiBoost > 1.0) {
    score *= pmiBoost;
    console.log(`${logPrefix}[PMI BOOST] ${candidateId}: ${pmiBoost.toFixed(2)}x boost from commercial pairings`);
  }
  
  return score;
}

/**
 * Check if commercial priors are available for a species
 */
export function hasCommercialPriors(species: Species): boolean {
  return getCommercialPriors(species) !== null;
}
</file>

<file path="lib/generator/ComprehensiveAudit.ts">
// Comprehensive Audit: All Species + Health Concerns
// Tests recipe generation for every species with single and paired health concerns

import { RecipeBuilder, type GenerationConstraints } from './RecipeBuilder';

type Species = 'dogs' | 'cats' | 'birds' | 'reptiles' | 'pocket-pets';

const SPECIES: Species[] = ['dogs', 'cats', 'birds', 'reptiles', 'pocket-pets'];

const HEALTH_CONCERNS = [
  'allergies',
  'digestive_issues',
  'joint_health',
  'skin_health',
  'weight_management',
  'dental_health',
  'immune_support',
];

interface AuditResult {
  species: Species;
  healthConcerns: string[];
  success: boolean;
  attempts: number;
  totalGrams?: number;
  primaryProteins?: number;
  error?: string;
}

const results: AuditResult[] = [];

console.log('='.repeat(80));
console.log('COMPREHENSIVE RECIPE GENERATION AUDIT');
console.log('='.repeat(80));
console.log(`Testing ${SPECIES.length} species √ó ${HEALTH_CONCERNS.length} concerns + pairs`);
console.log(`Total combinations: ~${SPECIES.length * (HEALTH_CONCERNS.length + (HEALTH_CONCERNS.length * (HEALTH_CONCERNS.length - 1)) / 2)}`);
console.log('='.repeat(80));

let totalTests = 0;
let passedTests = 0;
let failedTests = 0;

// Test 1: Single health concerns
console.log('\nüìã PHASE 1: Single Health Concerns');
console.log('-'.repeat(80));

for (const species of SPECIES) {
  for (const concern of HEALTH_CONCERNS) {
    totalTests++;
    const constraints: GenerationConstraints = {
      species,
      lifeStage: 'adult',
      petWeightKg: species === 'dogs' ? 20 : species === 'cats' ? 5 : 2,
      healthConcerns: [concern],
      targetCalories: 500,
    };

    let attempts = 0;
    let success = false;
    let totalGrams = 0;
    let primaryProteins = 0;

    for (let i = 0; i < 3; i++) {
      attempts++;
      try {
        const builder = new RecipeBuilder(constraints, 'standard', 'medium');
        const recipe = builder.generate();

        if (recipe && recipe.ingredients.length > 0) {
          success = true;
          totalGrams = recipe.ingredients.reduce((sum, p) => sum + p.grams, 0);
          primaryProteins = recipe.ingredients.filter(
            p => p.ingredient.category === 'protein' && p.ingredient.proteinRole === 'primary'
          ).length;
          break;
        }
      } catch (error) {
        // Continue to next attempt
      }
    }

    const result: AuditResult = {
      species,
      healthConcerns: [concern],
      success,
      attempts,
      totalGrams,
      primaryProteins,
    };

    results.push(result);

    if (success) {
      passedTests++;
      console.log(`‚úÖ ${species.padEnd(12)} + ${concern.padEnd(20)} | ${totalGrams}g | ${primaryProteins} primary protein`);
    } else {
      failedTests++;
      console.log(`‚ùå ${species.padEnd(12)} + ${concern.padEnd(20)} | Failed after ${attempts} attempts`);
    }
  }
}

// Test 2: Paired health concerns (sample combinations)
console.log('\nüìã PHASE 2: Paired Health Concerns (Sample)');
console.log('-'.repeat(80));

const pairCombos = [
  ['allergies', 'digestive_issues'],
  ['joint_health', 'weight_management'],
  ['skin_health', 'immune_support'],
  ['digestive_issues', 'dental_health'],
  ['weight_management', 'immune_support'],
];

for (const species of SPECIES) {
  for (const [concern1, concern2] of pairCombos) {
    totalTests++;
    const constraints: GenerationConstraints = {
      species,
      lifeStage: 'adult',
      petWeightKg: species === 'dogs' ? 20 : species === 'cats' ? 5 : 2,
      healthConcerns: [concern1, concern2],
      targetCalories: 500,
    };

    let attempts = 0;
    let success = false;
    let totalGrams = 0;
    let primaryProteins = 0;

    for (let i = 0; i < 3; i++) {
      attempts++;
      try {
        const builder = new RecipeBuilder(constraints, 'standard', 'medium');
        const recipe = builder.generate();

        if (recipe && recipe.ingredients.length > 0) {
          success = true;
          totalGrams = recipe.ingredients.reduce((sum, p) => sum + p.grams, 0);
          primaryProteins = recipe.ingredients.filter(
            p => p.ingredient.category === 'protein' && p.ingredient.proteinRole === 'primary'
          ).length;
          break;
        }
      } catch (error) {
        // Continue to next attempt
      }
    }

    const result: AuditResult = {
      species,
      healthConcerns: [concern1, concern2],
      success,
      attempts,
      totalGrams,
      primaryProteins,
    };

    results.push(result);

    if (success) {
      passedTests++;
      console.log(
        `‚úÖ ${species.padEnd(12)} + ${(concern1 + ' + ' + concern2).padEnd(35)} | ${totalGrams}g | ${primaryProteins} primary protein`
      );
    } else {
      failedTests++;
      console.log(
        `‚ùå ${species.padEnd(12)} + ${(concern1 + ' + ' + concern2).padEnd(35)} | Failed after ${attempts} attempts`
      );
    }
  }
}

// Summary
console.log('\n' + '='.repeat(80));
console.log('AUDIT SUMMARY');
console.log('='.repeat(80));
console.log(`Total Tests: ${totalTests}`);
console.log(`‚úÖ Passed: ${passedTests} (${((passedTests / totalTests) * 100).toFixed(1)}%)`);
console.log(`‚ùå Failed: ${failedTests} (${((failedTests / totalTests) * 100).toFixed(1)}%)`);

// Breakdown by species
console.log('\nüìä Results by Species:');
for (const species of SPECIES) {
  const speciesResults = results.filter(r => r.species === species);
  const speciesPassed = speciesResults.filter(r => r.success).length;
  const speciesTotal = speciesResults.length;
  console.log(
    `  ${species.padEnd(12)}: ${speciesPassed}/${speciesTotal} (${((speciesPassed / speciesTotal) * 100).toFixed(1)}%)`
  );
}

// Breakdown by health concern
console.log('\nüìä Results by Health Concern (Single):');
for (const concern of HEALTH_CONCERNS) {
  const concernResults = results.filter(r => r.healthConcerns.length === 1 && r.healthConcerns[0] === concern);
  const concernPassed = concernResults.filter(r => r.success).length;
  const concernTotal = concernResults.length;
  console.log(
    `  ${concern.padEnd(20)}: ${concernPassed}/${concernTotal} (${((concernPassed / concernTotal) * 100).toFixed(1)}%)`
  );
}

// Failed combinations
const failedResults = results.filter(r => !r.success);
if (failedResults.length > 0) {
  console.log('\n‚ö†Ô∏è  Failed Combinations:');
  for (const result of failedResults.slice(0, 10)) {
    console.log(`  ${result.species} + ${result.healthConcerns.join(', ')}`);
  }
  if (failedResults.length > 10) {
    console.log(`  ... and ${failedResults.length - 10} more`);
  }
}

console.log('\n' + '='.repeat(80));
</file>

<file path="lib/generator/DebugProteinRole.ts">
// Quick debug to check proteinRole population
import { getIngredientsForSpecies } from '../data/ingredients';

const dogs = getIngredientsForSpecies('dogs');
const proteins = dogs.filter(i => i.category === 'protein').slice(0, 10);

console.log('=== Dog Proteins ===');
proteins.forEach(p => {
  console.log(`${p.name}: proteinRole=${p.proteinRole || 'undefined'}`);
});
</file>

<file path="lib/generator/GenerateVerificationList.ts">
// Generate a verification list for manual Amazon link checking
// Outputs CSV format for easy tracking in Excel/Sheets

import { VETTED_PRODUCTS } from '../data/vetted-products';
import * as fs from 'fs';
import * as path from 'path';

interface VerificationItem {
  ingredient: string;
  productName: string;
  asin: string;
  link: string;
  issue: string;
  priority: 'high' | 'medium' | 'low';
  verified: 'pending' | 'correct' | 'wrong' | 'dead';
  notes: string;
}

const items: VerificationItem[] = [];

// Track duplicate ASINs
const asinMap = new Map<string, string[]>();

for (const [ingredientName, product] of Object.entries(VETTED_PRODUCTS)) {
  const asinLink = product.asinLink;
  const asinMatch = asinLink.match(/\/dp\/([A-Z0-9]{10})/i);
  
  if (asinMatch) {
    const asin = asinMatch[1];
    if (!asinMap.has(asin)) {
      asinMap.set(asin, []);
    }
    asinMap.get(asin)!.push(ingredientName);
  }
}

// Known dead links from HTTP check
const deadLinks = new Set(['B0082C00P8', 'B0006L2XNK']);

// Known suspicious mappings
const suspiciousMapping: Record<string, { ingredients: string[]; issue: string }> = {
  'B07VHR2WNZ': { ingredients: ['ground beef (lean)', 'venison'], issue: 'Beef and venison are different meats' },
  'B0082C00P8': { ingredients: ['ground lamb', 'rabbit meat'], issue: 'Lamb and rabbit are different meats (DEAD LINK)' },
  'B0BXZ3JJL9': { ingredients: ['chicken hearts', 'turkey giblets'], issue: 'Chicken and turkey are different poultry' },
  'B01FUWYO2M': { ingredients: ['sardines (canned in water)', 'herring (canned)', 'sardines (in water)'], issue: 'Sardines and herring are different fish' },
  'B00WM6CHFQ': { ingredients: ['mango', 'chia seed oil'], issue: 'Mango and chia oil are completely different' },
  'B0BWBNT8JX': { ingredients: ['egg (hard-boiled)', 'duck hearts'], issue: 'Eggs and duck hearts are different' },
  'B00027ZVG4': { ingredients: ['canary seed', 'flaxseeds', 'rapeseed', 'sunflower seeds (small amounts)', 'pumpkin seeds', 'cuttlebone'], issue: 'Multiple seed types - verify if seed mix is appropriate' },
  'B086211R4H': { ingredients: ['niger seed', 'oat groats', 'hemp seeds', 'sesame seeds', 'chia seeds', 'pellets (fortified)'], issue: 'Multiple seed types - verify if seed mix is appropriate' },
};

// Generate verification items
for (const [ingredientName, product] of Object.entries(VETTED_PRODUCTS)) {
  const asinLink = product.asinLink;
  const asinMatch = asinLink.match(/\/dp\/([A-Z0-9]{10})/i);
  
  if (!asinMatch) continue;
  
  const asin = asinMatch[1];
  
  // Check if this needs verification
  let needsVerification = false;
  let issue = '';
  let priority: 'high' | 'medium' | 'low' = 'low';
  
  // Dead link
  if (deadLinks.has(asin)) {
    needsVerification = true;
    issue = 'Dead link (HTTP 405) - needs replacement';
    priority = 'high';
  }
  // Suspicious mapping
  else if (suspiciousMapping[asin]) {
    needsVerification = true;
    issue = suspiciousMapping[asin].issue;
    priority = 'high';
  }
  // Duplicate ASIN (but not in suspicious list)
  else if (asinMap.get(asin)!.length > 1) {
    needsVerification = true;
    issue = `Shared with: ${asinMap.get(asin)!.filter(i => i !== ingredientName).join(', ')}`;
    priority = 'medium';
  }
  
  if (needsVerification) {
    items.push({
      ingredient: ingredientName,
      productName: product.productName,
      asin,
      link: asinLink,
      issue,
      priority,
      verified: deadLinks.has(asin) ? 'dead' : 'pending',
      notes: '',
    });
  }
}

// Sort by priority
items.sort((a, b) => {
  const priorityOrder = { high: 0, medium: 1, low: 2 };
  return priorityOrder[a.priority] - priorityOrder[b.priority];
});

// Generate CSV
const csvHeader = 'Priority,Ingredient,Product Name,ASIN,Issue,Verified,Notes,Link\n';
const csvRows = items.map(item => {
  const escapeCsv = (str: string) => `"${str.replace(/"/g, '""')}"`;
  return [
    item.priority.toUpperCase(),
    escapeCsv(item.ingredient),
    escapeCsv(item.productName),
    item.asin,
    escapeCsv(item.issue),
    item.verified.toUpperCase(),
    '', // Empty notes column for manual entry
    item.link,
  ].join(',');
}).join('\n');

const csv = csvHeader + csvRows;

// Save to file
const outputPath = path.join(process.cwd(), 'AMAZON_LINK_VERIFICATION.csv');
fs.writeFileSync(outputPath, csv, 'utf-8');

console.log('='.repeat(80));
console.log('VERIFICATION LIST GENERATED');
console.log('='.repeat(80));
console.log();
console.log(`Total items needing verification: ${items.length}`);
console.log(`  High priority: ${items.filter(i => i.priority === 'high').length}`);
console.log(`  Medium priority: ${items.filter(i => i.priority === 'medium').length}`);
console.log(`  Low priority: ${items.filter(i => i.priority === 'low').length}`);
console.log();
console.log(`CSV file saved to: ${outputPath}`);
console.log();
console.log('HOW TO USE:');
console.log('1. Open AMAZON_LINK_VERIFICATION.csv in Excel/Google Sheets');
console.log('2. Click each link in the "Link" column');
console.log('3. Verify if the Amazon product matches the ingredient');
console.log('4. Update "Verified" column: CORRECT, WRONG, or DEAD');
console.log('5. Add notes in "Notes" column if needed');
console.log('6. For WRONG/DEAD items, find correct ASIN and add to notes');
console.log();
console.log('='.repeat(80));

// Also generate a markdown table for easy viewing
const mdTable = `# Amazon Link Verification List

Total items: ${items.length}

## High Priority (${items.filter(i => i.priority === 'high').length})

| Ingredient | Product | ASIN | Issue | Link |
|------------|---------|------|-------|------|
${items.filter(i => i.priority === 'high').map(item => 
  `| ${item.ingredient} | ${item.productName} | ${item.asin} | ${item.issue} | [Verify](${item.link}) |`
).join('\n')}

## Medium Priority (${items.filter(i => i.priority === 'medium').length})

| Ingredient | Product | ASIN | Issue | Link |
|------------|---------|------|-------|------|
${items.filter(i => i.priority === 'medium').slice(0, 10).map(item => 
  `| ${item.ingredient} | ${item.productName} | ${item.asin} | ${item.issue} | [Verify](${item.link}) |`
).join('\n')}

${items.filter(i => i.priority === 'medium').length > 10 ? `\n... and ${items.filter(i => i.priority === 'medium').length - 10} more medium priority items (see CSV)\n` : ''}

## Instructions

1. Click each "Verify" link
2. Check if Amazon product matches ingredient name
3. Mark in CSV: CORRECT, WRONG, or DEAD
4. For WRONG/DEAD: Find correct product and note new ASIN
`;

const mdPath = path.join(process.cwd(), 'AMAZON_LINK_VERIFICATION.md');
fs.writeFileSync(mdPath, mdTable, 'utf-8');

console.log(`Markdown file saved to: ${mdPath}`);
console.log();
</file>

<file path="lib/generator/Phase1_5_AutoClassify.ts">
// Phase 1.5: Enhanced auto-classification with clustering and token equivalence
// Reduces manual review from ~90 items to ~20 items

import { VETTED_PRODUCTS } from '../data/vetted-products';
import { RETAIL_SPECS } from '../validation/retailSpecDefinitions';
import { EnhancedRetailValidator } from '../validation/enhancedRetailValidator';
import { ASINClusterer } from '../validation/asinClusterer';
import * as fs from 'fs';
import * as path from 'path';

interface EnhancedClassificationResult {
  ingredient: string;
  productName: string;
  asin: string;
  link: string;
  status: 'auto-valid' | 'auto-structurally-valid' | 'auto-invalid' | 'needs-review' | 'no-spec';
  confidence: 'high' | 'medium' | 'low';
  issues: string[];
  notes: string;
  aliasGroup?: string;
  reasoning?: string;
}

const validator = new EnhancedRetailValidator();
const clusterer = new ASINClusterer();
const results: EnhancedClassificationResult[] = [];

console.log('='.repeat(80));
console.log('PHASE 1.5: ENHANCED AUTO-CLASSIFICATION');
console.log('With ASIN clustering + token equivalence + 4-state validation');
console.log('='.repeat(80));
console.log();

// Known dead links
const deadLinks = new Set(['B0082C00P8', 'B0006L2XNK']);

// STEP 1: Cluster duplicate ASINs
console.log('Step 1: Clustering duplicate ASINs...');
const productMap = new Map(Object.entries(VETTED_PRODUCTS));
const { aliasGroups, conflicts, singles } = clusterer.clusterByASIN(productMap);

console.log(`  Found ${aliasGroups.length} alias groups`);
console.log(`  Found ${conflicts.length} conflicts (wrong products)`);
console.log(`  Found ${singles.length} single-ASIN ingredients`);
console.log();

// STEP 2: Validate alias groups (once per group)
console.log('Step 2: Validating alias groups...');
const groupValidations = new Map<string, any>();

for (const group of aliasGroups) {
  const product = VETTED_PRODUCTS[group.canonicalName];
  if (!product) continue;
  
  const spec = RETAIL_SPECS[group.canonicalName];
  if (!spec) {
    // No spec for this group - mark as structurally valid by default
    groupValidations.set(group.groupId, {
      status: 'structurally-valid',
      confidence: 'medium',
      notes: 'No spec defined - assumed OK (alias group)',
    });
    continue;
  }
  
  const validationResult = validator.validateProductTitle(
    product.productName,
    spec,
    group.sharedASIN,
    group.canonicalName
  );
  
  groupValidations.set(group.groupId, validationResult);
}

console.log(`  Validated ${groupValidations.size} alias groups`);
console.log();

// STEP 3: Process all ingredients
console.log('Step 3: Classifying all ingredients...');

// Create reverse lookup: ingredient -> alias group
const ingredientToGroup = new Map<string, string>();
for (const group of aliasGroups) {
  for (const alias of group.aliases) {
    ingredientToGroup.set(alias, group.groupId);
  }
}

for (const [ingredientName, product] of Object.entries(VETTED_PRODUCTS)) {
  const asinMatch = product.asinLink.match(/\/dp\/([A-Z0-9]{10})/i);
  if (!asinMatch) continue;
  
  const asin = asinMatch[1];
  const spec = RETAIL_SPECS[ingredientName];
  
  let status: EnhancedClassificationResult['status'];
  let confidence: EnhancedClassificationResult['confidence'];
  let issues: string[] = [];
  let notes = '';
  let reasoning = '';
  let aliasGroup: string | undefined;
  
  // Check if dead link
  if (deadLinks.has(asin)) {
    status = 'auto-invalid';
    confidence = 'high';
    issues.push('Dead link (HTTP 405)');
    notes = '‚ùå NEEDS REPLACEMENT - Link is dead';
  }
  // Check if part of alias group
  else if (ingredientToGroup.has(ingredientName)) {
    const groupId = ingredientToGroup.get(ingredientName)!;
    const groupValidation = groupValidations.get(groupId);
    aliasGroup = groupId;
    
    if (groupValidation) {
      // Inherit validation from group
      if (groupValidation.status === 'valid') {
        status = 'auto-valid';
        confidence = groupValidation.confidence;
        notes = `‚úÖ Valid (alias group: ${groupId})`;
      } else if (groupValidation.status === 'structurally-valid') {
        status = 'auto-structurally-valid';
        confidence = groupValidation.confidence;
        notes = `‚úÖ Structurally valid (alias group: ${groupId})`;
        if (groupValidation.reasoning?.equivalentTokensUsed?.length > 0) {
          reasoning = `Uses equivalent tokens: ${groupValidation.reasoning.equivalentTokensUsed.map((e: any) => `${e.token}‚âà${e.synonym}`).join(', ')}`;
        }
      } else if (groupValidation.status === 'ambiguous') {
        status = 'needs-review';
        confidence = groupValidation.confidence;
        notes = `‚ö†Ô∏è Ambiguous (alias group: ${groupId})`;
      } else {
        status = 'auto-invalid';
        confidence = groupValidation.confidence;
        notes = `‚ùå Invalid (alias group: ${groupId})`;
      }
      
      if (groupValidation.structuralIssues) {
        issues.push(...groupValidation.structuralIssues.map((i: any) => `STRUCTURAL: ${i.message}`));
      }
      if (groupValidation.semanticIssues) {
        issues.push(...groupValidation.semanticIssues.map((i: any) => `SEMANTIC: ${i.message}`));
      }
    } else {
      status = 'no-spec';
      confidence = 'medium';
      notes = `No spec (alias group: ${groupId})`;
    }
  }
  // Check if conflict
  else if (conflicts.some(c => c.ingredients.includes(ingredientName))) {
    const conflict = conflicts.find(c => c.ingredients.includes(ingredientName))!;
    status = 'needs-review';
    confidence = 'low';
    issues.push(`CONFLICT: ${conflict.reason}`);
    notes = `‚ö†Ô∏è Conflict detected - likely wrong product`;
  }
  // Has spec - validate individually
  else if (spec) {
    const validationResult = validator.validateProductTitle(
      product.productName,
      spec,
      asin,
      ingredientName
    );
    
    confidence = validationResult.confidence;
    
    if (validationResult.structuralIssues) {
      issues.push(...validationResult.structuralIssues.map(i => `STRUCTURAL: ${i.message}`));
    }
    if (validationResult.semanticIssues) {
      issues.push(...validationResult.semanticIssues.map(i => `SEMANTIC: ${i.message}`));
    }
    
    if (validationResult.reasoning?.equivalentTokensUsed?.length > 0) {
      reasoning = `Uses equivalent tokens: ${validationResult.reasoning.equivalentTokensUsed.map(e => `${e.token}‚âà${e.synonym}`).join(', ')}`;
    }
    
    if (validationResult.status === 'valid') {
      status = 'auto-valid';
      notes = '‚úÖ Passes all validation checks';
    } else if (validationResult.status === 'structurally-valid') {
      status = 'auto-structurally-valid';
      notes = '‚úÖ Structurally valid - safe to use';
    } else if (validationResult.status === 'invalid') {
      status = 'auto-invalid';
      notes = '‚ùå Failed validation - likely wrong product';
    } else {
      status = 'needs-review';
      notes = '‚ö†Ô∏è Ambiguous - manual review needed';
    }
  }
  // No spec - assume OK
  else {
    status = 'no-spec';
    confidence = 'medium';
    notes = 'No validation spec defined - assumed OK';
  }
  
  results.push({
    ingredient: ingredientName,
    productName: product.productName,
    asin,
    link: product.asinLink,
    status,
    confidence,
    issues,
    notes,
    aliasGroup,
    reasoning,
  });
}

// Generate statistics
const stats = {
  total: results.length,
  autoValid: results.filter(r => r.status === 'auto-valid').length,
  autoStructurallyValid: results.filter(r => r.status === 'auto-structurally-valid').length,
  autoInvalid: results.filter(r => r.status === 'auto-invalid').length,
  needsReview: results.filter(r => r.status === 'needs-review').length,
  noSpec: results.filter(r => r.status === 'no-spec').length,
  inAliasGroups: results.filter(r => r.aliasGroup).length,
};

console.log();
console.log('='.repeat(80));
console.log('PHASE 1.5 RESULTS');
console.log('='.repeat(80));
console.log();
console.log(`Total items: ${stats.total}`);
console.log(`‚úÖ Auto-valid: ${stats.autoValid} (${((stats.autoValid / stats.total) * 100).toFixed(1)}%)`);
console.log(`‚úÖ Auto-structurally-valid: ${stats.autoStructurallyValid} (${((stats.autoStructurallyValid / stats.total) * 100).toFixed(1)}%)`);
console.log(`‚ùå Auto-invalid: ${stats.autoInvalid} (${((stats.autoInvalid / stats.total) * 100).toFixed(1)}%)`);
console.log(`‚ö†Ô∏è  Needs review: ${stats.needsReview} (${((stats.needsReview / stats.total) * 100).toFixed(1)}%)`);
console.log(`üìã No spec: ${stats.noSpec} (${((stats.noSpec / stats.total) * 100).toFixed(1)}%)`);
console.log();
console.log(`üîó In alias groups: ${stats.inAliasGroups} (${((stats.inAliasGroups / stats.total) * 100).toFixed(1)}%)`);
console.log();

const totalAccepted = stats.autoValid + stats.autoStructurallyValid + stats.noSpec;
const manualReviewNeeded = stats.needsReview + stats.autoInvalid;

console.log(`üìä SUMMARY:`);
console.log(`   Automatically accepted: ${totalAccepted} (${((totalAccepted / stats.total) * 100).toFixed(1)}%)`);
console.log(`   Manual review required: ${manualReviewNeeded} (${((manualReviewNeeded / stats.total) * 100).toFixed(1)}%)`);
console.log();
console.log(`üéØ Manual review reduced from 94 ‚Üí ${manualReviewNeeded} items`);
console.log(`   (${Math.round((1 - manualReviewNeeded / 94) * 100)}% reduction)`);
console.log();

// Show items needing review
const reviewItems = results.filter(r => r.status === 'needs-review' || r.status === 'auto-invalid');

if (reviewItems.length > 0) {
  console.log('='.repeat(80));
  console.log(`ITEMS REQUIRING MANUAL REVIEW (${reviewItems.length})`);
  console.log('='.repeat(80));
  console.log();
  
  reviewItems.forEach((item, idx) => {
    console.log(`${idx + 1}. ${item.ingredient}`);
    console.log(`   Product: ${item.productName}`);
    console.log(`   ASIN: ${item.asin}`);
    console.log(`   Status: ${item.status.toUpperCase()}`);
    if (item.aliasGroup) console.log(`   Alias Group: ${item.aliasGroup}`);
    if (item.issues.length > 0) {
      console.log(`   Issues:`);
      item.issues.forEach(issue => console.log(`     - ${issue}`));
    }
    if (item.reasoning) console.log(`   Reasoning: ${item.reasoning}`);
    console.log(`   Notes: ${item.notes}`);
    console.log(`   Link: ${item.link}`);
    console.log();
  });
}

// Generate CSV for manual review
const csvHeader = 'Status,Ingredient,Product Name,ASIN,Confidence,Alias Group,Issues,Notes,Action Needed,Link\n';
const csvRows = reviewItems.map(item => {
  const escapeCsv = (str: string) => `"${str.replace(/"/g, '""')}"`;
  return [
    item.status.toUpperCase(),
    escapeCsv(item.ingredient),
    escapeCsv(item.productName),
    item.asin,
    item.confidence.toUpperCase(),
    item.aliasGroup || '',
    escapeCsv(item.issues.join('; ')),
    escapeCsv(item.notes),
    item.status === 'auto-invalid' ? 'FIND NEW ASIN' : 'VERIFY',
    item.link,
  ].join(',');
}).join('\n');

const csv = csvHeader + csvRows;
const outputPath = path.join(process.cwd(), 'PHASE_1_5_MANUAL_REVIEW.csv');
fs.writeFileSync(outputPath, csv, 'utf-8');

console.log('='.repeat(80));
console.log('FILES GENERATED');
console.log('='.repeat(80));
console.log();
console.log(`CSV saved to: ${outputPath}`);
console.log();
console.log('='.repeat(80));
</file>

<file path="lib/generator/QuickTest.ts">
/**
 * Phase 1 Smoke Test - Verify critical fixes
 * Tests: S1 (1 primary protein), portion calc (petWeightKg), T1/T2/T3 hard fails
 */

import { RecipeBuilder } from './RecipeBuilder';

console.log('\n=== PHASE 1 SMOKE TEST ===\n');

// Test 1: Dog recipe with actual pet weight
console.log('TEST 1: Dog recipe with petWeightKg (10kg dog)');
const dogConstraints = {
  species: 'dogs' as const,
  lifeStage: 'adult' as const,
  petWeightKg: 10, // PHASE 1.4: Actual pet weight
  healthConcerns: [],
  budgetPerMeal: 4.0,
  targetCalories: undefined,
  allergies: [],
  bannedIngredients: [],
};

let successCount = 0;
let failCount = 0;

for (let i = 0; i < 3; i++) {
  const builder = new RecipeBuilder(dogConstraints, 'standard', 'medium');
  const recipe = builder.generate();

  if (recipe) {
    successCount++;
    console.log(`\n‚úÖ Dog Recipe ${i + 1}:`);
    
    // PHASE 1.2: Verify exactly 1 primary protein (PHASE 1.7: use proteinRole)
    const primaryProteins = recipe.ingredients.filter(ing => ing.ingredient.proteinRole === 'primary');
    console.log(`   Primary proteins: ${primaryProteins.map(p => p.ingredient.name).join(', ')} (count: ${primaryProteins.length})`);
    if (primaryProteins.length !== 1) {
      console.log(`   ‚ùå FAIL: Expected 1 primary protein, got ${primaryProteins.length}`);
    } else {
      console.log(`   ‚úÖ PASS: Exactly 1 primary protein`);
    }
    
    // PHASE 1.4: Check portion calculation uses pet weight
    const totalGrams = recipe.totalGrams;
    console.log(`   Total grams: ${totalGrams} (for 10kg dog)`);
    if (totalGrams < 200 || totalGrams > 1000) {
      console.log(`   ‚ö†Ô∏è  Portion seems off for 10kg dog`);
    }
    
    // Check organ meat percentage
    const organMeatGrams = recipe.ingredients
      .filter(ing =>
        ing.ingredient.feedingRole === 'supplement' &&
        (ing.ingredient.name.toLowerCase().includes('liver') ||
         ing.ingredient.name.toLowerCase().includes('kidney') ||
         ing.ingredient.name.toLowerCase().includes('heart'))
      )
      .reduce((sum, ing) => sum + ing.grams, 0);
    
    const organPercent = (organMeatGrams / recipe.totalGrams) * 100;
    console.log(`   Organ meat: ${organPercent.toFixed(1)}%`);
    if (organPercent > 10) {
      console.log(`   ‚ùå FAIL: Organ meat exceeds 10%`);
    } else {
      console.log(`   ‚úÖ PASS: Organ meat within 10% cap`);
    }
    
    // Check for toxic pairings
    const hasLiver = recipe.ingredients.some(ing => ing.ingredient.name.toLowerCase().includes('liver'));
    const hasSalmon = recipe.ingredients.some(ing => ing.ingredient.name.toLowerCase().includes('salmon'));
    const hasCod = recipe.ingredients.some(ing => ing.ingredient.name.toLowerCase().includes('cod'));
    
    if (hasLiver && (hasSalmon || hasCod)) {
      console.log(`   ‚ùå FAIL: TOXIC PAIRING - Liver + ${hasSalmon ? 'salmon' : 'cod'}`);
    } else {
      console.log(`   ‚úÖ PASS: No toxic pairings`);
    }
  } else {
    failCount++;
    console.log(`\n‚ùå Dog Recipe ${i + 1}: Failed to generate`);
  }
}

// Test 2: Cat recipe (salmon_atlantic should be primary)
console.log('\n\nTEST 2: Cat recipe (salmon_atlantic as primary protein)');
const catConstraints = {
  species: 'cats' as const,
  lifeStage: 'adult' as const,
  petWeightKg: 4, // PHASE 1.4: Typical cat weight
  healthConcerns: [],
  budgetPerMeal: 3.0,
  targetCalories: undefined,
  allergies: [],
  bannedIngredients: [],
};

for (let i = 0; i < 2; i++) {
  const builder = new RecipeBuilder(catConstraints, 'standard', 'medium');
  const recipe = builder.generate();

  if (recipe) {
    successCount++;
    console.log(`\n‚úÖ Cat Recipe ${i + 1}:`);
    
    const primaryProteins = recipe.ingredients.filter(ing => ing.ingredient.feedingRole === 'staple');
    console.log(`   Primary protein: ${primaryProteins.map(p => p.ingredient.name).join(', ')}`);
    if (primaryProteins.length !== 1) {
      console.log(`   ‚ùå FAIL: Expected 1 primary protein, got ${primaryProteins.length}`);
    } else {
      console.log(`   ‚úÖ PASS: Exactly 1 primary protein`);
    }
    
    console.log(`   Total grams: ${recipe.totalGrams} (for 4kg cat)`);
  } else {
    failCount++;
    console.log(`\n‚ùå Cat Recipe ${i + 1}: Failed to generate`);
  }
}

console.log(`\n\n=== PHASE 1 SMOKE TEST RESULTS ===`);
console.log(`‚úÖ Passed: ${successCount}`);
console.log(`‚ùå Failed: ${failCount}`);
console.log(`Total: ${successCount + failCount}\n`);
</file>

<file path="lib/generator/RecipeBuilder.integration.test.ts">
/**
 * RECIPE BUILDER INTEGRATION TESTS
 * Tests biological invariants using real recipe generation
 * 
 * Run with: npm test -- RecipeBuilder.integration.test.ts
 */

import { RecipeBuilder, type GenerationConstraints } from './RecipeBuilder';

// ============================================================================
// TEST UTILITIES
// ============================================================================

interface TestResult {
  passed: boolean;
  name: string;
  error?: string;
}

const results: TestResult[] = [];

function assert(condition: boolean, message: string) {
  if (!condition) {
    throw new Error(message);
  }
}

function test(name: string, fn: () => void): TestResult {
  try {
    fn();
    const result = { passed: true, name };
    results.push(result);
    console.log(`  ‚úÖ ${name}`);
    return result;
  } catch (error) {
    const result = {
      passed: false,
      name,
      error: error instanceof Error ? error.message : String(error),
    };
    results.push(result);
    console.log(`  ‚ùå ${name}: ${result.error}`);
    return result;
  }
}

// ============================================================================
// 1. GOLDEN-PATH TESTS
// ============================================================================

console.log('\nüìã Golden-Path Tests (System Succeeds)');

test('Perfect dog: generates recipe with good composition', () => {
  const constraints: GenerationConstraints = {
    species: 'dogs',
    lifeStage: 'adult',
    healthConcerns: [],
    budgetPerMeal: 4.0,
    targetCalories: 500,
    allergies: [],
    bannedIngredients: [],
  };

  const builder = new RecipeBuilder(constraints, 'standard', 'medium');
  const recipe = builder.generate();

  assert(recipe !== null, 'Recipe should be generated');
  assert(recipe!.debugInfo?.topScores[0].score >= 60, 'Top score should be ‚â•60');

  // Check composition (most important)
  const hasProtein = recipe!.ingredients.some(ing => ing.ingredient.category === 'protein');
  const hasCarb = recipe!.ingredients.some(ing => ing.ingredient.category === 'carb');
  const hasVeg = recipe!.ingredients.some(ing => ing.ingredient.category === 'vegetable');

  assert(hasProtein && hasCarb && hasVeg, 'Should have protein + carb + veg');
});

test('Perfect cat: high protein, low carb, ‚â•90 score', () => {
  const constraints: GenerationConstraints = {
    species: 'cats',
    lifeStage: 'adult',
    healthConcerns: [],
    budgetPerMeal: 5.0,
    targetCalories: 400,
    allergies: [],
    bannedIngredients: [],
  };

  const builder = new RecipeBuilder(constraints, 'standard', 'medium');
  const recipe = builder.generate();

  assert(recipe !== null, 'Recipe should be generated');
  assert(recipe!.debugInfo?.topScores[0].score >= 90, 'Top score should be ‚â•90');

  // Cats should have high protein, low/no carb
  const proteinCount = recipe!.ingredients.filter(
    ing => ing.ingredient.category === 'protein'
  ).length;
  const carbCount = recipe!.ingredients.filter(ing => ing.ingredient.category === 'carb').length;

  assert(proteinCount >= 1, 'Should have at least 1 protein');
  assert(carbCount <= 1, 'Cats should have 0-1 carbs');
});

// ============================================================================
// 2. REJECTION TESTS (Safety Gates)
// ============================================================================

console.log('\nüìã Rejection Tests (Safety Gates Work)');

test('Multiple primary proteins rejected (S1 rule)', () => {
  const constraints: GenerationConstraints = {
    species: 'dogs',
    lifeStage: 'adult',
    healthConcerns: [],
    budgetPerMeal: 4.0,
    targetCalories: 500,
    allergies: [],
    bannedIngredients: [],
  };

  // Generate 20 recipes and verify none have multiple primary proteins
  for (let i = 0; i < 20; i++) {
    const builder = new RecipeBuilder(constraints, 'standard', 'medium');
    const recipe = builder.generate();

    if (recipe) {
      const primaryProteins = recipe.ingredients.filter(
        ing => ing.ingredient.feedingRole === 'staple' && ing.ingredient.category === 'protein'
      );
      assert(primaryProteins.length === 1, `Recipe ${i}: should have exactly 1 primary protein`);
    }
  }
});

test('Missing carb for dog rejected (S4 rule)', () => {
  const constraints: GenerationConstraints = {
    species: 'dogs',
    lifeStage: 'adult',
    healthConcerns: [],
    budgetPerMeal: 4.0,
    targetCalories: 500,
    allergies: [],
    bannedIngredients: [],
  };

  // Generate 20 recipes and verify all have carbs
  for (let i = 0; i < 20; i++) {
    const builder = new RecipeBuilder(constraints, 'standard', 'medium');
    const recipe = builder.generate();

    if (recipe) {
      const hasCarb = recipe.ingredients.some(ing => ing.ingredient.category === 'carb');
      assert(hasCarb, `Recipe ${i}: dogs require carbs`);
    }
  }
});

// ============================================================================
// 3. NUTRIENT CEILING TESTS
// ============================================================================

console.log('\nüìã Nutrient Ceiling Tests');

test('Vitamin A ceiling enforced (T1 rule)', () => {
  const constraints: GenerationConstraints = {
    species: 'dogs',
    lifeStage: 'adult',
    healthConcerns: [],
    budgetPerMeal: 4.0,
    targetCalories: 500,
    allergies: [],
    bannedIngredients: [],
  };

  // Generate 20 recipes and verify vitamin A doesn't exceed ceiling (5000 IU for dogs)
  for (let i = 0; i < 20; i++) {
    const builder = new RecipeBuilder(constraints, 'standard', 'medium');
    const recipe = builder.generate();

    if (recipe) {
      const totalVitaminA = recipe.ingredients.reduce(
        (sum, ing) => sum + (ing.ingredient.composition.vitaminA || 0),
        0
      );
      assert(
        totalVitaminA <= 5000,
        `Recipe ${i}: vitamin A ${totalVitaminA} exceeds dog ceiling of 5000 IU`
      );
    }
  }
});

test('Calcium-phosphorus ratio in range (T6 rule)', () => {
  const constraints: GenerationConstraints = {
    species: 'dogs',
    lifeStage: 'adult',
    healthConcerns: [],
    budgetPerMeal: 4.0,
    targetCalories: 500,
    allergies: [],
    bannedIngredients: [],
  };

  // Dog Ca:P range is 1.2-2.0
  for (let i = 0; i < 20; i++) {
    const builder = new RecipeBuilder(constraints, 'standard', 'medium');
    const recipe = builder.generate();

    if (recipe) {
      const totalCalcium = recipe.ingredients.reduce(
        (sum, ing) => sum + (ing.ingredient.composition.calcium || 0),
        0
      );
      const totalPhosphorus = recipe.ingredients.reduce(
        (sum, ing) => sum + (ing.ingredient.composition.phosphorus || 0),
        0
      );

      if (totalPhosphorus > 0) {
        const ratio = totalCalcium / totalPhosphorus;
        assert(
          ratio >= 1.2 && ratio <= 2.0,
          `Recipe ${i}: Ca:P ratio ${ratio.toFixed(2)} outside dog range 1.2-2.0`
        );
      }
    }
  }
});

// ============================================================================
// 4. ALLERGEN & DERIVATIVE TESTS
// ============================================================================

console.log('\nüìã Allergen & Derivative Tests');

test('Allergen derivatives rejected (T5 rule)', () => {
  const constraints: GenerationConstraints = {
    species: 'dogs',
    lifeStage: 'adult',
    healthConcerns: [],
    budgetPerMeal: 4.0,
    targetCalories: 500,
    allergies: ['chicken'],
    bannedIngredients: [],
  };

  // Generate 20 recipes and verify no chicken or chicken derivatives
  for (let i = 0; i < 20; i++) {
    const builder = new RecipeBuilder(constraints, 'standard', 'medium');
    const recipe = builder.generate();

    if (recipe) {
      const hasChickenDerivative = recipe.ingredients.some(ing =>
        ing.ingredient.id.toLowerCase().includes('chicken') ||
        ing.ingredient.name.toLowerCase().includes('chicken')
      );
      assert(!hasChickenDerivative, `Recipe ${i}: should not contain chicken derivatives`);
    }
  }
});

// ============================================================================
// 5. DISTRIBUTION TESTS (Catch Clustering)
// ============================================================================

console.log('\nüìã Distribution Tests (No Clustering)');

test('Score spread: 50 recipes have variance', () => {
  const constraints: GenerationConstraints = {
    species: 'dogs',
    lifeStage: 'adult',
    healthConcerns: [],
    budgetPerMeal: 4.0,
    targetCalories: 500,
    allergies: [],
    bannedIngredients: [],
  };

  const scores: number[] = [];
  for (let i = 0; i < 50; i++) {
    const builder = new RecipeBuilder(constraints, 'standard', 'medium');
    const recipe = builder.generate();
    if (recipe?.debugInfo?.topScores[0]) {
      scores.push(recipe.debugInfo.topScores[0].score);
    }
  }

  assert(scores.length >= 40, 'Should generate at least 40 recipes');

  const max = Math.max(...scores);
  const min = Math.min(...scores);
  const mean = scores.reduce((a, b) => a + b, 0) / scores.length;
  const variance = scores.reduce((sum, s) => sum + Math.pow(s - mean, 2), 0) / scores.length;
  const stdDev = Math.sqrt(variance);

  assert(max >= 95, `Max score should be ‚â•95 (got ${max})`);
  assert(min >= 60, `Min score should be ‚â•60 (got ${min})`);
  assert(stdDev > 6, `Std dev should be >6 (got ${stdDev.toFixed(2)})`);

  // Check for clustering (no more than 20% identical scores)
  const scoreFreq = new Map<number, number>();
  scores.forEach(s => scoreFreq.set(s, (scoreFreq.get(s) || 0) + 1));
  const maxFreq = Math.max(...scoreFreq.values());
  const clusterPercent = (maxFreq / scores.length) * 100;

  assert(
    clusterPercent <= 20,
    `No single score should appear >20% (got ${clusterPercent.toFixed(1)}%)`
  );
});

// ============================================================================
// 6. REGRESSION TESTS (Never Break Again)
// ============================================================================

console.log('\nüìã Regression Tests (Biological Invariants)');

test('Salmon + liver never appears', () => {
  const constraints: GenerationConstraints = {
    species: 'dogs',
    lifeStage: 'adult',
    healthConcerns: [],
    budgetPerMeal: 4.0,
    targetCalories: 500,
    allergies: [],
    bannedIngredients: [],
  };

  for (let i = 0; i < 50; i++) {
    const builder = new RecipeBuilder(constraints, 'standard', 'medium');
    const recipe = builder.generate();

    if (recipe) {
      const ingredients = recipe.ingredients.map(ing => ing.ingredient.name.toLowerCase());
      const hasSalmon = ingredients.some(ing => ing.includes('salmon'));
      const hasLiver = ingredients.some(ing => ing.includes('liver'));

      assert(
        !(hasSalmon && hasLiver),
        `Salmon + liver should never appear together (found in recipe ${i})`
      );
    }
  }
});

test('Organ meat never exceeds 10%', () => {
  const constraints: GenerationConstraints = {
    species: 'dogs',
    lifeStage: 'adult',
    healthConcerns: [],
    budgetPerMeal: 4.0,
    targetCalories: 500,
    allergies: [],
    bannedIngredients: [],
  };

  for (let i = 0; i < 50; i++) {
    const builder = new RecipeBuilder(constraints, 'standard', 'medium');
    const recipe = builder.generate();

    if (recipe) {
      const organMeatGrams = recipe.ingredients
        .filter(ing =>
          ing.ingredient.name.toLowerCase().includes('liver') ||
          ing.ingredient.name.toLowerCase().includes('kidney') ||
          ing.ingredient.name.toLowerCase().includes('heart')
        )
        .reduce((sum, ing) => sum + ing.grams, 0);

      const organPercent = (organMeatGrams / recipe.totalGrams) * 100;
      assert(organPercent <= 10, `Organ meat should be ‚â§10% (got ${organPercent.toFixed(1)}%)`);
    }
  }
});

test('Exactly one primary protein per recipe', () => {
  const constraints: GenerationConstraints = {
    species: 'dogs',
    lifeStage: 'adult',
    healthConcerns: [],
    budgetPerMeal: 4.0,
    targetCalories: 500,
    allergies: [],
    bannedIngredients: [],
  };

  for (let i = 0; i < 50; i++) {
    const builder = new RecipeBuilder(constraints, 'standard', 'medium');
    const recipe = builder.generate();

    if (recipe) {
      const primaryProteins = recipe.ingredients.filter(
        ing => ing.ingredient.feedingRole === 'staple' && ing.ingredient.category === 'protein'
      );

      assert(
        primaryProteins.length === 1,
        `Should have exactly 1 primary protein (got ${primaryProteins.length})`
      );
    }
  }
});

// ============================================================================
// 7. PROPERTY-BASED FUZZER (1000 Random Recipes)
// ============================================================================

console.log('\nüìã Property-Based Fuzzer (1000 Random Recipes)');

test('No unsafe recipe reaches scoring (all 1000 pass validation)', () => {
  const constraints: GenerationConstraints = {
    species: 'dogs',
    lifeStage: 'adult',
    healthConcerns: [],
    budgetPerMeal: 4.0,
    targetCalories: 500,
    allergies: [],
    bannedIngredients: [],
  };

  let unsafeCount = 0;
  for (let i = 0; i < 1000; i++) {
    const builder = new RecipeBuilder(constraints, 'standard', 'medium');
    const recipe = builder.generate();

    if (recipe?.debugInfo?.validation && !recipe.debugInfo.validation.isValid) {
      unsafeCount++;
    }
  }

  assert(unsafeCount === 0, `No recipes should fail validation (${unsafeCount} failed out of 1000)`);
});

test('No nutrient ceiling violations survive (all 1000 pass T rules)', () => {
  const constraints: GenerationConstraints = {
    species: 'dogs',
    lifeStage: 'adult',
    healthConcerns: [],
    budgetPerMeal: 4.0,
    targetCalories: 500,
    allergies: [],
    bannedIngredients: [],
  };

  let violationCount = 0;
  for (let i = 0; i < 1000; i++) {
    const builder = new RecipeBuilder(constraints, 'standard', 'medium');
    const recipe = builder.generate();

    if (recipe?.debugInfo?.validation?.failedRules.some(r => r.startsWith('T'))) {
      violationCount++;
    }
  }

  assert(
    violationCount === 0,
    `No nutrient ceiling violations should survive (${violationCount} found out of 1000)`
  );
});

// ============================================================================
// TEST SUMMARY
// ============================================================================

console.log('\n' + '='.repeat(70));
console.log('TEST SUMMARY');
console.log('='.repeat(70));

const passed = results.filter(r => r.passed).length;
const failed = results.filter(r => !r.passed).length;

console.log(`\n‚úÖ Passed: ${passed}`);
console.log(`‚ùå Failed: ${failed}`);
console.log(`üìä Total: ${results.length}`);

if (failed > 0) {
  console.log('\n' + '='.repeat(70));
  console.log('FAILURES');
  console.log('='.repeat(70));
  results
    .filter(r => !r.passed)
    .forEach(r => {
      console.log(`\n‚ùå ${r.name}`);
      console.log(`   ${r.error}`);
    });
  process.exit(1);
} else {
  console.log('\nüéâ All tests passed!');
  process.exit(0);
}
</file>

<file path="lib/generator/RecipeBuilder.smoke.test.ts">
/**
 * RECIPE BUILDER SMOKE TESTS
 * Minimal viable tests that prove core fixes work with actual ingredient data
 * 
 * Focus: Verify the system generates diverse, safe recipes
 * Not: Perfect nutrient ratios (ingredient data is incomplete)
 */

import { RecipeBuilder, type GenerationConstraints } from './RecipeBuilder';

let passed = 0;
let failed = 0;

function test(name: string, fn: () => void) {
  try {
    fn();
    console.log(`‚úÖ ${name}`);
    passed++;
  } catch (error) {
    console.log(`‚ùå ${name}`);
    console.log(`   ${error instanceof Error ? error.message : String(error)}`);
    failed++;
  }
}

function assert(condition: boolean, message: string) {
  if (!condition) throw new Error(message);
}

// ============================================================================
// CORE FIXES VERIFICATION
// ============================================================================

console.log('\nüìã CORE FIXES VERIFICATION\n');

test('Weighted random selection: 10 recipes are different', () => {
  const constraints: GenerationConstraints = {
    species: 'dogs',
    lifeStage: 'adult',
    healthConcerns: [],
    budgetPerMeal: 4.0,
    targetCalories: 500,
    allergies: [],
    bannedIngredients: [],
  };

  const recipes = [];
  for (let i = 0; i < 10; i++) {
    const builder = new RecipeBuilder(constraints, 'standard', 'medium');
    const recipe = builder.generate();
    if (recipe) {
      recipes.push(recipe.ingredients.map(ing => ing.ingredient.id).sort().join(','));
    }
  }

  const uniqueRecipes = new Set(recipes);
  assert(
    uniqueRecipes.size >= 5,
    `Should have at least 5 different recipes (got ${uniqueRecipes.size})`
  );
});

test('Organ meat never exceeds 10%', () => {
  const constraints: GenerationConstraints = {
    species: 'dogs',
    lifeStage: 'adult',
    healthConcerns: [],
    budgetPerMeal: 4.0,
    targetCalories: 500,
    allergies: [],
    bannedIngredients: [],
  };

  for (let i = 0; i < 20; i++) {
    const builder = new RecipeBuilder(constraints, 'standard', 'medium');
    const recipe = builder.generate();

    if (recipe) {
      const organMeatGrams = recipe.ingredients
        .filter(ing =>
          ing.ingredient.name.toLowerCase().includes('liver') ||
          ing.ingredient.name.toLowerCase().includes('kidney') ||
          ing.ingredient.name.toLowerCase().includes('heart')
        )
        .reduce((sum, ing) => sum + ing.grams, 0);

      const organPercent = (organMeatGrams / recipe.totalGrams) * 100;
      assert(organPercent <= 10, `Organ meat ${organPercent.toFixed(1)}% exceeds 10%`);
    }
  }
});

test('Salmon + liver never co-occur', () => {
  const constraints: GenerationConstraints = {
    species: 'dogs',
    lifeStage: 'adult',
    healthConcerns: [],
    budgetPerMeal: 4.0,
    targetCalories: 500,
    allergies: [],
    bannedIngredients: [],
  };

  for (let i = 0; i < 30; i++) {
    const builder = new RecipeBuilder(constraints, 'standard', 'medium');
    const recipe = builder.generate();

    if (recipe) {
      const ingredients = recipe.ingredients.map(ing => ing.ingredient.name.toLowerCase());
      const hasSalmon = ingredients.some(ing => ing.includes('salmon'));
      const hasLiver = ingredients.some(ing => ing.includes('liver'));

      assert(!(hasSalmon && hasLiver), `Salmon + liver found together in recipe ${i}`);
    }
  }
});

test('Dogs always get carbs', () => {
  const constraints: GenerationConstraints = {
    species: 'dogs',
    lifeStage: 'adult',
    healthConcerns: [],
    budgetPerMeal: 4.0,
    targetCalories: 500,
    allergies: [],
    bannedIngredients: [],
  };

  for (let i = 0; i < 20; i++) {
    const builder = new RecipeBuilder(constraints, 'standard', 'medium');
    const recipe = builder.generate();

    if (recipe) {
      const hasCarb = recipe.ingredients.some(ing => ing.ingredient.category === 'carb');
      assert(hasCarb, `Recipe ${i} missing carbs`);
    }
  }
});

test('Cats can be carb-free', () => {
  const constraints: GenerationConstraints = {
    species: 'cats',
    lifeStage: 'adult',
    healthConcerns: [],
    budgetPerMeal: 5.0,
    targetCalories: 400,
    allergies: [],
    bannedIngredients: [],
  };

  let carbFreeCount = 0;
  for (let i = 0; i < 20; i++) {
    const builder = new RecipeBuilder(constraints, 'standard', 'medium');
    const recipe = builder.generate();

    if (recipe) {
      const hasCarb = recipe.ingredients.some(ing => ing.ingredient.category === 'carb');
      if (!hasCarb) carbFreeCount++;
    }
  }

  assert(carbFreeCount > 0, 'At least some cat recipes should be carb-free');
});

test('Allergen filtering works', () => {
  const constraints: GenerationConstraints = {
    species: 'dogs',
    lifeStage: 'adult',
    healthConcerns: [],
    budgetPerMeal: 4.0,
    targetCalories: 500,
    allergies: ['chicken'],
    bannedIngredients: [],
  };

  for (let i = 0; i < 20; i++) {
    const builder = new RecipeBuilder(constraints, 'standard', 'medium');
    const recipe = builder.generate();

    if (recipe) {
      const hasChicken = recipe.ingredients.some(ing =>
        ing.ingredient.id.toLowerCase().includes('chicken') ||
        ing.ingredient.name.toLowerCase().includes('chicken')
      );
      assert(!hasChicken, `Recipe ${i} contains chicken despite allergy`);
    }
  }
});

test('Diversity modes produce different results', () => {
  const constraints: GenerationConstraints = {
    species: 'dogs',
    lifeStage: 'adult',
    healthConcerns: [],
    budgetPerMeal: 4.0,
    targetCalories: 500,
    allergies: [],
    bannedIngredients: [],
  };

  const modes = ['high', 'medium', 'low', 'none'] as const;
  const results: Record<string, string[]> = {};

  for (const mode of modes) {
    results[mode] = [];
    for (let i = 0; i < 5; i++) {
      const builder = new RecipeBuilder(constraints, 'standard', mode);
      const recipe = builder.generate();
      if (recipe) {
        results[mode].push(recipe.ingredients.map(ing => ing.ingredient.id).sort().join(','));
      }
    }
  }

  // Each mode should produce some variation
  for (const mode of modes) {
    const unique = new Set(results[mode]).size;
    assert(unique >= 1, `Mode ${mode} should produce at least 1 unique recipe`);
  }
});

// ============================================================================
// SUMMARY
// ============================================================================

console.log('\n' + '='.repeat(70));
console.log('TEST SUMMARY');
console.log('='.repeat(70));
console.log(`‚úÖ Passed: ${passed}`);
console.log(`‚ùå Failed: ${failed}`);
console.log(`üìä Total: ${passed + failed}\n`);

if (failed === 0) {
  console.log('üéâ All smoke tests passed!');
  console.log('\nCore fixes verified:');
  console.log('  ‚úì Weighted random selection (recipes are diverse)');
  console.log('  ‚úì Organ meat cap (‚â§10%)');
  console.log('  ‚úì Salmon + liver prevention');
  console.log('  ‚úì Carb requirement for dogs');
  console.log('  ‚úì Carb-free allowed for cats');
  console.log('  ‚úì Allergen filtering');
  console.log('  ‚úì Diversity modes working');
  process.exit(0);
} else {
  console.log(`\n‚ö†Ô∏è  ${failed} test(s) failed`);
  process.exit(1);
}
</file>

<file path="lib/generator/RecipeBuilder.test.ts">
/**
 * RECIPE BUILDER TEST SUITE
 * Tests biological invariants, not scoring hacks
 * 
 * Categories:
 * 1. Golden-Path Tests (system succeeds on perfect inputs)
 * 2. Rejection Tests (safety gates work)
 * 3. Nutrient Ceiling Tests (micronutrient caps enforced)
 * 4. Allergen & Derivative Tests (cross-source safety)
 * 5. Distribution Tests (no clustering/repetition)
 * 6. Regression Tests (never break again)
 * 7. Property-Based Fuzzer (1000 random recipes)
 */

import { RecipeBuilder, type GenerationConstraints } from './RecipeBuilder';
import { validateRecipeComprehensive } from './RecipeConstraintRules';
import type { Ingredient } from '@/lib/data/ingredients';

// ============================================================================
// TEST UTILITIES
// ============================================================================

interface TestResult {
  passed: boolean;
  name: string;
  error?: string;
  details?: Record<string, any>;
}

const results: TestResult[] = [];

function assert(condition: boolean, message: string) {
  if (!condition) {
    throw new Error(message);
  }
}

function test(name: string, fn: () => void): TestResult {
  try {
    fn();
    const result = { passed: true, name };
    results.push(result);
    return result;
  } catch (error) {
    const result = {
      passed: false,
      name,
      error: error instanceof Error ? error.message : String(error),
    };
    results.push(result);
    return result;
  }
}

function describe(category: string, tests: Array<() => void>) {
  console.log(`\nüìã ${category}`);
  tests.forEach(t => t());
}

// ============================================================================
// 1. GOLDEN-PATH TESTS
// ============================================================================

describe('Golden-Path Tests (System Succeeds)', [
  () => {
    test('Perfect dog: scores ‚â•95, safe composition', () => {
      const constraints: GenerationConstraints = {
        species: 'dogs',
        lifeStage: 'adult',
        healthConcerns: [],
        budgetPerMeal: 4.0,
        targetCalories: 500,
        allergies: [],
        bannedIngredients: [],
      };

      const builder = new RecipeBuilder(constraints, 'standard', 'medium');
      const recipe = builder.generate();

      assert(recipe !== null, 'Recipe should be generated');
      assert(recipe!.debugInfo?.topScores[0].score >= 95, 'Top score should be ‚â•95');
      assert(recipe!.debugInfo?.validation?.isValid, 'Recipe should pass validation');

      // Check composition
      const hasProtein = recipe!.ingredients.some(
        ing => ing.ingredient.category === 'protein'
      );
      const hasCarb = recipe!.ingredients.some(ing => ing.ingredient.category === 'carb');
      const hasVeg = recipe!.ingredients.some(ing => ing.ingredient.category === 'vegetable');

      assert(hasProtein && hasCarb && hasVeg, 'Should have protein + carb + veg');
    });
  },

  () => {
    test('Perfect cat: high protein, low carb, ‚â•90 score', () => {
      const constraints: GenerationConstraints = {
        species: 'cats',
        lifeStage: 'adult',
        healthConcerns: [],
        budgetPerMeal: 5.0,
        targetCalories: 400,
        allergies: [],
        bannedIngredients: [],
      };

      const builder = new RecipeBuilder(constraints, 'standard', 'medium');
      const recipe = builder.generate();

      assert(recipe !== null, 'Recipe should be generated');
      assert(recipe!.debugInfo?.topScores[0].score >= 90, 'Top score should be ‚â•90');

      // Cats should have high protein, low/no carb
      const proteinCount = recipe!.ingredients.filter(
        ing => ing.ingredient.category === 'protein'
      ).length;
      const carbCount = recipe!.ingredients.filter(ing => ing.ingredient.category === 'carb')
        .length;

      assert(proteinCount >= 1, 'Should have at least 1 protein');
      assert(carbCount <= 1, 'Cats should have 0-1 carbs');
    });
  },
]);

// ============================================================================
// 2. REJECTION TESTS (Safety Gates)
// ============================================================================

describe('Rejection Tests (Safety Gates Work)', [
  () => {
    test('Organ overdose rejected: salmon + beef liver', () => {
      const constraints: GenerationConstraints = {
        species: 'dogs',
        lifeStage: 'adult',
        healthConcerns: [],
        budgetPerMeal: 4.0,
        targetCalories: 500,
        allergies: [],
        bannedIngredients: [],
      };

      // Simulate selecting salmon + beef liver
      const mockIngredients: Ingredient[] = [
        {
          id: 'salmon',
          name: 'salmon',
          category: 'protein',
          feedingRole: 'staple',
          composition: { protein: 25, fat: 13, kcal: 208, calcium: 12, phosphorus: 200 },
          speciesCompatibility: { dog: 'ok', cat: 'ok', bird: 'limit', reptile: 'limit', 'pocket-pet': 'avoid' },
          pricePerLb: 8.0,
        },
        {
          id: 'beef_liver',
          name: 'beef_liver',
          category: 'protein',
          feedingRole: 'supplement',
          composition: { protein: 20, fat: 3, kcal: 135, calcium: 6, phosphorus: 387, vitaminA: 30000 },
          speciesCompatibility: { dog: 'ok', cat: 'caution', bird: 'limit', reptile: 'limit', 'pocket-pet': 'avoid' },
          pricePerLb: 3.0,
        },
      ];

      const validation = validateRecipeComprehensive(
        mockIngredients,
        'dogs',
        'adult',
        4.0,
        []
      );

      assert(!validation.isValid, 'Should reject organ overdose');
      assert(
        validation.failedRules.includes('T1') || validation.failedRules.includes('S2'),
        'Should fail vitamin A or organ meat rule'
      );
    });
  },

  () => {
    test('Multiple primary proteins rejected', () => {
      const mockIngredients: Ingredient[] = [
        {
          id: 'chicken',
          name: 'chicken_breast',
          category: 'protein',
          feedingRole: 'staple',
          composition: { protein: 31, fat: 3, kcal: 165, calcium: 11, phosphorus: 196 },
          speciesCompatibility: { dog: 'ok', cat: 'ok', bird: 'limit', reptile: 'limit', 'pocket-pet': 'avoid' },
          pricePerLb: 3.0,
        },
        {
          id: 'salmon',
          name: 'salmon',
          category: 'protein',
          feedingRole: 'staple',
          composition: { protein: 25, fat: 13, kcal: 208, calcium: 12, phosphorus: 200 },
          speciesCompatibility: { dog: 'ok', cat: 'ok', bird: 'limit', reptile: 'limit', 'pocket-pet': 'avoid' },
          pricePerLb: 8.0,
        },
      ];

      const validation = validateRecipeComprehensive(
        mockIngredients,
        'dogs',
        'adult',
        4.0,
        []
      );

      assert(!validation.isValid, 'Should reject multiple primary proteins');
      assert(validation.failedRules.includes('S1'), 'Should fail S1 rule');
    });
  },

  () => {
    test('Missing carb for dog rejected', () => {
      const mockIngredients: Ingredient[] = [
        {
          id: 'beef',
          name: 'beef',
          category: 'protein',
          feedingRole: 'staple',
          composition: { protein: 26, fat: 15, kcal: 250, calcium: 10, phosphorus: 180 },
          speciesCompatibility: { dog: 'ok', cat: 'ok', bird: 'limit', reptile: 'limit', 'pocket-pet': 'avoid' },
          pricePerLb: 5.0,
        },
        {
          id: 'carrots',
          name: 'carrots',
          category: 'vegetable',
          feedingRole: 'staple',
          composition: { protein: 0.9, fat: 0.2, kcal: 41, calcium: 33, phosphorus: 35 },
          speciesCompatibility: { dog: 'ok', cat: 'ok', bird: 'ok', reptile: 'ok', 'pocket-pet': 'ok' },
          pricePerLb: 0.5,
        },
        {
          id: 'fish_oil',
          name: 'fish_oil',
          category: 'fat',
          feedingRole: 'supplement',
          composition: { protein: 0, fat: 100, kcal: 902, calcium: 0, phosphorus: 0 },
          speciesCompatibility: { dog: 'ok', cat: 'ok', bird: 'limit', reptile: 'limit', 'pocket-pet': 'avoid' },
          pricePerLb: 15.0,
        },
      ];

      const validation = validateRecipeComprehensive(
        mockIngredients,
        'dogs',
        'adult',
        4.0,
        []
      );

      assert(!validation.isValid, 'Should reject carb-free dog recipe');
      assert(validation.failedRules.includes('S4'), 'Should fail S4 rule');
    });
  },
]);

// ============================================================================
// 3. NUTRIENT CEILING TESTS
// ============================================================================

describe('Nutrient Ceiling Tests', [
  () => {
    test('Vitamin A ceiling enforced (dog)', () => {
      // Liver has ~30,000 IU per 100g
      // Dog ceiling is 5,000 IU
      // 20% liver would exceed ceiling
      const mockIngredients: Ingredient[] = [
        {
          id: 'chicken',
          name: 'chicken_breast',
          category: 'protein',
          feedingRole: 'staple',
          composition: { protein: 31, fat: 3, kcal: 165, calcium: 11, phosphorus: 196, vitaminA: 0 },
          speciesCompatibility: { dog: 'ok', cat: 'ok', bird: 'limit', reptile: 'limit', 'pocket-pet': 'avoid' },
          pricePerLb: 3.0,
        },
        {
          id: 'beef_liver',
          name: 'beef_liver',
          category: 'protein',
          feedingRole: 'supplement',
          composition: { protein: 20, fat: 3, kcal: 135, calcium: 6, phosphorus: 387, vitaminA: 30000 },
          speciesCompatibility: { dog: 'ok', cat: 'caution', bird: 'limit', reptile: 'limit', 'pocket-pet': 'avoid' },
          pricePerLb: 3.0,
        },
        {
          id: 'rice',
          name: 'rice',
          category: 'carb',
          feedingRole: 'staple',
          composition: { protein: 2.7, fat: 0.3, kcal: 130, calcium: 10, phosphorus: 68 },
          speciesCompatibility: { dog: 'ok', cat: 'ok', bird: 'ok', reptile: 'ok', 'pocket-pet': 'ok' },
          pricePerLb: 0.5,
        },
      ];

      const validation = validateRecipeComprehensive(
        mockIngredients,
        'dogs',
        'adult',
        4.0,
        []
      );

      assert(!validation.isValid, 'Should reject vitamin A overload');
      assert(validation.failedRules.includes('T1'), 'Should fail T1 rule');
    });
  },
]);

// ============================================================================
// 4. ALLERGEN & DERIVATIVE TESTS
// ============================================================================

describe('Allergen & Derivative Tests', [
  () => {
    test('Chicken fat rejected for chicken-allergic dog', () => {
      const mockIngredients: Ingredient[] = [
        {
          id: 'beef',
          name: 'beef',
          category: 'protein',
          feedingRole: 'staple',
          composition: { protein: 26, fat: 15, kcal: 250, calcium: 10, phosphorus: 180 },
          speciesCompatibility: { dog: 'ok', cat: 'ok', bird: 'limit', reptile: 'limit', 'pocket-pet': 'avoid' },
          pricePerLb: 5.0,
        },
        {
          id: 'chicken_fat',
          name: 'chicken_fat',
          category: 'fat',
          feedingRole: 'supplement',
          composition: { protein: 0, fat: 100, kcal: 884, calcium: 0, phosphorus: 0 },
          speciesCompatibility: { dog: 'ok', cat: 'ok', bird: 'limit', reptile: 'limit', 'pocket-pet': 'avoid' },
          pricePerLb: 2.0,
        },
      ];

      const validation = validateRecipeComprehensive(
        mockIngredients,
        'dogs',
        'adult',
        4.0,
        ['chicken'] // Pet allergic to chicken
      );

      assert(!validation.isValid, 'Should reject chicken derivative for chicken-allergic pet');
      assert(validation.failedRules.includes('T5'), 'Should fail T5 rule');
    });
  },
]);

// ============================================================================
// 5. DISTRIBUTION TESTS (Catch Clustering)
// ============================================================================

describe('Distribution Tests (No Clustering)', [
  () => {
    test('Score spread: 50 recipes have variance', () => {
      const constraints: GenerationConstraints = {
        species: 'dogs',
        lifeStage: 'adult',
        healthConcerns: [],
        budgetPerMeal: 4.0,
        targetCalories: 500,
        allergies: [],
        bannedIngredients: [],
      };

      const scores: number[] = [];
      for (let i = 0; i < 50; i++) {
        const builder = new RecipeBuilder(constraints, 'standard', 'medium');
        const recipe = builder.generate();
        if (recipe?.debugInfo?.topScores[0]) {
          scores.push(recipe.debugInfo.topScores[0].score);
        }
      }

      assert(scores.length >= 40, 'Should generate at least 40 recipes');

      const max = Math.max(...scores);
      const min = Math.min(...scores);
      const mean = scores.reduce((a, b) => a + b, 0) / scores.length;
      const variance = scores.reduce((sum, s) => sum + Math.pow(s - mean, 2), 0) / scores.length;
      const stdDev = Math.sqrt(variance);

      assert(max >= 95, `Max score should be ‚â•95 (got ${max})`);
      assert(min >= 60, `Min score should be ‚â•60 (got ${min})`);
      assert(stdDev > 6, `Std dev should be >6 (got ${stdDev.toFixed(2)})`);

      // Check for clustering (no more than 20% identical scores)
      const scoreFreq = new Map<number, number>();
      scores.forEach(s => scoreFreq.set(s, (scoreFreq.get(s) || 0) + 1));
      const maxFreq = Math.max(...scoreFreq.values());
      const clusterPercent = (maxFreq / scores.length) * 100;

      assert(
        clusterPercent <= 20,
        `No single score should appear >20% (got ${clusterPercent.toFixed(1)}%)`
      );
    });
  },
]);

// ============================================================================
// 6. REGRESSION TESTS (Never Break Again)
// ============================================================================

describe('Regression Tests (Biological Invariants)', [
  () => {
    test('Salmon + liver never appears', () => {
      const constraints: GenerationConstraints = {
        species: 'dogs',
        lifeStage: 'adult',
        healthConcerns: [],
        budgetPerMeal: 4.0,
        targetCalories: 500,
        allergies: [],
        bannedIngredients: [],
      };

      for (let i = 0; i < 20; i++) {
        const builder = new RecipeBuilder(constraints, 'standard', 'medium');
        const recipe = builder.generate();

        if (recipe) {
          const ingredients = recipe.ingredients.map(ing => ing.ingredient.name.toLowerCase());
          const hasSalmon = ingredients.some(ing => ing.includes('salmon'));
          const hasLiver = ingredients.some(ing => ing.includes('liver'));

          assert(
            !(hasSalmon && hasLiver),
            `Salmon + liver should never appear together (found in recipe ${i})`
          );
        }
      }
    });
  },

  () => {
    test('Organ meat never exceeds 10%', () => {
      const constraints: GenerationConstraints = {
        species: 'dogs',
        lifeStage: 'adult',
        healthConcerns: [],
        budgetPerMeal: 4.0,
        targetCalories: 500,
        allergies: [],
        bannedIngredients: [],
      };

      for (let i = 0; i < 20; i++) {
        const builder = new RecipeBuilder(constraints, 'standard', 'medium');
        const recipe = builder.generate();

        if (recipe) {
          const organMeatGrams = recipe.ingredients
            .filter(ing =>
              ing.ingredient.name.toLowerCase().includes('liver') ||
              ing.ingredient.name.toLowerCase().includes('kidney') ||
              ing.ingredient.name.toLowerCase().includes('heart')
            )
            .reduce((sum, ing) => sum + ing.grams, 0);

          const organPercent = (organMeatGrams / recipe.totalGrams) * 100;
          assert(organPercent <= 10, `Organ meat should be ‚â§10% (got ${organPercent.toFixed(1)}%)`);
        }
      }
    });
  },

  () => {
    test('Exactly one primary protein per recipe', () => {
      const constraints: GenerationConstraints = {
        species: 'dogs',
        lifeStage: 'adult',
        healthConcerns: [],
        budgetPerMeal: 4.0,
        targetCalories: 500,
        allergies: [],
        bannedIngredients: [],
      };

      for (let i = 0; i < 20; i++) {
        const builder = new RecipeBuilder(constraints, 'standard', 'medium');
        const recipe = builder.generate();

        if (recipe) {
          const primaryProteins = recipe.ingredients.filter(
            ing => ing.ingredient.feedingRole === 'staple' && ing.ingredient.category === 'protein'
          );

          assert(
            primaryProteins.length === 1,
            `Should have exactly 1 primary protein (got ${primaryProteins.length})`
          );
        }
      }
    });
  },
]);

// ============================================================================
// 7. PROPERTY-BASED FUZZER (1000 Random Recipes)
// ============================================================================

describe('Property-Based Fuzzer (1000 Random Recipes)', [
  () => {
    test('No unsafe recipe reaches scoring', () => {
      const constraints: GenerationConstraints = {
        species: 'dogs',
        lifeStage: 'adult',
        healthConcerns: [],
        budgetPerMeal: 4.0,
        targetCalories: 500,
        allergies: [],
        bannedIngredients: [],
      };

      let unsafeCount = 0;
      for (let i = 0; i < 1000; i++) {
        const builder = new RecipeBuilder(constraints, 'standard', 'medium');
        const recipe = builder.generate();

        if (recipe?.debugInfo?.validation && !recipe.debugInfo.validation.isValid) {
          unsafeCount++;
        }
      }

      assert(
        unsafeCount === 0,
        `No recipes should fail validation (${unsafeCount} failed out of 1000)`
      );
    });
  },

  () => {
    test('No nutrient ceiling violations survive', () => {
      const constraints: GenerationConstraints = {
        species: 'dogs',
        lifeStage: 'adult',
        healthConcerns: [],
        budgetPerMeal: 4.0,
        targetCalories: 500,
        allergies: [],
        bannedIngredients: [],
      };

      let violationCount = 0;
      for (let i = 0; i < 1000; i++) {
        const builder = new RecipeBuilder(constraints, 'standard', 'medium');
        const recipe = builder.generate();

        if (recipe?.debugInfo?.validation?.failedRules.some(r => r.startsWith('T'))) {
          violationCount++;
        }
      }

      assert(
        violationCount === 0,
        `No nutrient ceiling violations should survive (${violationCount} found out of 1000)`
      );
    });
  },
]);

// ============================================================================
// TEST SUMMARY
// ============================================================================

export function runAllTests() {
  console.log('\n' + '='.repeat(70));
  console.log('RECIPE BUILDER TEST SUITE');
  console.log('='.repeat(70));

  const passed = results.filter(r => r.passed).length;
  const failed = results.filter(r => !r.passed).length;

  console.log(`\n‚úÖ Passed: ${passed}`);
  console.log(`‚ùå Failed: ${failed}`);
  console.log(`üìä Total: ${results.length}`);

  if (failed > 0) {
    console.log('\n' + '='.repeat(70));
    console.log('FAILURES');
    console.log('='.repeat(70));
    results
      .filter(r => !r.passed)
      .forEach(r => {
        console.log(`\n‚ùå ${r.name}`);
        console.log(`   Error: ${r.error}`);
      });
  }

  return { passed, failed, total: results.length };
}

// Export for testing
export { test, describe, assert };
</file>

<file path="lib/generator/RecipeBuilder.ts">
/**
 * ENHANCED RECIPE BUILDER
 * Adds health-aware ingredient selection + palatability
 * 
 * Key improvements:
 * 1. Health concerns drive ingredient selection (40% weight)
 * 2. Contraindications filtered as hard constraints
 * 3. Palatability built into scoring (30% weight)
 * 4. Species-specific taste preferences
 * 5. Debug info for transparency
 */

import type { Species } from '@/lib/data/ingredients';
import { INGREDIENTS, getIngredientsForSpecies, type Ingredient, type IngredientCategory } from '@/lib/data/ingredients';

/**
 * Normalize ingredient category strings to canonical values.
 * Handles variations like 'fish', 'seafood', 'meat', 'poultry' ‚Üí 'protein'
 */
function canonicalCategory(cat: any): IngredientCategory | 'unknown' {
  const c = String(cat ?? '').toLowerCase().trim();

  // PROTEIN family (fish, meat, poultry, seafood, eggs)
  if (
    c === 'protein' ||
    c.includes('protein') ||
    c.includes('meat') ||
    c.includes('poultry') ||
    c.includes('fish') ||
    c.includes('seafood') ||
    c.includes('egg')
  ) return 'protein';

  // VEGETABLE family
  if (c === 'vegetable' || c.includes('veg')) return 'vegetable';

  // FAT family (oils)
  if (c === 'fat' || c.includes('oil')) return 'fat';

  // CARB family (grains, starches)
  if (c === 'carb' || c.includes('grain') || c.includes('starch')) return 'carb';

  // Keep specialized categories as-is
  if (['seed', 'nut', 'fruit', 'insect', 'hay', 'pellet', 'supplement'].includes(c)) {
    return c as IngredientCategory;
  }

  return 'unknown';
}
import { getNutritionalStandard } from '@/lib/data/aafco-standards';
import { HEALTH_BENEFIT_MAP, HEALTH_CONTRAINDICATIONS } from '@/lib/data/healthBenefitMap';
import { validateRecipeComprehensive } from './RecipeConstraintRules';
import { shouldPruneCandidateForMicronutrients, getPruningReason } from './CombinatoricsPruning';
import { isFatCompatibleWithProteins, calculatePairingScore, logPairingDecision } from './RecipePMIScoring';
import { applyPriorScoring } from './RecipePriorScoring';
import { filterCandidatesByCommercialPriors, applyCommercialPriorScoring, hasCommercialPriors } from './CommercialPriorEnforcement';

export interface GenerationConstraints {
  species: Species;
  lifeStage: 'puppy' | 'adult' | 'senior';
  petWeightKg?: number; // PHASE 1.3: Actual pet weight for portion calculation
  healthConcerns?: string[];
  budgetPerMeal?: number;
  targetCalories?: number;
  allergies?: string[];
  bannedIngredients?: string[];
  recentIngredients?: string[]; // Track recently used ingredients for variety
}

export interface PortionedIngredient {
  ingredient: Ingredient;
  grams: number;
}

export interface GeneratedRecipeRaw {
  ingredients: PortionedIngredient[];
  totalGrams: number;
  estimatedCost: number;
  micronutrientDataIncomplete?: boolean; // Flag for exotic pets (no AAFCO standards)
  debugInfo?: {
    candidateCount: number;
    topScores: Array<{ name: string; score: number; breakdown: any }>;
    validation?: {
      isValid: boolean;
      failedRules: string[];
      softPenalties: Array<{ ruleId: string; penalty: number; message: string }>;
    };
  };
}

interface ScoredIngredient {
  ingredient: Ingredient;
  totalScore: number;
  breakdown: {
    health: number;
    quality: number;
    nutritional: number;
    diversity?: number;
  };
}

export type DiversityMode = 'high' | 'medium' | 'low' | 'none';

export class RecipeBuilder {
  private constraints: GenerationConstraints;
  private qualityTier: 'premium' | 'standard' | 'budget';
  private diversityMode: DiversityMode;

  // Scoring weights (reflects priority order)
  private weights = {
    health: 0.40,
    nutritional: 0.50,
    quality: 0.10,
  };

  constructor(
    constraints: GenerationConstraints,
    qualityTier: 'premium' | 'standard' | 'budget' = 'standard',
    diversityMode: DiversityMode = 'medium'
  ) {
    this.constraints = constraints;
    this.qualityTier = qualityTier;
    this.diversityMode = diversityMode;
  }

  /**
   * Main generation method
   */
  generate(): GeneratedRecipeRaw | null {
    try {
      console.log(`\n========== RECIPE GENERATION START (${this.constraints.species}) ==========`);
      const maxRetries = 3;
      let attempt = 0;
      const failedIngredients = new Set<string>(); // Track ingredients that failed hard gates

      while (attempt < maxRetries) {
        attempt++;
        console.log(`\n--- Attempt ${attempt}/${maxRetries} ---`);

        // 1. Get candidate ingredients (hard filters)
        let candidates = this.getCandidateIngredients();
        console.log(`[Step 1] Candidates after filters: ${candidates.length}`);
        
        // üî• CRITICAL GUARDRAIL: Block small candidate pools (vetted-only path)
        const MIN_POOL = 200;
        if (this.constraints.species === 'cats' && candidates.length < MIN_POOL) {
          throw new Error(
            `[RecipeBuilder] Candidate pool collapsed to ${candidates.length}. ` +
            `Refusing to generate recipes from small pool (likely vetted-only/products-only path). ` +
            `Minimum required: ${MIN_POOL}`
          );
        }
        
        if (candidates.length === 0) {
          console.warn(`No candidate ingredients found for ${this.constraints.species}`);
          return null;
        }

        // üî• NEW: Exclude ingredients that failed hard gates in previous attempts
        if (failedIngredients.size > 0) {
          candidates = candidates.filter(ing => !failedIngredients.has(ing.name));
          if (candidates.length === 0) {
            console.warn('All candidates excluded due to previous failures');
            return null;
          }
        }

        // 2. Score all candidates
        const scored = this.scoreIngredients(candidates);
        console.log(`[Step 2] Scored ingredients: ${scored.length}`);
        console.log(`[Step 2] Top 5 scores:`, scored.slice(0, 5).map(s => `${s.ingredient.name} (${s.totalScore.toFixed(1)})`));

        // 3. Select best ingredients by category
        const selected = this.selectIngredients(scored);
        console.log(`[Step 3] Selected ingredients: ${selected.length}`);
        console.log(`[Step 3] Ingredients:`, selected.map(i => `${i.name} (${i.category})`));
        if (selected.length === 0) {
          console.warn('No ingredients selected');
          return null;
        }

        // üî• NEW: Prune micronutrient-toxic candidates BEFORE validation
        if (shouldPruneCandidateForMicronutrients(selected)) {
          if (attempt < maxRetries) {
            console.warn(
              `Attempt ${attempt} pruned (micronutrient risk): ${getPruningReason(selected)}`
            );
            continue; // Retry with different random selections
          }
        }

        // 4. Calculate portions
        const portioned = this.calculatePortions(selected);
        console.log(`[Step 4] Portioned ingredients: ${portioned.length}`);
        console.log(`[Step 4] Portions:`, portioned.map(p => `${p.ingredient.name}: ${p.grams}g`));
        if (portioned.length === 0) {
          console.warn('Failed to calculate portions');
          return null;
        }

        // 5. Calculate cost
        const estimatedCost = this.calculateCost(portioned);
        console.log(`[Step 5] Estimated cost: $${estimatedCost.toFixed(2)}`);

        // üî• NEW: Validate recipe composition (comprehensive)
        const comprehensiveValidation = validateRecipeComprehensive(
          selected,
          this.constraints.species,
          this.constraints.lifeStage,
          estimatedCost,
          this.constraints.allergies
        );

        console.log(`[Step 6] Validation result: ${comprehensiveValidation.isValid ? 'PASS' : 'FAIL'}`);
        if (!comprehensiveValidation.isValid) {
          console.warn(`[Step 6] Failed hard gates:`, comprehensiveValidation.failedRules);
          
          // üî• NEW: Track which ingredients to exclude next time
          // If S2 (organ meat) failed, exclude organ meats
          if (comprehensiveValidation.failedRules.includes('S2')) {
            selected.forEach(ing => {
              if (ing.name.toLowerCase().includes('liver') ||
                  ing.name.toLowerCase().includes('kidney') ||
                  ing.name.toLowerCase().includes('heart')) {
                failedIngredients.add(ing.name);
              }
            });
          }
          
          if (attempt < maxRetries) {
            continue; // Retry with different random selections
          }
          // Last attempt failed - do NOT return recipe
          console.error('Could not generate valid recipe after', maxRetries, 'attempts');
          continue; // Skip to next retry (which will exit loop)
        } else {
          console.log(`[Step 6] ‚úÖ Validation passed!`);
          if (comprehensiveValidation.totalPenalty > 0) {
            console.warn(
              `[Step 6] Recipe quality penalties: ${comprehensiveValidation.totalPenalty}`,
              comprehensiveValidation.softGates.map(g => `${g.ruleId}: -${g.penalty}`)
            );
          }
        }

        // üî• PHASE 1: Only return if validation passed
        const species = this.constraints.species;
        const isExoticPet = species === 'birds' || species === 'reptiles' || species === 'pocket-pets';
        
        return {
          ingredients: portioned,
          totalGrams: portioned.reduce((sum, p) => sum + p.grams, 0),
          estimatedCost,
          // Flag exotic pets: micronutrient data incomplete (no AAFCO standards)
          micronutrientDataIncomplete: isExoticPet,
          debugInfo: {
            candidateCount: candidates.length,
            topScores: scored.slice(0, 10).map(s => ({
              name: s.ingredient.name,
              score: Math.round(s.totalScore),
              breakdown: {
                health: Math.round(s.breakdown.health),
                quality: Math.round(s.breakdown.quality),
                nutrition: Math.round(s.breakdown.nutritional),
              },
            })),
            validation: {
              isValid: comprehensiveValidation.isValid,
              failedRules: comprehensiveValidation.failedRules,
              softPenalties: comprehensiveValidation.softGates.map(g => ({
                ruleId: g.ruleId,
                penalty: g.penalty,
                message: g.message,
              })),
            },
          },
        };
      }

      return null;
    } catch (error) {
      console.error('RecipeBuilder.generate() error:', error);
      return null;
    }
  }


  /**
   * STEP 1: HARD FILTERS
   * Get candidate ingredients filtered by species and hard constraints
   */
  private getCandidateIngredients(): Ingredient[] {
    let candidates = getIngredientsForSpecies(this.constraints.species);
    
    // üî• STACK TRACE: Identify source of small pools
    console.log(`[PoolSource] Initial candidates: ${candidates.length}`, {
      species: this.constraints.species,
      source: 'getIngredientsForSpecies'
    });
    if (candidates.length < 200) {
      console.trace('[PoolSource] Small pool detected - trace:');
    }
    
    // üî• INVARIANT: Full pool must be large enough for cats
    if (this.constraints.species === 'cats' && candidates.length < 200) {
      throw new Error(
        `[Invariant] Full ingredient pool too small (${candidates.length}). ` +
        `Registry/provider is wrong. Expected 400+. ` +
        `This means getIngredientsForSpecies is returning a subset (vetted-only? priced-only?).`
      );
    }

    // Apply each filter individually with logging
    candidates = candidates.filter(ing => {
      // Filter 1: Allergies (HARD)
      if (
        this.constraints.allergies?.some(a =>
          ing.name.toLowerCase().includes(a.toLowerCase())
        )
      ) {
        return false;
      }

      // Filter 2: Banned ingredients (HARD)
      if (
        this.constraints.bannedIngredients?.some(b =>
          ing.name.toLowerCase().includes(b.toLowerCase())
        )
      ) {
        return false;
      }

      // Filter 3: Health contraindications (HARD)
      if (this.constraints.healthConcerns?.length) {
        for (const concern of this.constraints.healthConcerns) {
          const contraindicated = HEALTH_CONTRAINDICATIONS[concern] || [];
          const isContraindicated = contraindicated.some(
            contra =>
              ing.name.toLowerCase().includes(contra.toLowerCase()) ||
              ing.id.includes(contra.toLowerCase())
          );
          if (isContraindicated) {
            return false; // Hard exclude
          }
        }
      }

      // Filter 4: Exclude supplements from base recipes (HARD)
      // Supplements should only appear in supplements tab as add-ons
      if (ing.category === 'supplement') {
        return false;
      }

      // Filter 4b: Explicitly exclude fish oils (HARD)
      // Fish oils should only be supplements, not base ingredients
      const lowerName = ing.name.toLowerCase();
      const lowerId = ing.id.toLowerCase();
      if (lowerName.includes('fish oil') || 
          lowerName.includes('salmon oil') || 
          lowerName.includes('anchovy oil') ||
          lowerName.includes('mackerel oil') ||
          lowerName.includes('krill oil') ||
          lowerName.includes('cod liver oil') ||
          lowerName.includes('sardine oil') ||
          lowerName.includes('tuna oil') ||
          lowerName.includes('herring oil') ||
          lowerId.includes('fish_oil') ||
          lowerId.includes('salmon_oil') ||
          lowerId.includes('anchovy_oil') ||
          lowerId.includes('mackerel_oil') ||
          lowerId.includes('krill_oil') ||
          lowerId.includes('cod_liver_oil') ||
          lowerId.includes('sardine_oil') ||
          lowerId.includes('tuna_oil') ||
          lowerId.includes('herring_oil')) {
        console.log(`[FILTER] Excluding fish oil: ${ing.name} (id: ${ing.id})`);
        return false;
      }

      // Filter 5: Budget constraint (SOFT - allow some flex)
      if (this.constraints.budgetPerMeal && ing.pricePerLb) {
        const maxPrice = this.constraints.budgetPerMeal * 3; // Allow 3x for high-value ingredients
        if (ing.pricePerLb > maxPrice) return false;
      }

      return true;
    });
    
    console.log(`[Filters] After all filters: ${candidates.length} candidates`);
    
    // üî• INVARIANT: Check category pools for cats
    if (this.constraints.species === 'cats') {
      const veg = candidates.filter(x => canonicalCategory(x.category) === 'vegetable');
      const fat = candidates.filter(x => canonicalCategory(x.category) === 'fat');
      // Allow all proteins (exotic proteins already filtered out earlier)
      const proteinPool = candidates.filter(x => canonicalCategory(x.category) === 'protein');
      
      console.log(`[CategoryPools] protein=${proteinPool.length}, veg=${veg.length}, fat=${fat.length}`);
      
      if (veg.length < 2 || fat.length < 1 || proteinPool.length < 1) {
        throw new Error(
          `[Invariant] Missing required ingredient categories for cats: ` +
          `protein=${proteinPool.length} (need 1+), veg=${veg.length} (need 2+), fat=${fat.length} (need 1+). ` +
          `Cannot generate valid recipes. Pool size: ${candidates.length}`
        );
      }
    }

    return candidates;
  }

  /**
   * STEP 2: SCORE ALL CANDIDATES
   * Multi-factor scoring: health + quality + nutrition + diversity penalty
   * CRITICAL FIX: For protein category, heavily prioritize protein density
   */
  private scoreIngredients(candidates: Ingredient[]): ScoredIngredient[] {
    const recentIngredients = this.constraints.recentIngredients || [];
    
    return candidates
      .map(ing => {
        const breakdown = {
          health: this.scoreHealth(ing),
          quality: this.scoreQuality(ing),
          nutritional: this.scoreNutritional(ing),
        };

        // CRITICAL FIX: For protein category, use special weights
        // USER REQUIREMENT: Nutrition ALWAYS wins - protein density must dominate
        let weights = this.weights;
        if (canonicalCategory(ing.category) === 'protein') {
          weights = {
            health: 0.20,
            nutritional: 0.75,  // NUTRITION ALWAYS WINS - protein density dominates
            quality: 0.05,      // Minimal influence from quality
          };
        }

        let totalScore =
          breakdown.health * weights.health +
          breakdown.quality * weights.quality +
          breakdown.nutritional * weights.nutritional;

        // Apply diversity penalty for recently used ingredients
        const ingNameLower = ing.name.toLowerCase();
        const timesUsedRecently = recentIngredients.filter(r => r === ingNameLower).length;
        
        if (timesUsedRecently > 0) {
          // Heavy penalty: 50% reduction per recent use
          const diversityPenalty = Math.pow(0.5, timesUsedRecently);
          totalScore *= diversityPenalty;
          
          if (timesUsedRecently >= 2) {
            console.log(`[Diversity] Penalizing ${ing.name}: used ${timesUsedRecently}x recently, score ${totalScore.toFixed(1)} ‚Üí ${(totalScore * diversityPenalty).toFixed(1)}`);
          }
        }

        return { ingredient: ing, totalScore, breakdown };
      })
      .sort((a, b) => b.totalScore - a.totalScore); // Sort by total score descending
  }

  /**
   * HEALTH SCORE (0-100)
   * Does this ingredient help with pet's health concerns?
   */
  private scoreHealth(ing: Ingredient): number {
    if (!this.constraints.healthConcerns?.length) return 50; // Neutral if no concerns

    let score = 0;
    const ingName = ing.name.toLowerCase();

    for (const concern of this.constraints.healthConcerns) {
      const beneficialIngredients = HEALTH_BENEFIT_MAP[concern] || [];

      // Check if this ingredient is explicitly beneficial
      const isBeneficial = beneficialIngredients.some(
        beneficial =>
          ingName.includes(beneficial.toLowerCase()) ||
          beneficial.toLowerCase().includes(ingName)
      );

      if (isBeneficial) {
        score += 35; // +35 per matched health concern (can exceed 100)
      }
    }

    return Math.min(100, score);
  }

  /**
   * QUALITY SCORE (0-100)
   * Ingredient quality rating
   */
  private scoreQuality(ing: Ingredient): number {
    return ing.qualityScore * 10; // Convert 1-10 to 0-100
  }

  /**
   * NUTRITIONAL SCORE (0-100)
   * CRITICAL FIX: Heavily prioritize protein density to meet AAFCO standards
   * Protein is now 60% of nutritional score (was ~30%)
   */
  private scoreNutritional(ing: Ingredient): number {
    const comp = ing.composition;
    let score = 0;

    // PROTEIN DENSITY - Now 70 points max
    // Prioritize actual protein content over omega-3 for protein ingredients
    if (comp.protein) {
      if (comp.protein >= 30) score += 70;        // Chicken breast, turkey breast
      else if (comp.protein >= 25) score += 55;   // Ground turkey, ground chicken, tuna
      else if (comp.protein >= 20) score += 40;   // Salmon, duck
      else if (comp.protein >= 15) score += 25;   // Eggs, some fish
      else if (comp.protein >= 10) score += 12;   // Legumes
      else if (comp.protein >= 5) score += 6;     // Some vegetables
    }

    // Healthy fats (omega-3) - 10 points max (reduced from 20)
    // Omega-3 is good but shouldn't make canned fish dominate every recipe
    if (comp.omega3 && comp.omega3 > 1) score += 10;
    else if (comp.omega3 && comp.omega3 > 0.5) score += 5;

    // Fiber (good for digestion) - 10 points max
    if (comp.fiber && comp.fiber > 5) score += 10;
    else if (comp.fiber && comp.fiber > 2) score += 5;

    // Micronutrients - 10 points max
    if (comp.calcium && comp.calcium > 100) score += 5;
    if (comp.vitaminA && comp.vitaminA > 500) score += 5;

    return Math.min(100, score);
  }

  /**
   * Get required categories for a given species
   */
  private getRequiredCategoriesForSpecies(): IngredientCategory[] {
    const species = this.constraints.species;
    
    switch (species) {
      case 'dogs':
        return ['protein', 'carb', 'vegetable'];
      case 'cats':
        return ['protein', 'vegetable'];
      
      case 'birds':
        // Birds need seeds/nuts as protein, fruits/veggies for vitamins
        return ['seed', 'nut', 'fruit', 'vegetable'];
      
      case 'reptiles':
        // Reptiles need insects as protein, veggies for fiber
        return ['insect', 'vegetable', 'fruit'];
      
      case 'pocket-pets':
        // Pocket-pets need hay as staple, veggies/fruits for variety
        return ['hay', 'vegetable', 'fruit', 'seed'];
      
      default:
        return ['protein', 'carb', 'vegetable'];
    }
  }

  /**
   * Get how many ingredients to select from each category
   * Some categories are more important than others
   */
  private getIngredientCountForCategory(category: IngredientCategory): number {
    const species = this.constraints.species;
    
    // Dogs/Cats
    if (species === 'dogs' || species === 'cats') {
      if (category === 'protein') {
        return 1; // S1: Exactly 1 primary protein (hard gate)
      }
      if (category === 'carb') {
        return species === 'cats' ? 0 : 1; // Cats don't need carbs (obligate carnivores)
      }
      if (category === 'vegetable') {
        return species === 'cats' ? 2 : 1; // Cats get 2 veggies for variety (min 3 ingredients)
      }
      if (category === 'fat') {
        return 1; // 1 fat
      }
      return 1; // Default
    }
    
    // Birds
    if (species === 'birds') {
      if (category === 'seed' || category === 'nut') {
        return 2; // 2 seeds/nuts for variety
      }
      if (category === 'fruit') {
        return 1; // 1 fruit
      }
      if (category === 'vegetable') {
        return 1; // 1 veggie
      }
    }
    
    // Reptiles
    if (species === 'reptiles') {
      if (category === 'insect') {
        return 2; // 2 insects for variety
      }
      if (category === 'vegetable') {
        return 1; // 1 veggie
      }
      if (category === 'fruit') {
        return 1; // 1 fruit (optional)
      }
    }
    
    // Pocket-pets
    if (species === 'pocket-pets') {
      if (category === 'hay') {
        return 1; // 1 hay type (essential)
      }
      if (category === 'vegetable') {
        return 2; // 2 veggies for variety
      }
      if (category === 'fruit') {
        return 1; // 1 fruit (treat)
      }
      if (category === 'seed') {
        return 1; // 1 seed type (optional)
      }
    }
    
    return 1; // Default
  }

  // REMOVED: Hardcoded fat-protein pairing logic
  // Now using PMI-based pairing intelligence from recipePriors.json
  // See RecipePMIScoring.ts for learned pairing logic

  /**
   * STEP 3: SELECT BEST INGREDIENTS
   * Pick ingredients with weighted randomization to ensure diversity
   * üî• FIX: Species-aware ingredient selection
   */
  private selectIngredients(scored: ScoredIngredient[]): Ingredient[] {
    const selected: Ingredient[] = [];
    const categories = this.getRequiredCategoriesForSpecies();

    // üî• PRECONDITION CHECK: For cats, ensure we have all required categories
    if (this.constraints.species === 'cats') {
      const vegPool = scored.filter(s => canonicalCategory(s.ingredient.category) === 'vegetable');
      const fatPool = scored.filter(s => canonicalCategory(s.ingredient.category) === 'fat');
      // Allow all proteins (exotic proteins already filtered out earlier)
      const proteinPool = scored.filter(s => canonicalCategory(s.ingredient.category) === 'protein');
      
      if (vegPool.length < 2 || fatPool.length < 1 || proteinPool.length < 1) {
        throw new Error(
          `[RecipeBuilder] Insufficient pools for cats: ` +
          `protein=${proteinPool.length}, veg=${vegPool.length}, fat=${fatPool.length}. ` +
          `Cannot generate valid recipe without all required categories.`
        );
      }
    }

    // DEBUG: Log what we're looking for
    if (this.constraints.species === 'birds') {
      console.log(`[BIRD DEBUG] Looking for categories: ${categories.join(', ')}`);
      console.log(`[BIRD DEBUG] Total scored ingredients: ${scored.length}`);
    }

    for (const category of categories) {
      let inCategory = scored.filter(s => canonicalCategory(s.ingredient.category) === category);
      
      // CRITICAL: For dogs/cats protein category, all proteins allowed (exotic already filtered)
      // No additional filtering needed here
      
      // üî• COMMERCIAL PRIORS: Filter candidates using learned commercial pairing rules
      if (hasCommercialPriors(this.constraints.species) && selected.length > 0) {
        const selectedIds = selected.map(ing => ing.id);
        const beforeCommercialFilter = inCategory.length;
        
        // Filter out hardBlockPairs (never co-occur in commercial products)
        inCategory = filterCandidatesByCommercialPriors(
          inCategory.map(s => s.ingredient),
          selectedIds,
          this.constraints.species,
          '[Commercial] '
        ).map(ing => {
          // Find the scored ingredient back
          return inCategory.find(s => s.ingredient.id === ing.id)!;
        }).filter(Boolean);
        
        const afterCommercialFilter = inCategory.length;
        if (beforeCommercialFilter !== afterCommercialFilter) {
          console.log(`[Commercial Filter] Removed ${beforeCommercialFilter - afterCommercialFilter} hard-blocked ingredients`);
        }
      }
      
      // üî• PMI-BASED: Filter fats using learned pairing intelligence
      if (category === 'fat') {
        const selectedProteins = selected.filter(ing => canonicalCategory(ing.category) === 'protein');
        if (selectedProteins.length > 0) {
          const beforeFilter = inCategory.length;
          inCategory = inCategory.filter(s => {
            const compat = isFatCompatibleWithProteins(s.ingredient, selectedProteins, this.constraints.species);
            if (!compat.compatible) {
              console.log(`[PMI Filter] ${s.ingredient.name}: ${compat.reason}`);
            }
            return compat.compatible;
          });
          const afterFilter = inCategory.length;
          if (beforeFilter !== afterFilter) {
            console.log(`[PMI Filter] Removed ${beforeFilter - afterFilter} incompatible fats based on learned priors`);
          }
        }
      }
      
      // üî• DEBUG: Log protein pool details for cats
      if (this.constraints.species === 'cats' && category === 'protein') {
        console.log(`[ProteinPool] Total proteins in scored: ${inCategory.length}`);
        console.log(`[ProteinPool] Top 10 proteins:`, inCategory.slice(0, 10).map(s => 
          `${s.ingredient.name} (score: ${s.totalScore.toFixed(1)}, role: ${s.ingredient.proteinRole || 'none'})`
        ));
      }
      
      if (inCategory.length === 0) {
        console.warn(`No ingredients found for category: ${category} (species: ${this.constraints.species})`);
        continue;
      }

      const count = this.getIngredientCountForCategory(category);
      
      // DEBUG: Log selection details for birds
      if (this.constraints.species === 'birds') {
        console.log(`[BIRD DEBUG] Category '${category}': ${inCategory.length} available, selecting ${count}`);
        if (inCategory.length > 0) {
          console.log(`[BIRD DEBUG]   Top 3 in ${category}:`, inCategory.slice(0, 3).map(s => 
            `${s.ingredient.name} (score: ${s.totalScore.toFixed(1)})`
          ));
        }
      }
      
      // Skip if count is 0 (e.g., cats don't need grains)
      if (count === 0) continue;

      // Pick randomly from top N
      for (let i = 0; i < count && inCategory.length > 0; i++) {
        let poolSize: number;
        switch (this.diversityMode) {
          case 'high':
            poolSize = Math.min(8, inCategory.length);
            break;
          case 'medium':
            poolSize = Math.min(5, inCategory.length);
            break;
          case 'low':
            poolSize = Math.min(3, inCategory.length);
            break;
          case 'none':
            poolSize = 1;
            break;
        }

        const randomIndex = this.weightedRandomSelection(inCategory.slice(0, poolSize));
        const selectedIng = inCategory[randomIndex].ingredient;
        selected.push(selectedIng);
        
        // üî• DEBUG: Log what was selected
        if (this.constraints.species === 'cats' && category === 'protein') {
          console.log(`[Selection] Picked protein: ${selectedIng.name} (from pool of ${poolSize})`);
        }
        
        // Remove selected to avoid duplicates
        inCategory.splice(randomIndex, 1);
      }
    }

    if (selected.length === 0) {
      console.error('No ingredients selected for species:', this.constraints.species);
      console.error('Available categories:', categories);
      console.error('Scored ingredients count:', scored.length);
    }

    // CRITICAL: Enforce minimum 3 ingredients for proper meal prep
    // 2-ingredient meals are just "putting ingredients in a bowl", not meal prep
    const MIN_INGREDIENTS = 3;
    if (selected.length < MIN_INGREDIENTS) {
      console.warn(`Only ${selected.length} ingredients selected, need at least ${MIN_INGREDIENTS}`);
      
      // üî• NEVER pad with proteins when vegetables/fats are missing
      // Check what categories we're missing
      const selectedCategories = new Set(selected.map(ing => ing.category));
      const missingCategories = categories.filter(cat => !selectedCategories.has(cat));
      
      if (missingCategories.length > 0) {
        console.error(`Missing required categories: ${missingCategories.join(', ')}`);
        console.error('Cannot pad with random ingredients - aborting recipe generation');
        throw new Error(
          `Recipe generation failed: missing required categories [${missingCategories.join(', ')}]. ` +
          `This indicates the ingredient pool is too small or filtered incorrectly.`
        );
      }
      
      // Only pad if we have all required categories but just need more variety
      const remainingNeeded = MIN_INGREDIENTS - selected.length;
      const alreadySelectedIds = new Set(selected.map(ing => ing.id));
      
      // Get top-scoring ingredients from EXISTING categories only (no proteins if we already have one)
      const availableToAdd = scored
        .filter(s => {
          // Don't add if already selected
          if (alreadySelectedIds.has(s.ingredient.id)) return false;
          
          // For cats: don't add more proteins (we already have 1)
          if (this.constraints.species === 'cats' && canonicalCategory(s.ingredient.category) === 'protein') {
            return false;
          }
          
          // Only add from categories we already have
          return selectedCategories.has(s.ingredient.category);
        })
        .slice(0, remainingNeeded * 3); // Get 3x needed for variety
      
      for (let i = 0; i < remainingNeeded && availableToAdd.length > 0; i++) {
        const randomIndex = Math.floor(Math.random() * Math.min(5, availableToAdd.length));
        selected.push(availableToAdd[randomIndex].ingredient);
        availableToAdd.splice(randomIndex, 1);
      }
      
      console.log(`Added ${remainingNeeded} ingredients to reach minimum. Total: ${selected.length}`);
    }

    // DEBUG: Log final selection for birds
    if (this.constraints.species === 'birds') {
      console.log(`[BIRD DEBUG] Final selection: ${selected.length} ingredients`);
      selected.forEach(ing => console.log(`[BIRD DEBUG]   - ${ing.name} (${ing.category})`));
    }

    return selected;
  }

  /**
   * Weighted random selection
   * Higher-scoring ingredients have higher probability of being selected
   */
  private weightedRandomSelection(pool: ScoredIngredient[]): number {
    if (pool.length === 1) return 0;

    // Calculate weights (score^2 gives exponential preference to higher scores)
    const weights = pool.map(s => Math.pow(Math.max(0, s.totalScore), 2));
    const totalWeight = weights.reduce((sum, w) => sum + w, 0);

    if (totalWeight === 0) {
      // Fallback to uniform random if all scores are 0 or negative
      return Math.floor(Math.random() * pool.length);
    }

    // Pick random value in [0, totalWeight)
    let random = Math.random() * totalWeight;

    // Find which ingredient this corresponds to
    for (let i = 0; i < weights.length; i++) {
      random -= weights[i];
      if (random <= 0) return i;
    }

    return pool.length - 1; // Fallback
  }

  /**
   * Calculate portions based on NUTRIENT TARGETS (not category weights)
   * CRITICAL FIX: Calculate protein/fat needs UPFRONT, then allocate portions to meet targets
   * This ensures recipes meet AAFCO standards for all species
   */
  private calculatePortions(ingredients: Ingredient[]): PortionedIngredient[] {
    const petWeightKg = this.constraints.petWeightKg || 5;
    const species = this.constraints.species;
    
    // Step 1: Calculate total meal size
    const totalMealGrams = this.calculateTotalMealSize(petWeightKg, species);
    
    // Step 2: Get nutritional targets for this species
    const targets = this.getNutritionalTargets(species);
    
    // Step 3: Calculate required nutrient grams
    const targetProteinGrams = totalMealGrams * targets.proteinPercent;
    const targetFatGrams = totalMealGrams * targets.fatPercent;
    
    // Step 4: Allocate portions to meet nutrient targets
    return this.allocateNutrientTargetedPortions(
      ingredients,
      totalMealGrams,
      targetProteinGrams,
      targetFatGrams,
      petWeightKg
    );
  }
  
  /**
   * Calculate total meal size based on species and pet weight
   */
  private calculateTotalMealSize(petWeightKg: number, species: Species): number {
    if (species === 'dogs' || species === 'cats') {
      const mealMultiplier = this.qualityTier === 'premium' ? 80 : this.qualityTier === 'standard' ? 65 : 50;
      return petWeightKg * mealMultiplier;
    } else if (species === 'birds') {
      return petWeightKg * 40;
    } else if (species === 'reptiles') {
      return petWeightKg * 30;
    } else if (species === 'pocket-pets') {
      return petWeightKg * 100;
    }
    return petWeightKg * 65;
  }
  
  /**
   * Get nutritional targets (protein %, fat %) for each species
   * Based on AAFCO standards
   */
  private getNutritionalTargets(species: Species): { proteinPercent: number; fatPercent: number } {
    switch (species) {
      case 'dogs':
        return { proteinPercent: 0.20, fatPercent: 0.08 }; // 20% protein, 8% fat (above 18% minimum)
      case 'cats':
        return { proteinPercent: 0.23, fatPercent: 0.10 }; // 23% protein, 10% fat (allows diverse protein sources)
      case 'birds':
        // Target 15% but accept 13-17% range (natural fluctuation in seed diets)
        return { proteinPercent: 0.15, fatPercent: 0.08 };
      case 'reptiles':
        // Target 15% but accept 13-17% range (natural fluctuation in insect diets)
        return { proteinPercent: 0.15, fatPercent: 0.07 };
      case 'pocket-pets':
        // Target 14% but accept 12-16% range (natural fluctuation in hay diets)
        return { proteinPercent: 0.14, fatPercent: 0.06 };
      default:
        return { proteinPercent: 0.20, fatPercent: 0.08 };
    }
  }
  
  /**
   * Allocate portions to meet nutrient targets
   * Uses iterative approach: start with base allocation, then adjust to hit targets
   */
  private allocateNutrientTargetedPortions(
    ingredients: Ingredient[],
    totalMealGrams: number,
    targetProteinGrams: number,
    targetFatGrams: number,
    petWeightKg: number
  ): PortionedIngredient[] {
    const species = this.constraints.species;
    
    // Note: highProtein used later for boosting portions if needed
    const highProtein = ingredients.filter(ing => (ing.composition.protein || 0) >= 15);
    
    const portioned: PortionedIngredient[] = [];
    let allocatedGrams = 0;
    let allocatedProtein = 0;
    let allocatedFat = 0;
    
    // USER REQUIREMENT: Distribute portions across ALL selected ingredients
    // Don't allocate 90% to one ingredient - spread it out for variety
    
    // For dogs/cats: Use SELECTED protein (whatever was chosen by scoring)
    if (species === 'dogs' || species === 'cats') {
      // Get ANY protein that was selected (no primary/secondary distinction)
      const proteinIngredients = ingredients.filter(ing => canonicalCategory(ing.category) === 'protein');
      
      if (proteinIngredients.length === 0) {
        console.warn('No protein ingredients available for dogs/cats!');
        console.warn('Selected ingredients:', ingredients.map(i => `${i.name} (cat: ${i.category})`));
        return [];
      }
      
      // Use whichever protein was selected (chicken, sardines, mackerel, turkey, etc.)
      const primaryProtein = proteinIngredients[0];
      
      // Calculate portion needed to hit protein target with THIS protein
      const proteinDensity = (primaryProtein.composition.protein || 20) / 100;
      const requiredIngredientGrams = targetProteinGrams / proteinDensity;
      
      let proteinPortion = requiredIngredientGrams;
      
      // ARCHITECTURAL RULE: Hard upper bound to prevent crowding out micronutrients/fats
      // Cats: 90% max (obligate carnivores, need high protein even with diverse sources)
      // Dogs: 85% max (leaves 15% for variety & micronutrient carriers)
      const maxProteinPercent = species === 'cats' ? 0.90 : 0.85;
      proteinPortion = Math.min(proteinPortion, totalMealGrams * maxProteinPercent);
      
      // ARCHITECTURAL RULE: Never override max-inclusion constraints
      const maxGrams = petWeightKg * 1000 * primaryProtein.maxInclusionPercent[species];
      proteinPortion = Math.min(proteinPortion, maxGrams);
      
      proteinPortion = Math.round(proteinPortion);
      
      if (proteinPortion > 0) {
        portioned.push({ ingredient: primaryProtein, grams: proteinPortion });
        allocatedGrams += proteinPortion;
        allocatedProtein += (primaryProtein.composition.protein || 0) * proteinPortion / 100;
        allocatedFat += (primaryProtein.composition.fat || 0) * proteinPortion / 100;
      }
      
      // Allocate remaining grams to other ingredients
      const remainingGrams = totalMealGrams - allocatedGrams;
      const otherIngredients = ingredients.filter(ing => ing.id !== primaryProtein.id);
      
      if (remainingGrams > 0 && otherIngredients.length > 0) {
        const gramsPerIngredient = remainingGrams / otherIngredients.length;
        
        for (const ing of otherIngredients) {
          let grams = gramsPerIngredient;
          grams *= (0.85 + Math.random() * 0.3);
          
          const maxGrams = petWeightKg * 1000 * ing.maxInclusionPercent[species];
          grams = Math.min(grams, maxGrams);
          grams = Math.round(grams);
          
          if (grams > 0) {
            portioned.push({ ingredient: ing, grams });
            allocatedGrams += grams;
            allocatedProtein += (ing.composition.protein || 0) * grams / 100;
            allocatedFat += (ing.composition.fat || 0) * grams / 100;
          }
        }
      }
    } else {
      // For exotic pets: Distribute with bias toward higher-protein items
      // Equal grams ‚â† equal nutrition - bias toward protein-dense natural foods
      
      // Calculate protein density weights for each ingredient
      const totalProteinDensity = ingredients.reduce((sum, ing) => 
        sum + (ing.composition.protein || 0), 0);
      
      for (const ing of ingredients) {
        const proteinDensity = ing.composition.protein || 0;
        
        // Base allocation: equal distribution
        const baseGrams = totalMealGrams / ingredients.length;
        
        // Protein bias: allocate more to higher-protein ingredients
        // Weight = 70% equal + 30% protein-density-weighted
        const proteinWeight = totalProteinDensity > 0 
          ? proteinDensity / totalProteinDensity 
          : 1 / ingredients.length;
        
        let grams = (baseGrams * 0.70) + (totalMealGrams * proteinWeight * 0.30);
        
        // Add variation (¬±15%)
        grams *= (0.85 + Math.random() * 0.3);
        
        // ARCHITECTURAL RULE: Never override max-inclusion constraints
        const maxGrams = petWeightKg * 1000 * ing.maxInclusionPercent[species];
        grams = Math.min(grams, maxGrams);
        grams = Math.round(grams);
        
        if (grams > 0) {
          portioned.push({ ingredient: ing, grams });
          allocatedGrams += grams;
          allocatedProtein += (ing.composition.protein || 0) * grams / 100;
          allocatedFat += (ing.composition.fat || 0) * grams / 100;
        }
      }
    }
    
    // Step 4: Adjust if we're still below protein target
    const currentProteinPercent = allocatedGrams > 0 ? (allocatedProtein / allocatedGrams) : 0;
    const targetProteinPercent = targetProteinGrams / totalMealGrams;
    
    if (currentProteinPercent < targetProteinPercent * 0.95 && highProtein.length > 0) {
      // Boost high-protein portions by 20%
      for (const portioned_ing of portioned) {
        if ((portioned_ing.ingredient.composition.protein || 0) >= 15) {
          const boost = Math.round(portioned_ing.grams * 0.2);
          const maxGrams = petWeightKg * 1000 * portioned_ing.ingredient.maxInclusionPercent[species];
          portioned_ing.grams = Math.min(portioned_ing.grams + boost, maxGrams);
        }
      }
    }
    
    return portioned;
  }


  /**
   * Calculate estimated cost
   */
  private calculateCost(portioned: PortionedIngredient[]): number {
    return portioned.reduce((sum, p) => {
      if (!p.ingredient.pricePerLb) return sum;
      const lbs = p.grams / 453.592;
      return sum + lbs * p.ingredient.pricePerLb;
    }, 0);
  }
}
</file>

<file path="lib/generator/RecipeCompositionValidator.ts">
/**
 * RECIPE COMPOSITION VALIDATOR
 * Ensures recipes follow safe ingredient combination rules
 * Prevents unsafe combinations like multiple organ meats or unbalanced macros
 */

import type { Ingredient, Species } from '@/lib/data/ingredients';

// ============================================================================
// INGREDIENT ROLE DEFINITIONS
// ============================================================================

export const INGREDIENT_ROLES = {
  // Main proteins - can be primary ingredient (30-40% of recipe)
  mainProtein: [
    'chicken', 'turkey', 'beef', 'lamb', 'duck', 'venison',
    'salmon', 'whitefish', 'cod', 'sardine', 'tuna', 'egg'
  ],

  // Organ meats - MUST be limited to <10% of recipe
  organMeat: [
    'liver', 'kidney', 'heart', 'tripe', 'lung', 'spleen'
  ],

  // Carbohydrates - should be 30-40% of recipe
  carbs: [
    'rice', 'oats', 'quinoa', 'barley', 'potato', 'sweet potato',
    'pumpkin', 'squash', 'lentils', 'chickpeas', 'beans'
  ],

  // Vegetables - should be 10-20% of recipe
  vegetables: [
    'carrots', 'green beans', 'broccoli', 'spinach', 'kale',
    'zucchini', 'celery', 'peas', 'asparagus', 'lettuce'
  ],

  // Fats/oils - should be <5% of recipe
  fats: [
    'fish oil', 'coconut oil', 'olive oil', 'salmon oil', 'flaxseed', 'oil'
  ],
};

// ============================================================================
// UNSAFE COMBINATIONS
// ============================================================================

export const UNSAFE_COMBINATIONS = [
  {
    name: 'Multiple Organ Meats',
    ingredients: ['liver', 'kidney', 'heart'],
    maxCombined: 1, // Can only have 1 organ meat per recipe
    reason: 'Risk of vitamin A toxicity and mineral imbalance',
  },
  {
    name: 'High-Fat Proteins Together',
    ingredients: ['salmon', 'sardine', 'duck', 'lamb', 'mackerel'],
    maxCombined: 1, // Only 1 high-fat protein per recipe
    reason: 'Too much fat can cause pancreatitis',
  },
  {
    name: 'Multiple Fish Sources',
    ingredients: ['salmon', 'sardine', 'tuna', 'mackerel', 'whitefish', 'cod'],
    maxCombined: 1, // Only 1 fish per recipe
    reason: 'Risk of mercury accumulation and thiamine deficiency',
  },
];

// ============================================================================
// REQUIRED RECIPE STRUCTURE BY SPECIES
// ============================================================================

export const REQUIRED_RECIPE_STRUCTURE: Record<Species, {
  mustHave: string[];
  shouldHave: string[];
  optional: string[];
  minIngredients: number;
  maxIngredients: number;
}> = {
  dogs: {
    mustHave: ['mainProtein', 'carbs'], // REQUIRED
    shouldHave: ['vegetables'], // RECOMMENDED
    optional: ['fats', 'organMeat'], // OPTIONAL
    minIngredients: 3, // At least protein + carb + veggie
    maxIngredients: 6, // Don't overcomplicate
  },
  cats: {
    mustHave: ['mainProtein'], // Obligate carnivores - protein is essential
    shouldHave: ['fats'], // Cats need higher fat
    optional: ['carbs', 'vegetables'], // Cats don't need carbs, but tolerate some
    minIngredients: 2, // Can be simpler (protein + fat)
    maxIngredients: 5,
  },
  birds: {
    mustHave: ['vegetables', 'seed'], // Birds need seeds/veggies
    shouldHave: ['fruit'], // Birds love fruits
    optional: ['protein', 'carbs'],
    minIngredients: 2,
    maxIngredients: 5,
  },
  reptiles: {
    mustHave: ['protein'], // Carnivorous reptiles need protein
    shouldHave: ['vegetable'], // Some herbivorous/omnivorous reptiles
    optional: ['carbs', 'fruit'],
    minIngredients: 1,
    maxIngredients: 4,
  },
  'pocket-pets': {
    mustHave: ['hay', 'vegetable'], // Herbivores need hay and veggies
    shouldHave: ['fruit'], // Optional treats
    optional: ['carbs', 'seed'],
    minIngredients: 2,
    maxIngredients: 5,
  },
};

// ============================================================================
// VALIDATION RESULT
// ============================================================================

export interface ValidationResult {
  isValid: boolean;
  issues: string[];
  warnings: string[];
}

// ============================================================================
// MAIN VALIDATION FUNCTION
// ============================================================================

/**
 * Validate recipe composition for safety and balance
 */
export function validateRecipeComposition(
  selectedIngredients: Ingredient[],
  species: Species
): ValidationResult {
  const issues: string[] = [];
  const warnings: string[] = [];

  const ingredientNames = selectedIngredients.map(ing => ing.name.toLowerCase());

  // ========================================================================
  // CHECK 1: Required structure
  // ========================================================================
  const structure = REQUIRED_RECIPE_STRUCTURE[species];
  if (structure) {
    // Check mustHave categories
    for (const category of structure.mustHave) {
      const hasCategory = ingredientNames.some(name =>
        INGREDIENT_ROLES[category as keyof typeof INGREDIENT_ROLES]?.some(role =>
          name.includes(role)
        )
      );
      if (!hasCategory) {
        issues.push(`Missing required ingredient type: ${category}`);
      }
    }

    // Check shouldHave categories
    for (const category of structure.shouldHave) {
      const hasCategory = ingredientNames.some(name =>
        INGREDIENT_ROLES[category as keyof typeof INGREDIENT_ROLES]?.some(role =>
          name.includes(role)
        )
      );
      if (!hasCategory) {
        warnings.push(`Recommended ingredient type missing: ${category}`);
      }
    }

    // Check ingredient count
    if (selectedIngredients.length < structure.minIngredients) {
      issues.push(
        `Too few ingredients (${selectedIngredients.length}, need ${structure.minIngredients}+)`
      );
    }
    if (selectedIngredients.length > structure.maxIngredients) {
      warnings.push(
        `Too many ingredients (${selectedIngredients.length}, recommended max ${structure.maxIngredients})`
      );
    }
  }

  // ========================================================================
  // CHECK 2: Unsafe combinations
  // ========================================================================
  for (const combo of UNSAFE_COMBINATIONS) {
    const matchedIngredients = ingredientNames.filter(name =>
      combo.ingredients.some(unsafe => name.includes(unsafe))
    );

    if (matchedIngredients.length > combo.maxCombined) {
      issues.push(
        `Unsafe combination: ${matchedIngredients.join(' + ')}. ` +
        `${combo.reason}. Max ${combo.maxCombined} allowed.`
      );
    }
  }

  // ========================================================================
  // CHECK 3: Organ meat percentage (if present)
  // ========================================================================
  const hasOrganMeat = ingredientNames.some(name =>
    INGREDIENT_ROLES.organMeat.some(organ => name.includes(organ))
  );

  if (hasOrganMeat) {
    const organMeats = selectedIngredients.filter(ing =>
      INGREDIENT_ROLES.organMeat.some(organ => ing.name.toLowerCase().includes(organ))
    );

    // Check if organ meat has proper role
    const organMeatRole = organMeats[0]?.feedingRole;
    if (organMeatRole === 'staple') {
      issues.push(
        `${organMeats[0].name} is marked as staple but should be supplement. ` +
        `Organ meats must be limited to <10% of recipe.`
      );
    }

    // If multiple ingredients, warn if organ meat portion is too large
    if (selectedIngredients.length <= 2 && hasOrganMeat) {
      issues.push(
        `Recipe has too few ingredients with organ meat present. ` +
        `Add carbs/vegetables to dilute organ meat concentration.`
      );
    }
  }

  // ========================================================================
  // CHECK 4: No double proteins without carbs (for dogs)
  // ========================================================================
  if (species === 'dogs') {
    const proteinCount = ingredientNames.filter(name =>
      INGREDIENT_ROLES.mainProtein.some(p => name.includes(p)) ||
      INGREDIENT_ROLES.organMeat.some(o => name.includes(o))
    ).length;

    const hasCarbs = ingredientNames.some(name =>
      INGREDIENT_ROLES.carbs.some(c => name.includes(c))
    );

    if (proteinCount >= 2 && !hasCarbs) {
      issues.push(
        `Recipe has ${proteinCount} protein sources but no carbohydrates. ` +
        `This is unbalanced and too protein-heavy.`
      );
    }
  }

  return {
    isValid: issues.length === 0,
    issues,
    warnings,
  };
}

/**
 * Check if an ingredient should be categorized as a supplement (organ meat)
 */
export function isOrganMeat(ingredient: Ingredient): boolean {
  const name = ingredient.name.toLowerCase();
  return INGREDIENT_ROLES.organMeat.some(organ => name.includes(organ));
}

/**
 * Get ingredient category role
 */
export function getIngredientRole(ingredient: Ingredient): string {
  const name = ingredient.name.toLowerCase();

  if (INGREDIENT_ROLES.mainProtein.some(p => name.includes(p))) return 'mainProtein';
  if (INGREDIENT_ROLES.organMeat.some(o => name.includes(o))) return 'organMeat';
  if (INGREDIENT_ROLES.carbs.some(c => name.includes(c))) return 'carbs';
  if (INGREDIENT_ROLES.vegetables.some(v => name.includes(v))) return 'vegetables';
  if (INGREDIENT_ROLES.fats.some(f => name.includes(f))) return 'fats';

  return 'unknown';
}
</file>

<file path="lib/generator/RecipeConstraintRules.ts">
/**
 * RECIPE CONSTRAINT RULES
 * Pre-scoring validation gates that reject unsafe/invalid recipes before optimization
 * 
 * Pipeline:
 * 1. Constraint Gate (hard rejections)
 * 2. Composition Validator (structure + balance)
 * 3. Nutrient Ceiling Validator (micronutrient caps)
 * 4. Optimizer (cost + nutrition)
 * 5. Scorer (quality + fit)
 */

import type { Ingredient, Species } from '@/lib/data/ingredients';

// ============================================================================
// NUTRIENT CEILING TABLE (Species-Aware)
// Absolute caps per day equivalent, not scoring targets
// ============================================================================

export const NUTRIENT_CEILINGS: Record<Species, {
  vitaminA_IU: number;
  copper_mg: number;
  iodine_mcg: number;
  fat_percent: number;
  calcium_g: number;
  calcium_phosphorus_min: number;
  calcium_phosphorus_max: number;
}> = {
  dogs: {
    vitaminA_IU: 30000,       // PHASE 2: Per recipe (realistic with organs)
    copper_mg: 5.0,           // PHASE 2: Per recipe ceiling (realistic with organs)
    iodine_mcg: 1000,         // PHASE 2: Per recipe ceiling (realistic)
    fat_percent: 30,
    calcium_g: 2.5,
    calcium_phosphorus_min: 1.2,
    calcium_phosphorus_max: 2.0,
  },
  cats: {
    vitaminA_IU: 25000,       // PHASE 2: Per recipe (realistic with organs)
    copper_mg: 4.0,           // PHASE 2: Per recipe ceiling (realistic with organs)
    iodine_mcg: 800,          // PHASE 2: Per recipe ceiling (realistic)
    fat_percent: 45,
    calcium_g: 2.0,
    calcium_phosphorus_min: 1.1,
    calcium_phosphorus_max: 1.5,
  },
  birds: {
    vitaminA_IU: 4000, // Species-dependent, conservative estimate
    copper_mg: 0.3,
    iodine_mcg: 150,
    fat_percent: 15,
    calcium_g: 1.5,
    calcium_phosphorus_min: 1.0,
    calcium_phosphorus_max: 2.0,
  },
  reptiles: {
    vitaminA_IU: 3000, // Highly species-dependent
    copper_mg: 0.2,
    iodine_mcg: 100,
    fat_percent: 20,
    calcium_g: 2.0,
    calcium_phosphorus_min: 1.5,
    calcium_phosphorus_max: 2.5,
  },
  'pocket-pets': {
    vitaminA_IU: 4000,
    copper_mg: 0.3,
    iodine_mcg: 150,
    fat_percent: 20,
    calcium_g: 1.8,
    calcium_phosphorus_min: 1.0,
    calcium_phosphorus_max: 2.0,
  },
};

// ============================================================================
// INGREDIENT ROLE MATRIX
// Prevents "two mains in disguise" and organ stacking
// ============================================================================

export const INGREDIENT_ROLE_MATRIX = {
  'primary-protein': {
    allowedAsPrimary: true,
    percentCap: 0.60,
    maxPerRecipe: 1, // Exactly one primary protein
    examples: ['chicken_breast', 'beef', 'salmon', 'turkey_breast'],
  },
  'carb-base': {
    allowedAsPrimary: false,
    percentCap: 0.40,
    maxPerRecipe: 2,
    examples: ['rice', 'sweet_potato', 'oats', 'barley'],
  },
  'vegetable': {
    allowedAsPrimary: false,
    percentCap: 0.25,
    maxPerRecipe: 3,
    examples: ['carrots', 'green_beans', 'spinach', 'broccoli'],
  },
  'organ-meat': {
    allowedAsPrimary: false,
    percentCap: 0.10, // Hard cap for organ meats
    maxPerRecipe: 1, // Only one organ meat per recipe
    examples: ['chicken_liver', 'beef_liver', 'chicken_hearts'],
  },
  'fat-supplement': {
    allowedAsPrimary: false,
    percentCap: 0.05,
    maxPerRecipe: 1, // Only one added fat source
    examples: ['fish_oil', 'coconut_oil', 'olive_oil'],
  },
  'micronutrient': {
    allowedAsPrimary: false,
    percentCap: 0.01,
    maxPerRecipe: 1,
    examples: ['kelp', 'eggshell_powder', 'vitamin_premix'],
  },
};

// ============================================================================
// STRUCTURAL COMPOSITION RULES (Hard Gates)
// ============================================================================

export interface CompositionRuleResult {
  passed: boolean;
  ruleId: string;
  message: string;
}

export function validateStructuralComposition(
  ingredients: Ingredient[],
  species: Species,
  lifeStage: 'puppy' | 'adult' | 'senior'
): CompositionRuleResult[] {
  const results: CompositionRuleResult[] = [];

  // S1: Exactly 1 protein source (STRICT) - Species-aware
  // Dogs/cats: Must have 1 'protein' category (any protein, not just "primary")
  // Birds: Can have seeds/nuts as protein
  // Reptiles: Can have insects as protein
  // Pocket-pets: Can have hay/seeds as protein
  
  // Helper to normalize categories
  const canonicalCategory = (cat: any): string => {
    const c = String(cat ?? '').toLowerCase().trim();
    if (c === 'protein' || c.includes('protein') || c.includes('meat') || 
        c.includes('poultry') || c.includes('fish') || c.includes('seafood') || c.includes('egg')) {
      return 'protein';
    }
    return c;
  };
  
  let primaryProteins: Ingredient[];
  if (species === 'dogs' || species === 'cats') {
    // Accept ANY protein ingredient (chicken, turkey, sardines, mackerel, etc.)
    primaryProteins = ingredients.filter(ing => canonicalCategory(ing.category) === 'protein');
  } else if (species === 'birds') {
    // Birds: seeds/nuts/insects, but exclude oils (they're fats, not protein sources)
    primaryProteins = ingredients.filter(ing =>
      ['seed', 'nut', 'insect'].includes(ing.category) &&
      !ing.name.toLowerCase().includes('oil')
    );
  } else if (species === 'reptiles') {
    primaryProteins = ingredients.filter(ing =>
      ['insect', 'protein'].includes(ing.category)
    );
  } else if (species === 'pocket-pets') {
    primaryProteins = ingredients.filter(ing =>
      ['hay', 'seed'].includes(ing.category)
    );
  } else {
    // Default: accept any protein
    primaryProteins = ingredients.filter(ing => canonicalCategory(ing.category) === 'protein');
  }
  
  // Dogs/cats need exactly 1, exotic species can have 1-2 for variety
  const minRequired = (species === 'dogs' || species === 'cats') ? 1 : 1;
  const maxAllowed = (species === 'dogs' || species === 'cats') ? 1 : 3;
  
  results.push({
    passed: primaryProteins.length >= minRequired && primaryProteins.length <= maxAllowed,
    ruleId: 'S1',
    message: `Primary protein sources: ${primaryProteins.length} (species: ${species}, range: ${minRequired}-${maxAllowed})`,
  });

  // S2: Organ meats ‚â§ 1 per recipe (count-based, not weight)
  // NOTE: Weight-based cap moved to quality scoring as soft gate
  const organMeatNames = ['liver', 'kidney', 'heart'];
  const organMeats = ingredients.filter(ing => {
    const name = ing.name.toLowerCase();
    return ing.feedingRole === 'supplement' && organMeatNames.some(organ => name.includes(organ));
  });
  
  results.push({
    passed: organMeats.length <= 1,
    ruleId: 'S2',
    message: `Organ meats ‚â§ 1 per recipe (found ${organMeats.length})`,
  });

  // S3: Organ meats cannot be primary protein
  const organAsPrimary = ingredients.filter(ing =>
    ing.feedingRole === 'staple' &&
    (ing.name.toLowerCase().includes('liver') ||
      ing.name.toLowerCase().includes('kidney') ||
      ing.name.toLowerCase().includes('heart'))
  );
  results.push({
    passed: organAsPrimary.length === 0,
    ruleId: 'S3',
    message: `Organ meats cannot be primary protein (found ${organAsPrimary.length})`,
  });

  // S4: Must include carb/energy source (species-aware)
  // Dogs: need 'carb' (grains)
  // Birds: need 'seed' or 'nut' (energy-dense)
  // Pocket-pets: need 'hay' (fiber/energy)
  // Cats/reptiles: optional carbs
  let hasEnergySource = false;
  if (species === 'dogs') {
    hasEnergySource = ingredients.some(ing => ing.category === 'carb');
  } else if (species === 'birds') {
    hasEnergySource = ingredients.some(ing => ['seed', 'nut', 'carb'].includes(ing.category));
  } else if (species === 'pocket-pets') {
    hasEnergySource = ingredients.some(ing => ['hay', 'seed', 'carb'].includes(ing.category));
  } else {
    hasEnergySource = true; // Cats/reptiles don't require carbs
  }
  
  results.push({
    passed: hasEnergySource,
    ruleId: 'S4',
    message: `${species} energy source requirement met: ${hasEnergySource}`,
  });

  // S5: Carnivores may be carb-free (informational, not a gate)
  const isCarnivore = ['cats', 'reptiles'].includes(species);
  results.push({
    passed: true, // Always pass - this is permissive
    ruleId: 'S5',
    message: `${species} may be carb-free (allowed)`,
  });

  // S6: Minimum ingredient categories
  // All species need at least 2 different categories for nutritional balance
  const categories = new Set(ingredients.map(ing => ing.category));
  results.push({
    passed: categories.size >= 2,
    ruleId: 'S6',
    message: `Minimum 2 ingredient categories required (found ${categories.size})`,
  });

  // S7: Added fat sources ‚â§ 1
  const addedFats = ingredients.filter(ing => ing.category === 'fat');
  results.push({
    passed: addedFats.length <= 1,
    ruleId: 'S7',
    message: `Maximum 1 added fat source (found ${addedFats.length})`,
  });

  // S8: Ingredient diversity ‚â• 3 unique foods
  const uniqueIngredients = new Set(ingredients.map(ing => ing.id));
  results.push({
    passed: uniqueIngredients.size >= 3,
    ruleId: 'S8',
    message: `Minimum 3 unique ingredients required (found ${uniqueIngredients.size})`,
  });

  return results;
}

// ============================================================================
// SAFETY & TOXICITY RULES (Hard Gates)
// ============================================================================

export interface SafetyRuleResult {
  passed: boolean;
  ruleId: string;
  message: string;
  value?: number;
  ceiling?: number;
}

export function validateSafetyAndToxicity(
  ingredients: Ingredient[],
  species: Species,
  allergies?: string[]
): SafetyRuleResult[] {
  const results: SafetyRuleResult[] = [];
  const ceilings = NUTRIENT_CEILINGS[species];

  // T1: Vitamin A ceiling (HARD for dogs/cats, SOFT for exotic pets)
  const proteinAndOrganMeats = ingredients.filter(ing => 
    ing.category === 'protein' || 
    ing.name.toLowerCase().includes('liver') ||
    ing.name.toLowerCase().includes('kidney') ||
    ing.name.toLowerCase().includes('heart')
  );
  
  const totalVitaminA = ingredients.reduce((sum, ing) => sum + (ing.composition.vitaminA || 0), 0);
  const hasVitaminAData = proteinAndOrganMeats.every(ing => ing.composition.vitaminA !== undefined);
  
  // Only enforce for dogs/cats (AAFCO standards exist)
  const enforceT1 = species === 'dogs' || species === 'cats';
  results.push({
    passed: enforceT1 ? (hasVitaminAData && totalVitaminA <= ceilings.vitaminA_IU) : true,
    ruleId: 'T1',
    message: hasVitaminAData 
      ? `Vitamin A: ${totalVitaminA} IU (ceiling: ${ceilings.vitaminA_IU})`
      : enforceT1 
        ? `Vitamin A data incomplete for proteins/organs - cannot validate`
        : `Vitamin A data incomplete (soft warning for ${species})`,
    value: totalVitaminA,
    ceiling: ceilings.vitaminA_IU,
  });

  // T2: Copper ceiling (HARD for dogs/cats, SOFT for exotic pets)
  const totalCopper = ingredients.reduce((sum, ing) => sum + (ing.composition.copper_mg_per_100g || 0), 0);
  const hasAllCopperData = ingredients.every(ing => ing.composition.copper_mg_per_100g !== undefined);
  
  // Only enforce for dogs/cats
  const enforceT2 = species === 'dogs' || species === 'cats';
  results.push({
    passed: enforceT2 ? (hasAllCopperData && totalCopper <= ceilings.copper_mg) : true,
    ruleId: 'T2',
    message: hasAllCopperData 
      ? `Copper: ${totalCopper.toFixed(2)} mg (ceiling: ${ceilings.copper_mg})`
      : enforceT2
        ? `Copper data incomplete - cannot validate`
        : `Copper data incomplete (soft warning for ${species})`,
    value: totalCopper,
    ceiling: ceilings.copper_mg,
  });

  // T3: Iodine ceiling (PHASE 2: Now using class-based defaults + measured overrides)
  const totalIodine = ingredients.reduce((sum, ing) => sum + (ing.composition.iodine_mcg_per_100g || 0), 0);
  const hasAllIodineData = ingredients.every(ing => ing.composition.iodine_mcg_per_100g !== undefined);
  results.push({
    passed: hasAllIodineData && totalIodine <= ceilings.iodine_mcg,
    ruleId: 'T3',
    message: hasAllIodineData 
      ? `Iodine: ${totalIodine.toFixed(1)} mcg (ceiling: ${ceilings.iodine_mcg})`
      : `Iodine data incomplete - cannot validate`,
    value: totalIodine,
    ceiling: ceilings.iodine_mcg,
  });

  // T4: Known toxic ingredient present
  const toxicIngredients = ['grape', 'raisin', 'onion', 'garlic', 'chocolate', 'xylitol'];
  const hasToxic = ingredients.some(ing =>
    toxicIngredients.some(toxic => ing.name.toLowerCase().includes(toxic))
  );
  results.push({
    passed: !hasToxic,
    ruleId: 'T4',
    message: `No known toxic ingredients (found: ${hasToxic})`,
  });

  // T5: Allergen or derivative present
  const hasAllergen =
    allergies && allergies.length > 0
      ? ingredients.some(ing =>
          allergies.some(allergen =>
            ing.name.toLowerCase().includes(allergen.toLowerCase()) ||
            ing.id.includes(allergen.toLowerCase())
          )
        )
      : false;
  results.push({
    passed: !hasAllergen,
    ruleId: 'T5',
    message: `No allergens present (found: ${hasAllergen})`,
  });

  // T6: Ca:P ratio (SOFT WARNING - hard gate disabled until supplements available)
  // Phase 1: Just track it. Phase 2: Apply soft penalties if out of range.
  // Real fix: Add calcium supplement ingredients (eggshell powder, bone meal, etc.)
  const totalCalcium = ingredients.reduce((sum, ing) => sum + (ing.composition.calcium || 0), 0);
  const totalPhosphorus = ingredients.reduce((sum, ing) => sum + (ing.composition.phosphorus || 0), 0);
  const caPRatio = totalPhosphorus > 0 ? totalCalcium / totalPhosphorus : 1;
  const hasCalciumSupplement = ingredients.some(ing =>
    ing.name.toLowerCase().includes('eggshell') ||
    ing.name.toLowerCase().includes('bone meal') ||
    ing.name.toLowerCase().includes('calcium')
  );
  
  // Pass if: naturally in range OR has calcium supplement
  const caPValid = (caPRatio >= 1.0 && caPRatio <= 2.0) || hasCalciumSupplement;
  
  results.push({
    passed: true, // Always pass - this is now a soft warning, not hard gate
    ruleId: 'T6',
    message: `Ca:P ratio: ${Math.round(caPRatio * 100) / 100} ${hasCalciumSupplement ? '(supplement present)' : '(natural)'}`,
    value: Math.round(caPRatio * 100) / 100,
    ceiling: 2.0,
  });

  return results;
}

// ============================================================================
// LIFE STAGE RULES (Hard Gates)
// ============================================================================

export interface LifeStageRuleResult {
  passed: boolean;
  ruleId: string;
  message: string;
}

export function validateLifeStage(
  ingredients: Ingredient[],
  species: Species,
  lifeStage: 'puppy' | 'adult' | 'senior'
): LifeStageRuleResult[] {
  const results: LifeStageRuleResult[] = [];

  if (lifeStage === 'puppy') {
    // L1: Puppy calcium upper limit (prevent skeletal issues)
    const totalCalcium = ingredients.reduce((sum, ing) => sum + (ing.composition.calcium || 0), 0);
    const puppyCalciumMax = 2.0; // g per day
    results.push({
      passed: totalCalcium <= puppyCalciumMax,
      ruleId: 'L1',
      message: `Puppy calcium ‚â§ ${puppyCalciumMax}g (found ${totalCalcium}g)`,
    });

    // L4: Growth diets require higher protein
    const totalProtein = ingredients.reduce((sum, ing) => sum + (ing.composition.protein || 0), 0);
    const puppyProteinMin = 18; // % of calories
    results.push({
      passed: totalProtein >= puppyProteinMin,
      ruleId: 'L4',
      message: `Puppy protein ‚â• ${puppyProteinMin}% (found ${totalProtein}%)`,
    });
  }

  if (lifeStage === 'senior' && species === 'dogs') {
    // L3: Senior kidney load (reduce phosphorus)
    const totalPhosphorus = ingredients.reduce((sum, ing) => sum + (ing.composition.phosphorus || 0), 0);
    const seniorPhosphorusMax = 1.0; // g per day
    results.push({
      passed: totalPhosphorus <= seniorPhosphorusMax,
      ruleId: 'L3',
      message: `Senior phosphorus ‚â§ ${seniorPhosphorusMax}g (found ${totalPhosphorus}g)`,
    });
  }

  return results;
}

// ============================================================================
// QUALITY / PLAUSIBILITY RULES (Soft Gates ‚Üí Penalty)
// ============================================================================

export interface QualityRuleResult {
  passed: boolean;
  ruleId: string;
  message: string;
  penalty: number; // 0-100, applied to score
}

export function validateQualityAndPlausibility(
  ingredients: Ingredient[],
  estimatedCost: number
): QualityRuleResult[] {
  const results: QualityRuleResult[] = [];

  // Q1: "Two mains in disguise" (multiple high-protein ingredients)
  const highProteinCount = ingredients.filter(ing =>
    ing.composition.protein && ing.composition.protein > 20
  ).length;
  const twoMainsPenalty = highProteinCount > 1 ? 30 : 0;
  results.push({
    passed: highProteinCount <= 1,
    ruleId: 'Q1',
    message: `Multiple high-protein ingredients detected (${highProteinCount})`,
    penalty: twoMainsPenalty,
  });

  // Q2: Excessive powders / oils (low ingredient diversity)
  const powderOilCount = ingredients.filter(ing =>
    ing.name.toLowerCase().includes('oil') ||
    ing.name.toLowerCase().includes('powder') ||
    ing.name.toLowerCase().includes('premix')
  ).length;
  const excessivePowderPenalty = powderOilCount > 2 ? 25 : 0;
  results.push({
    passed: powderOilCount <= 2,
    ruleId: 'Q2',
    message: `Excessive powders/oils (${powderOilCount})`,
    penalty: excessivePowderPenalty,
  });

  // Q3: Human implausibility heuristic
  // Recipes that are technically complete but no one would actually make
  const implausiblePatterns = [
    ingredients.length === 2, // Too simple
    estimatedCost < 0.50, // Suspiciously cheap
    ingredients.every(ing => ing.category === 'supplement'), // All supplements
  ];
  const implausiblePenalty = implausiblePatterns.filter(p => p).length > 0 ? 20 : 0;
  results.push({
    passed: implausiblePenalty === 0,
    ruleId: 'Q3',
    message: `Recipe may be implausible (${implausiblePatterns.filter(p => p).length} flags)`,
    penalty: implausiblePenalty,
  });

  // Q4: Repetitive cheap filler pattern
  const cheapFillers = ingredients.filter(ing =>
    (ing.name.toLowerCase().includes('rice') ||
      ing.name.toLowerCase().includes('corn') ||
      ing.name.toLowerCase().includes('wheat')) &&
    (ing.pricePerLb || 1) < 0.50
  ).length;
  const fillerPenalty = cheapFillers >= 2 ? 15 : 0;
  results.push({
    passed: cheapFillers < 2,
    ruleId: 'Q4',
    message: `Repetitive cheap filler pattern (${cheapFillers})`,
    penalty: fillerPenalty,
  });

  // Q5: Organ meat weight cap (soft gate - penalize if >10%)
  const organMeatNames = ['liver', 'kidney', 'heart'];
  const organMeats = ingredients.filter(ing => {
    const name = ing.name.toLowerCase();
    return ing.feedingRole === 'supplement' && organMeatNames.some(organ => name.includes(organ));
  });
  
  const totalWeight = ingredients.reduce((sum, ing) => sum + (ing.composition.protein || 1), 0);
  const organMeatWeight = organMeats.reduce((sum, ing) => sum + (ing.composition.protein || 1), 0);
  const organMeatPercent = totalWeight > 0 ? (organMeatWeight / totalWeight) * 100 : 0;
  
  let organMeatPenalty = 0;
  if (organMeatPercent > 15) organMeatPenalty = 30; // Way over
  else if (organMeatPercent > 10) organMeatPenalty = 15; // Slightly over
  
  results.push({
    passed: organMeatPercent <= 10,
    ruleId: 'Q5',
    message: `Organ meat weight: ${organMeatPercent.toFixed(1)}% (soft cap 10%)`,
    penalty: organMeatPenalty,
  });

  return results;
}

// ============================================================================
// MASTER VALIDATION FUNCTION
// ============================================================================

export interface RecipeValidationResult {
  isValid: boolean;
  hardGates: {
    structural: CompositionRuleResult[];
    safety: SafetyRuleResult[];
    lifeStage: LifeStageRuleResult[];
  };
  softGates: QualityRuleResult[];
  totalPenalty: number;
  failedRules: string[];
}

export function validateRecipeComprehensive(
  ingredients: Ingredient[],
  species: Species,
  lifeStage: 'puppy' | 'adult' | 'senior',
  estimatedCost: number,
  allergies?: string[]
): RecipeValidationResult {
  const structural = validateStructuralComposition(ingredients, species, lifeStage);
  const safety = validateSafetyAndToxicity(ingredients, species, allergies);
  const lifeStageRules = validateLifeStage(ingredients, species, lifeStage);
  const quality = validateQualityAndPlausibility(ingredients, estimatedCost);

  const hardGateFailed = [
    ...structural,
    ...safety,
    ...lifeStageRules,
  ].filter(r => !r.passed);

  const totalPenalty = quality.reduce((sum, q) => sum + q.penalty, 0);

  return {
    isValid: hardGateFailed.length === 0,
    hardGates: {
      structural,
      safety,
      lifeStage: lifeStageRules,
    },
    softGates: quality,
    totalPenalty,
    failedRules: hardGateFailed.map(r => r.ruleId),
  };
}
</file>

<file path="lib/generator/RecipePMIScoring.ts">
/**
 * PMI-BASED PAIRING INTELLIGENCE
 * Uses learned statistical priors from BOTH recipe scraping AND commercial products
 * NOT hardcoded rules - behavior changes when recipePriors.json changes
 */

import type { Ingredient } from '@/lib/data/ingredients';
import priors from '@/lib/data/recipePriors.json';

interface PairingScore {
  score: number;
  reason: string;
  pmiValue?: number;
  source?: 'recipe' | 'commercial' | 'both';
}

/**
 * Calculate PMI-based pairing score for an ingredient given already-selected ingredients
 * Combines recipe priors AND commercial priors for stronger signal
 * Returns both the score and an explanation
 */
export function calculatePairingScore(
  ingredient: Ingredient,
  selectedIngredients: Ingredient[],
  species: string
): PairingScore {
  if (selectedIngredients.length === 0) {
    return { score: 0, reason: 'No selected ingredients' };
  }

  const ingName = ingredient.name;
  let totalPMI = 0;
  let pairCount = 0;
  let negativePenalty = 0;
  const reasons: string[] = [];
  let hasRecipePriors = false;
  let hasCommercialPriors = false;

  // Check recipe priors (homemade recipes)
  const recipePriors = priors.coOccurrence?.[species];
  if (recipePriors) {
    for (const selected of selectedIngredients) {
      const selName = selected.name;
      const pair = [ingName, selName].sort().join('+');
      
      const pmi = recipePriors.pairPMI?.[pair];
      if (pmi !== undefined && pmi > 0) {
        totalPMI += pmi;
        pairCount++;
        hasRecipePriors = true;
        reasons.push(`+${pmi.toFixed(2)} recipe PMI with ${selName}`);
      }
      
      const negativePMI = recipePriors.negativePairs?.[pair];
      if (negativePMI !== undefined) {
        negativePenalty += Math.abs(negativePMI) * 10;
        hasRecipePriors = true;
        reasons.push(`-${Math.abs(negativePMI).toFixed(2)} NEGATIVE recipe pair with ${selName}`);
      }
    }
  }

  // Check commercial priors (pet food products)
  const commercialPriors = (priors as any).commercial?.[species];
  if (commercialPriors) {
    for (const selected of selectedIngredients) {
      const selName = selected.name;
      const pair = [ingName, selName].sort().join('|'); // Commercial uses | separator
      
      const pmi = commercialPriors.pairPMI?.[pair];
      if (pmi !== undefined && pmi > 0) {
        totalPMI += pmi * 1.2; // Boost commercial data slightly (more products = stronger signal)
        pairCount++;
        hasCommercialPriors = true;
        reasons.push(`+${pmi.toFixed(2)} commercial PMI with ${selName}`);
      }
      
      const rarePMI = commercialPriors.rarePairs?.[pair];
      if (rarePMI !== undefined) {
        negativePenalty += Math.abs(rarePMI) * 15; // Strong penalty for commercial rare pairs
        hasCommercialPriors = true;
        reasons.push(`-${Math.abs(rarePMI).toFixed(2)} RARE commercial pair with ${selName}`);
      }
    }
  }

  // Average PMI across all pairs
  const avgPMI = pairCount > 0 ? totalPMI / pairCount : 0;
  const finalScore = avgPMI - negativePenalty;

  const source = hasRecipePriors && hasCommercialPriors ? 'both' 
    : hasCommercialPriors ? 'commercial' 
    : hasRecipePriors ? 'recipe' 
    : undefined;

  const reason = reasons.length > 0 
    ? reasons.join(', ')
    : 'No learned pairings';

  return {
    score: finalScore,
    reason,
    pmiValue: avgPMI,
    source
  };
}

/**
 * Check if a fat is compatible with selected proteins based on PMI
 * Checks BOTH recipe and commercial priors for hard blocks
 * Returns true if fat should be ALLOWED
 */
export function isFatCompatibleWithProteins(
  fat: Ingredient,
  proteins: Ingredient[],
  species: string
): { compatible: boolean; reason: string; pmiScore?: number } {
  if (proteins.length === 0) {
    return { compatible: true, reason: 'No proteins selected yet' };
  }

  const fatName = fat.name;
  let totalPMI = 0;
  let pmiCount = 0;
  let hasNegativePair = false;
  let negativePairWith = '';
  let negativeSource = '';

  // Check recipe priors
  const recipePriors = priors.coOccurrence?.[species];
  if (recipePriors) {
    for (const protein of proteins) {
      const proteinName = protein.name;
      const pair = [fatName, proteinName].sort().join('+');
      
      const negativePMI = recipePriors.negativePairs?.[pair];
      if (negativePMI !== undefined && negativePMI < -1.0) {
        hasNegativePair = true;
        negativePairWith = proteinName;
        negativeSource = 'recipes';
        break;
      }
      
      const pmi = recipePriors.pairPMI?.[pair];
      if (pmi !== undefined) {
        totalPMI += pmi;
        pmiCount++;
      }
    }
  }

  // Check commercial priors (stronger signal)
  const commercialPriors = (priors as any).commercial?.[species];
  if (commercialPriors && !hasNegativePair) {
    for (const protein of proteins) {
      const proteinName = protein.name;
      const pair = [fatName, proteinName].sort().join('|');
      
      const rarePMI = commercialPriors.rarePairs?.[pair];
      if (rarePMI !== undefined && rarePMI < -1.5) {
        hasNegativePair = true;
        negativePairWith = proteinName;
        negativeSource = 'commercial products';
        break;
      }
      
      const pmi = commercialPriors.pairPMI?.[pair];
      if (pmi !== undefined) {
        totalPMI += pmi * 1.2; // Weight commercial data higher
        pmiCount++;
      }
    }
  }

  // Hard block if negative pairing detected
  if (hasNegativePair) {
    return {
      compatible: false,
      reason: `Negative pairing with ${negativePairWith} (learned from ${negativeSource})`,
      pmiScore: undefined
    };
  }

  // Allow if positive PMI or no learned relationship
  const avgPMI = pmiCount > 0 ? totalPMI / pmiCount : 0;
  
  if (avgPMI > 0.3) {
    return {
      compatible: true,
      reason: `Strong positive pairing (PMI: ${avgPMI.toFixed(2)})`,
      pmiScore: avgPMI
    };
  } else if (avgPMI > 0) {
    return {
      compatible: true,
      reason: `Weak positive pairing (PMI: ${avgPMI.toFixed(2)})`,
      pmiScore: avgPMI
    };
  } else {
    // No learned relationship - allow by default (species-appropriate fats)
    return {
      compatible: true,
      reason: 'No learned pairing (species-default allowed)',
      pmiScore: 0
    };
  }
}

/**
 * Get top-N fats that pair well with selected proteins
 * Uses PMI to rank fats, not hardcoded rules
 */
export function getTopPairedFats(
  availableFats: Ingredient[],
  proteins: Ingredient[],
  species: string,
  topN: number = 5
): Array<{ fat: Ingredient; pmiScore: number; reason: string }> {
  const scored = availableFats.map(fat => {
    const compat = isFatCompatibleWithProteins(fat, proteins, species);
    return {
      fat,
      pmiScore: compat.pmiScore || 0,
      reason: compat.reason,
      compatible: compat.compatible
    };
  });

  // Filter to compatible only, then sort by PMI
  return scored
    .filter(s => s.compatible)
    .sort((a, b) => b.pmiScore - a.pmiScore)
    .slice(0, topN);
}

/**
 * Log pairing decision for debugging
 */
export function logPairingDecision(
  ingredient: Ingredient,
  selectedIngredients: Ingredient[],
  species: string,
  action: 'selected' | 'rejected'
): void {
  const pairingScore = calculatePairingScore(ingredient, selectedIngredients, species);
  const prefix = action === 'selected' ? '‚úì' : '‚úó';
  console.log(
    `[PMI ${prefix}] ${ingredient.name}: score=${pairingScore.score.toFixed(2)} | ${pairingScore.reason}`
  );
}
</file>

<file path="lib/generator/RecipePriorScoring.ts">
/**
 * RECIPE PRIOR SCORING
 * Soft scoring boosts based on learned patterns from scraped recipes
 * Integrates with RecipeBuilder to improve realism and variety
 */

import recipePriors from '../data/recipePriors.json';
import { Ingredient } from '../data/ingredients';

interface RecipePriors {
  coOccurrence: {
    [species: string]: {
      pairs: Record<string, number>;
      triples: Record<string, number>;
    };
  };
  categoryRatios: {
    [species: string]: {
      protein: { mean: number; stdDev: number };
      vegetable: { mean: number; stdDev: number };
      fat: { mean: number; stdDev: number };
      carbohydrate: { mean: number; stdDev: number };
    };
  };
  ingredientCounts: {
    [species: string]: {
      mean: number;
      median: number;
      min: number;
      max: number;
    };
  };
}

const priors = recipePriors as RecipePriors;

/**
 * Calculate co-occurrence boost for an ingredient based on already-selected ingredients
 * Returns a score boost (0-1) based on how often this ingredient appears with the selected ones
 */
export function calculateCoOccurrenceBoost(
  candidateIngredient: Ingredient,
  selectedIngredients: Ingredient[],
  species: string
): number {
  if (selectedIngredients.length === 0) return 0;
  
  const speciesPriors = priors.coOccurrence[species];
  if (!speciesPriors) return 0;

  let totalBoost = 0;
  let pairCount = 0;

  // Check pairs with each selected ingredient
  for (const selected of selectedIngredients) {
    const pair1 = `${candidateIngredient.name}+${selected.name}`;
    const pair2 = `${selected.name}+${candidateIngredient.name}`;
    
    const count = speciesPriors.pairs[pair1] || speciesPriors.pairs[pair2] || 0;
    if (count > 0) {
      totalBoost += Math.log(count + 1) / 10; // Logarithmic scaling
      pairCount++;
    }
  }

  // Check triples if we have 2+ selected ingredients
  if (selectedIngredients.length >= 2) {
    for (let i = 0; i < selectedIngredients.length - 1; i++) {
      for (let j = i + 1; j < selectedIngredients.length; j++) {
        const ingredients = [
          candidateIngredient.name,
          selectedIngredients[i].name,
          selectedIngredients[j].name,
        ].sort();
        
        const triple = ingredients.join('+');
        const count = speciesPriors.triples[triple] || 0;
        
        if (count > 0) {
          totalBoost += Math.log(count + 1) / 5; // Higher weight for triples
        }
      }
    }
  }

  // Normalize to 0-1 range
  return Math.min(totalBoost, 1.0);
}

/**
 * Calculate category ratio penalty based on deviation from learned distributions
 * Returns a penalty (0-1) where 0 = perfect match, 1 = very far from typical
 */
export function calculateCategoryRatioPenalty(
  categoryRatios: Record<string, number>,
  species: string
): number {
  const speciesPriors = priors.categoryRatios[species];
  if (!speciesPriors) return 0;

  let totalDeviation = 0;
  let categoryCount = 0;

  for (const [category, ratio] of Object.entries(categoryRatios)) {
    const prior = speciesPriors[category as keyof typeof speciesPriors];
    if (!prior) continue;

    // Calculate z-score (how many standard deviations away)
    const zScore = Math.abs(ratio - prior.mean) / prior.stdDev;
    
    // Convert to penalty (0-1)
    // z-score of 0 = 0 penalty, z-score of 3+ = 1 penalty
    const penalty = Math.min(zScore / 3, 1.0);
    
    totalDeviation += penalty;
    categoryCount++;
  }

  return categoryCount > 0 ? totalDeviation / categoryCount : 0;
}

/**
 * Calculate ingredient count penalty based on deviation from typical recipe sizes
 * Returns a penalty (0-1) where 0 = typical count, 1 = very unusual count
 */
export function calculateIngredientCountPenalty(
  ingredientCount: number,
  species: string
): number {
  const speciesPriors = priors.ingredientCounts[species];
  if (!speciesPriors) return 0;

  const { mean, min, max } = speciesPriors;

  // Within typical range = no penalty
  if (ingredientCount >= min && ingredientCount <= max) {
    // Small penalty for being far from mean
    const deviation = Math.abs(ingredientCount - mean);
    return Math.min(deviation / (max - min), 0.3);
  }

  // Outside typical range = higher penalty
  if (ingredientCount < min) {
    const deficit = min - ingredientCount;
    return Math.min(0.5 + (deficit / min) * 0.5, 1.0);
  }

  // Too many ingredients
  const excess = ingredientCount - max;
  return Math.min(0.5 + (excess / max) * 0.5, 1.0);
}

/**
 * Get typical ingredient count range for a species
 */
export function getTypicalIngredientCount(species: string): { min: number; max: number; median: number } {
  const speciesPriors = priors.ingredientCounts[species];
  if (!speciesPriors) {
    return { min: 3, max: 10, median: 6 };
  }
  return {
    min: speciesPriors.min,
    max: speciesPriors.max,
    median: speciesPriors.median,
  };
}

/**
 * Check if an ingredient is commonly paired with a protein for this species
 * Used to boost vegetables/fats that commonly appear with the selected protein
 */
export function isCommonProteinPairing(
  ingredient: Ingredient,
  protein: Ingredient,
  species: string,
  pairingType: 'fat' | 'vegetable'
): boolean {
  const speciesPriors = priors.categoryPairs?.[species];
  if (!speciesPriors) return false;

  const pairings = pairingType === 'fat' 
    ? speciesPriors.proteinWithFat 
    : speciesPriors.proteinWithVeg;

  const commonPairs = pairings?.[protein.name] || [];
  return commonPairs.includes(ingredient.name);
}

/**
 * Apply all prior-based scoring adjustments to a base score
 * This is the main integration point for RecipeBuilder
 */
export function applyPriorScoring(
  ingredient: Ingredient,
  baseScore: number,
  selectedIngredients: Ingredient[],
  species: string,
  options: {
    coOccurrenceWeight?: number;
    proteinPairingWeight?: number;
  } = {}
): number {
  const {
    coOccurrenceWeight = 0.15,
    proteinPairingWeight = 0.1,
  } = options;

  let adjustedScore = baseScore;

  // 1. Co-occurrence boost
  const coOccurrenceBoost = calculateCoOccurrenceBoost(
    ingredient,
    selectedIngredients,
    species
  );
  adjustedScore += coOccurrenceBoost * coOccurrenceWeight;

  // 2. Protein pairing boost
  const selectedProtein = selectedIngredients.find(i => i.category === 'protein');
  if (selectedProtein) {
    if (ingredient.category === 'fat') {
      const isCommon = isCommonProteinPairing(ingredient, selectedProtein, species, 'fat');
      if (isCommon) {
        adjustedScore += proteinPairingWeight;
      }
    } else if (ingredient.category === 'vegetable') {
      const isCommon = isCommonProteinPairing(ingredient, selectedProtein, species, 'vegetable');
      if (isCommon) {
        adjustedScore += proteinPairingWeight;
      }
    }
  }

  return adjustedScore;
}
</file>

<file path="lib/generator/VerifyAmazonLinks.ts">
// Verify Amazon Links - Check if links are live and accessible
// Note: This checks HTTP status, but can't verify product details without scraping

import { VETTED_PRODUCTS } from '../data/vetted-products';

interface VerificationResult {
  ingredient: string;
  productName: string;
  asinLink: string;
  asin: string;
  status: 'checking' | 'live' | 'dead' | 'redirect' | 'error';
  httpStatus?: number;
  error?: string;
}

const results: VerificationResult[] = [];

console.log('='.repeat(80));
console.log('AMAZON LINK VERIFICATION - HTTP Status Check');
console.log('='.repeat(80));
console.log();
console.log('‚ö†Ô∏è  Note: This checks if links are accessible, but cannot verify');
console.log('    if the product matches the ingredient without manual review.');
console.log();
console.log('Checking links...');
console.log();

// Sample a subset of links to check (checking all 292 would take too long)
const entries = Object.entries(VETTED_PRODUCTS);
const sampleSize = 50; // Check first 50 products
const sampled = entries.slice(0, sampleSize);

async function checkLink(url: string): Promise<{ status: number; ok: boolean }> {
  try {
    const response = await fetch(url, {
      method: 'HEAD', // Just check headers, don't download content
      redirect: 'follow',
    });
    return { status: response.status, ok: response.ok };
  } catch (error: any) {
    throw new Error(error.message);
  }
}

async function verifyLinks() {
  let checked = 0;
  let live = 0;
  let dead = 0;
  let errors = 0;

  for (const [ingredientName, product] of sampled) {
    const asinLink = product.asinLink;
    const asinMatch = asinLink.match(/\/dp\/([A-Z0-9]{10})/i);
    const asin = asinMatch ? asinMatch[1] : 'unknown';

    const result: VerificationResult = {
      ingredient: ingredientName,
      productName: product.productName,
      asinLink,
      asin,
      status: 'checking',
    };

    try {
      const { status, ok } = await checkLink(asinLink);
      result.httpStatus = status;
      
      if (ok && status === 200) {
        result.status = 'live';
        live++;
      } else if (status >= 300 && status < 400) {
        result.status = 'redirect';
        live++; // Redirects are usually fine
      } else {
        result.status = 'dead';
        dead++;
      }
    } catch (error: any) {
      result.status = 'error';
      result.error = error.message;
      errors++;
    }

    results.push(result);
    checked++;

    // Progress indicator
    if (checked % 10 === 0) {
      console.log(`Checked ${checked}/${sampleSize}...`);
    }
  }

  console.log();
  console.log('='.repeat(80));
  console.log('VERIFICATION RESULTS');
  console.log('='.repeat(80));
  console.log();
  console.log(`Sample size: ${sampleSize} products (out of ${entries.length} total)`);
  console.log(`Live links: ${live} (${((live / checked) * 100).toFixed(1)}%)`);
  console.log(`Dead links: ${dead} (${((dead / checked) * 100).toFixed(1)}%)`);
  console.log(`Errors: ${errors} (${((errors / checked) * 100).toFixed(1)}%)`);
  console.log();

  // Show dead links
  const deadLinks = results.filter(r => r.status === 'dead');
  if (deadLinks.length > 0) {
    console.log('DEAD LINKS FOUND:');
    console.log('-'.repeat(80));
    deadLinks.forEach(r => {
      console.log(`‚ùå ${r.ingredient}`);
      console.log(`   Product: ${r.productName}`);
      console.log(`   ASIN: ${r.asin}`);
      console.log(`   Status: ${r.httpStatus}`);
      console.log(`   Link: ${r.asinLink}`);
      console.log();
    });
  }

  // Show errors
  const errorLinks = results.filter(r => r.status === 'error');
  if (errorLinks.length > 0) {
    console.log('ERRORS ENCOUNTERED:');
    console.log('-'.repeat(80));
    errorLinks.forEach(r => {
      console.log(`‚ö†Ô∏è  ${r.ingredient}`);
      console.log(`   Product: ${r.productName}`);
      console.log(`   Error: ${r.error}`);
      console.log(`   Link: ${r.asinLink}`);
      console.log();
    });
  }

  console.log('='.repeat(80));
  console.log('IMPORTANT NOTES');
  console.log('='.repeat(80));
  console.log();
  console.log('1. This script only checks if links are accessible (HTTP 200)');
  console.log('2. It CANNOT verify if the product actually matches the ingredient');
  console.log('3. Manual review is needed to confirm product accuracy');
  console.log();
  console.log('RECOMMENDED MANUAL CHECKS:');
  console.log('- Verify "venison" ASIN actually links to venison (not beef)');
  console.log('- Verify "rabbit meat" ASIN actually links to rabbit (not lamb)');
  console.log('- Verify "turkey giblets" ASIN actually links to turkey (not chicken)');
  console.log('- Verify seed products link to correct seed types');
  console.log();
  console.log('To manually verify, visit the links and check product titles/descriptions.');
  console.log('='.repeat(80));
}

// Run verification
verifyLinks().catch(console.error);
</file>

<file path="lib/utils/__tests__/affiliateLinks.test.ts">
// lib/utils/__tests__/affiliateLinks.test.ts
import { describe, it, expect } from 'vitest';
import {
  ensureSellerId,
  ensureCartUrlSellerId,
  hasSellerId,
  extractASIN,
  isValidAmazonUrl,
  isCartUrl,
  addSellerIdIfMissing,
} from '../affiliateLinks';

describe('affiliateLinks utilities', () => {
  describe('ensureSellerId', () => {
    it('should add seller ID to URL without existing tag', () => {
      const url = 'https://www.amazon.com/dp/B01234567';
      const result = ensureSellerId(url);
      expect(result).toContain('tag=robinfrench-20');
      expect(result).toBe('https://www.amazon.com/dp/B01234567?tag=robinfrench-20');
    });

    it('should replace existing tag parameter with our seller ID', () => {
      const url = 'https://www.amazon.com/dp/B01234567?tag=someone-else-20';
      const result = ensureSellerId(url);
      expect(result).toContain('tag=robinfrench-20');
      expect(result).not.toContain('someone-else-20');
    });

    it('should replace AssociateTag with tag parameter', () => {
      const url = 'https://www.amazon.com/dp/B01234567?AssociateTag=other-20';
      const result = ensureSellerId(url);
      expect(result).toContain('tag=robinfrench-20');
      expect(result).not.toContain('AssociateTag');
    });

    it('should handle URL with existing query parameters', () => {
      const url = 'https://www.amazon.com/dp/B01234567?ref=sr_1_1';
      const result = ensureSellerId(url);
      expect(result).toContain('tag=robinfrench-20');
      expect(result).toContain('ref=sr_1_1');
    });

    it('should handle /gp/product/ URL format', () => {
      const url = 'https://www.amazon.com/gp/product/B01234567';
      const result = ensureSellerId(url);
      expect(result).toContain('tag=robinfrench-20');
    });

    it('should return empty string for null/undefined input', () => {
      expect(ensureSellerId(null)).toBe('');
      expect(ensureSellerId(undefined)).toBe('');
      expect(ensureSellerId('')).toBe('');
    });

    it('should handle malformed URLs gracefully', () => {
      const url = 'not-a-url';
      const result = ensureSellerId(url);
      expect(result).toContain('tag=robinfrench-20');
    });

    it('should handle URLs without protocol', () => {
      const url = 'www.amazon.com/dp/B01234567';
      const result = ensureSellerId(url);
      // Should still attempt to add tag (may fail gracefully)
      expect(result).toBeTruthy();
    });
  });

  describe('ensureCartUrlSellerId', () => {
    it('should add AssociateTag to cart URL without existing tag', () => {
      const cartUrl = 'https://www.amazon.com/gp/aws/cart/add.html?ASIN.1=B01234567&Quantity.1=1';
      const result = ensureCartUrlSellerId(cartUrl);
      expect(result).toContain('AssociateTag=robinfrench-20');
      expect(result).toContain('ASIN.1=B01234567');
    });

    it('should replace existing AssociateTag with our seller ID', () => {
      const cartUrl = 'https://www.amazon.com/gp/aws/cart/add.html?ASIN.1=B01234567&AssociateTag=other-20';
      const result = ensureCartUrlSellerId(cartUrl);
      expect(result).toContain('AssociateTag=robinfrench-20');
      expect(result).not.toContain('other-20');
    });

    it('should replace tag parameter with AssociateTag in cart URLs', () => {
      const cartUrl = 'https://www.amazon.com/gp/aws/cart/add.html?ASIN.1=B01234567&tag=other-20';
      const result = ensureCartUrlSellerId(cartUrl);
      expect(result).toContain('AssociateTag=robinfrench-20');
      expect(result).not.toContain('tag=');
    });

    it('should handle multiple ASINs in cart URL', () => {
      const cartUrl = 'https://www.amazon.com/gp/aws/cart/add.html?ASIN.1=B01234567&Quantity.1=1&ASIN.2=B09876543&Quantity.2=1';
      const result = ensureCartUrlSellerId(cartUrl);
      expect(result).toContain('AssociateTag=robinfrench-20');
      expect(result).toContain('ASIN.1=B01234567');
      expect(result).toContain('ASIN.2=B09876543');
    });

    it('should return empty string for null/undefined input', () => {
      expect(ensureCartUrlSellerId(null)).toBe('');
      expect(ensureCartUrlSellerId(undefined)).toBe('');
      expect(ensureCartUrlSellerId('')).toBe('');
    });
  });

  describe('hasSellerId', () => {
    it('should return true for URL with tag parameter', () => {
      expect(hasSellerId('https://www.amazon.com/dp/B01234567?tag=robinfrench-20')).toBe(true);
    });

    it('should return true for URL with AssociateTag parameter', () => {
      expect(hasSellerId('https://www.amazon.com/gp/aws/cart/add.html?AssociateTag=robinfrench-20')).toBe(true);
    });

    it('should return false for URL without seller ID', () => {
      expect(hasSellerId('https://www.amazon.com/dp/B01234567')).toBe(false);
    });

    it('should return false for URL with different tag', () => {
      expect(hasSellerId('https://www.amazon.com/dp/B01234567?tag=other-20')).toBe(false);
    });

    it('should return false for null/undefined/empty input', () => {
      expect(hasSellerId(null)).toBe(false);
      expect(hasSellerId(undefined)).toBe(false);
      expect(hasSellerId('')).toBe(false);
    });
  });

  describe('extractASIN', () => {
    it('should extract ASIN from /dp/ URL format', () => {
      expect(extractASIN('https://www.amazon.com/dp/B012345678')).toBe('B012345678');
      expect(extractASIN('https://www.amazon.com/dp/B012345678?tag=robinfrench-20')).toBe('B012345678');
    });

    it('should extract ASIN from /gp/product/ URL format', () => {
      expect(extractASIN('https://www.amazon.com/gp/product/B012345678')).toBe('B012345678');
    });

    it('should extract ASIN from /product/ URL format', () => {
      expect(extractASIN('https://www.amazon.com/product/B012345678')).toBe('B012345678');
    });

    it('should extract ASIN from ASIN parameter', () => {
      expect(extractASIN('https://www.amazon.com/gp/aws/cart/add.html?ASIN=B012345678')).toBe('B012345678');
    });

    it('should return null for URL without ASIN', () => {
      expect(extractASIN('https://www.amazon.com/s?k=chicken')).toBe(null);
      expect(extractASIN('https://www.amazon.com')).toBe(null);
    });

    it('should return null for invalid ASIN format', () => {
      expect(extractASIN('https://www.amazon.com/dp/B123')).toBe(null);
      expect(extractASIN('https://www.amazon.com/dp/B01234567890')).toBe(null);
      // 9 characters should not match (ASINs are exactly 10)
      expect(extractASIN('https://www.amazon.com/dp/B01234567')).toBe(null);
    });

    it('should return null for null/undefined/empty input', () => {
      expect(extractASIN(null)).toBe(null);
      expect(extractASIN(undefined)).toBe(null);
      expect(extractASIN('')).toBe(null);
    });
  });

  describe('isValidAmazonUrl', () => {
    it('should return true for amazon.com URLs', () => {
      expect(isValidAmazonUrl('https://www.amazon.com/dp/B01234567')).toBe(true);
      expect(isValidAmazonUrl('http://amazon.com/product')).toBe(true);
    });

    it('should return true for amzn. URLs', () => {
      expect(isValidAmazonUrl('https://amzn.to/abc123')).toBe(true);
    });

    it('should return false for non-Amazon URLs', () => {
      expect(isValidAmazonUrl('https://www.google.com')).toBe(false);
      expect(isValidAmazonUrl('https://www.chewy.com')).toBe(false);
    });

    it('should return false for invalid URLs', () => {
      expect(isValidAmazonUrl('not-a-url')).toBe(false);
      expect(isValidAmazonUrl('')).toBe(false);
    });

    it('should return false for null/undefined input', () => {
      expect(isValidAmazonUrl(null)).toBe(false);
      expect(isValidAmazonUrl(undefined)).toBe(false);
    });
  });

  describe('isCartUrl', () => {
    it('should return true for /gp/aws/cart/add.html URLs', () => {
      expect(isCartUrl('https://www.amazon.com/gp/aws/cart/add.html?ASIN.1=B01234567')).toBe(true);
    });

    it('should return true for /gp/cart/view.html URLs', () => {
      expect(isCartUrl('https://www.amazon.com/gp/cart/view.html')).toBe(true);
    });

    it('should return false for product URLs', () => {
      expect(isCartUrl('https://www.amazon.com/dp/B01234567')).toBe(false);
    });

    it('should return false for null/undefined/empty input', () => {
      expect(isCartUrl(null)).toBe(false);
      expect(isCartUrl(undefined)).toBe(false);
      expect(isCartUrl('')).toBe(false);
    });
  });

  describe('addSellerIdIfMissing', () => {
    it('should add seller ID if missing', () => {
      const url = 'https://www.amazon.com/dp/B01234567';
      const result = addSellerIdIfMissing(url);
      expect(result).toContain('tag=robinfrench-20');
    });

    it('should not add seller ID if already present', () => {
      const url = 'https://www.amazon.com/dp/B01234567?tag=robinfrench-20';
      const result = addSellerIdIfMissing(url);
      // Should still ensure it's our seller ID (may normalize)
      expect(result).toContain('robinfrench-20');
    });

    it('should replace other seller IDs with ours', () => {
      const url = 'https://www.amazon.com/dp/B01234567?tag=other-20';
      const result = addSellerIdIfMissing(url);
      expect(result).toContain('tag=robinfrench-20');
      expect(result).not.toContain('other-20');
    });

    it('should handle AssociateTag parameter', () => {
      const url = 'https://www.amazon.com/dp/B01234567?AssociateTag=other-20';
      const result = addSellerIdIfMissing(url);
      expect(result).toContain('robinfrench-20');
    });
  });
});
</file>

<file path="lib/utils/__tests__/getAmazonBuyLink.test.ts">
// Tests for Amazon buy link finalization

import { getAmazonBuyLink, getAmazonBuyLinkWithStatus, getFallbackAmazonSearchLink } from '../getAmazonBuyLink';

describe('getAmazonBuyLink', () => {
  test('adds affiliate tag to valid Amazon URL', () => {
    const link = getAmazonBuyLink('https://www.amazon.com/dp/B012345678');
    expect(link).toContain('tag=robinfrench-20');
    expect(link).toContain('B012345678');
  });

  test('preserves existing affiliate tag', () => {
    const link = getAmazonBuyLink('https://www.amazon.com/dp/B012345678?tag=robinfrench-20');
    expect(link).toContain('tag=robinfrench-20');
  });

  test('rejects non-Amazon URLs', () => {
    const link = getAmazonBuyLink('https://example.com/product/123');
    expect(link).toBeNull();
  });

  test('rejects empty/null URLs', () => {
    expect(getAmazonBuyLink('')).toBeNull();
    expect(getAmazonBuyLink(null)).toBeNull();
    expect(getAmazonBuyLink(undefined)).toBeNull();
  });

  test('rejects Amazon search URLs (no ASIN)', () => {
    const link = getAmazonBuyLink('https://www.amazon.com/s?k=chicken+breast');
    expect(link).toBeNull();
  });

  test('handles /gp/product/ format', () => {
    const link = getAmazonBuyLink('https://www.amazon.com/gp/product/B012345678');
    expect(link).toContain('tag=robinfrench-20');
    expect(link).toContain('B012345678');
  });

  test('handles URLs with existing query parameters', () => {
    const link = getAmazonBuyLink('https://www.amazon.com/dp/B012345678?ref=xyz');
    expect(link).toContain('tag=robinfrench-20');
    expect(link).toContain('B012345678');
  });
});

describe('getAmazonBuyLinkWithStatus', () => {
  test('returns ok status for valid link', () => {
    const result = getAmazonBuyLinkWithStatus('https://www.amazon.com/dp/B012345678');
    expect(result.status).toBe('ok');
    expect(result.url).toContain('tag=robinfrench-20');
    expect(result.asin).toBe('B012345678');
  });

  test('returns missing status for null URL', () => {
    const result = getAmazonBuyLinkWithStatus(null);
    expect(result.status).toBe('missing');
    expect(result.url).toBeNull();
  });

  test('returns invalid status for non-Amazon URL', () => {
    const result = getAmazonBuyLinkWithStatus('https://example.com/product/123');
    expect(result.status).toBe('invalid');
    expect(result.url).toBeNull();
  });

  test('returns invalid status for search URL', () => {
    const result = getAmazonBuyLinkWithStatus('https://www.amazon.com/s?k=chicken');
    expect(result.status).toBe('invalid');
    expect(result.url).toBeNull();
  });

  test('returns region-unavailable for non-US regions', () => {
    const result = getAmazonBuyLinkWithStatus('https://www.amazon.com/dp/B012345678', 'UK');
    expect(result.status).toBe('region-unavailable');
    expect(result.asin).toBe('B012345678');
  });
});

describe('getFallbackAmazonSearchLink', () => {
  test('creates search link with affiliate tag', () => {
    const link = getFallbackAmazonSearchLink('chicken breast organic');
    expect(link).toContain('amazon.com/s');
    expect(link).toContain('k=chicken%20breast%20organic');
    expect(link).toContain('tag=robinfrench-20');
  });

  test('handles UK region', () => {
    const link = getFallbackAmazonSearchLink('chicken breast', 'UK');
    expect(link).toContain('amazon.co.uk/s');
    expect(link).toContain('tag=robinfrench-20');
  });

  test('URL encodes special characters', () => {
    const link = getFallbackAmazonSearchLink('Bob\'s Red Mill Oats');
    expect(link).toContain('Bob%27s');
  });
});
</file>

<file path="lib/utils/abTesting.ts">
// A/B Testing Utilities for Button Copy Optimization
// Tracks which button text drives more affiliate clicks

export type ButtonVariant = 'shop-now' | 'buy-amazon' | 'get-ingredients';

export interface ButtonCopyVariant {
  id: ButtonVariant;
  text: string;
  icon?: string;
}

export const BUTTON_VARIANTS: ButtonCopyVariant[] = [
  { id: 'shop-now', text: 'Buy', icon: 'üõí' },
  { id: 'buy-amazon', text: 'Buy', icon: 'üì¶' },
  { id: 'get-ingredients', text: 'Buy', icon: '‚ú®' }
];

export const BUY_ALL_VARIANTS: ButtonCopyVariant[] = [
  { id: 'shop-now', text: 'Buy All', icon: 'üõí' },
  { id: 'buy-amazon', text: 'Buy All', icon: 'üì¶' },
  { id: 'get-ingredients', text: 'Buy All', icon: '‚ú®' }
];

// Assign user to a variant (sticky - stays same across session)
export function getAssignedVariant(): ButtonVariant {
  if (typeof window === 'undefined') return 'shop-now';
  
  // Check if user already has assigned variant
  const stored = localStorage.getItem('ab_button_variant');
  if (stored && ['shop-now', 'buy-amazon', 'get-ingredients'].includes(stored)) {
    return stored as ButtonVariant;
  }
  
  // Randomly assign new user to a variant (33/33/33 split)
  const variants: ButtonVariant[] = ['shop-now', 'buy-amazon', 'get-ingredients'];
  const random = Math.floor(Math.random() * 3);
  const assigned = variants[random];
  
  localStorage.setItem('ab_button_variant', assigned);
  return assigned;
}

// Get button text for assigned variant
export function getButtonCopy(isBuyAll: boolean = false): ButtonCopyVariant {
  const variant = getAssignedVariant();
  const variants = isBuyAll ? BUY_ALL_VARIANTS : BUTTON_VARIANTS;
  return variants.find(v => v.id === variant) || variants[0];
}

// Track button click (for conversion analysis)
export function trackButtonClick(
  variant: ButtonVariant,
  context: 'individual' | 'buy-all' | 'preview',
  ingredientName?: string
) {
  if (typeof window === 'undefined') return;
  
  const clicks = JSON.parse(localStorage.getItem('ab_button_clicks') || '[]');
  
  clicks.push({
    variant,
    context,
    ingredientName,
    timestamp: new Date().toISOString()
  });
  
  // Keep only last 1000 clicks
  if (clicks.length > 1000) {
    clicks.splice(0, clicks.length - 1000);
  }
  
  localStorage.setItem('ab_button_clicks', JSON.stringify(clicks));
}

// Get conversion stats for analysis
export function getConversionStats() {
  if (typeof window === 'undefined') return null;
  
  const clicks = JSON.parse(localStorage.getItem('ab_button_clicks') || '[]');
  
  const stats: Record<ButtonVariant, { total: number; byContext: Record<string, number> }> = {
    'shop-now': { total: 0, byContext: {} },
    'buy-amazon': { total: 0, byContext: {} },
    'get-ingredients': { total: 0, byContext: {} }
  };
  
  clicks.forEach((click: any) => {
    const variant = click.variant as ButtonVariant;
    if (stats[variant]) {
      stats[variant].total++;
      stats[variant].byContext[click.context] = (stats[variant].byContext[click.context] || 0) + 1;
    }
  });
  
  return stats;
}

// Console command to see results
export function logABTestResults() {
  const stats = getConversionStats();
  if (!stats) {
    console.log('No A/B test data available');
    return;
  }
  
  console.log('üß™ A/B Test Results - Button Copy Optimization\n');
  console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
  
  Object.entries(stats).forEach(([variant, data]) => {
    console.log(`${variant.toUpperCase()}:`);
    console.log(`  Total clicks: ${data.total}`);
    console.log(`  By context:`, data.byContext);
    console.log('');
  });
  
  // Calculate winner
  const sorted = Object.entries(stats).sort((a, b) => b[1].total - a[1].total);
  const winner = sorted[0];
  
  console.log(`üèÜ WINNER: "${winner[0]}" with ${winner[1].total} clicks`);
  console.log('\nTo reset test: localStorage.removeItem("ab_button_clicks")');
  console.log('To change your variant: localStorage.removeItem("ab_button_variant")');
}

// Make available globally for easy console access
if (typeof window !== 'undefined') {
  (window as any).logABTestResults = logABTestResults;
  (window as any).getConversionStats = getConversionStats;
}
</file>

<file path="lib/utils/affiliateLinks.ts">
// lib/utils/affiliateLinks.ts
// Utility functions to ensure all affiliate links have seller ID

const SELLER_ID = 'robinfrench-20';

/**
 * Ensures an Amazon product link has the seller ID affiliate tag.
 * If the link already has a tag, it replaces it with ours.
 * If the link doesn't have a tag, it adds ours.
 * 
 * @param url The Amazon product URL to ensure has seller ID (format: /dp/ASIN or /gp/product/ASIN)
 * @returns The URL with seller ID guaranteed
 * 
 * @example
 * ensureSellerId('https://www.amazon.com/dp/B01234567') 
 * // Returns: 'https://www.amazon.com/dp/B01234567?tag=robinfrench-20'
 */
export function ensureSellerId(url: string | undefined | null): string {
  if (!url) return '';
  
  try {
    // Remove any existing tag parameters
    const urlObj = new URL(url);
    urlObj.searchParams.delete('tag');
    urlObj.searchParams.delete('AssociateTag');
    
    // Add our seller ID
    urlObj.searchParams.set('tag', SELLER_ID);
    
    return urlObj.toString();
  } catch (e) {
    // If URL parsing fails, try simple string manipulation as fallback
    if (url.includes('?')) {
      return `${url}&tag=${SELLER_ID}`;
    }
    return `${url}?tag=${SELLER_ID}`;
  }
}

/**
 * Ensures an Amazon cart URL has the seller ID affiliate tag.
 * Cart URLs use AssociateTag parameter instead of tag parameter.
 * 
 * @param cartUrl The Amazon cart URL (format: /gp/aws/cart/add.html?ASIN.1=...)
 * @returns The cart URL with AssociateTag parameter added
 * 
 * @example
 * ensureCartUrlSellerId('https://www.amazon.com/gp/aws/cart/add.html?ASIN.1=B01234567&Quantity.1=1')
 * // Returns: 'https://www.amazon.com/gp/aws/cart/add.html?ASIN.1=B01234567&Quantity.1=1&AssociateTag=robinfrench-20'
 */
export function ensureCartUrlSellerId(cartUrl: string | undefined | null): string {
  if (!cartUrl) return '';
  
  // If it already has AssociateTag, replace it with ours
  if (cartUrl.includes('AssociateTag=')) {
    return cartUrl.replace(/AssociateTag=[^&]+/, `AssociateTag=${SELLER_ID}`);
  }
  
  // If it has tag parameter, replace with AssociateTag
  if (cartUrl.includes('tag=')) {
    return cartUrl.replace(/tag=[^&]+/, `AssociateTag=${SELLER_ID}`);
  }
  
  // Add AssociateTag parameter
  const separator = cartUrl.includes('?') ? '&' : '?';
  return `${cartUrl}${separator}AssociateTag=${SELLER_ID}`;
}

/**
 * Adds seller ID to a link only if it doesn't already have one.
 * @param url The URL to potentially add seller ID to
 * @returns The URL with seller ID if it was missing
 */
export function addSellerIdIfMissing(url: string | undefined | null): string {
  if (!url) return '';
  
  if (url.includes('tag=') || url.includes('AssociateTag=')) {
    // Already has a tag, ensure it's ours
    return ensureSellerId(url);
  }
  
  // Add our seller ID
  const separator = url.includes('?') ? '&' : '?';
  return `${url}${separator}tag=${SELLER_ID}`;
}

/**
 * Extracts ASIN from an Amazon URL.
 * Supports multiple URL formats: /dp/ASIN, /gp/product/ASIN, /product/ASIN
 * 
 * @param url The Amazon URL containing an ASIN
 * @returns The ASIN (10-character alphanumeric code) or null if not found
 * 
 * @example
 * extractASIN('https://www.amazon.com/dp/B01234567?tag=robinfrench-20')
 * // Returns: 'B01234567'
 */
export function extractASIN(url: string | undefined | null): string | null {
  if (!url) return null;
  
  // Try /dp/ASIN pattern (most common) - ASIN is 10 characters, stop at / or ? or end
  const dpMatch = url.match(/\/dp\/([A-Z0-9]{10})(?:\/|$|\?)/);
  if (dpMatch) return dpMatch[1];
  
  // Try /gp/product/ASIN pattern
  const gpMatch = url.match(/\/gp\/product\/([A-Z0-9]{10})(?:\/|$|\?)/);
  if (gpMatch) return gpMatch[1];
  
  // Try /product/ASIN pattern
  const productMatch = url.match(/\/product\/([A-Z0-9]{10})(?:\/|$|\?)/);
  if (productMatch) return productMatch[1];
  
  // Try ASIN parameter
  try {
    const urlObj = new URL(url);
    const asinParam = urlObj.searchParams.get('ASIN');
    if (asinParam && /^[A-Z0-9]{10}$/.test(asinParam)) {
      return asinParam;
    }
  } catch (e) {
    // Invalid URL, continue
  }
  
  return null;
}

/**
 * Checks if a URL has our seller ID.
 * Works with both product links (tag=) and cart links (AssociateTag=).
 * 
 * @param url The URL to check
 * @returns True if the URL has our seller ID
 * 
 * @example
 * hasSellerId('https://www.amazon.com/dp/B01234567?tag=robinfrench-20')
 * // Returns: true
 */
export function hasSellerId(url: string | undefined | null): boolean {
  if (!url) return false;
  return url.includes(`tag=${SELLER_ID}`) || url.includes(`AssociateTag=${SELLER_ID}`);
}

/**
 * Validates that a URL is a valid Amazon URL.
 * 
 * @param url The URL to validate
 * @returns True if the URL is a valid Amazon URL
 */
export function isValidAmazonUrl(url: string | undefined | null): boolean {
  if (!url) return false;
  
  try {
    const urlObj = new URL(url);
    return urlObj.hostname.includes('amazon.com') || urlObj.hostname.includes('amzn.');
  } catch (e) {
    return false;
  }
}

/**
 * Validates that a URL is an Amazon cart URL.
 * 
 * @param url The URL to validate
 * @returns True if the URL is an Amazon cart URL
 */
export function isCartUrl(url: string | undefined | null): boolean {
  if (!url) return false;
  return url.includes('/gp/aws/cart/add.html') || url.includes('/gp/cart/view.html');
}
</file>

<file path="lib/utils/allIngredients.ts">
// lib/utils/allIngredients.ts
// Extract all ingredients from generate-recipes.js INGREDIENTS object
// This contains all the scraped AAFCO and research-based ingredients
// Also includes auto-generated ingredients from scraped data

import { GENERATED_INGREDIENTS } from '@/lib/data/generatedIngredients';

export interface SpeciesIngredients {
  [category: string]: string[];
}

export interface AllIngredients {
  dogs: {
    proteins: string[];
    carbs: string[];
    vegetables: string[];
    fats: string[];
  };
  cats: {
    proteins: string[];
    carbs: string[];
    vegetables: string[];
    fats: string[];
    fiber_supplements: string[];
    supplements: string[];
  };
  birds: {
    seeds: string[];
    nuts: string[]; // Added for large parrots
    vegetables: string[];
    fruits: string[];
    supplements: string[];
  };
  reptiles: {
    insects: string[];
    whole_prey: string[]; // Added for snakes
    vegetables: string[];
    fruits: string[];
  };
  'pocket-pets': {
    hay: string[];
    vegetables: string[];
    pellets: string[];
    fruits: string[];
    hamster_additions: string[];
    sugar_glider_special: string[]; // Added for gliders
  };
}

// This is the complete ingredient list from generate-recipes.js
// Contains all scraped AAFCO and research-based ingredients
export const ALL_INGREDIENTS: AllIngredients = {
  dogs: {
    proteins: [
      'ground chicken', 'ground turkey', 'ground beef (lean)', 'ground lamb', 'salmon (boneless)',
      'chicken breast', 'chicken thighs', 'turkey breast', 'beef liver', 'chicken liver',
      'chicken hearts', 'sardines (canned in water)', 'eggs', 'Turkey Giblets', 'Chicken Giblets',
      'Duck Breast', 'Venison', 'Rabbit Meat', 'quail', 'ground pork (lean)', 'turkey necks',
      'Ground Duck', 'Turkey Thighs', 'Chicken Necks', 'Ground Venison', 'Ground Rabbit',
      'Lamb Liver', 'Turkey Liver', 'Duck Hearts', 'Quail Eggs', 'Ground Quail'
    ],
    carbs: [
      'brown rice', 'white rice', 'quinoa', 'sweet potato', 'Regular Potato',
      'oats', 'Barley', 'pumpkin', 'Butternut Squash', 'lentils',
      'chickpeas', 'black beans', 'green peas', 'Wild Rice',
      'Amaranth', 'Buckwheat', 'Millet', 'Sorghum', 'Farro', 'Bulgur',
      'Split Peas', 'Kidney Beans (mashed)', 'Pinto Beans (mashed)', 'Navy Beans (mashed)',
      'Acorn Squash', 'Spaghetti Squash', 'Delicata Squash', 'Kabocha Squash'
    ],
    vegetables: [
      'carrots', 'green beans', 'Peas', 'spinach', 'broccoli', 'zucchini',
      'kale', 'celery', 'Bell Peppers (red/green)', 'brussels sprouts', 'asparagus', 'parsley',
      'cucumber', 'lettuce (romaine)', 'arugula', 'Endive', 'Escarole', 'Dandelion Greens',
      'Collard Greens', 'Turnip Greens', 'Beet Greens', 'Radish Greens',
      'Swiss Chard', 'bok choy', 'Napa Cabbage', 'Red Cabbage', 'Green Cabbage',
      'Cauliflower', 'Romanesco Broccoli', 'Snow Peas', 'Sugar Snap Peas',
      'Fennel', 'Leeks', 'Shallots', 'Garlic (small amounts)', 'Ginger (small amounts)',
      'Artichokes', 'Eggplant', 'Tomatoes (small amounts)', 'Yellow Squash', 'Pattypan Squash',
      'Radicchio', 'Frisee', 'Mache', 'Watercress', 'Purslane', 'Miner\'s Lettuce',
      'Lamb\'s Quarters', 'Amaranth Leaves', 'Malabar Spinach', 'New Zealand Spinach'
    ],
    fats: [
      'Coconut Oil', 'Olive Oil', 'Salmon Oil', 'Flaxseed (ground)', 'Hemp Seeds',
      'Eggshells (crushed)', 'Kelp Powder', 'Turmeric', 'Fish Oil', 'Avocado Oil',
      'Sunflower Oil', 'Sesame Oil', 'Pumpkin Seed Oil', 'Walnut Oil', 'Almond Oil',
      'Cod Liver Oil', 'Herring Oil', 'Mackerel Oil', 'Sardine Oil', 'Anchovy Oil',
      'Evening Primrose Oil', 'Borage Oil', 'Black Currant Oil', 'Chia Seed Oil'
    ]
  },
  cats: {
    proteins: [
      'ground chicken', 'ground turkey', 'ground beef (lean)', 'chicken thighs',
      'Turkey Thighs', 'salmon (boneless)', 'tuna', 'chicken liver',
      'Turkey Liver', 'sardines (canned in water)', 'eggs', 'Ground Duck', 'Rabbit Meat',
      'Venison', 'quail', 'ground lamb', 'Turkey Giblets', 'Chicken Giblets',
      'Ground Venison', 'Ground Rabbit', 'Duck Liver', 'Quail Meat', 'Ground Quail',
      'turkey necks', 'Chicken Necks', 'Duck Hearts', 'Turkey Hearts', 'Mackerel (canned)',
      'Herring (canned)', 'Anchovies (canned)', 'Ground Mackerel', 'Ground Herring',
      'Lamb Liver', 'beef liver', 'ground pork (lean)',
      'Turkey Sausage (no additives)', 'Chicken Sausage (no additives)'
    ],
    carbs: [
      'pumpkin', 'brown rice', 'oats',
      'sweet potato', 'quinoa', 'Barley (cooked, minimal)',
      'Butternut Squash (mashed, minimal)', 'Acorn Squash (mashed, minimal)', 'pumpkin',
      'Oat Bran (small amounts)', 'Rice Bran (small amounts)', 'Millet (tiny amounts)',
      'Amaranth (tiny amounts)', 'Buckwheat (tiny amounts)', 'lentils',
      'chickpeas', 'green peas', 'Split Peas (mashed)',
      'black beans', 'Kidney Beans (mashed, tiny amounts)'
    ],
    vegetables: [
      'carrots', 'Peas (mashed)', 'zucchini', 'spinach',
      'broccoli', 'green beans', 'Asparagus (tips only)',
      'celery', 'parsley', 'cucumber', 'lettuce (romaine)',
      'kale', 'Collard Greens (cooked, tiny amounts)',
      'Dandelion Greens (fresh, small amounts)', 'Endive (small amounts)', 'arugula',
      'bok choy', 'Napa Cabbage (small amounts)', 'green beans',
      'Snow Peas (mashed)', 'Sugar Snap Peas (mashed)', 'Fennel (small amounts)',
      'Swiss Chard (cooked, tiny amounts)', 'Beet Greens (cooked, tiny amounts)', 'Turnip Greens (cooked, tiny amounts)',
      'Radish Greens (cooked, tiny amounts)', 'Watercress (small amounts)', 'Purslane (small amounts)',
      'Cat Grass (wheatgrass)', 'Barley Grass', 'Alfalfa Sprouts (small amounts)'
    ],
    fats: [
      'Salmon Oil', 'Fish Oil', 'Cod Liver Oil', 'Herring Oil', 'Sardine Oil',
      'Mackerel Oil', 'Anchovy Oil', 'Krill Oil', 'Algae Oil (DHA)', 'Evening Primrose Oil',
      'Borage Oil', 'Black Currant Oil', 'Chia Seed Oil', 'Hemp Seed Oil', 'Flaxseed Oil',
      'Coconut Oil', 'Olive Oil (small amounts)', 'Avocado Oil (tiny amounts)', 'Wheat Germ Oil'
    ],
    fiber_supplements: [
      'Hairball Control Paste', 'Psyllium Husk', 'Probiotic Powder', 'Digestive Enzymes',
      'Brewer\'s Yeast', 'Spirulina Powder', 'Kelp Powder', 'Wheat Germ', 'Oat Bran',
      'Rice Bran', 'Inulin (prebiotic)', 'Fructooligosaccharides (FOS)', 'Mannanoligosaccharides (MOS)',
      'Beta-glucans', 'Pectin (from apples)', 'Chicory Root', 'Jerusalem Artichoke'
    ],
    supplements: [
      'Taurine Powder', 'L-Carnitine Powder', 'Lysine Powder', 'Vitamin E Oil',
      'Vitamin C (small amounts)', 'Vitamin B Complex', 'Niacinamide', 'Biotin',
      'Egg Yolks', 'Eggshells (crushed)', 'Chicken Broth (no salt)', 'Turkey Broth (no salt)',
      'Fish Broth (no salt)', 'Bone Broth (low sodium)', 'Cranberry Extract', 'D-Mannose',
      'Ursodeoxycholic Acid (UDCA)', 'S-Adenosyl methionine (SAM-e)', 'Milk Thistle',
      'Curcumin (turmeric extract)', 'Quercetin', 'Omega-3 Capsules', 'Joint Health Supplement',
      'Glucosamine Sulfate', 'Chondroitin Sulfate', 'MSM (methylsulfonylmethane)', 'Hyaluronic Acid'
    ]
  },
  birds: {
    seeds: [
      'Millet (white/red)', 'Canary Seed', 'Niger Seed', 'Oat Groats', 'Hemp Seeds',
      'Flaxseeds', 'Sesame Seeds', 'Chia Seeds', 'quinoa', 'Rapeseed',
      'Sunflower Seeds (small amounts)', 'Pumpkin Seeds', 'Safflower Seeds', 'Nyjer Seeds',
      'Amaranth Seeds', 'Buckwheat (hulled)', 'Barley (hulled)', 'Wheat (hulled)',
      'Rice (hulled)', 'Corn (cracked)', 'Poppy Seeds', 'Teff Seeds', 'Wild Bird Mix'
    ],
    nuts: [
      'Walnuts (in shell)', 'Almonds', 'Brazil Nuts', 'Pecans', 'Macadamia Nuts', 
      'Hazelnuts', 'Pine Nuts', 'Cashews', 'Pistachios', 'Peanuts (unsalted, roasted)'
    ],
    vegetables: [
      'carrots', 'broccoli', 'spinach', 'kale', 'Bell Peppers', 'zucchini',
      'sweet potato', 'Peas', 'Corn (fresh)', 'lettuce (romaine)', 'Endive',
      'Escarole', 'arugula', 'Dandelion Greens', 'Collard Greens',
      'Turnip Greens', 'Beet Greens', 'Swiss Chard', 'bok choy', 'Napa Cabbage',
      'Cauliflower', 'Romanesco Broccoli', 'Snow Peas', 'Sugar Snap Peas', 'asparagus',
      'celery', 'Fennel', 'parsley', 'Cilantro', 'Basil', 'Mint', 'Thyme'
    ],
    fruits: [
      'Apples (no seeds)', 'blueberries', 'Strawberries', 'Mango', 'bananas',
      'Grapes (chopped)', 'Papaya', 'Melon', 'Pineapple (small amounts)', 'Kiwi',
      'Raspberries', 'Blackberries', 'Cranberries', 'Cherries (pitted)', 'Pears (no seeds)',
      'Peaches (pitted)', 'Plums (pitted)', 'Apricots (pitted)', 'Figs', 'Dates (pitted)',
      'Raisins (unsweetened)', 'Currants', 'Goji Berries', 'Mulberries'
    ],
    supplements: [
      'eggs', 'Pellets (fortified)', 'Cuttlebone', 'Honey (tiny amounts)',
      'Peanut Butter (unsalted, tiny amounts)', 'Brewer\'s Yeast', 'Spirulina Powder',
      'Kelp Powder', 'Probiotic Powder', 'Vitamin D3 Drops', 'calcium carbonate',
      'Electrolyte Powder', 'Amino Acid Supplement', 'Fish Oil', 'Joint Health Powder'
    ]
  },
  reptiles: {
    insects: [
      'Dubia Roaches', 'Crickets', 'Mealworms', 'Superworms', 'Black Soldier Fly Larvae', 'Hornworms',
      'Silkworms', 'Waxworms', 'Butterworms', 'Phoenix Worms', 'Earthworms', 'Grasshoppers',
      'Locusts', 'Mantids', 'Fruit Flies', 'Pinhead Crickets', 'Small Dubia Roaches'
    ],
    whole_prey: [
      'Pinkie Mice (frozen/thawed)', 'Fuzzy Mice', 'Hopper Mice', 'Adult Mice',
      'Rat Pups', 'Adult Rats', 'Day-Old Chicks', 'quail', 'Feeder Fish (Guppies)', 'Silversides'
    ],
    vegetables: [
      'Collard Greens', 'Turnip Greens', 'Dandelion Greens', 'Butternut Squash',
      'Bell Peppers', 'carrots', 'zucchini', 'green beans', 'Snap Peas',
      'Acorn Squash', 'Endive', 'Escarole', 'arugula', 'kale', 'Swiss Chard', 'bok choy',
      'Napa Cabbage', 'Romaine Lettuce', 'Iceberg Lettuce', 'Red Leaf Lettuce', 'Butter Lettuce',
      'Cauliflower', 'broccoli', 'Romanesco Broccoli', 'asparagus', 'celery', 'Fennel',
      'parsley', 'Cilantro', 'Basil', 'Mint', 'Thyme', 'Oregano', 'Sage', 'Rosemary',
      'sweet potato', 'pumpkin', 'Squash (various)', 'cucumber', 'Eggplant'
    ],
    fruits: [
      'blueberries', 'Mango', 'Papaya', 'Strawberries', 'Figs', 'Apples (no seeds)',
      'Pears (no seeds)', 'bananas', 'Melon', 'Cantaloupe', 'Honeydew', 'Watermelon',
      'Pineapple', 'Kiwi', 'Raspberries', 'Blackberries', 'Cranberries', 'Cherries (pitted)',
      'Peaches (pitted)', 'Plums (pitted)', 'Apricots (pitted)', 'Grapes (seedless)',
      'Raisins (unsweetened)', 'Dates (pitted)', 'Prunes', 'Goji Berries', 'Mulberries'
    ]
  },
  'pocket-pets': {
    hay: [
      'Timothy Hay', 'Meadow Hay', 'Orchard Grass Hay', 'Alfalfa Hay (babies/pregnant only)',
      'Bermuda Hay', 'Bluegrass Hay', 'Fescue Hay', 'Ryegrass Hay', 'Wheat Hay',
      'Oat Hay', 'Barley Hay', 'Straw (wheat/pine)', 'Dried Grass'
    ],
    vegetables: [
      'lettuce (romaine)', 'Bell Peppers (high vitamin C)', 'carrots', 'cucumber', 'zucchini',
      'celery', 'parsley', 'Cilantro', 'kale', 'spinach', 'broccoli',
      'arugula', 'Endive', 'Basil', 'Mint', 'Collard Greens', 'Turnip Greens',
      'Dandelion Greens', 'Swiss Chard', 'bok choy', 'Napa Cabbage', 'Red Cabbage',
      'Green Cabbage', 'Cauliflower', 'asparagus', 'Fennel', 'Leeks', 'Shallots',
      'Garlic Chives', 'Radicchio', 'Frisee', 'Mache', 'Watercress', 'Purslane',
      'Miner\'s Lettuce', 'Lamb\'s Quarters', 'Amaranth Leaves', 'Malabar Spinach',
      'New Zealand Spinach', 'sweet potato', 'pumpkin', 'Squash (cooked)'
    ],
    pellets: [
      'Guinea Pig Pellets (with vitamin C)', 'Rabbit Pellets (high fiber)', 'Hamster Pellets (higher protein)',
      'Gerbil Pellets', 'Mouse/Rat Pellets', 'Chinchilla Pellets', 'Degus Pellets',
      'Fortified Pellets (vitamin C)', 'Timothy-Based Pellets', 'Alfalfa-Based Pellets'
    ],
    fruits: [
      'Apples (no seeds)', 'Strawberries', 'blueberries', 'bananas', 'Melon', 'Grapes', 'Papaya',
      'Pears (no seeds)', 'Peaches (pitted)', 'Plums (pitted)', 'Apricots (pitted)', 'Cherries (pitted)',
      'Raspberries', 'Blackberries', 'Cranberries', 'Kiwi', 'Pineapple (small amounts)',
      'Mango (small amounts)', 'Papaya (small amounts)', 'Figs', 'Dates (pitted)', 'Raisins (unsweetened)',
      'Goji Berries', 'Mulberries', 'Currants', 'Elderberries'
    ],
    hamster_additions: [
      'Mealworms (freeze-dried)', 'eggs', 'Whole Grain Cheerios',
      'Sunflower Seeds (unsalted)', 'Pumpkin Seeds (unsalted)', 'Flaxseeds', 'Chia Seeds',
      'Hemp Seeds', 'Sesame Seeds', 'Popcorn (plain)', 'Whole Wheat Pasta (cooked)',
      'brown rice', 'quinoa', 'Amaranth (cooked)', 'Buckwheat (cooked)',
      'Millet (cooked)', 'Barley (cooked)', 'oats', 'Corn (cooked)', 'Peas (cooked)'
    ],
    sugar_glider_special: [
      'Nectar Mix (commercial)', 'Gum Arabic', 'Eucalyptus Leaves', 'Acacia Gum', 
      'Bee Pollen', 'Manuka Honey', 'calcium carbonate'
    ]
  }
};

/**
 * Get all ingredients for a specific species
 * Now includes generated ingredients from scraped data
 */
export function getIngredientsForSpecies(species: string): string[] {
  const speciesData = ALL_INGREDIENTS[species as keyof AllIngredients];
  const all: string[] = [];
  
  // Add from manual ALL_INGREDIENTS
  if (speciesData) {
    Object.values(speciesData).forEach(category => {
      if (Array.isArray(category)) {
        all.push(...category);
      }
    });
  }
  
  // Add from generated ingredients based on subtype tags
  const normalizedSpecies = species === 'dog' ? 'dog' : 
                           species === 'cat' ? 'cat' :
                           species === 'bird' || species === 'birds' ? 'bird' :
                           species === 'reptile' || species === 'reptiles' ? 'reptile' :
                           species === 'pocket-pet' || species === 'pocket-pets' ? 'pocket-pet' : species;
  
  // Map species to potential subtypes
  const possibleSubtypes: string[] = [];
  if (normalizedSpecies === 'bird') {
    possibleSubtypes.push('bird_small', 'bird_large');
  } else if (normalizedSpecies === 'reptile') {
    possibleSubtypes.push('reptile_herbivore', 'reptile_insectivore', 'reptile_omnivore', 'reptile_carnivore');
  } else if (normalizedSpecies === 'pocket-pet') {
    possibleSubtypes.push('pocket_hay', 'pocket_varied', 'pocket_carnivore', 'pocket_insectivore');
    // For pocket pets (herbivores/omnivores like hamsters, guinea pigs, rabbits),
    // avoid auto-adding generated ingredients that may include meats (e.g., rabbit).
    // Return only the curated list above.
    return [...new Set(all)];
  }
  
  // Add generated ingredients that match any of the possible subtypes
  GENERATED_INGREDIENTS.forEach(ing => {
    if (possibleSubtypes.length === 0 || possibleSubtypes.some(subtype => ing.subtypeTags.includes(subtype))) {
      all.push(ing.name);
    }
  });
  
  return [...new Set(all)]; // Remove duplicates
}

/**
 * Map ingredient name to ingredient composition key
 */
export function mapIngredientToCompositionKey(ingredientName: string): string | null {
  const normalized = ingredientName
    .toLowerCase()
    .trim()
    .replace(/\s*\([^)]*\)/g, '') // Remove parentheses
    .replace(/\s+/g, '_')
    .replace(/[^a-z0-9_]/g, '');
  
  // Import composition keys dynamically
  const { INGREDIENT_COMPOSITIONS } = require('@/lib/data/ingredientCompositions');
  
  // Direct lookup
  if (INGREDIENT_COMPOSITIONS[normalized]) {
    return normalized;
  }
  
  // Common mappings (only for variants/aliases, not fallbacks)
  const mappings: Record<string, string> = {
    'chicken_breast': 'chicken_breast',
    'chicken_liver': 'chicken_liver',
    'chicken_hearts': 'chicken_hearts',
    'beef_liver': 'beef_liver',
    'ground_beef': 'ground_beef_lean',
    'ground_turkey': 'ground_turkey',
    'ground_chicken': 'ground_chicken', // Now has its own entry
    'turkey_breast': 'turkey_breast',
    'salmon': 'salmon_atlantic',
    'tuna': 'tuna_water',
    'sardines': 'sardines_water',
    'white_rice': 'white_rice_cooked', // Now has its own entry
    'brown_rice': 'brown_rice_cooked',
    'quinoa': 'quinoa_cooked',
    'sweet_potato': 'sweet_potato',
    'pumpkin': 'pumpkin', // Now has its own entry
    'carrots': 'carrots_raw',
    'green_beans': 'green_beans_raw', // Now has its own entry
    'bok_choy': 'bok_choy', // Key uses standard spelling, but display is "Bok Choi"
    'bok_choi': 'bok_choy', // User prefers "bok choi" spelling
    'broccoli': 'broccoli_raw',
    'spinach': 'spinach_raw',
    'kale': 'kale_raw',
    'celery': 'celery_raw',
    'blueberries': 'blueberries_raw',
    'bananas': 'bananas_raw',
    'eggs': 'eggs_whole',
    'fish_oil': 'fish_oil',
    'salmon_oil': 'fish_oil', // Similar enough to use fish_oil
    'herring_oil': 'fish_oil', // Similar enough to use fish_oil
    'mackerel_oil': 'fish_oil', // Similar enough to use fish_oil
    'sardine_oil': 'fish_oil', // Similar enough to use fish_oil
    'cod_liver_oil': 'fish_oil', // Similar enough to use fish_oil
    'olive_oil': 'fish_oil', // Different but acceptable fallback
    'coconut_oil': 'fish_oil', // Different but acceptable fallback
    'avocado_oil': 'fish_oil', // Different but acceptable fallback
    'sunflower_oil': 'fish_oil', // Different but acceptable fallback
    'sesame_oil': 'fish_oil', // Different but acceptable fallback
    'oats': 'oats',
    'taurine': 'taurine_powder',
    'calcium': 'calcium_carbonate',
  };
  
  if (mappings[normalized]) {
    return mappings[normalized];
  }
  
  // Try partial matches
  for (const key in INGREDIENT_COMPOSITIONS) {
    if (normalized.includes(key) || key.includes(normalized)) {
      return key;
    }
  }
  
  return null;
}

/**
 * Get all available ingredients for recipe builder (all species combined)
 */
export function getAllAvailableIngredients(): string[] {
  const all = new Set<string>();
  
  Object.keys(ALL_INGREDIENTS).forEach(species => {
    getIngredientsForSpecies(species).forEach(ing => all.add(ing));
  });
  
  return Array.from(all).sort();
}

/**
 * Get display name for an ingredient composition key
 * Maps back to the original scraped ingredient name if available
 */
export function getIngredientDisplayName(compositionKey: string, species?: string): string {
  // If we have a species, try to find the original name from scraped data
  if (species) {
    const speciesData = ALL_INGREDIENTS[species as keyof AllIngredients];
    if (speciesData) {
      // Search through all categories for this species
      for (const category of Object.values(speciesData)) {
        if (Array.isArray(category)) {
          for (const ingName of category) {
            const mappedKey = mapIngredientToCompositionKey(ingName);
            if (mappedKey === compositionKey) {
              return ingName; // Return the original scraped name
            }
          }
        }
      }
    }
  }
  
  // Fallback: convert composition key to readable name
  return compositionKey
    .split('_')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}
</file>

<file path="lib/utils/auth.ts">
// lib/utils/auth.ts
// Centralized authentication utilities

import { useAuth, useUser } from '@clerk/nextjs';

/**
 * Get the current user ID from Clerk
 * Falls back to simulated ID for development
 */
export function useCurrentUserId(): string | null {
  const { userId } = useAuth();
  
  // Use Clerk user ID if available
  if (userId) return userId;
  
  // Fallback for development (when not authenticated)
  if (typeof window !== 'undefined') {
    const stored = localStorage.getItem('last_user_id');
    if (stored) return stored;
  }
  
  return null;
}

/**
 * Server-side: Get user ID from localStorage fallback
 * This is a temporary bridge during migration
 */
export function getStoredUserId(): string {
  if (typeof window === 'undefined') return 'server-fallback-id';
  
  const stored = localStorage.getItem('last_user_id');
  return stored || 'clerk_simulated_user_id_123';
}

/**
 * Check if user is authenticated
 */
export function useIsAuthenticated(): boolean {
  const { isSignedIn, isLoaded } = useAuth();
  return isLoaded && (isSignedIn ?? false);
}
</file>

<file path="lib/utils/badgeChecker.ts">
// lib/utils/badgeChecker.ts
// Badge checking logic for pet achievements

import { BadgeType, BadgeTier, BadgeCheckContext } from '@/lib/types/badges';
import { getPetBadges, unlockBadge, updateBadgeProgress, hasBadge } from './badgeStorage';
import { getTierForProgress, getNextTierThreshold } from '@/lib/data/badgeDefinitions';
import { getPetPurchaseCount } from './petPurchaseTracking';
import { getPets } from './petStorage';
import { logger } from './logger';

/**
 * Check The Nutrient Navigator badge (100% compatibility score)
 */
export async function checkNutrientNavigatorBadge(
  userId: string,
  petId: string,
  compatibilityScore: number
): Promise<boolean> {
  if (compatibilityScore !== 100) {
    return false;
  }

  const badges = getPetBadges(userId, petId);
  if (hasBadge(badges, BadgeType.NUTRIENT_NAVIGATOR)) {
    return false; // Already unlocked
  }

  return unlockBadge(userId, petId, BadgeType.NUTRIENT_NAVIGATOR);
}

/**
 * Check The Master Meal Planner badge (requires ALL THREE conditions)
 */
export async function checkMasterMealPlannerBadge(
  userId: string,
  petId: string,
  mealPlanCount: number,
  savedRecipesCount: number,
  weeklyPlanCompleted: boolean
): Promise<boolean> {
  // Check if ALL THREE conditions are met
  const has4PlusMeals = mealPlanCount >= 4;
  const has10PlusSaved = savedRecipesCount >= 10;
  const hasCompletedWeek = weeklyPlanCompleted;

  if (!has4PlusMeals || !has10PlusSaved || !hasCompletedWeek) {
    return false; // Not all conditions met
  }

  const badges = getPetBadges(userId, petId);
  if (hasBadge(badges, BadgeType.MASTER_MEAL_PLANNER)) {
    return false; // Already unlocked
  }

  return unlockBadge(userId, petId, BadgeType.MASTER_MEAL_PLANNER);
}

/**
 * Check Planning Volume badge (progressive: 1, 10, 50)
 */
export async function checkPlanningVolumeBadge(
  userId: string,
  petId: string,
  completionCount: number
): Promise<boolean> {
  if (completionCount < 1) {
    return false;
  }

  const tier = getTierForProgress(BadgeType.PLANNING_VOLUME, completionCount);
  if (!tier) {
    return false;
  }

  const nextThreshold = getNextTierThreshold(BadgeType.PLANNING_VOLUME, tier);
  
  updateBadgeProgress(
    userId,
    petId,
    BadgeType.PLANNING_VOLUME,
    completionCount,
    tier
  );

  // Also unlock if this is a new tier
  const badges = getPetBadges(userId, petId);
  const existingBadge = badges.badges.find(b => b.type === BadgeType.PLANNING_VOLUME);
  
  if (!existingBadge || existingBadge.tier !== tier) {
    // New tier unlocked
    unlockBadge(userId, petId, BadgeType.PLANNING_VOLUME, tier);
    return true;
  }

  // Update progress
  if (existingBadge) {
    existingBadge.progress = completionCount;
    existingBadge.nextTierThreshold = nextThreshold || undefined;
  }

  return false; // No new unlock, just progress update
}

/**
 * Check Purchase Commitment badge (progressive: 1, 10, 20, 30, 40, 50+)
 */
export async function checkPurchaseCommitmentBadge(
  userId: string,
  petId: string,
  purchaseCount: number
): Promise<boolean> {
  if (purchaseCount < 1) {
    return false;
  }

  const tier = getTierForProgress(BadgeType.PURCHASE_COMMITMENT, purchaseCount);
  if (!tier) {
    return false;
  }

  const nextThreshold = getNextTierThreshold(BadgeType.PURCHASE_COMMITMENT, tier);
  
  updateBadgeProgress(
    userId,
    petId,
    BadgeType.PURCHASE_COMMITMENT,
    purchaseCount,
    tier
  );

  // Also unlock if this is a new tier
  const badges = getPetBadges(userId, petId);
  const existingBadge = badges.badges.find(b => b.type === BadgeType.PURCHASE_COMMITMENT);
  
  if (!existingBadge || existingBadge.tier !== tier) {
    // New tier unlocked
    unlockBadge(userId, petId, BadgeType.PURCHASE_COMMITMENT, tier);
    return true;
  }

  // Update progress
  if (existingBadge) {
    existingBadge.progress = purchaseCount;
    existingBadge.nextTierThreshold = nextThreshold || undefined;
  }

  return false; // No new unlock, just progress update
}

/**
 * Main function to check all relevant badges based on action context
 */
export async function checkAllBadges(
  userId: string,
  petId: string,
  context: BadgeCheckContext
): Promise<{ unlocked: BadgeType[]; updated: BadgeType[] }> {
  const unlocked: BadgeType[] = [];
  const updated: BadgeType[] = [];

  try {
    // Load pet data for context
    const pets = await getPets(userId);
    const pet = pets.find(p => p.id === petId);
    
    if (!pet) {
      logger.warn('Pet not found for badge checking', { userId, petId });
      return { unlocked, updated };
    }

    // Check Nutrient Navigator (100% compatibility)
    if (context.compatibilityScore === 100) {
      const wasUnlocked = await checkNutrientNavigatorBadge(
        userId,
        petId,
        context.compatibilityScore
      );
      if (wasUnlocked) {
        unlocked.push(BadgeType.NUTRIENT_NAVIGATOR);
      }
    }

    // Check Master Meal Planner (requires all conditions)
    if (context.action === 'meal_plan_created' || 
        context.action === 'recipe_saved' || 
        context.action === 'recipe_removed' ||
        context.action === 'meal_plan_completed') {
      
      const mealPlanCount = context.mealPlanCount ?? 0;
      const savedRecipesCount = context.savedRecipesCount ?? (pet.savedRecipes?.length || 0);
      const weeklyPlanCompleted = context.weeklyPlanCompleted ?? false;

      const wasUnlocked = await checkMasterMealPlannerBadge(
        userId,
        petId,
        mealPlanCount,
        savedRecipesCount,
        weeklyPlanCompleted
      );
      if (wasUnlocked) {
        unlocked.push(BadgeType.MASTER_MEAL_PLANNER);
      }
    }

    // Check Planning Volume (progressive)
    if (context.action === 'meal_plan_completed' && context.completionCount !== undefined) {
      const wasUnlocked = await checkPlanningVolumeBadge(
        userId,
        petId,
        context.completionCount
      );
      if (wasUnlocked) {
        unlocked.push(BadgeType.PLANNING_VOLUME);
      } else {
        updated.push(BadgeType.PLANNING_VOLUME);
      }
    }

    // Check Purchase Commitment (progressive)
    if (context.action === 'purchase_confirmed') {
      const purchaseCount = context.purchaseCount ?? getPetPurchaseCount(userId, petId);
      
      const wasUnlocked = await checkPurchaseCommitmentBadge(
        userId,
        petId,
        purchaseCount
      );
      if (wasUnlocked) {
        unlocked.push(BadgeType.PURCHASE_COMMITMENT);
      } else {
        updated.push(BadgeType.PURCHASE_COMMITMENT);
      }
    }

  } catch (error) {
    logger.error('Error checking badges', error as Error, { userId, petId, context });
  }

  return { unlocked, updated };
}
</file>

<file path="lib/utils/badgeStorage.ts">
// lib/utils/badgeStorage.ts
// Badge storage system for pet achievements

import { PetBadges, PetBadge, BadgeType, BadgeTier } from '@/lib/types/badges';
import { safeGetItem, safeSetItem, safeParseJSON } from './localStorageSafe';
import { logger } from './logger';

const PREFIX = 'pet_badges_';

/**
 * Get storage key for pet badges
 */
function getStorageKey(userId: string, petId: string): string {
  return `${PREFIX}${userId}_${petId}`;
}

/**
 * Load badges for a pet
 */
export function getPetBadges(userId: string, petId: string): PetBadges {
  if (!userId || !petId) {
    return { badges: [] };
  }

  try {
    const key = getStorageKey(userId, petId);
    const stored = safeGetItem(key);
    
    if (!stored) {
      return { badges: [] };
    }

    const parsed = safeParseJSON<PetBadges>(stored, { badges: [] });
    if (parsed && Array.isArray(parsed.badges)) {
      return parsed;
    }

    return { badges: [] };
  } catch (error) {
    logger.error('Failed to load pet badges', error as Error, { userId, petId } as any);
    return { badges: [] };
  }
}

/**
 * Save badges for a pet
 */
export function savePetBadges(userId: string, petId: string, badges: PetBadges): void {
  if (!userId || !petId) {
    logger.warn('Cannot save badges: missing userId or petId', { userId, petId });
    return;
  }

  try {
    const key = getStorageKey(userId, petId);
    badges.lastChecked = new Date().toISOString();
    safeSetItem(key, JSON.stringify(badges));
  } catch (error) {
    logger.error('Failed to save pet badges', error as Error, { userId, petId });
  }
}

/**
 * Check if a badge is unlocked
 */
export function hasBadge(badges: PetBadges, badgeType: BadgeType, tier?: BadgeTier): boolean {
  if (!badges || !badges.badges) {
    return false;
  }

  const badge = badges.badges.find(b => b.type === badgeType);
  
  if (!badge) {
    return false;
  }

  // For progressive badges, check if tier matches or is higher
  if (tier && badge.tier) {
    const tierOrder: BadgeTier[] = ['bronze', 'silver', 'gold', 'platinum', 'diamond', 'sultan'];
    const badgeTierIndex = tierOrder.indexOf(badge.tier);
    const requiredTierIndex = tierOrder.indexOf(tier);
    return badgeTierIndex >= requiredTierIndex;
  }

  return true;
}

/**
 * Unlock a badge (idempotent - safe to call multiple times)
 */
export function unlockBadge(
  userId: string,
  petId: string,
  badgeType: BadgeType,
  tier?: BadgeTier
): boolean {
  const badges = getPetBadges(userId, petId);
  
  // Check if already unlocked
  if (hasBadge(badges, badgeType, tier)) {
    return false; // Already unlocked
  }

  // Check if badge exists but needs tier upgrade
  const existingBadge = badges.badges.find(b => b.type === badgeType);
  
  if (existingBadge && tier) {
    // Upgrade tier if new tier is higher
    const tierOrder: BadgeTier[] = ['bronze', 'silver', 'gold', 'platinum', 'diamond', 'sultan'];
    const currentTierIndex = tierOrder.indexOf(existingBadge.tier || 'bronze');
    const newTierIndex = tierOrder.indexOf(tier);
    
    if (newTierIndex > currentTierIndex) {
      existingBadge.tier = tier;
      existingBadge.unlockedAt = new Date().toISOString();
      savePetBadges(userId, petId, badges);
      return true; // Tier upgraded
    }
    
    return false; // Already at this tier or higher
  }

  // Create new badge
  const newBadge: PetBadge = {
    type: badgeType,
    tier,
    unlockedAt: new Date().toISOString(),
  };

  badges.badges.push(newBadge);
  savePetBadges(userId, petId, badges);
  return true; // New badge unlocked
}

/**
 * Update progressive badge progress
 */
export function updateBadgeProgress(
  userId: string,
  petId: string,
  badgeType: BadgeType,
  progress: number,
  tier?: BadgeTier
): boolean {
  const badges = getPetBadges(userId, petId);
  const existingBadge = badges.badges.find(b => b.type === badgeType);

  if (existingBadge) {
    // Update existing badge
    existingBadge.progress = progress;
    if (tier) {
      existingBadge.tier = tier;
    }
    existingBadge.unlockedAt = existingBadge.unlockedAt || new Date().toISOString();
    savePetBadges(userId, petId, badges);
    return true;
  } else {
    // Create new badge with progress
    const newBadge: PetBadge = {
      type: badgeType,
      tier,
      progress,
      unlockedAt: new Date().toISOString(),
    };
    badges.badges.push(newBadge);
    savePetBadges(userId, petId, badges);
    return true;
  }
}

/**
 * Get badge by type
 */
export function getBadge(badges: PetBadges, badgeType: BadgeType): PetBadge | null {
  if (!badges || !badges.badges) {
    return null;
  }
  return badges.badges.find(b => b.type === badgeType) || null;
}

/**
 * Remove a badge (for testing/demo purposes)
 */
export function removeBadge(userId: string, petId: string, badgeType: BadgeType): boolean {
  const badges = getPetBadges(userId, petId);
  const index = badges.badges.findIndex(b => b.type === badgeType);
  
  if (index === -1) {
    return false; // Badge not found
  }
  
  badges.badges.splice(index, 1);
  savePetBadges(userId, petId, badges);
  return true; // Badge removed
}
</file>

<file path="lib/utils/beep.ts">
/**
 * Beep utility for task completion notifications
 * Quiet, automatic beeps that don't require user permission
 */

/**
 * Play a quiet beep sound
 * Uses Web Audio API for a softer, less intrusive beep
 */
export function beep(frequency: number = 400, duration: number = 100, volume: number = 0.1): void {
  if (typeof window === 'undefined') return;
  
  try {
    const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    // Set quiet volume (0.1 = 10% volume)
    gainNode.gain.value = volume;
    oscillator.frequency.value = frequency;
    oscillator.type = 'sine'; // Softer sine wave instead of harsh square wave
    
    oscillator.start();
    oscillator.stop(audioContext.currentTime + duration / 1000);
  } catch (error) {
    // Fallback: silent if Web Audio API not available
    // Don't use console.beep as it's too loud and requires permission
  }
}

/**
 * Quiet beep for task completion
 */
export function taskCompleteBeep(): void {
  beep(400, 100, 0.08); // Very quiet completion beep
}

/**
 * Beep when user action is needed (approval/run)
 */
export function actionNeededBeep(): void {
  beep(500, 150, 0.12); // Slightly louder for important notifications
}
</file>

<file path="lib/utils/buyLinkValidation.ts">
// Intent-based buy link validation
// Validates Amazon links point to correct product TYPE, not exact title match

export type BuyLinkIntent =
  | 'produce'        // Fresh fruits/vegetables
  | 'pantry'         // Rice, oats, canned goods, grains
  | 'oil'            // Cooking oils, fish oils, supplements
  | 'supplement'     // Vitamins, minerals, health supplements
  | 'pet-feed'       // Hay, pellets, pet-specific foods
  | 'insect'         // Live/dried insects for reptiles/birds
  | 'meat'           // Fresh/frozen meat, organs
  | 'other';         // Catch-all

export interface IngredientRetailValidation {
  intent: BuyLinkIntent;
  required?: string[];   // Tokens that MUST appear in title (case-insensitive)
  forbidden?: string[];  // Tokens that must NOT appear (indicates wrong product)
  optional?: string[];   // Bonus tokens (not enforced, but good to have)
}

export type ValidationResult = 'PASS' | 'WARN' | 'FAIL';

export interface ValidationReport {
  result: ValidationResult;
  reason?: string;
  matchedRequired?: string[];
  foundForbidden?: string[];
  suggestions?: string[];
}

/**
 * Validates an Amazon product title against ingredient expectations.
 * Uses intent + token matching instead of string similarity.
 */
export function validateProductTitle(
  productTitle: string,
  validation: IngredientRetailValidation
): ValidationReport {
  const normalizedTitle = productTitle.toLowerCase();
  const tokens = normalizedTitle.split(/\s+/);
  
  // Check forbidden tokens (immediate fail)
  if (validation.forbidden) {
    const foundForbidden = validation.forbidden.filter(token => 
      normalizedTitle.includes(token.toLowerCase())
    );
    
    if (foundForbidden.length > 0) {
      return {
        result: 'FAIL',
        reason: `Contains forbidden tokens: ${foundForbidden.join(', ')}`,
        foundForbidden,
        suggestions: ['Find product without these terms', 'Check if this is cosmetic/non-food grade'],
      };
    }
  }
  
  // Check required tokens
  if (validation.required && validation.required.length > 0) {
    const matchedRequired = validation.required.filter(token =>
      normalizedTitle.includes(token.toLowerCase())
    );
    
    if (matchedRequired.length === 0) {
      return {
        result: 'FAIL',
        reason: `Missing all required tokens: ${validation.required.join(', ')}`,
        suggestions: ['Verify ASIN points to correct product type', 'Search for product with required terms'],
      };
    }
    
    if (matchedRequired.length < validation.required.length) {
      return {
        result: 'WARN',
        reason: `Missing some required tokens: ${validation.required.filter(t => !matchedRequired.includes(t)).join(', ')}`,
        matchedRequired,
        suggestions: ['Review if partial match is acceptable'],
      };
    }
    
    return {
      result: 'PASS',
      matchedRequired,
    };
  }
  
  // No required tokens - just check intent is reasonable
  return {
    result: 'PASS',
    reason: 'No specific validation rules, assuming correct',
  };
}

/**
 * Infers validation rules from ingredient name and category.
 * This provides sensible defaults when explicit rules aren't defined.
 */
export function inferValidationRules(
  ingredientName: string,
  category: string
): IngredientRetailValidation {
  const name = ingredientName.toLowerCase();
  
  // Oils - require "oil" and forbid cosmetic terms
  if (category === 'Oil' || name.includes('oil')) {
    const oilType = name.replace(/\s*oil.*/, '').trim();
    return {
      intent: 'oil',
      required: ['oil'],
      forbidden: ['massage', 'hair', 'skin', 'cosmetic', 'beauty', 'lotion', 'aromatherapy'],
      optional: [oilType, 'food', 'grade', 'culinary'],
    };
  }
  
  // Supplements - require supplement-related terms
  if (category === 'Supplement' || name.includes('supplement') || name.includes('vitamin')) {
    return {
      intent: 'supplement',
      forbidden: ['dog', 'cat', 'pet', 'chew', 'treat'], // Avoid pet-specific supplements
    };
  }
  
  // Meat - require meat type, forbid treats/jerky
  if (category === 'Meat') {
    return {
      intent: 'meat',
      forbidden: ['treat', 'jerky', 'chew', 'toy', 'dog', 'cat'],
      optional: ['fresh', 'frozen', 'raw'],
    };
  }
  
  // Insects - require insect type
  if (category === 'Insect') {
    return {
      intent: 'insect',
      forbidden: ['food', 'mix', 'blend'], // Avoid mixes, want pure insects
    };
  }
  
  // Hay/Pellets - pet-specific is OK
  if (category === 'Hay' || category === 'Pellet') {
    return {
      intent: 'pet-feed',
    };
  }
  
  // Vegetables/Fruits - produce
  if (category === 'Vegetable' || category === 'Fruit') {
    return {
      intent: 'produce',
      forbidden: ['juice', 'powder', 'extract'], // Want whole produce
    };
  }
  
  // Grains/Carbs - pantry items
  if (category === 'Carb' || category === 'Grain') {
    return {
      intent: 'pantry',
      forbidden: ['flour', 'bread', 'cereal'], // Want whole grains
    };
  }
  
  // Seeds
  if (category === 'Seed') {
    return {
      intent: 'pantry',
      forbidden: ['mix', 'blend', 'food'], // Want pure seeds
    };
  }
  
  return {
    intent: 'other',
  };
}

/**
 * Generates a suggested Amazon search query for manual ASIN lookup.
 */
export function generateSearchQuery(
  ingredientName: string,
  validation: IngredientRetailValidation
): string {
  const terms = [ingredientName];
  
  // Add intent-specific qualifiers
  if (validation.intent === 'oil') {
    terms.push('food grade', 'culinary');
  } else if (validation.intent === 'supplement') {
    terms.push('dietary supplement');
  } else if (validation.intent === 'meat') {
    terms.push('fresh', 'raw');
  } else if (validation.intent === 'produce') {
    terms.push('organic', 'fresh');
  }
  
  // Add required tokens if specified
  if (validation.required) {
    terms.push(...validation.required);
  }
  
  return terms.join(' ');
}

/**
 * Creates an Amazon search URL with affiliate tag.
 */
export function generateSearchUrl(searchQuery: string): string {
  const encoded = encodeURIComponent(searchQuery);
  return `https://www.amazon.com/s?k=${encoded}&tag=robinfrench-20`;
}
</file>

<file path="lib/utils/convertCustomMealToRecipe.ts">
import type { CustomMeal, Recipe } from '@/lib/types';

/**
 * Converts a CustomMeal to Recipe format for display in recipe detail pages
 */
export function convertCustomMealToRecipe(customMeal: CustomMeal): Recipe {
  return {
    id: customMeal.id,
    name: customMeal.name,
    category: 'custom' as any,
    ageGroup: ['adult'],
    healthConcerns: [],
    description: `Custom meal created on ${customMeal.createdAt ? new Date(customMeal.createdAt).toLocaleDateString() : 'unknown date'}`,
    ingredients: customMeal.ingredients.map((ing, idx) => ({
      id: `${idx + 1}`,
      name: ing.key.replace(/_/g, ' '),
      amount: `${ing.grams}g`,
    })),
    instructions: [
      'Mix all ingredients according to saved recipe',
      'Serve at recommended portion size',
      `Recommended serving: ${customMeal.analysis.recommendedServingGrams}g`,
    ],
    nutritionalInfo: {
      protein: {
        min: (customMeal.analysis.nutrients.protein_g || 0) / (customMeal.analysis.totalRecipeGrams / 100),
        max: (customMeal.analysis.nutrients.protein_g || 0) / (customMeal.analysis.totalRecipeGrams / 100),
        unit: '%',
      },
      fat: {
        min: (customMeal.analysis.nutrients.fat_g || 0) / (customMeal.analysis.totalRecipeGrams / 100),
        max: (customMeal.analysis.nutrients.fat_g || 0) / (customMeal.analysis.totalRecipeGrams / 100),
        unit: '%',
      },
      calories: {
        min: customMeal.analysis.nutrients.kcal || customMeal.analysis.nutrients.calories_kcal || 0,
        max: customMeal.analysis.nutrients.kcal || customMeal.analysis.nutrients.calories_kcal || 0,
        unit: 'kcal',
      },
    },
    rating: 0,
    reviews: 0,
    tags: ['custom', 'user-created'],
  };
}
</file>

<file path="lib/utils/customMealStorage.ts">
// lib/utils/customMealStorage.ts
// Abstracted custom meal storage layer - Migrated to Firestore
// Note: All operations are now ASYNCHRONOUS

import { CustomMeal } from '@/lib/types';
import { MealAnalysis, IngredientSelection } from '@/lib/analyzeCustomMeal';
import * as firestoreService from '@/lib/services/firestoreService';
import { getPets, savePet } from './petStorage';
import { checkAllBadges } from './badgeChecker';

/**
 * Retrieves all custom meals for a given pet.
 * 
 * @param userId - User identifier
 * @param petId - Pet identifier
 * @returns Promise<CustomMeal[]>
 */
export async function getCustomMeals(userId: string, petId: string): Promise<CustomMeal[]> {
  if (!userId || !petId) return [];
  
  // TEMPORARY: Skip Firestore entirely if no Firebase config
  const hasFirebase = typeof process !== 'undefined' && process.env?.NEXT_PUBLIC_FIREBASE_API_KEY;
  if (!hasFirebase) {
    console.log('Firebase not configured - loading custom meals from localStorage only');
    if (typeof window !== 'undefined') {
      const stored = localStorage.getItem(`custom_meals_${userId}_${petId}`);
      try {
        return stored ? JSON.parse(stored) : [];
      } catch {
        return [];
      }
    }
    return [];
  }
  
  try {
    return await firestoreService.getCustomMeals(userId, petId);
  } catch (e) {
    console.warn('Firestore getCustomMeals failed', e);
    // Fallback to localStorage
    if (typeof window !== 'undefined') {
      const stored = localStorage.getItem(`custom_meals_${userId}_${petId}`);
      return stored ? JSON.parse(stored) : [];
    }
    return [];
  }
}

/**
 * Saves a custom meal to storage.
 * 
 * @param userId - User identifier
 * @param petId - Pet identifier
 * @param mealName - Name of the meal
 * @param ingredients - Array of ingredient selections
 * @param analysis - Meal analysis results
 * @returns Promise<CustomMeal>
 */
export async function saveCustomMeal(
  userId: string,
  petId: string,
  mealName: string,
  ingredients: IngredientSelection[],
  analysis: MealAnalysis
): Promise<CustomMeal> {
  const now = new Date().toISOString();
  
  const customMeal: CustomMeal = {
    id: `custom_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    petId,
    userId,
    name: mealName,
    createdAt: now,
    updatedAt: now,
    ingredients: ingredients.map(ing => ({
      key: ing.key,
      grams: ing.grams
    })),
    analysis: {
      score: analysis.score,
      nutrients: analysis.nutrients,
      totalRecipeGrams: analysis.totalRecipeGrams,
      recommendedServingGrams: analysis.recommendedServingGrams,
      breakdown: analysis.breakdown,
      toxicityWarnings: analysis.toxicityWarnings.map(w => ({
        message: w.message,
        severity: w.severity,
        ingredientKey: w.ingredientKey,
        ingredientName: w.ingredientName,
      })),
      allergyWarnings: analysis.allergyWarnings.map(w => ({
        message: typeof w === 'string' ? w : w.message,
        severity: typeof w === 'string' ? 'medium' : w.severity,
      })),
      nutrientWarnings: analysis.nutrientWarnings.map(w => ({
        message: w.message,
        severity: w.severity,
      })),
      suggestions: analysis.suggestions.map(s => ({
        message: typeof s === 'string' ? s : s.message,
        action: typeof s === 'string' ? undefined : s.action,
        confidence: typeof s === 'string' ? undefined : s.confidence,
      })),
    },
  };
  
  // TEMPORARY: Skip Firestore entirely if no Firebase config
  const hasFirebase = typeof process !== 'undefined' && process.env?.NEXT_PUBLIC_FIREBASE_API_KEY;
  if (!hasFirebase) {
    console.log('Firebase not configured - saving custom meal to localStorage only');
    
    // Save to localStorage
    if (typeof window !== 'undefined') {
      const stored = localStorage.getItem(`custom_meals_${userId}_${petId}`);
      const meals = stored ? JSON.parse(stored) : [];
      meals.push(customMeal);
      localStorage.setItem(`custom_meals_${userId}_${petId}`, JSON.stringify(meals));
    }
    
    // Also add the custom meal ID to the pet's savedRecipes array
    const pets = await getPets(userId);
    const pet = pets.find(p => p.id === petId);
    
    if (pet) {
      const savedRecipes = pet.savedRecipes || [];
      if (!savedRecipes.includes(customMeal.id)) {
        const updatedPet = {
          ...pet,
          savedRecipes: [...savedRecipes, customMeal.id],
        };
        await savePet(userId, updatedPet);
      }
    }
    
    // Dispatch custom event for same-tab updates
    if (typeof window !== 'undefined') {
      window.dispatchEvent(new CustomEvent('customMealsUpdated', { 
        detail: { userId, petId, mealId: customMeal.id } 
      }));
    }
    
    // Check badges (Nutrient Navigator if score is 100)
    // Note: analysis.score might be a different metric, we'll check compatibility score separately
    // For now, we'll check badges when the meal is viewed/scored elsewhere
    // This is a placeholder - actual compatibility scoring happens in MealCompleteView
    
    return customMeal;
  }
  
  // Save to Firestore
  await firestoreService.saveCustomMeal(userId, customMeal);
  
  // Also add the custom meal ID to the pet's savedRecipes array
  // We need to fetch the pet, update it, and save it back
  const pets = await getPets(userId);
  const pet = pets.find(p => p.id === petId);
  
  if (pet) {
    const savedRecipes = pet.savedRecipes || [];
    if (!savedRecipes.includes(customMeal.id)) {
      const updatedPet = {
        ...pet,
        savedRecipes: [...savedRecipes, customMeal.id],
      };
      await savePet(userId, updatedPet);
    }
  }
  
  // Backup to localStorage for safety
  if (typeof window !== 'undefined') {
    const stored = localStorage.getItem(`custom_meals_${userId}_${petId}`);
    const meals = stored ? JSON.parse(stored) : [];
    meals.push(customMeal);
    localStorage.setItem(`custom_meals_${userId}_${petId}`, JSON.stringify(meals));
    
    // Dispatch custom event for same-tab updates
    window.dispatchEvent(new CustomEvent('customMealsUpdated', { 
      detail: { userId, petId, mealId: customMeal.id } 
    }));
  }
  
  return customMeal;
}

/**
 * Deletes a custom meal from storage.
 * 
 * @param userId - User identifier
 * @param petId - Pet identifier
 * @param mealId - Meal ID to delete
 * @returns Promise<void>
 */
export async function deleteCustomMeal(userId: string, petId: string, mealId: string): Promise<void> {
  // TEMPORARY: Skip Firestore entirely if no Firebase config
  const hasFirebase = typeof process !== 'undefined' && process.env?.NEXT_PUBLIC_FIREBASE_API_KEY;
  if (!hasFirebase) {
    console.log('Firebase not configured - deleting custom meal from localStorage only');
    
    // Delete from localStorage
    if (typeof window !== 'undefined') {
      const stored = localStorage.getItem(`custom_meals_${userId}_${petId}`);
      if (stored) {
        try {
          const meals: any[] = JSON.parse(stored);
          const filtered = meals.filter(m => m.id !== mealId);
          localStorage.setItem(`custom_meals_${userId}_${petId}`, JSON.stringify(filtered));
        } catch (e) {
          console.error('Error deleting custom meal from localStorage:', e);
        }
      }
    }
    
    // Also remove from pet's savedRecipes
    const pets = await getPets(userId);
    const pet = pets.find(p => p.id === petId);
    
    if (pet) {
      const savedRecipes = pet.savedRecipes || [];
      const updatedPet = {
        ...pet,
        savedRecipes: savedRecipes.filter(id => id !== mealId),
      };
      await savePet(userId, updatedPet);
    }
    
    return;
  }
  
  await firestoreService.deleteCustomMeal(userId, mealId);
  
  // Also remove from pet's savedRecipes
  const pets = await getPets(userId);
  const pet = pets.find(p => p.id === petId);
  
  if (pet) {
    const savedRecipes = pet.savedRecipes || [];
    const updatedPet = {
      ...pet,
      savedRecipes: savedRecipes.filter(id => id !== mealId),
    };
    await savePet(userId, updatedPet);
  }
  
  // Sync localStorage
  if (typeof window !== 'undefined') {
    const stored = localStorage.getItem(`custom_meals_${userId}_${petId}`);
    if (stored) {
      const meals: any[] = JSON.parse(stored);
      const filtered = meals.filter(m => m.id !== mealId);
      localStorage.setItem(`custom_meals_${userId}_${petId}`, JSON.stringify(filtered));
    }
  }
}

/**
 * Gets a single custom meal by ID.
 * 
 * @param userId - User identifier
 * @param petId - Pet identifier
 * @param mealId - Meal ID to retrieve
 * @returns Promise<CustomMeal | null>
 */
export async function getCustomMeal(userId: string, petId: string, mealId: string): Promise<CustomMeal | null> {
  const meals = await getCustomMeals(userId, petId);
  return meals.find(m => m.id === mealId) || null;
}

/**
 * Updates a custom meal's name.
 * 
 * @param userId - User identifier
 * @param petId - Pet identifier
 * @param mealId - Meal ID to update
 * @param newName - New name for the meal
 * @returns Promise<void>
 */
export async function updateCustomMealName(
  userId: string,
  petId: string,
  mealId: string,
  newName: string
): Promise<void> {
  const meal = await getCustomMeal(userId, petId, mealId);
  if (meal) {
    meal.name = newName;
    meal.updatedAt = new Date().toISOString();
    await firestoreService.saveCustomMeal(userId, meal);
    
    // Sync localStorage
    if (typeof window !== 'undefined') {
      const stored = localStorage.getItem(`custom_meals_${userId}_${petId}`);
      if (stored) {
        const meals: any[] = JSON.parse(stored);
        const localMeal = meals.find(m => m.id === mealId);
        if (localMeal) {
          localMeal.name = newName;
          localMeal.updatedAt = meal.updatedAt;
          localStorage.setItem(`custom_meals_${userId}_${petId}`, JSON.stringify(meals));
        }
      }
    }
  }
}
</file>

<file path="lib/utils/customMealStorageFirebase.ts">
// lib/utils/customMealStorageFirebase.ts
// Firebase implementation of custom meal storage
// This replaces localStorage with Firestore while maintaining the same API

import type { CustomMeal } from '@/lib/types';
import type { MealAnalysis, IngredientSelection } from '@/lib/analyzeCustomMeal';
import { getFirebaseServices, getAppId } from './firebaseConfig';
import { 
  collection, 
  doc, 
  addDoc, 
  getDocs, 
  getDoc, 
  deleteDoc, 
  updateDoc,
  onSnapshot,
  query,
  where,
  type Firestore
} from 'firebase/firestore';

/**
 * Firebase implementation of getCustomMeals
 * Uses real-time listener (onSnapshot) for live updates
 */
export function getCustomMealsFirebase(
  userId: string, 
  petId: string,
  onUpdate?: (meals: CustomMeal[]) => void
): () => void {
  const services = getFirebaseServices();
  if (!services) {
    // Fallback to localStorage if Firebase not available
    const { getCustomMeals } = require('./customMealStorage');
    const meals = getCustomMeals(userId, petId);
    if (onUpdate) onUpdate(meals);
    return () => {}; // No-op unsubscribe
  }
  
  const { db } = services;
  const appId = getAppId();
  const recipesRef = collection(db, `artifacts/${appId}/users/${userId}/recipes`);
  
  // Query for recipes for this pet
  const q = query(recipesRef, where('petId', '==', petId));
  
  // Set up real-time listener
  const unsubscribe = onSnapshot(q, (snapshot) => {
    const meals: CustomMeal[] = [];
    snapshot.forEach((docSnap) => {
      const data = docSnap.data();
      meals.push({
        id: docSnap.id,
        ...data
      } as CustomMeal);
    });
    
    // Sort by most recent first
    meals.sort((a, b) => 
      new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
    );
    
    if (onUpdate) {
      onUpdate(meals);
    }
  }, (error) => {
    console.error('Error listening to custom meals:', error);
    // Fallback to localStorage on error
    const { getCustomMeals } = require('./customMealStorage');
    const meals = getCustomMeals(userId, petId);
    if (onUpdate) onUpdate(meals);
  });
  
  return unsubscribe;
}

/**
 * Firebase implementation of saveCustomMeal
 */
export async function saveCustomMealFirebase(
  userId: string,
  petId: string,
  mealName: string,
  ingredients: IngredientSelection[],
  analysis: MealAnalysis
): Promise<CustomMeal> {
  const services = getFirebaseServices();
  if (!services) {
    // Fallback to localStorage
    const { saveCustomMeal } = require('./customMealStorage');
    return saveCustomMeal(userId, petId, mealName, ingredients, analysis);
  }
  
  const { db } = services;
  const appId = getAppId();
  const recipesRef = collection(db, `artifacts/${appId}/users/${userId}/recipes`);
  
  const now = new Date().toISOString();
  
  const customMealData = {
    petId,
    userId,
    name: mealName,
    createdAt: now,
    updatedAt: now,
    ingredients: ingredients.map(ing => ({
      key: ing.key,
      grams: ing.grams
    })),
    analysis: {
      score: analysis.score,
      nutrients: analysis.nutrients,
      totalRecipeGrams: analysis.totalRecipeGrams,
      recommendedServingGrams: analysis.recommendedServingGrams,
      breakdown: {
        nutrientCoverageScore: analysis.breakdown.nutrientCoverageScore,
        toxicityPenalty: analysis.breakdown.toxicityPenalty,
        balanceVarietyScore: analysis.breakdown.balanceVarietyScore,
      },
      toxicityWarnings: analysis.toxicityWarnings.map(w => ({
        message: w.message,
        severity: w.severity,
        ingredientKey: w.ingredientKey,
        ingredientName: w.ingredientName,
      })),
      allergyWarnings: analysis.allergyWarnings.map(w => ({
        message: typeof w === 'string' ? w : w.message,
        severity: typeof w === 'string' ? 'medium' : w.severity,
      })),
      nutrientWarnings: analysis.nutrientWarnings.map(w => ({
        message: w.message,
        severity: w.severity,
      })),
      suggestions: analysis.suggestions.map(s => ({
        message: typeof s === 'string' ? s : s.message,
        action: typeof s === 'string' ? undefined : s.action,
        confidence: typeof s === 'string' ? undefined : s.confidence,
      })),
    },
  };
  
  try {
    const docRef = await addDoc(recipesRef, customMealData);
    return {
      id: docRef.id,
      ...customMealData
    } as CustomMeal;
  } catch (error) {
    console.error('Error saving custom meal to Firestore:', error);
    // Fallback to localStorage
    const { saveCustomMeal } = require('./customMealStorage');
    return saveCustomMeal(userId, petId, mealName, ingredients, analysis);
  }
}

/**
 * Firebase implementation of deleteCustomMeal
 */
export async function deleteCustomMealFirebase(
  userId: string,
  petId: string,
  mealId: string
): Promise<void> {
  const services = getFirebaseServices();
  if (!services) {
    // Fallback to localStorage
    const { deleteCustomMeal } = require('./customMealStorage');
    return deleteCustomMeal(userId, petId, mealId);
  }
  
  const { db } = services;
  const appId = getAppId();
  const mealRef = doc(db, `artifacts/${appId}/users/${userId}/recipes/${mealId}`);
  
  try {
    await deleteDoc(mealRef);
  } catch (error) {
    console.error('Error deleting custom meal from Firestore:', error);
    // Fallback to localStorage
    const { deleteCustomMeal } = require('./customMealStorage');
    return deleteCustomMeal(userId, petId, mealId);
  }
}

/**
 * Firebase implementation of getCustomMeal
 */
export async function getCustomMealFirebase(
  userId: string,
  petId: string,
  mealId: string
): Promise<CustomMeal | null> {
  const services = getFirebaseServices();
  if (!services) {
    // Fallback to localStorage
    const { getCustomMeal } = require('./customMealStorage');
    return getCustomMeal(userId, petId, mealId);
  }
  
  const { db } = services;
  const appId = getAppId();
  const mealRef = doc(db, `artifacts/${appId}/users/${userId}/recipes/${mealId}`);
  
  try {
    const docSnap = await getDoc(mealRef);
    if (docSnap.exists()) {
      return {
        id: docSnap.id,
        ...docSnap.data()
      } as CustomMeal;
    }
    return null;
  } catch (error) {
    console.error('Error getting custom meal from Firestore:', error);
    // Fallback to localStorage
    const { getCustomMeal } = require('./customMealStorage');
    return getCustomMeal(userId, petId, mealId);
  }
}
</file>

<file path="lib/utils/diversityTracker.ts">
import type { Ingredient } from '@/lib/types';

export interface MealHistoryEntry {
  petId: string;
  recipeId: string;
  recipeName: string;
  ingredients: string[];
  fedAt: Date;
}

const HISTORY_KEY = (petId: string) => `mealHistory_${petId}`;

function readHistory(petId: string): MealHistoryEntry[] {
  if (typeof window === 'undefined') return [];
  try {
    const raw = localStorage.getItem(HISTORY_KEY(petId));
    if (!raw) return [];
    const parsed = JSON.parse(raw) as MealHistoryEntry[];
    return parsed.map((e) => ({ ...e, fedAt: new Date(e.fedAt) }));
  } catch {
    return [];
  }
}

function writeHistory(petId: string, entries: MealHistoryEntry[]) {
  if (typeof window === 'undefined') return;
  localStorage.setItem(HISTORY_KEY(petId), JSON.stringify(entries));
}

// Log a meal fed to a pet
export function logMealFed(entry: MealHistoryEntry): void {
  if (typeof window === 'undefined') return;
  const existing = readHistory(entry.petId);
  const withDate = { ...entry, fedAt: new Date(entry.fedAt) };
  existing.unshift(withDate);
  // Cap history to avoid unbounded growth
  writeHistory(entry.petId, existing.slice(0, 200));
}

// Get meal history for a pet, optionally limited by days
export function getMealHistory(petId: string, days?: number): MealHistoryEntry[] {
  const history = readHistory(petId);
  if (!days) return history.sort((a, b) => b.fedAt.getTime() - a.fedAt.getTime());
  const cutoff = Date.now() - days * 24 * 60 * 60 * 1000;
  return history
    .filter((h) => h.fedAt.getTime() >= cutoff)
    .sort((a, b) => b.fedAt.getTime() - a.fedAt.getTime());
}

// Get unique ingredient names used in the past N days
export function getRecentIngredients(petId: string, days: number = 7): string[] {
  const recent = getMealHistory(petId, days);
  const set = new Set<string>();
  recent.forEach((m) => m.ingredients.forEach((ing) => set.add(ing.toLowerCase().trim())));
  return Array.from(set);
}

// Calculate overlap-based diversity penalty
export function calculateDiversityPenalty(
  recipeIngredients: string[],
  recentIngredients: string[]
): { overlap: number; penalty: number } {
  const normRecent = recentIngredients.map((r) => r.toLowerCase());
  const overlap = recipeIngredients.filter((ing) => normRecent.includes(ing.toLowerCase())).length;
  return { overlap, penalty: overlap * 5 };
}

// Normalize ingredient names from Recipe ingredient objects or strings
export function normalizeIngredientNames(ings: (string | Ingredient)[]): string[] {
  return ings.map((ing) => (typeof ing === 'string' ? ing : ing.name || ing.id)).map((n) => n.toLowerCase().trim());
}
</file>

<file path="lib/utils/emojiMapping.ts">
// lib/utils/emojiMapping.ts
// Smart emoji to image mapping based on actual grid content

/**
 * Based on NEW grid analysis (updated with latest uploads):
 * - amojis.png: 8x10 grid, 80 unique animal emojis (NEW - segmented as amojis_001.png through amojis_080.png)
 * - copilot_emojis: 10x11 grid, 110 emojis (more variety, includes symbols)
 * - emoji_grid: 7 grids, 64 each (some duplicates with amojis)
 * - best set: 4x4 grid, 16 ultra-minimalist icons (NEW - segmented with descriptive names)
 * 
 * Priority: best > amojis > copilot > emoji_grid
 * 
 * NEW Best set grid layout (4x4):
 * Row 1: Dog (best_dog.png), Cat (best_cat.png), Bird (best_bird.png), Lizard/Frog (best_reptile.png)
 * Row 2: Rabbit (best_rabbit.png), Hamster (best_hamster.png), Thumbs Up Left (best_thumbs_up_left.png), Thumbs Up Right (best_thumbs_up_right.png)
 * Row 3: Balance Scale (best_balance_scale.png), Warning (best_warning.png), Check Mark (best_check_mark.png), Trophy (best_trophy.png)
 * Row 4: Paw Prints (best_paw_prints.png), Star (best_star.png), Sparkle Single (best_sparkle_single.png), Sparkles Multiple (best_sparkles_multiple.png)
 */

// Primary pet emojis - using mascot images
export const PET_EMOJI_MAP: Record<string, string> = {
  // Main pet types - using mascot images
  'üêï': '/images/emojis/Mascots/Prep Puppy.jpg', // Dog - Prep Puppy mascot
  'üê∂': '/images/emojis/Mascots/Prep Puppy.jpg', // Dog (alternative) - Prep Puppy mascot
  'üêà': '/images/emojis/Mascots/ProfessorPurffesor.jpg', // Cat - Professor Purrfessor mascot
  'üê±': '/images/emojis/Mascots/ProfessorPurffesor.jpg', // Cat (alternative) - Professor Purrfessor mascot
  'ü¶ú': '/images/emojis/Mascots/RobinRed-Route.jpg', // Bird/Parrot - Robin Redroute mascot
  'üê¶': '/images/emojis/Mascots/RobinRed-Route.jpg', // Bird (alternative) - Robin Redroute mascot
  'ü¶é': '/images/emojis/Mascots/SherlockShells.jpg', // Lizard/Frog - Sherlock Shells mascot
  'üê¢': '/images/emojis/Mascots/SherlockShells.jpg', // Turtle (alternative) - Sherlock Shells mascot
  'üê∞': '/images/emojis/Mascots/harvesthamster.jpg', // Rabbit - Harvest Hamster mascot
  'üêá': '/images/emojis/Mascots/harvesthamster.jpg', // Rabbit (alternative) - Harvest Hamster mascot
  
  // Pocket pet variations - using mascot images
  'üêπ': '/images/emojis/Mascots/harvesthamster.jpg', // Hamster - Harvest Hamster mascot
  'üê≠': '/images/emojis/amojis_038.png', // Mouse (not in best set, using amojis fallback - Row 5, position 8)
  'ü¶î': '/images/emojis/Mascots/harvesthamster.jpg', // Hedgehog (use hamster) - Harvest Hamster mascot
  'ü¶¶': '/images/emojis/Mascots/harvesthamster.jpg', // Ferret/Otter (use hamster) - Harvest Hamster mascot
  
  // Additional animals - fallback to amojis for ones not in best set
  // Amojis grid (8x10, 80 icons) - various animals including:
  'üêª': '/images/emojis/amojis_011.png', // Bear (brown, standing on two legs) - Amojis grid Row 1, position 8
  'üêº': '/images/emojis/amojis_012.png', // Panda (black and white, facing left/right) - Amojis grid Row 1, position 9 or Row 2, positions 4-5
  'ü¶ä': '/images/emojis/amojis_014.png', // Fox (orange, pointed ears, bushy tail) - Amojis grid Row 1, position 9 or Row 2, position 6
  'üê®': '/images/emojis/amojis_017.png', // Koala (grey, with leaf) - Amojis grid Row 3, position 1
  'üê∏': '/images/emojis/Mascots/SherlockShells.jpg', // Frog (use reptile mascot) - Sherlock Shells mascot
  'üêü': '/images/emojis/amojis_026.png', // Fish (yellow, with fins) - Amojis grid Row 5, position 2
  'üê¥': '/images/emojis/amojis_049.png', // Horse (yellow/grey/brown/orange, standing on four legs) - Amojis grid Row 6, position 9 or Row 7, positions 1,5,7,8,9
  'ü¶â': '/images/emojis/amojis_007.png', // Owl (black/brown, large white eyes) - Amojis grid Row 1, position 2 or Row 8, position 6
  
  // Paw prints - using best set (Row 4 of best grid)
  'üêæ': '/images/emojis/best_paw_prints.png', // Paw Prints (three dark grey/black prints, diagonal arrangement) - Best grid Row 4, position 1
};

// Status/symbol emojis - using "best" set (ultra-minimalist, best quality)
// Best set grid positions: Row 2 (positions 3-4), Row 3 (positions 1-4), Row 4 (positions 2-4)
export const STATUS_EMOJI_MAP: Record<string, string> = {
  '‚≠ê': '/images/emojis/best_star.png', // Star (five-pointed yellow) - Best grid Row 4, position 2
  '‚ú®': '/images/emojis/best_sparkles_multiple.png', // Sparkles (multiple yellow four-pointed sparkles) - Best grid Row 4, position 4
  '‚úÖ': '/images/emojis/best_check_mark.png', // Check Mark (bold green) - Best grid Row 3, position 3
  '‚ùå': '/images/emojis/copilot_emojis_071.png', // X Mark (not in best set, use copilot)
  '‚ö†Ô∏è': '/images/emojis/best_warning.png', // Warning (yellow equilateral triangle with black exclamation mark) - Best grid Row 3, position 2
  'üëç': '/images/emojis/best_thumbs_up_right.png', // Thumbs Up (yellow hand gesture, pointing right) - Best grid Row 2, position 4
  'üëé': '/images/emojis/copilot_emojis_072.png', // Thumbs Down (not in best set, use copilot)
  '‚öñÔ∏è': '/images/emojis/Mascots/ProfessorPurffesor.jpg', // Balance Scale - Professor Purrfessor mascot (research, balance)
  'üèÜ': '/images/emojis/best_trophy.png', // Trophy (yellow cup with two handles) - Best grid Row 3, position 4
  // Additional celebration emojis used on site - using mascot images
  'üéâ': '/images/emojis/Mascots/Prep Puppy.jpg', // Party Popper - Prep Puppy mascot (celebration)
  'üéä': '/images/emojis/Mascots/Prep Puppy.jpg', // Confetti - Prep Puppy mascot (celebration)
  '‚ù§Ô∏è': '/images/emojis/Mascots/Prep Puppy.jpg', // Red Heart - Prep Puppy mascot (warmth, care)
  'üíö': '/images/emojis/Mascots/Prep Puppy.jpg', // Green Heart - Prep Puppy mascot (warmth, care)
  'üíõ': '/images/emojis/Mascots/Prep Puppy.jpg', // Yellow Heart - Prep Puppy mascot (warmth, care)
  'üéÇ': '/images/emojis/Mascots/Prep Puppy.jpg', // Birthday Cake - Prep Puppy mascot (celebration)
};

// Combined map
export const EMOJI_IMAGE_MAP: Record<string, string> = {
  ...PET_EMOJI_MAP,
  ...STATUS_EMOJI_MAP,
};

/**
 * Get image path for an emoji
 * Returns null if no mapping found (fallback to hash-based selection)
 */
export function getEmojiImagePath(emoji: string): string | null {
  return EMOJI_IMAGE_MAP[emoji] || null;
}

/**
 * Hash-based fallback for unmapped emojis
 * Uses amojis set (most consistent quality)
 */
export function getHashBasedEmojiImage(emoji: string): string {
  // Simple hash function
  let hash = 0;
  for (let i = 0; i < emoji.length; i++) {
    hash = ((hash << 5) - hash) + emoji.charCodeAt(i);
    hash = hash & hash; // Convert to 32bit integer
  }
  
  // Use NEW amojis grid (80 images, most consistent)
  const imageNum = (Math.abs(hash) % 80) + 1;
  return `/images/emojis/amojis_${imageNum.toString().padStart(3, '0')}.png`;
}

/**
 * Mascot face emojis - head/bust portraits of the 5 Meal Masters mascots
 * Source: mascot_face_emojis-removebg-preview.png (5 mascot heads in a horizontal row)
 * 
 * Brand Bible Alignment:
 * - Puppy Prepper (Chef) - Light gold dog with chef hat
 * - Professor Purrfessor (Researcher) - Black cat with glasses
 * - Sherlock Shells (Explorer) - Green turtle with cap and monocle
 * - Farmer Fluff (Ingredient Provider) - Dark brown hamster
 * - Robin Redroute (Delivery Specialist) - Red bird with captain's hat and goggles
 *
 * Usage Guidelines (Strategic Mascot Usage):
 * ‚úÖ GOOD: Meal creation tool, ingredient selection, compatibility scoring, error/success states, 
 *          loading screens, tooltips, achievements, homepage hero, empty states, onboarding,
 *          "ingredient discovered" moments, "new recipe unlocked" popups, delivery confirmations
 * ‚ùå AVOID: Educational nutritional text, legal/policy pages, checkout, payment, longform articles, 
 *          scientific explanations, body text paragraphs, navigation menus, critical flows
 */
export const MASCOT_FACE_EMOJI_MAP: Record<string, string> = {
  // Puppy Prepper - The Chef & Meal-Prep Lead
  // Position 1 (left): Yellow dog's head with friendly expression, small black eyes and nose/mouth, wearing puffy white chef's hat
  // Personality: Serious chef energy, impatient, slightly Gordon Ramsay; secretly soft-hearted
  // Color: Light gold
  'puppy-prepper': '/images/emojis/Mascots/Prep Puppy.jpg', // Official name from brand bible
  'barker': '/images/emojis/Mascots/Prep Puppy.jpg', // Legacy name (deprecated)
  'prepperpuppy': '/images/emojis/Mascots/Prep Puppy.jpg', // Alternative spelling
  
  // Professor Purrfessor - The Researcher & Recipe Tester
  // Position 2: Dark grey/black cat's head with large round white glasses covering eyes, small white triangular nose and mouth, pointed ears
  // Personality: Nerdy, anxious, brilliant, catastrophizes constantly
  // Color: Black/charcoal
  'professor-purrfessor': '/images/emojis/Mascots/ProfessorPurffesor.jpg', // Official name from brand bible
  'whiskers': '/images/emojis/Mascots/ProfessorPurffesor.jpg', // Legacy name (deprecated)
  
  // Sherlock Shells - Explorer & Risk Inspector
  // Position 3: Light green round creature's head (turtle/blob), single large black eye with white highlight, wearing dark orange cap with small brim, black monocle hanging from right eye
  // Personality: Soft-spoken, melancholy, overly thoughtful
  // Color: Green
  'sherlock-shells': '/images/emojis/Mascots/SherlockShells.jpg', // Official name from brand bible
  'scales': '/images/emojis/Mascots/SherlockShells.jpg', // Legacy name (deprecated)
  
  // Farmer Fluff - Ingredient Provider & Farm Manager
  // Position 4: Brown hamster's head, light brown face with darker brown outline for head and ears, small black eyes and nose/mouth
  // Personality: ADHD, upbeat, impulsive, very productive in bursts
  // Color: Dark brown
  'farmer-fluff': '/images/emojis/Mascots/harvesthamster.jpg', // Official name from brand bible
  'pip': '/images/emojis/Mascots/harvesthamster.jpg', // Legacy name (deprecated)
  'harvest-hamster': '/images/emojis/Mascots/harvesthamster.jpg', // Legacy name (deprecated)
  
  // Robin Redroute - Packaging & Delivery Specialist
  // Position 5 (right): Red bird's head with small yellow beak, wearing dark blue/black captain's hat with brim, round green goggles over eyes
  // Personality: Hyper, chatty, easily excited
  // Color: Red
  'robin-redroute': '/images/emojis/Mascots/RobinRed-Route.jpg', // Official name from brand bible
  'robin-red-route': '/images/emojis/Mascots/RobinRed-Route.jpg', // Alternative spelling
  'sunny': '/images/emojis/Mascots/RobinRed-Route.jpg', // Legacy name (deprecated)
};

/**
 * Get emoji image path with fallback
 */
export function getEmojiImage(emoji: string): string {
  return getEmojiImagePath(emoji) || getHashBasedEmojiImage(emoji);
}

/**
 * Get mascot face image path
 * Returns the image path for a mascot face identifier
 */
export function getMascotFaceImage(mascotName: string): string | null {
  const normalized = mascotName.toLowerCase().replace(/\s+/g, '-');
  return MASCOT_FACE_EMOJI_MAP[normalized] || null;
}

/**
 * Get mascot face image for a pet category
 * Maps pet types to their corresponding mascot images
 */
export function getMascotFaceForPetType(petType: string): string {
  const typeLower = (petType || '').toLowerCase();
  const typeToMascot: Record<string, string> = {
    'dogs': '/images/emojis/Mascots/Prep Puppy.jpg',
    'cats': '/images/emojis/Mascots/ProfessorPurffesor.jpg',
    'birds': '/images/emojis/Mascots/RobinRed-Route.jpg',
    'reptiles': '/images/emojis/Mascots/SherlockShells.jpg',
    'pocket-pets': '/images/emojis/Mascots/harvesthamster.jpg',
    // Handle singular forms
    'dog': '/images/emojis/Mascots/Prep Puppy.jpg',
    'cat': '/images/emojis/Mascots/ProfessorPurffesor.jpg',
    'bird': '/images/emojis/Mascots/RobinRed-Route.jpg',
    'reptile': '/images/emojis/Mascots/SherlockShells.jpg',
    'pocket-pet': '/images/emojis/Mascots/harvesthamster.jpg',
  };
  return typeToMascot[typeLower] || '/images/emojis/Mascots/Mascot-Emoji-Faces.png';
}

/**
 * Get full profile picture image for a pet type
 * Used for the large profile picture in profile cards (not thumbnails)
 * Maps to full-body character images based on pet type
 */
export function getProfilePictureForPetType(petType: string): string {
  const typeLower = (petType || '').toLowerCase();
  const typeToProfilePic: Record<string, string> = {
    'dogs': '/images/emojis/Mascots/PrepPuppy/PrepPuppy.jpg', // Yellow dog chef with spoon and bowl
    'cats': '/images/emojis/Mascots/Proffessor Purfessor/PUrfessorDesk.jpg', // Black cat with glasses and lab coat at desk
    'birds': '/images/emojis/Mascots/RobinRed-Route.jpg', // Orange bird with goggles and satchel
    'reptiles': '/images/emojis/Mascots/Sherlock Shells/SherlockShells.jpg', // Green turtle detective with monocle
    'pocket-pets': '/images/emojis/Mascots/Harvest Hamster/HHCarrot.jpg', // Brown beaver/hamster with carrot
    // Handle singular forms
    'dog': '/images/emojis/Mascots/PrepPuppy/PrepPuppy.jpg',
    'cat': '/images/emojis/Mascots/Proffessor Purfessor/PUrfessorDesk.jpg',
    'bird': '/images/emojis/Mascots/RobinRed-Route.jpg',
    'reptile': '/images/emojis/Mascots/Sherlock Shells/SherlockShells.jpg',
    'pocket-pet': '/images/emojis/Mascots/Harvest Hamster/HHCarrot.jpg',
  };
  return typeToProfilePic[typeLower] || '/images/emojis/Mascots/Mascot-Emoji-Faces.png';
}
</file>

<file path="lib/utils/enhancedCompatibilityScoring.ts">
// lib/utils/enhancedCompatibilityScoring.ts
// Enhanced compatibility scoring system with ingredient-level analysis
// and multi-factor evaluation

import type { Recipe } from '@/lib/types';
import { getIngredientComposition, INGREDIENT_COMPOSITIONS } from '@/lib/data/ingredientCompositions';
import { getSpeciesCompatibility, shouldAvoid, shouldLimit, normalizeSpecies } from './ingredientCompatibility';
import { AAFCO_NUTRIENT_PROFILES, validateCriticalNutrients } from '@/lib/data/aafco-standards';
import { getAvianStandards, AVIAN_NUTRITION_STANDARDS } from '@/lib/data/avian-nutrition-standards';
import { getReptileStandards, validateReptileNutrition } from '@/lib/data/reptile-nutrition';
import { getFallbackNutrition } from './nutritionFallbacks';
import { nutritionalGuidelines } from '@/lib/data/nutritional-guidelines';
import {
  getHealthConcernBenefits,
  normalizeHealthConcern,
  isBeneficialIngredient,
  isAvoidIngredient,
  checkMacroAlignment,
} from './healthConcernMatching';
import { calculateIngredientQualityScore } from '@/lib/data/ingredientTiers';
import { matchesSpecies } from './recipeRecommendations';

export interface Pet {
  id: string;
  name: string;
  type: 'dog' | 'cat' | 'bird' | 'reptile' | 'pocket-pet';
  breed: string;
  age: number;
  weight: number;
  activityLevel?: 'sedentary' | 'moderate' | 'active' | 'very-active';
  healthConcerns: string[];
  dietaryRestrictions: string[];
  allergies?: string[];
  dislikes?: string[];
  savedRecipes?: string[];
  names?: string[];
  weightKg?: number;
}

export interface EnhancedCompatibilityScore {
  overallScore: number; // 0-100
  grade: 'A+' | 'A' | 'B+' | 'B' | 'C+' | 'C' | 'D' | 'F';
  usesFallbackNutrition?: boolean; // True if any ingredient used fallback nutrition
  fallbackIngredients?: string[]; // List of ingredients that used fallback nutrition
  factors: {
    ingredientSafety: FactorScore;
    nutritionalAdequacy: FactorScore;
    healthAlignment: FactorScore;
    lifeStageFit: FactorScore;
    activityFit: FactorScore;
    allergenSafety: FactorScore;
    ingredientQuality: FactorScore;
  };
  detailedBreakdown: {
    ingredientAnalysis: IngredientAnalysis[];
    nutritionalGaps: string[];
    nutritionalStrengths: string[];
    healthBenefits: string[];
    warnings: string[];
    recommendations: string[];
  };
}

interface FactorScore {
  score: number; // 0-100
  weight: number; // 0-1, how much this factor contributes
  reasoning: string;
  issues: string[];
  strengths: string[];
}

interface IngredientAnalysis {
  ingredient: string;
  compatibility: 'excellent' | 'good' | 'caution' | 'avoid';
  speciesCompat: 'ok' | 'avoid' | 'limit' | 'caution' | null;
  healthImpact: 'positive' | 'neutral' | 'negative';
  notes: string[];
}

/**
 * Enhanced compatibility scoring with ingredient-level analysis
 * 
 * This system provides:
 * 1. Deep ingredient-by-ingredient compatibility checking
 * 2. Real nutritional analysis using USDA data
 * 3. Multi-factor weighted scoring
 * 4. Detailed breakdown for transparency
 */
export function calculateEnhancedCompatibility(
  recipe: Recipe,
  pet: Pet
): EnhancedCompatibilityScore {
  // All recipes go through full scoring pipeline - no short-circuits
  const normalizedSpecies = normalizeSpecies(pet.type);
  const factors = {
    ingredientSafety: calculateIngredientSafety(recipe, pet, normalizedSpecies),
    nutritionalAdequacy: calculateNutritionalAdequacy(recipe, pet, normalizedSpecies),
    healthAlignment: calculateHealthAlignment(recipe, pet),
    lifeStageFit: calculateLifeStageFit(recipe, pet),
    activityFit: calculateActivityFit(recipe, pet),
    allergenSafety: calculateAllergenSafety(recipe, pet),
    ingredientQuality: calculateIngredientQuality(recipe),
  };

  // Calculate safety score (gate) - used to prevent unsafe recipes from scoring high
  const safetyScore = calculateSafetyScore(recipe, pet, normalizedSpecies);
  
  // Calculate optimality score (quality) - considers quality, ideal ranges, health alignment
  const optimalityScore = calculateOptimalityScore(recipe, pet, normalizedSpecies, factors);
  
  // Safety gates the overall score: if safety < 60, cap at 30-40
  // This prevents unsafe recipes from scoring high regardless of other factors
  let gatedScore: number;
  if (safetyScore < 60) {
    // Unsafe recipes: cap at 30-40 based on safety level
    // Still allow some differentiation based on optimality, but heavily penalized
    gatedScore = Math.min(40, safetyScore * 0.5 + optimalityScore * 0.1);
  } else {
    // Safe recipes: combine safety and optimality, but safety doesn't dominate
    // Use 70% optimality + 30% safety for safe recipes
    gatedScore = optimalityScore * 0.70 + safetyScore * 0.30;
  }
  
  // Add bonus points for perfect matches (reduced generosity)
  const bonuses = calculateBonuses(recipe, pet);
  
  // Perfect match bonus: adds 2-5 points if recipe meets strict perfect match criteria
  // This is a bonus, not an override - all recipes go through full scoring
  const perfectMatchBonus = isPerfectMatch(recipe, pet) ? 3 : 0; // 3 points for perfect match
  
  // Ingredient quality is a bonus, not a requirement (0-2% bonus, reduced to prevent clustering)
  const qualityBonus = factors.ingredientQuality.score * 0.02;
  
  // Calculate final score with bonuses, capped at 100
  // Use maximum precision before rounding
  const scoreWithBonuses = gatedScore + bonuses + qualityBonus + perfectMatchBonus;
  
  let finalScore = scoreWithBonuses;
  
  // Add small deterministic variation (¬±1-2 points) based on recipe ID to break ties
  // This prevents identical recipes from getting identical scores
  function hashString(str: string): number {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
    return Math.abs(hash);
  }
  const variation = (hashString(recipe.id) % 5) - 2; // -2 to +2 (as specified in plan)
  
  const overallScore = Math.round(Math.max(0, Math.min(100, finalScore + variation)));

  // Calculate grade
  const grade = getGrade(overallScore);

  // Detailed breakdown
  const ingredientAnalysis = analyzeIngredients(recipe, pet, normalizedSpecies);
  const nutritionalAnalysis = analyzeNutrition(recipe, pet, normalizedSpecies);
  
  // Check for fallback nutrition usage
  const nutrition = calculateRecipeNutrition(recipe);
  const usesFallback = nutrition.usesFallbackNutrition || false;
  const fallbackIngs = nutrition.fallbackIngredients || [];
  
  const healthBenefits: string[] = [];
  const warnings: string[] = [];
  const recommendations: string[] = [];
  
  // Add warning if fallback nutrition is used
  if (usesFallback && fallbackIngs.length > 0) {
    warnings.push(`Recipe uses estimated nutrition data for: ${fallbackIngs.join(', ')}. Recipe should be marked as needsReview.`);
  }

  // Collect health benefits
  if (factors.healthAlignment.strengths.length > 0) {
    healthBenefits.push(...factors.healthAlignment.strengths);
  }

  // Collect warnings
  Object.values(factors).forEach(factor => {
    if (factor.issues.length > 0) {
      warnings.push(...factor.issues);
    }
  });

  // Generate recommendations
  if (factors.nutritionalAdequacy.score < 70) {
    recommendations.push('Consider adding supplements to meet nutritional requirements');
  }
  if (factors.healthAlignment.score < 60 && pet.healthConcerns.length > 0) {
    recommendations.push('This recipe may not address your pet\'s specific health concerns');
  }
  if (factors.activityFit.score < 70 && pet.activityLevel === 'very-active') {
    recommendations.push('This recipe may need additional calories for very active pets');
  }
  if (factors.ingredientQuality.score < 50) {
    recommendations.push('Consider recipes with higher-quality, less processed ingredients');
  }

  return {
    overallScore: Math.max(0, Math.min(100, overallScore)),
    grade,
    factors,
    usesFallbackNutrition: usesFallback,
    fallbackIngredients: fallbackIngs,
    detailedBreakdown: {
      ingredientAnalysis,
      nutritionalGaps: nutritionalAnalysis.gaps,
      nutritionalStrengths: nutritionalAnalysis.strengths,
      healthBenefits,
      warnings: [...new Set(warnings)], // Remove duplicates
      recommendations: [...new Set(recommendations)],
    },
  };
}

/**
 * Factor 1: Ingredient Safety (Weight: 0.25)
 * Checks each ingredient for species compatibility
 */
function calculateIngredientSafety(
  recipe: Recipe,
  pet: Pet,
  normalizedSpecies: string
): FactorScore {
  const ingredients = recipe.ingredients || [];
  let safeCount = 0;
  let cautionCount = 0;
  let avoidCount = 0;
  const issues: string[] = [];
  const strengths: string[] = [];

  // Check for banned ingredients
  const bannedIngredients = (pet as any).bannedIngredients || [];
  const bannedLower = bannedIngredients.map((b: string) => b.toLowerCase());

  for (const ing of ingredients) {
    const ingName = typeof ing === 'string' ? ing : ing.name;
    const ingKey = ingName.toLowerCase().replace(/\s+/g, '_');
    const ingNameLower = ingName.toLowerCase();
    
    // Check if ingredient is banned by user
    const isBanned = bannedLower.some((banned: string) => 
      ingNameLower.includes(banned) || banned.includes(ingNameLower) || ingKey.includes(banned.toLowerCase())
    );
    
    if (isBanned) {
      avoidCount++;
      issues.push(`${ingName} is banned for this pet`);
      continue; // Skip other checks for banned ingredients
    }
    
    // Check species compatibility
    const compat = getSpeciesCompatibility(ingKey, normalizedSpecies);
    
    if (compat === 'avoid') {
      avoidCount++;
      issues.push(`${ingName} should be avoided for ${pet.type}s`);
    } else if (compat === 'limit' || compat === 'caution') {
      cautionCount++;
      issues.push(`${ingName} should be used with caution for ${pet.type}s`);
    } else if (compat === 'ok') {
      safeCount++;
    } else {
      // Unknown ingredient - assume safe but note
      safeCount++;
    }
  }

  // Calculate score with gradual, proportional penalties for better granularity
  const totalIngredients = ingredients.length || 1;
  let score = 100;
  
  // Avoid ingredients: -20 per avoid (reduced from -30), scaled by proportion for gradual penalties
  // This allows recipes with many safe ingredients + one avoid to score better than recipes with mostly avoids
  const avoidRatio = avoidCount / totalIngredients;
  const avoidPenalty = avoidCount * 20 * (1 + avoidRatio); // More gradual
  score -= Math.min(avoidPenalty, 60); // Max -60 for avoids (reduced from -70)
  
  // Caution ingredients: -5 per caution (reduced from -10), scaled by proportion
  const cautionRatio = cautionCount / totalIngredients;
  const cautionPenalty = cautionCount * 5 * (1 + cautionRatio); // More gradual
  score -= Math.min(cautionPenalty, 30); // Max -30 for cautions (reduced from -40)
  
  score = Math.max(0, score);

  if (avoidCount > 0) {
    // Cap at 50 if any avoids (increased from 40 to allow more differentiation)
    score = Math.min(score, 50);
  }

  if (safeCount === ingredients.length && ingredients.length > 0) {
    strengths.push('All ingredients are safe for this species');
  }

  return {
    score: Math.max(0, Math.min(100, score)),
    weight: 0.25, // Weight already correct
    reasoning: avoidCount > 0
      ? `${avoidCount} ingredient(s) should be avoided`
      : cautionCount > 0
      ? `${cautionCount} ingredient(s) need caution`
      : 'All ingredients are species-appropriate',
    issues,
    strengths,
  };
}

/**
 * Calculate continuous score for a nutrient based on distance from ideal range
 * Returns score from 0-100, where 100 = at ideal midpoint, lower = further from ideal
 */
function calculateNutrientScore(
  actual: number,
  min: number,
  max: number
): { score: number; bonus: number } {
  if (max <= min) return { score: 50, bonus: 0 }; // Invalid range
  
  const ideal = (min + max) / 2;
  const range = max - min;
  
  // Calculate distance from ideal (normalized to 0-1)
  const distance = Math.abs(actual - ideal) / range;
  
  // Score: 100 at ideal, decreases linearly with distance
  // Cap at 0 for values way outside range
  let score = Math.max(0, 100 - (distance * 100));
  
  // Bonus for exceeding minimums (up to +8 points, reduced from +15)
  let bonus = 0;
  if (min > 0 && actual > min) {
    const excessPercent = ((actual - min) / min) * 100;
    // +2 points per 5% over minimum, capped at +8 (reduced to prevent over-scoring)
    bonus = Math.min(8, Math.floor(excessPercent / 5) * 2);
  }
  
  return { score, bonus };
}

/**
 * Calculate ingredient diversity bonus (Phase 2.3)
 * Rewards recipes with varied ingredient categories
 */
function calculateIngredientDiversity(recipe: Recipe): number {
  const ingredients = (recipe.ingredients || []).map(ing => {
    const name = typeof ing === 'string' ? ing : ing.name;
    return name.toLowerCase();
  });
  
  if (ingredients.length === 0) return 0;
  
  // Categorize ingredients
  const categories = new Set<string>();
  ingredients.forEach(ing => {
    if (ing.includes('chicken') || ing.includes('turkey') || ing.includes('beef') || 
        ing.includes('fish') || ing.includes('salmon') || ing.includes('lamb') ||
        ing.includes('pork') || ing.includes('duck') || ing.includes('egg')) {
      categories.add('protein');
    } else if (ing.includes('rice') || ing.includes('quinoa') || ing.includes('oats') ||
               ing.includes('barley') || ing.includes('wheat') || ing.includes('corn')) {
      categories.add('grain');
    } else if (ing.includes('carrot') || ing.includes('broccoli') || ing.includes('spinach') ||
               ing.includes('kale') || ing.includes('peas') || ing.includes('green-bean') ||
               ing.includes('sweet-potato') || ing.includes('pumpkin')) {
      categories.add('vegetable');
    } else if (ing.includes('apple') || ing.includes('blueberry') || ing.includes('banana') ||
               ing.includes('cranberry')) {
      categories.add('fruit');
    } else if (ing.includes('oil') || ing.includes('fat')) {
      categories.add('fat');
    } else if (ing.includes('supplement') || ing.includes('vitamin') || ing.includes('mineral')) {
      categories.add('supplement');
    }
  });
  
  // Bonus: +1 point per unique category (max +10)
  const diversityBonus = Math.min(10, categories.size);
  
  return diversityBonus;
}

/**
 * Factor 2: Nutritional Adequacy (Weight: 0.30)
 * Continuous scoring based on distance from ideal nutritional ranges
 */
function calculateNutritionalAdequacy(
  recipe: Recipe,
  pet: Pet,
  normalizedSpecies: string
): FactorScore {
  const issues: string[] = [];
  const strengths: string[] = [];
  
  // Calculate recipe nutrition from ingredients
  const nutrition = calculateRecipeNutrition(recipe);
  
  // Get pet's age group for nutritional guidelines
  let ageGroup: 'puppy' | 'adult' | 'senior' = 'adult';
  if (normalizedSpecies === 'dog' || normalizedSpecies === 'cat') {
    if (pet.age < 1) ageGroup = 'puppy';
    else if (pet.age >= 7) ageGroup = 'senior';
  }
  
  // Map normalized species to PetCategory
  const speciesMap: Record<string, keyof typeof nutritionalGuidelines> = {
    'dog': 'dogs',
    'cat': 'cats',
    'bird': 'birds',
    'reptile': 'reptiles',
    'pocket-pet': 'pocket-pets',
  };
  
  const petCategory = speciesMap[normalizedSpecies];
  let requirements = petCategory ? nutritionalGuidelines[petCategory]?.[ageGroup] : null;
  
  // Fallback to adult if specific age group not available
  if (!requirements && petCategory) {
    requirements = nutritionalGuidelines[petCategory]?.adult;
  }
  
  // Initialize nutrient scores
  const nutrientScores: { name: string; score: number; bonus: number }[] = [];
  let totalScore = 0;
  let totalWeight = 0;
  
  if (requirements) {
    // Protein scoring (weight: 0.30)
    if (requirements.protein) {
      const { score, bonus } = calculateNutrientScore(
        nutrition.protein,
        requirements.protein.min,
        requirements.protein.max
      );
      nutrientScores.push({ name: 'protein', score, bonus });
      totalScore += score * 0.30;
      totalWeight += 0.30;
      
      if (nutrition.protein < requirements.protein.min) {
        issues.push(`Protein (${nutrition.protein.toFixed(1)}%) below minimum (${requirements.protein.min}%)`);
      } else if (nutrition.protein > requirements.protein.max) {
        issues.push(`Protein (${nutrition.protein.toFixed(1)}%) above maximum (${requirements.protein.max}%)`);
      } else {
        strengths.push(`Protein (${nutrition.protein.toFixed(1)}%) within ideal range`);
      }
    }
    
    // Fat scoring (weight: 0.25)
    if (requirements.fat) {
      const { score, bonus } = calculateNutrientScore(
        nutrition.fat,
        requirements.fat.min,
        requirements.fat.max
      );
      nutrientScores.push({ name: 'fat', score, bonus });
      totalScore += score * 0.25;
      totalWeight += 0.25;
      
      if (nutrition.fat < requirements.fat.min) {
        issues.push(`Fat (${nutrition.fat.toFixed(1)}%) below minimum (${requirements.fat.min}%)`);
      } else if (nutrition.fat > requirements.fat.max) {
        issues.push(`Fat (${nutrition.fat.toFixed(1)}%) above maximum (${requirements.fat.max}%)`);
      }
    }
    
    // Fiber scoring (weight: 0.15)
    if (requirements.fiber) {
      const { score, bonus } = calculateNutrientScore(
        nutrition.fiber,
        requirements.fiber.min,
        requirements.fiber.max
      );
      nutrientScores.push({ name: 'fiber', score, bonus });
      totalScore += score * 0.15;
      totalWeight += 0.15;
    }
    
    // Calcium scoring (weight: 0.15)
    if (requirements.calcium) {
      const { score, bonus } = calculateNutrientScore(
        nutrition.calcium,
        requirements.calcium.min,
        requirements.calcium.max
      );
      nutrientScores.push({ name: 'calcium', score, bonus });
      totalScore += score * 0.15;
      totalWeight += 0.15;
    }
    
    // Phosphorus scoring (weight: 0.15)
    if (requirements.phosphorus) {
      const { score, bonus } = calculateNutrientScore(
        nutrition.phosphorus,
        requirements.phosphorus.min,
        requirements.phosphorus.max
      );
      nutrientScores.push({ name: 'phosphorus', score, bonus });
      totalScore += score * 0.15;
      totalWeight += 0.15;
    }
    
    // Ca:P ratio precision scoring (Phase 2.2)
    if (nutrition.calcium && nutrition.phosphorus && requirements.calcium && requirements.phosphorus) {
      const caPRatio = nutrition.calcium / nutrition.phosphorus;
      // Ideal Ca:P ratio varies by species, but generally 1.2:1 to 2:1
      const idealCaP = petCategory === 'dogs' || petCategory === 'cats' ? 1.5 : 1.8;
      const minCaP = 1.2;
      const maxCaP = 2.0;
      
      if (caPRatio >= minCaP && caPRatio <= maxCaP) {
        // Calculate distance from ideal
        const distance = Math.abs(caPRatio - idealCaP) / (maxCaP - minCaP);
        const ratioScore = 100 - (distance * 50); // Max penalty -50
        totalScore += ratioScore * 0.10; // 10% weight for ratio
        totalWeight += 0.10;
        
        if (distance < 0.1) {
          strengths.push(`Optimal Ca:P ratio (${caPRatio.toFixed(2)})`);
        } else if (distance < 0.3) {
          strengths.push(`Good Ca:P ratio (${caPRatio.toFixed(2)})`);
        } else {
          issues.push(`Ca:P ratio (${caPRatio.toFixed(2)}) could be closer to ideal (${idealCaP})`);
        }
      } else {
        // Outside ideal range - elastic thresholds with diminishing returns
        const safeMin = 0.8; // Animals tolerate broader ranges
        const safeMax = 3.0;
        
        if (caPRatio >= safeMin && caPRatio < minCaP) {
          // Slightly low - small penalty
          const deviation = minCaP - caPRatio;
          const penalty = Math.min(deviation * 5, 10); // Reduced penalty
          totalScore -= penalty * 0.10;
          totalWeight += 0.10;
          issues.push(`Ca:P ratio (${caPRatio.toFixed(2)}) slightly below ideal range`);
        } else if (caPRatio > maxCaP && caPRatio <= safeMax) {
          // Slightly high - small penalty
          const deviation = caPRatio - maxCaP;
          const penalty = Math.min(deviation * 5, 10); // Reduced penalty
          totalScore -= penalty * 0.10;
          totalWeight += 0.10;
          issues.push(`Ca:P ratio (${caPRatio.toFixed(2)}) slightly above ideal range`);
        } else {
          // Outside safe range - larger penalty
          const penalty = caPRatio < safeMin ? (safeMin - caPRatio) * 20 : (caPRatio - safeMax) * 20;
          totalScore -= Math.min(penalty, 50) * 0.10;
          totalWeight += 0.10;
          issues.push(`Ca:P ratio (${caPRatio.toFixed(2)}) outside safe range (${safeMin}-${safeMax})`);
        }
      }
    }
  }
  
  // Calculate weighted average score
  let finalScore = totalWeight > 0 ? totalScore / totalWeight : 50;
  
  // Add bonuses for exceeding minimums (average across nutrients)
  const avgBonus = nutrientScores.length > 0
    ? nutrientScores.reduce((sum, n) => sum + n.bonus, 0) / nutrientScores.length
    : 0;
  finalScore += avgBonus;
  
  // Add ingredient diversity bonus (Phase 2.3)
  const diversityBonus = calculateIngredientDiversity(recipe);
  finalScore += diversityBonus;
  
  // Safety validation check (still important for critical failures)
  if (normalizedSpecies === 'dog' || normalizedSpecies === 'cat') {
    const lifeStage = pet.age < 1 ? 'growth' : 'adult';
    const validation = validateCriticalNutrients(
      recipe,
      normalizedSpecies as 'dog' | 'cat',
      lifeStage
    );
    
    if (!validation.isValid) {
      // Critical violations reduce score gradually using distance-based penalty
      // Penalty = violations^2 * scalingFactor for better granularity
      const violationPenalty = Math.min(30, validation.violations.length * validation.violations.length * 2);
      finalScore -= violationPenalty;
      validation.violations.forEach(v => {
        issues.push(`Critical nutritional gap: ${v}`);
      });
    }
  } else if (normalizedSpecies === 'bird') {
    const standards = getAvianStandards(pet.breed) || AVIAN_NUTRITION_STANDARDS.psittacines;
    if (nutrition.protein < (standards.protein?.min || 12)) {
      // Gradual penalty based on how far below minimum
      const deviation = (standards.protein?.min || 12) - nutrition.protein;
      const penalty = Math.min(20, deviation * deviation * 2); // Quadratic penalty
      finalScore -= penalty;
      issues.push('Protein critically low for birds');
    }
  } else if (normalizedSpecies === 'reptile') {
    const standards = getReptileStandards(pet.breed);
    if (standards) {
      const validation = validateReptileNutrition(recipe, pet.breed || 'unknown');
      if (!validation.isValid) {
        finalScore -= validation.violations.length * 5; // Reduced from -10 to -5
        validation.violations.forEach(v => {
          issues.push(`Reptile nutrition gap: ${v}`);
        });
      }
    }
  } else if (normalizedSpecies === 'pocket-pet') {
    const breed = (pet.breed || '').toLowerCase();
    const isLowFiber = ['sugar', 'glider', 'hamster', 'rat', 'mouse', 'ferret'].some(b => breed.includes(b));
    const isHayEater = ['rabbit', 'guinea', 'chinchilla'].some(b => breed.includes(b));
    
    if (isLowFiber && nutrition.protein < 12) {
      // Gradual penalty based on deviation
      const deviation = 12 - nutrition.protein;
      const penalty = Math.min(20, deviation * deviation * 2);
      finalScore -= penalty;
      issues.push('Protein critically low for this pocket-pet type');
    }
    if (isHayEater && nutrition.fiber < 15) {
      // Gradual penalty based on deviation
      const deviation = 15 - nutrition.fiber;
      const penalty = Math.min(20, deviation * deviation * 2);
      finalScore -= penalty;
      issues.push('Fiber critically low for hay-eating pocket-pets');
    }
    if (breed.includes('ferret') && nutrition.protein < 30) {
      // Gradual penalty based on deviation
      const deviation = 30 - nutrition.protein;
      const penalty = Math.min(25, deviation * deviation * 1.5);
      finalScore -= penalty;
      issues.push('Ferrets require high protein (30%+) as obligate carnivores');
    }
  }
  
  // Add missing data penalty - FIXED: Only penalize for pets with health concerns requiring precise nutrition
  // Use gradual penalty: (100 - coverage) / 10 instead of binary thresholds
  if (nutrition.usesFallbackNutrition && nutrition.fallbackIngredients && pet.healthConcerns.length > 0) {
    const totalIngredients = (recipe.ingredients || []).length;
    const missingPercentage = totalIngredients > 0 
      ? nutrition.fallbackIngredients.length / totalIngredients 
      : 0;
    const coverage = (1 - missingPercentage) * 100;
    const penalty = Math.min(15, (100 - coverage) / 10); // Gradual: -1 per 10% missing
    finalScore -= penalty;
    
    if (penalty > 0) {
      issues.push(`Uses estimated nutrition data for ${nutrition.fallbackIngredients.length} ingredient(s) (${Math.round(missingPercentage * 100)}%)`);
    }
  }
  // For perfect pets, fallback data is acceptable and doesn't penalize
  
  // Add strength messages for good scores
  if (finalScore >= 85) {
    strengths.push('Excellent nutritional profile');
  } else if (finalScore >= 75) {
    strengths.push('Good nutritional profile');
  } else if (finalScore >= 65) {
    strengths.push('Adequate nutritional profile');
  }

  return {
    score: Math.max(0, Math.min(100, Math.round(finalScore))),
    weight: 0.35, // Updated weight to match new distribution
    reasoning: issues.length === 0
      ? `Nutritional score: ${Math.round(finalScore)}% (${strengths[0] || 'within acceptable ranges'})`
      : `${issues.length} nutritional concern(s) identified`,
    issues,
    strengths,
  };
}

/**
 * Factor 3: Health Alignment (Weight: 0.20)
 * Tiered scoring based on precision of health concern matching
 */
function calculateHealthAlignment(
  recipe: Recipe,
  pet: Pet
): FactorScore {
  const issues: string[] = [];
  const strengths: string[] = [];

  if (pet.healthConcerns.length === 0) {
    return {
      score: 100,
      weight: 0.15, // Updated weight to match new distribution
      reasoning: 'No specific health concerns to evaluate',
      issues: [],
      strengths: ['Recipe suitable for healthy pets'],
    };
  }

  // Calculate recipe nutrition for macro alignment checks
  const nutrition = calculateRecipeNutrition(recipe);
  
  // Get recipe ingredients
  const recipeIngredients = (recipe.ingredients || []).map(ing => {
    const name = typeof ing === 'string' ? ing : ing.name;
    return name.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
  });
  
  const recipeConcerns = (recipe.healthConcerns || []).map(c => normalizeHealthConcern(c));
  const recipeNotSuitable = (recipe.notSuitableFor || []).map(c => normalizeHealthConcern(c));
  
  const petConcerns = pet.healthConcerns.map(c => normalizeHealthConcern(c));
  
  // Calculate tiered scores for each concern
  const concernScores: number[] = [];
  const concernWeights: number[] = [];
  
  for (let i = 0; i < petConcerns.length; i++) {
    const concern = petConcerns[i];
    const concernData = getHealthConcernBenefits(concern);
    
    // Weight: Primary concern (first) gets full weight, others get 0.7x
    const weight = i === 0 ? 1.0 : 0.7;
    
    // Check if recipe explicitly says it's not suitable
    const notSuitable = recipeNotSuitable.some(ns => 
      ns.includes(concern) || concern.includes(ns)
    );
    
    if (notSuitable) {
      // Tier 5: Negative match - contains problematic elements
      concernScores.push(20);
      concernWeights.push(weight);
      issues.push(`Recipe is not suitable for ${concern.replace(/-/g, ' ')}`);
      continue;
    }
    
    // Check if recipe explicitly targets this concern
    const explicitlyTargets = recipeConcerns.some(rc => 
      rc.includes(concern) || concern.includes(rc)
    );
    
    if (concernData) {
      // Check for beneficial ingredients
      const beneficialCount = recipeIngredients.filter(ing => 
        isBeneficialIngredient(ing, concernData.beneficialIngredients)
      ).length;
      
      // Check for avoid ingredients
      const avoidCount = recipeIngredients.filter(ing => 
        isAvoidIngredient(ing, concernData.avoidIngredients, pet.allergies)
      ).length;
      
      // Check macro alignment
      const macroAlignment = checkMacroAlignment(nutrition, concernData.targetMacros);
      
      // Tier 1: Perfect match - explicitly targets + has beneficial + avoids problematic + good macros
      if (explicitlyTargets && beneficialCount > 0 && avoidCount === 0 && macroAlignment >= 25) {
        concernScores.push(100);
        concernWeights.push(weight);
        strengths.push(`Perfect match for ${concern.replace(/-/g, ' ')}: targets concern with beneficial ingredients`);
      }
      // Tier 2: Strong match - explicitly targets + has some beneficial ingredients
      else if (explicitlyTargets && beneficialCount > 0) {
        const tier2Score = 70 + Math.min(beneficialCount * 5, 15) + (avoidCount === 0 ? 10 : -avoidCount * 5);
        concernScores.push(Math.min(100, tier2Score));
        concernWeights.push(weight);
        strengths.push(`Strong match for ${concern.replace(/-/g, ' ')}: targets concern with ${beneficialCount} beneficial ingredient(s)`);
      }
      // Tier 3: Supportive match - has beneficial ingredients but doesn't explicitly target
      else if (beneficialCount > 0 && avoidCount === 0) {
        const tier3Score = 50 + Math.min(beneficialCount * 5, 20) + (macroAlignment >= 25 ? 10 : 0);
        concernScores.push(Math.min(100, tier3Score));
        concernWeights.push(weight);
        strengths.push(`Supportive for ${concern.replace(/-/g, ' ')}: contains ${beneficialCount} beneficial ingredient(s)`);
      }
      // Tier 4: Neutral - no alignment but no conflicts
      else if (avoidCount === 0) {
        concernScores.push(50);
        concernWeights.push(weight);
      }
      // Tier 5: Negative - contains problematic ingredients
      else {
        const tier5Score = Math.max(0, 30 - (avoidCount * 10));
        concernScores.push(tier5Score);
        concernWeights.push(weight);
        issues.push(`Contains ${avoidCount} problematic ingredient(s) for ${concern.replace(/-/g, ' ')}`);
      }
    } else {
      // No specific data for this concern - use basic tag matching
      if (explicitlyTargets) {
        concernScores.push(85);
        concernWeights.push(weight);
        strengths.push(`Recipe targets ${concern.replace(/-/g, ' ')}`);
      } else {
        concernScores.push(50);
        concernWeights.push(weight);
      }
    }
  }
  
  // Calculate weighted average across all concerns
  let totalScore = 0;
  let totalWeight = 0;
  for (let i = 0; i < concernScores.length; i++) {
    totalScore += concernScores[i] * concernWeights[i];
    totalWeight += concernWeights[i];
  }
  
  const finalScore = totalWeight > 0 ? totalScore / totalWeight : 50;

  return {
    score: Math.max(0, Math.min(100, Math.round(finalScore))),
    weight: 0.15, // Updated weight to match new distribution
    reasoning: concernScores.length > 0
      ? `Health alignment: ${Math.round(finalScore)}% (${strengths.length > 0 ? strengths[0] : 'neutral'})`
      : 'Neutral health alignment',
    issues,
    strengths,
  };
}

/**
 * Factor 4: Life Stage Fit (Weight: 0.10)
 * Checks if recipe is appropriate for pet's age
 */
function calculateLifeStageFit(
  recipe: Recipe,
  pet: Pet
): FactorScore {
  const issues: string[] = [];
  const strengths: string[] = [];
  
  const petAgeGroup = pet.age < 1 ? 'baby' : pet.age < 2 ? 'young' : pet.age < 7 ? 'adult' : 'senior';
  const recipeAgeGroups = recipe.ageGroup || [];
  
  const isMatch = recipeAgeGroups.includes(petAgeGroup) || 
                  recipeAgeGroups.includes('all') ||
                  recipeAgeGroups.length === 0;

  if (isMatch) {
    strengths.push(`Appropriate for ${petAgeGroup} pets`);
  } else {
    issues.push(`Recipe designed for ${recipeAgeGroups.join(', ')}, but pet is ${petAgeGroup}`);
  }

  return {
    score: isMatch ? 100 : 60,
    weight: 0.10, // Weight already correct
    reasoning: isMatch
      ? `Recipe is appropriate for ${petAgeGroup} pets`
      : `Age group mismatch`,
    issues,
    strengths,
  };
}

/**
 * Factor 5: Activity Fit (Weight: 0.05)
 * Checks if calorie content matches activity level
 */
function calculateActivityFit(
  recipe: Recipe,
  pet: Pet
): FactorScore {
  const issues: string[] = [];
  const strengths: string[] = [];
  
  if (!pet.activityLevel) {
    return {
      score: 100,
      weight: 0.05,
      reasoning: 'Activity level not specified',
      issues: [],
      strengths: [],
    };
  }

  const nutrition = calculateRecipeNutrition(recipe);
  const calories = nutrition.calories || 150; // Default estimate

  // Rough calorie needs by activity (kcal per kg body weight per day)
  const activityMultipliers = {
    'sedentary': 80,
    'moderate': 100,
    'active': 120,
    'very-active': 150,
  };

  const estimatedNeeds = (activityMultipliers[pet.activityLevel] || 100) * pet.weight;
  const recipeCalories = calories * (pet.weight / 10); // Rough estimate for portion

  if (pet.activityLevel === 'very-active' && recipeCalories < estimatedNeeds * 0.8) {
    issues.push('Recipe may be too low in calories for very active pets');
  } else if (pet.activityLevel === 'sedentary' && recipeCalories > estimatedNeeds * 1.2) {
    issues.push('Recipe may be too high in calories for sedentary pets');
  } else {
    strengths.push(`Calorie content appropriate for ${pet.activityLevel} activity level`);
  }

  return {
    score: issues.length > 0 ? 70 : 100,
    weight: 0.05,
    reasoning: issues.length > 0
      ? 'Calorie content may not match activity level'
      : 'Calorie content matches activity level',
    issues,
    strengths,
  };
}

/**
 * Factor 6.5: Ingredient Quality (Weight: 0.10)
 * Scores based on ingredient sophistication and quality
 */
function calculateIngredientQuality(
  recipe: Recipe
): FactorScore {
  const issues: string[] = [];
  const strengths: string[] = [];
  
  const ingredients = (recipe.ingredients || []).map(ing => 
    typeof ing === 'string' ? { name: ing } : ing
  );
  
  const qualityResult = calculateIngredientQualityScore(ingredients);
  
  if (qualityResult.premiumCount > 0) {
    strengths.push(`${qualityResult.premiumCount} premium ingredient(s)`);
  }
  
  if (qualityResult.basicCount > 0) {
    issues.push(`${qualityResult.basicCount} processed/basic ingredient(s)`);
  }
  
  if (qualityResult.freshRatio > 0.5) {
    strengths.push('High proportion of fresh ingredients');
  }
  
  return {
    score: qualityResult.score,
    weight: 0.00, // FIXED: Quality is now a bonus, not part of base weight
    reasoning: qualityResult.score >= 70
      ? `High-quality ingredients (${qualityResult.premiumCount} premium)`
      : qualityResult.score >= 50
      ? 'Standard ingredient quality'
      : 'Contains processed/basic ingredients',
    issues,
    strengths,
  };
}

/**
 * Factor 6: Allergen Safety (Weight: 0.10)
 * Critical safety check for allergies
 */
function calculateAllergenSafety(
  recipe: Recipe,
  pet: Pet
): FactorScore {
  const issues: string[] = [];
  const strengths: string[] = [];
  
  const allAllergens = [
    ...(pet.allergies || []),
    ...pet.dietaryRestrictions.filter(r => 
      ['chicken', 'beef', 'dairy', 'wheat', 'egg', 'fish', 'pork'].some(a => 
        r.toLowerCase().includes(a)
      )
    ),
  ];

  if (allAllergens.length === 0) {
    return {
      score: 100,
      weight: 0.10,
      reasoning: 'No known allergies or restrictions',
      issues: [],
      strengths: ['No allergen concerns'],
    };
  }

  const ingredients = (recipe.ingredients || []).map(i => 
    (typeof i === 'string' ? i : i.name).toLowerCase()
  ).join(' ');

  let hasAllergen = false;
  for (const allergen of allAllergens) {
    if (ingredients.includes(allergen.toLowerCase())) {
      hasAllergen = true;
      issues.push(`Contains ${allergen} - AVOID`);
    }
  }

  if (!hasAllergen) {
    strengths.push('Recipe avoids all known allergens');
  }

  return {
    score: hasAllergen ? 0 : 100, // Zero if allergen present
    weight: 0.10, // Weight already correct
    reasoning: hasAllergen
      ? 'Contains known allergens - NOT SAFE'
      : 'No allergens detected',
    issues,
    strengths,
  };
}

/**
 * Calculate safety score (0-100) - only considers hard safety requirements
 * This is used as a gate to prevent unsafe recipes from scoring high
 */
function calculateSafetyScore(
  recipe: Recipe,
  pet: Pet,
  normalizedSpecies: string
): number {
  const ingredients = recipe.ingredients || [];
  let hasAvoid = false;
  let hasAllergen = false;
  
  // Check for banned ingredients
  const bannedIngredients = (pet as any).bannedIngredients || [];
  const bannedLower = bannedIngredients.map((b: string) => b.toLowerCase());
  
  for (const ing of ingredients) {
    const ingName = typeof ing === 'string' ? ing : ing.name;
    const ingKey = ingName.toLowerCase().replace(/\s+/g, '_');
    const ingNameLower = ingName.toLowerCase();
    
    // Check if ingredient is banned
    const isBanned = bannedLower.some((banned: string) => 
      ingNameLower.includes(banned) || banned.includes(ingNameLower) || ingKey.includes(banned.toLowerCase())
    );
    
    if (isBanned) {
      hasAvoid = true;
      continue;
    }
    
    // Check species compatibility
    const compat = getSpeciesCompatibility(ingKey, normalizedSpecies);
    if (compat === 'avoid') {
      hasAvoid = true;
    }
  }
  
  // Check for allergens
  const allergies = pet.allergies || [];
  const dietaryRestrictions = pet.dietaryRestrictions || [];
  const allAllergens = [...allergies, ...dietaryRestrictions];
  
  if (allAllergens.length > 0) {
    const recipeIngNames = ingredients.map(ing => 
      (typeof ing === 'string' ? ing : ing.name).toLowerCase()
    ).join(' ');
    
    hasAllergen = allAllergens.some(a => 
      recipeIngNames.includes(a.toLowerCase())
    );
  }
  
  // Safety score: 0 if unsafe, 100 if completely safe
  if (hasAvoid || hasAllergen) {
    return 0; // Unsafe - will gate overall score
  }
  
  // Check hard nutritional minimums (meets core species standards)
  const nutrition = calculateRecipeNutrition(recipe);
  const petCategory = normalizedSpecies === 'dog' ? 'dogs' : 
                      normalizedSpecies === 'cat' ? 'cats' :
                      normalizedSpecies === 'bird' ? 'birds' :
                      normalizedSpecies === 'reptile' ? 'reptiles' : 'pocket-pets';
  const ageGroup = pet.age < 1 ? 'puppy' : pet.age >= 7 ? 'senior' : 'adult';
  const requirements = nutritionalGuidelines[petCategory]?.[ageGroup] || nutritionalGuidelines[petCategory]?.adult;
  
  if (requirements) {
    // Check critical minimums
    if (requirements.protein && nutrition.protein < requirements.protein.min * 0.8) {
      return 30; // Critically low protein
    }
    if (requirements.fat && nutrition.fat < requirements.fat.min * 0.8) {
      return 40; // Critically low fat
    }
  }
  
  // All safety checks passed
  return 100;
}

/**
 * Calculate optimality score (0-100) - considers quality, ideal ranges, health alignment
 * This is the "how good is it" score, separate from safety
 */
function calculateOptimalityScore(
  recipe: Recipe,
  pet: Pet,
  normalizedSpecies: string,
  factors: {
    ingredientSafety: FactorScore;
    nutritionalAdequacy: FactorScore;
    healthAlignment: FactorScore;
    lifeStageFit: FactorScore;
    activityFit: FactorScore;
    allergenSafety: FactorScore;
    ingredientQuality: FactorScore;
  }
): number {
  // Optimality weights (different from safety)
  const optimalityWeights = {
    nutritionalAdequacy: 0.40, // How close to ideal nutrient bands
    healthAlignment: 0.20, // Health concern matching
    lifeStageFit: 0.15, // Age appropriateness
    activityFit: 0.10, // Activity level matching
    ingredientQuality: 0.15, // Quality of ingredients
  };
  
  // Calculate weighted optimality score
  const optimalityScore = 
    factors.nutritionalAdequacy.score * optimalityWeights.nutritionalAdequacy +
    factors.healthAlignment.score * optimalityWeights.healthAlignment +
    factors.lifeStageFit.score * optimalityWeights.lifeStageFit +
    factors.activityFit.score * optimalityWeights.activityFit +
    factors.ingredientQuality.score * optimalityWeights.ingredientQuality;
  
  return Math.max(0, Math.min(100, optimalityScore));
}

/**
 * Analyze each ingredient individually
 */
function analyzeIngredients(
  recipe: Recipe,
  pet: Pet,
  normalizedSpecies: string
): IngredientAnalysis[] {
  const ingredients = recipe.ingredients || [];
  const analysis: IngredientAnalysis[] = [];

  for (const ing of ingredients) {
    const ingName = typeof ing === 'string' ? ing : ing.name;
    const ingKey = ingName.toLowerCase().replace(/\s+/g, '_');
    
    const compat = getSpeciesCompatibility(ingKey, normalizedSpecies);
    const composition = getIngredientComposition(ingKey);
    
    let compatibility: 'excellent' | 'good' | 'caution' | 'avoid';
    let healthImpact: 'positive' | 'neutral' | 'negative' = 'neutral';
    const notes: string[] = [];

    if (compat === 'avoid') {
      compatibility = 'avoid';
      healthImpact = 'negative';
      notes.push('Should be avoided for this species');
    } else if (compat === 'limit' || compat === 'caution') {
      compatibility = 'caution';
      notes.push('Use with caution');
    } else if (compat === 'ok') {
      compatibility = 'good';
    } else {
      compatibility = 'good'; // Unknown, assume safe
    }

    // Check health concerns
    const recipeConcerns = (recipe.healthConcerns || []).map(c => c.toLowerCase());
    const petConcerns = pet.healthConcerns.map(c => c.toLowerCase());
    
    // Check if ingredient benefits health concerns
    if (composition) {
      if (composition.omega3 && petConcerns.some(c => c.includes('joint') || c.includes('skin'))) {
        healthImpact = 'positive';
        notes.push('Rich in omega-3, beneficial for joint/skin health');
      }
      if (composition.taurine && pet.type === 'cat') {
        healthImpact = 'positive';
        notes.push('Contains taurine, essential for cats');
      }
    }

    analysis.push({
      ingredient: ingName,
      compatibility,
      speciesCompat: compat,
      healthImpact,
      notes,
    });
  }

  return analysis;
}

/**
 * Analyze nutritional profile
 */
function analyzeNutrition(
  recipe: Recipe,
  pet: Pet,
  normalizedSpecies: string
): { gaps: string[]; strengths: string[] } {
  const gaps: string[] = [];
  const strengths: string[] = [];
  
  const nutrition = calculateRecipeNutrition(recipe);
  
  if (normalizedSpecies === 'dog' || normalizedSpecies === 'cat') {
    if (nutrition.protein < 18) {
      gaps.push('Protein content may be below optimal');
    } else {
      strengths.push('Adequate protein content');
    }
    
    if (nutrition.calcium && nutrition.phosphorus) {
      const caPRatio = nutrition.calcium / nutrition.phosphorus;
      if (caPRatio < 1.0 || caPRatio > 2.0) {
        gaps.push(`Ca:P ratio (${caPRatio.toFixed(2)}) outside ideal range`);
      } else {
        strengths.push('Ideal Ca:P ratio');
      }
    }
  }

  if (nutrition.source === 'real') {
    strengths.push('Nutritional data based on USDA values');
  }

  return { gaps, strengths };
}

/**
 * Calculate recipe nutrition from ingredients
 * Returns nutrition values as percentages (dry matter basis)
 */
export function calculateRecipeNutrition(recipe: Recipe): {
  protein: number;
  fat: number;
  fiber: number;
  calcium: number;
  phosphorus: number;
  calories: number;
  source: 'real' | 'estimated';
  usesFallbackNutrition?: boolean;
  fallbackIngredients?: string[];
} {
  // Check if recipe has pre-calculated nutritional data (from custom meal analysis)
  const nutritionalCalc = (recipe as any).nutritionalCalculation;
  if (nutritionalCalc) {
    const totalGrams = nutritionalCalc.totalGrams || 100;
    // Convert from grams to percentages
    return {
      protein: totalGrams > 0 ? ((nutritionalCalc.protein_g || 0) / totalGrams) * 100 : 0,
      fat: totalGrams > 0 ? ((nutritionalCalc.fat_g || 0) / totalGrams) * 100 : 0,
      fiber: totalGrams > 0 ? ((nutritionalCalc.fiber_g || 0) / totalGrams) * 100 : 0,
      calcium: totalGrams > 0 ? ((nutritionalCalc.ca_mg || 0) / totalGrams) * 100 : 0,
      phosphorus: totalGrams > 0 ? ((nutritionalCalc.p_mg || 0) / totalGrams) * 100 : 0,
      calories: totalGrams > 0 ? ((nutritionalCalc.calories_kcal || nutritionalCalc.kcal || 0) / totalGrams) * 100 : 0,
      source: 'real',
    };
  }

  const ingredients = recipe.ingredients || [];
  const supplements = (recipe as any).supplements || [];
  
  let totalProtein = 0;
  let totalFat = 0;
  let totalFiber = 0;
  let totalCalcium = 0;
  let totalPhosphorus = 0;
  let totalCalories = 0;
  let totalWeight = 0;
  let realDataCount = 0;
  const fallbackIngredients: string[] = [];

  // Helper function to map supplement names to ingredient composition keys
  const mapSupplementToCompositionKey = (supplementName: string): string | null => {
    const lower = supplementName.toLowerCase();
    // Map common supplement names to ingredient composition keys
    if (lower.includes('taurine')) return 'taurine_powder';
    if (lower.includes('calcium') && (lower.includes('carbonate') || lower.includes('supplement'))) return 'calcium_carbonate';
    if (lower.includes('omega') || lower.includes('fish oil') || lower.includes('krill') || lower.includes('salmon oil')) return 'fish_oil';
    // Note: psyllium, probiotics, vitamins don't have composition data yet
    // They can still be added but won't contribute to macro calculations
    return null;
  };

  // Process ingredients
  for (const ingredient of ingredients) {
    const name = typeof ingredient === 'string' ? ingredient : ingredient.name;
    const amount = typeof ingredient === 'string' ? 100 : (ingredient.amount ? parseFloat(String(ingredient.amount).replace(/[^0-9.]/g, '')) : 100);

    const ingKey = name.toLowerCase().replace(/\s+/g, '_');
    const composition = getIngredientComposition(ingKey);
    
    if (composition && composition.protein !== undefined) {
      // Check if composition uses fallback (has needsReview and source is estimated_fallback)
      const usesFallback = (composition as any).needsReview === true && 
                          (composition.source === 'estimated_fallback' || composition.source?.includes('fallback'));
      
      if (usesFallback) {
        fallbackIngredients.push(name);
      }
      
      totalProtein += (composition.protein || 0) * (amount / 100);
      totalFat += (composition.fat || 0) * (amount / 100);
      totalFiber += (composition.fiber || 0) * (amount / 100);
      totalCalcium += (composition.calcium || 0) * (amount / 100);
      totalPhosphorus += (composition.phosphorus || 0) * (amount / 100);
      totalCalories += (composition.kcal || 0) * (amount / 100);
      totalWeight += amount;
      realDataCount++;
    } else {
      // Try fallback nutrition
      const fallback = getFallbackNutrition(name);
      if (fallback) {
        fallbackIngredients.push(name);
        totalProtein += (fallback.protein || 0) * (amount / 100);
        totalFat += (fallback.fat || 0) * (amount / 100);
        totalFiber += (fallback.fiber || 0) * (amount / 100);
        totalCalcium += (fallback.calcium || 0) * (amount / 100);
        totalPhosphorus += (fallback.phosphorus || 0) * (amount / 100);
        totalCalories += (fallback.kcal || 0) * (amount / 100);
        totalWeight += amount;
        realDataCount++;
      }
    }
  }

  // Process supplements - add their nutritional contributions
  for (const supplement of supplements) {
    const name = supplement.name || supplement.productName || '';
    if (!name) continue;
    
    // Map supplement name to ingredient composition key
    const compositionKey = mapSupplementToCompositionKey(name);
    if (!compositionKey) continue;
    
    // Get composition data
    const composition = getIngredientComposition(compositionKey);
    if (!composition) continue;
    
    // Supplements are typically added in small amounts (mg or grams)
    // Parse amount from supplement.amount (e.g., "250mg", "1g", "As directed")
    let supplementAmount = 0;
    const amountStr = supplement.amount || supplement.defaultAmount || '';
    if (amountStr) {
      // Extract numeric value
      const numericMatch = amountStr.match(/([\d.]+)/);
      if (numericMatch) {
        supplementAmount = parseFloat(numericMatch[1]);
        // Convert mg to grams if needed
        if (amountStr.toLowerCase().includes('mg')) {
          supplementAmount = supplementAmount / 1000;
        }
      } else {
        // Default supplement amount (typically 1-5g for powders)
        supplementAmount = 2; // 2g default
      }
    } else {
      supplementAmount = 2; // 2g default
    }
    
    // Add supplement nutrition to totals
    // Supplements contribute nutrients but typically don't add significant weight to the meal
    // We'll add them proportionally to the existing meal weight
    if (totalWeight > 0) {
      // Add supplement nutrients as if they were part of the meal
      totalCalcium += (composition.calcium || 0) * (supplementAmount / 100);
      totalPhosphorus += (composition.phosphorus || 0) * (supplementAmount / 100);
      totalProtein += (composition.protein || 0) * (supplementAmount / 100);
      totalFat += (composition.fat || 0) * (supplementAmount / 100);
      totalFiber += (composition.fiber || 0) * (supplementAmount / 100);
      totalCalories += (composition.kcal || 0) * (supplementAmount / 100);
      // Add supplement weight to total (small contribution)
      totalWeight += supplementAmount;
      realDataCount++;
    }
  }

  if (realDataCount > 0 && totalWeight > 0) {
    return {
      protein: (totalProtein / totalWeight) * 100,
      fat: (totalFat / totalWeight) * 100,
      fiber: (totalFiber / totalWeight) * 100,
      calcium: (totalCalcium / totalWeight) * 100,
      phosphorus: (totalPhosphorus / totalWeight) * 100,
      calories: (totalCalories / totalWeight) * 100,
      source: fallbackIngredients.length > 0 ? 'estimated' : 'real',
      usesFallbackNutrition: fallbackIngredients.length > 0,
      fallbackIngredients: fallbackIngredients.length > 0 ? fallbackIngredients : undefined,
    };
  }

  // Fallback estimates
  return {
    protein: 25,
    fat: 15,
    fiber: 3,
    calcium: 0.8,
    phosphorus: 0.6,
    calories: 150,
    source: 'estimated',
  };
}

/**
 * Perfect path short-circuit: Check if recipe is a perfect match for a perfect pet
 */
function isPerfectMatch(recipe: Recipe, pet: Pet): boolean {
  // Pet must have no health concerns and no allergies
  if (pet.healthConcerns.length > 0) return false;
  if ((pet.allergies?.length ?? 0) > 0) return false;
  if (pet.dietaryRestrictions.length > 0) return false;
  
  // Recipe must match species
  if (!matchesSpecies(recipe, pet)) return false;
  
  // Recipe must match age group
  const petAgeGroup = pet.age < 1 ? 'baby' : pet.age < 2 ? 'young' : pet.age < 7 ? 'adult' : 'senior';
  if (!recipe.ageGroup || !recipe.ageGroup.includes(petAgeGroup)) {
    if (!recipe.ageGroup?.includes('all') && recipe.ageGroup && recipe.ageGroup.length > 0) {
      return false;
    }
  }
  
  // All ingredients must be safe for species
  const normalizedSpecies = normalizeSpecies(pet.type);
  const ingredients = recipe.ingredients || [];
  for (const ing of ingredients) {
    const ingName = typeof ing === 'string' ? ing : ing.name;
    const ingKey = ingName.toLowerCase().replace(/\s+/g, '_');
    const compat = getSpeciesCompatibility(ingKey, normalizedSpecies);
    if (compat === 'avoid') return false;
  }
  
  // Check for banned ingredients
  const bannedIngredients = (pet as any).bannedIngredients || [];
  if (bannedIngredients.length > 0) {
    const recipeIngNames = ingredients.map(ing => 
      (typeof ing === 'string' ? ing : ing.name).toLowerCase()
    );
    for (const banned of bannedIngredients) {
      if (recipeIngNames.some(name => name.includes(banned.toLowerCase()) || banned.toLowerCase().includes(name))) {
        return false;
      }
    }
  }
  
  // Recipe must meet OPTIMAL nutrient requirements (not just minimums)
  const nutrition = calculateRecipeNutrition(recipe);
  const petCategory = normalizedSpecies === 'dog' ? 'dogs' : 
                      normalizedSpecies === 'cat' ? 'cats' :
                      normalizedSpecies === 'bird' ? 'birds' :
                      normalizedSpecies === 'reptile' ? 'reptiles' : 'pocket-pets';
  const ageGroup = pet.age < 1 ? 'puppy' : pet.age >= 7 ? 'senior' : 'adult';
  const requirements = nutritionalGuidelines[petCategory]?.[ageGroup] || nutritionalGuidelines[petCategory]?.adult;
  
  if (requirements) {
    // Require nutrition to be in IDEAL range (middle 30% of min-max range - very strict for perfect match)
    if (requirements.protein) {
      const range = requirements.protein.max - requirements.protein.min;
      const idealMin = requirements.protein.min + (range * 0.35); // Middle 30% of range
      const idealMax = requirements.protein.max - (range * 0.35);
      if (nutrition.protein < idealMin || nutrition.protein > idealMax) {
        return false;
      }
    }
    if (requirements.fat) {
      const range = requirements.fat.max - requirements.fat.min;
      const idealMin = requirements.fat.min + (range * 0.35);
      const idealMax = requirements.fat.max - (range * 0.35);
      if (nutrition.fat < idealMin || nutrition.fat > idealMax) {
        return false;
      }
    }
    
    // Require Ca:P ratio to be in OPTIMAL range (1.4-1.7, very tight for perfect match)
    if (nutrition.calcium && nutrition.phosphorus && requirements.calcium && requirements.phosphorus) {
      const ratio = nutrition.calcium / nutrition.phosphorus;
      if (ratio < 1.4 || ratio > 1.7) {
        return false;
      }
    }
  }
  
  // Require NO fallback nutrition (100% data coverage required for perfect match)
  if (nutrition.usesFallbackNutrition) {
    return false; // Perfect matches must have complete nutritional data
  }
  
  // Require data coverage > 95% (not just "no fallback")
  const totalIngredients = ingredients.length;
  if (nutrition.fallbackIngredients && nutrition.fallbackIngredients.length > 0) {
    const coverage = ((totalIngredients - nutrition.fallbackIngredients.length) / totalIngredients) * 100;
    if (coverage < 95) {
      return false; // Must have >95% data coverage
    }
  }
  
  // Require all core nutrients in ideal bands (not just protein/fat)
  if (requirements) {
    // Check fiber if required
    if (requirements.fiber) {
      const range = requirements.fiber.max - requirements.fiber.min;
      const idealMin = requirements.fiber.min + (range * 0.35);
      const idealMax = requirements.fiber.max - (range * 0.35);
      if (nutrition.fiber < idealMin || nutrition.fiber > idealMax) {
        return false;
      }
    }
    // Check calcium if required
    if (requirements.calcium) {
      const range = requirements.calcium.max - requirements.calcium.min;
      const idealMin = requirements.calcium.min + (range * 0.35);
      const idealMax = requirements.calcium.max - (range * 0.35);
      if (nutrition.calcium < idealMin || nutrition.calcium > idealMax) {
        return false;
      }
    }
    // Check phosphorus if required
    if (requirements.phosphorus) {
      const range = requirements.phosphorus.max - requirements.phosphorus.min;
      const idealMin = requirements.phosphorus.min + (range * 0.35);
      const idealMax = requirements.phosphorus.max - (range * 0.35);
      if (nutrition.phosphorus < idealMin || nutrition.phosphorus > idealMax) {
        return false;
      }
    }
  }
  
  // Require ingredient quality to be above threshold (at least 85% - very strict for perfect match)
  const qualityScore = calculateIngredientQualityScore(recipe.ingredients || []);
  if (qualityScore.score < 85) {
    return false;
  }
  
  // Require sufficient ingredient diversity (at least 3 different ingredient types)
  const ingredientTypes = new Set<string>();
  for (const ing of ingredients) {
    const ingName = typeof ing === 'string' ? ing : ing.name;
    const ingKey = ingName.toLowerCase().replace(/\s+/g, '_');
    const compat = getSpeciesCompatibility(ingKey, normalizedSpecies);
    if (compat === 'ok') {
      // Categorize ingredient type
      if (ingKey.includes('chicken') || ingKey.includes('turkey') || ingKey.includes('beef') || 
          ingKey.includes('lamb') || ingKey.includes('fish') || ingKey.includes('salmon') ||
          ingKey.includes('pork') || ingKey.includes('duck') || ingKey.includes('organ') ||
          ingKey.includes('heart') || ingKey.includes('liver') || ingKey.includes('egg')) {
        ingredientTypes.add('protein');
      } else if (ingKey.includes('rice') || ingKey.includes('potato') || ingKey.includes('oats') ||
                 ingKey.includes('quinoa') || ingKey.includes('barley') || ingKey.includes('grain')) {
        ingredientTypes.add('carb');
      } else if (ingKey.includes('carrot') || ingKey.includes('broccoli') || ingKey.includes('spinach') ||
                 ingKey.includes('kale') || ingKey.includes('vegetable') || ingKey.includes('green')) {
        ingredientTypes.add('vegetable');
      } else if (ingKey.includes('blueberry') || ingKey.includes('apple') || ingKey.includes('fruit')) {
        ingredientTypes.add('fruit');
      } else if (ingKey.includes('oil') || ingKey.includes('fat') || ingKey.includes('supplement')) {
        ingredientTypes.add('supplement');
      }
    }
  }
  if (ingredientTypes.size < 3) {
    return false; // Need at least 3 different ingredient types
  }
  
  return true;
}

/**
 * Calculate bonus points for perfect matches
 */
export function calculateBonuses(recipe: Recipe, pet: Pet): number {
  let bonus = 0;
  
  // Exact species fit (reduced from 2 to 1)
  if (matchesSpecies(recipe, pet)) {
    bonus += 1;
  }
  
  // Exact life stage match (reduced from 2 to 1)
  const petAgeGroup = pet.age < 1 ? 'baby' : pet.age < 2 ? 'young' : pet.age < 7 ? 'adult' : 'senior';
  if (recipe.ageGroup?.includes(petAgeGroup) || recipe.ageGroup?.includes('all')) {
    bonus += 1;
  }
  
  // No allergens (reduced from 2 to 1)
  if ((pet.allergies?.length ?? 0) === 0 && pet.dietaryRestrictions.length === 0) {
    bonus += 1;
  } else {
    // Check if recipe avoids allergens
    const allAllergens = [...(pet.allergies || []), ...pet.dietaryRestrictions];
    const recipeIngNames = (recipe.ingredients || []).map(ing => 
      (typeof ing === 'string' ? ing : ing.name).toLowerCase()
    ).join(' ');
    const hasAllergen = allAllergens.some(a => recipeIngNames.includes(a.toLowerCase()));
    if (!hasAllergen) {
      bonus += 1;
    }
  }
  
  // No fallback nutritional data (reduced from 2 to 1)
  const nutrition = calculateRecipeNutrition(recipe);
  if (!nutrition.usesFallbackNutrition) {
    bonus += 1;
  }
  
  // Ideal nutrient ratios (reduced from 2 to 1)
  if (nutrition.calcium && nutrition.phosphorus) {
    const ratio = nutrition.calcium / nutrition.phosphorus;
    if (ratio >= 1.2 && ratio <= 2.0) {
      bonus += 1;
    }
  }
  
  // Complete ingredient data (check coverage) (reduced from 2 to 1)
  const totalIngredients = (recipe.ingredients || []).length;
  if (nutrition.fallbackIngredients) {
    const coverage = totalIngredients > 0 
      ? 1 - (nutrition.fallbackIngredients.length / totalIngredients)
      : 0;
    if (coverage >= 0.9) {
      bonus += 1;
    }
  } else if (totalIngredients > 0) {
    bonus += 1; // All ingredients have data
  }
  
  return Math.min(2, bonus); // Cap at 2% bonus (further reduced to prevent clustering at 100%)
}

/**
 * Convert score to letter grade
 */
export function getGrade(score: number): 'A+' | 'A' | 'B+' | 'B' | 'C+' | 'C' | 'D' | 'F' {
  if (score >= 95) return 'A+';
  if (score >= 90) return 'A';
  if (score >= 85) return 'B+';
  if (score >= 80) return 'B';
  if (score >= 75) return 'C+';
  if (score >= 70) return 'C';
  if (score >= 60) return 'D';
  return 'F';
}

/**
 * Scoring tier system for better UX
 */
export type ScoreTier = 'A+' | 'A' | 'B+' | 'B' | 'C+' | 'C' | 'D' | 'F';

export function getScoreTier(score: number): ScoreTier {
  if (score >= 95) return 'A+';
  if (score >= 90) return 'A';
  if (score >= 85) return 'B+';
  if (score >= 80) return 'B';
  if (score >= 75) return 'C+';
  if (score >= 70) return 'C';
  if (score >= 60) return 'D';
  return 'F';
}

/**
 * Check if recipe is gold-standard for a simple pet (perfect match criteria)
 */
export function isGoldStandardForSimplePet(recipe: Recipe, pet: Pet): boolean {
  // Species & age correct
  if (!matchesSpecies(recipe, pet)) return false;
  
  const petAgeGroup = pet.age < 1 ? 'baby' : pet.age < 2 ? 'young' : pet.age < 7 ? 'adult' : 'senior';
  if (!recipe.ageGroup || !recipe.ageGroup.includes(petAgeGroup)) {
    if (!recipe.ageGroup?.includes('all') && recipe.ageGroup && recipe.ageGroup.length > 0) {
      return false;
    }
  }
  
  // No allergens/never-feed ingredients
  const allAllergens = [...(pet.allergies || []), ...pet.dietaryRestrictions];
  if (allAllergens.length > 0) {
    const recipeIngNames = (recipe.ingredients || []).map(ing => 
      (typeof ing === 'string' ? ing : ing.name).toLowerCase()
    ).join(' ');
    const hasAllergen = allAllergens.some(a => recipeIngNames.includes(a.toLowerCase()));
    if (hasAllergen) return false;
  }
  
  // Check for banned ingredients
  const bannedIngredients = (pet as any).bannedIngredients || [];
  if (bannedIngredients.length > 0) {
    const recipeIngNames = (recipe.ingredients || []).map(ing => 
      (typeof ing === 'string' ? ing : ing.name).toLowerCase()
    );
    for (const banned of bannedIngredients) {
      if (recipeIngNames.some(name => name.includes(banned.toLowerCase()) || banned.toLowerCase().includes(name))) {
        return false;
      }
    }
  }
  
  // No health concerns OR recipe is neutral/beneficial
  if (pet.healthConcerns.length > 0) {
    const recipeNotSuitable = (recipe.notSuitableFor || []).map(c => normalizeHealthConcern(c));
    const petConcerns = pet.healthConcerns.map(c => normalizeHealthConcern(c));
    const hasConflict = recipeNotSuitable.some(ns => 
      petConcerns.some(pc => ns.includes(pc) || pc.includes(ns))
    );
    if (hasConflict) return false;
  }
  
  // Core nutrients within ideal bands
  const nutrition = calculateRecipeNutrition(recipe);
  const normalizedSpecies = normalizeSpecies(pet.type);
  const petCategory = normalizedSpecies === 'dog' ? 'dogs' : 
                      normalizedSpecies === 'cat' ? 'cats' :
                      normalizedSpecies === 'bird' ? 'birds' :
                      normalizedSpecies === 'reptile' ? 'reptiles' : 'pocket-pets';
  const ageGroup = pet.age < 1 ? 'puppy' : pet.age >= 7 ? 'senior' : 'adult';
  const requirements = nutritionalGuidelines[petCategory]?.[ageGroup] || nutritionalGuidelines[petCategory]?.adult;
  
  if (requirements) {
    if (requirements.protein) {
      if (nutrition.protein < requirements.protein.min || nutrition.protein > requirements.protein.max) {
        return false;
      }
    }
    if (requirements.fat) {
      if (nutrition.fat < requirements.fat.min || nutrition.fat > requirements.fat.max) {
        return false;
      }
    }
    
    // Ca:P ratio in safe range
    if (nutrition.calcium && nutrition.phosphorus && requirements.calcium && requirements.phosphorus) {
      const ratio = nutrition.calcium / nutrition.phosphorus;
      if (ratio < 1.0 || ratio > 2.5) return false;
    }
  }
  
  // No fallback nutrition (or confidence threshold met)
  if (nutrition.usesFallbackNutrition && nutrition.fallbackIngredients) {
    const totalIngredients = (recipe.ingredients || []).length;
    const confidence = totalIngredients > 0 
      ? 1 - (nutrition.fallbackIngredients.length / totalIngredients)
      : 0;
    if (confidence < 0.8) return false; // Require 80% data coverage
  }
  
  return true;
}

/**
 * Per-pet calibration: Rescale scores so best gold-standard recipe becomes 100%
 */
/**
 * Calibrate scores for a pet across multiple recipes
 * Rescales scores so the best perfect match becomes 95-100, or caps at 90-95 if no perfect matches
 * Preserves ranking while improving distribution
 */
export function calibrateScoresForPet(
  recipes: Recipe[],
  pet: Pet
): Map<string, number> {
  // Score all recipes
  const scored = recipes.map(recipe => ({
    recipe,
    rawScore: calculateEnhancedCompatibility(recipe, pet).overallScore,
    isPerfectMatch: isPerfectMatch(recipe, pet)
  }));
  
  // Find best perfect match recipe
  const perfectMatchRecipes = scored.filter(s => s.isPerfectMatch);
  const bestPerfectMatch = perfectMatchRecipes.length > 0
    ? perfectMatchRecipes.reduce((best, current) => 
        current.rawScore > best.rawScore ? current : best
      )
    : null;
  
  // If we have a perfect match recipe, rescale so it becomes 95-100
  if (bestPerfectMatch && bestPerfectMatch.rawScore > 0) {
    // Target: best perfect match should be 98 (allows room for variation)
    const targetScore = 98;
    const scaleFactor = targetScore / bestPerfectMatch.rawScore;
    const calibrated = new Map<string, number>();
    
    // Calculate mean and std dev for monotonic transform
    const scores = scored.map(s => s.rawScore);
    const mean = scores.reduce((a, b) => a + b, 0) / scores.length;
    const variance = scores.reduce((sum, score) => sum + Math.pow(score - mean, 2), 0) / scores.length;
    const stdDev = Math.sqrt(variance);
    
    scored.forEach(({ recipe, rawScore, isPerfectMatch }) => {
      // Rescale proportionally
      let calibratedScore = rawScore * scaleFactor;
      
      // Perfect matches can reach 100, others capped at 95
      if (isPerfectMatch) {
        calibratedScore = Math.min(100, calibratedScore);
      } else {
        calibratedScore = Math.min(95, calibratedScore);
      }
      
      calibrated.set(recipe.id, Math.max(0, Math.min(100, Math.round(calibratedScore))));
    });
    
    return calibrated;
  }
  
  // No perfect match found - cap top score at 90-95 to honestly reflect "no perfect match"
  const maxRawScore = Math.max(...scored.map(s => s.rawScore));
  const calibrated = new Map<string, number>();
  
  if (maxRawScore > 0) {
    // Rescale so max becomes 92 (honest "no perfect match" ceiling)
    const scaleFactor = 92 / maxRawScore;
    
    scored.forEach(({ recipe, rawScore }) => {
      const calibratedScore = rawScore * scaleFactor;
      calibrated.set(recipe.id, Math.max(0, Math.min(92, Math.round(calibratedScore))));
    });
  } else {
    // All scores are 0 - return as-is
    scored.forEach(({ recipe, rawScore }) => {
      calibrated.set(recipe.id, rawScore);
    });
  }
  
  return calibrated;
}

/**
 * Calculate enhanced compatibility with per-pet calibration applied
 * This is a convenience function that scores a single recipe but applies calibration
 * if a recipe set is provided. For batch operations, use calibrateScoresForPet() directly.
 */
export function calculateEnhancedCompatibilityWithCalibration(
  recipe: Recipe,
  pet: Pet,
  allRecipes?: Recipe[]
): EnhancedCompatibilityScore {
  const rawScore = calculateEnhancedCompatibility(recipe, pet);
  
  // If all recipes provided, apply calibration
  if (allRecipes && allRecipes.length > 1) {
    const calibratedScores = calibrateScoresForPet(allRecipes, pet);
    const calibratedScore = calibratedScores.get(recipe.id);
    
    if (calibratedScore !== undefined) {
      // Return score with calibrated overallScore
      return {
        ...rawScore,
        overallScore: calibratedScore,
        grade: getGrade(calibratedScore),
      };
    }
  }
  
  return rawScore;
}
</file>

<file path="lib/utils/errorHandler.ts">
// lib/utils/errorHandler.ts
// Centralized error handling utilities

export class AppError extends Error {
  constructor(
    message: string,
    public code: string,
    public statusCode: number = 500,
    public isOperational: boolean = true
  ) {
    super(message);
    this.name = 'AppError';
    Error.captureStackTrace(this, this.constructor);
  }
}

export class DatabaseError extends AppError {
  constructor(message: string, originalError?: Error) {
    super(message, 'DATABASE_ERROR', 500);
    this.name = 'DatabaseError';
    if (originalError) {
      this.stack = originalError.stack;
    }
  }
}

export class ValidationError extends AppError {
  constructor(message: string, public fields?: Record<string, string>) {
    super(message, 'VALIDATION_ERROR', 400);
    this.name = 'ValidationError';
  }
}

export class AuthenticationError extends AppError {
  constructor(message: string = 'Authentication required') {
    super(message, 'AUTH_ERROR', 401);
    this.name = 'AuthenticationError';
  }
}

/**
 * Handle errors consistently across the app
 */
export function handleError(error: unknown): AppError {
  console.error('Error occurred:', error);
  
  if (error instanceof AppError) {
    return error;
  }
  
  if (error instanceof Error) {
    // Firebase errors
    if (error.message.includes('permission-denied')) {
      return new AuthenticationError('You don\'t have permission to access this resource');
    }
    
    if (error.message.includes('not-found')) {
      return new AppError('Resource not found', 'NOT_FOUND', 404);
    }
    
    if (error.message.includes('already-exists')) {
      return new ValidationError('Resource already exists');
    }
    
    // Network errors
    if (error.message.includes('network')) {
      return new AppError('Network error. Please check your connection.', 'NETWORK_ERROR', 503);
    }
    
    // Generic error
    return new AppError(
      error.message || 'An unexpected error occurred',
      'UNKNOWN_ERROR',
      500,
      false
    );
  }
  
  return new AppError('An unexpected error occurred', 'UNKNOWN_ERROR', 500, false);
}

/**
 * Log error to external service (e.g., Sentry)
 */
export function logError(error: Error | AppError, context?: Record<string, any>) {
  // In production, send to error tracking service
  if (process.env.NODE_ENV === 'production') {
    // TODO: Integrate with Sentry or similar
    console.error('Production error:', { error, context });
  } else {
    console.error('Development error:', error, context);
  }
}

/**
 * Toast-friendly error message
 */
export function getErrorMessage(error: unknown): string {
  if (error instanceof AppError) {
    return error.message;
  }
  
  if (error instanceof Error) {
    return error.message;
  }
  
  return 'An unexpected error occurred. Please try again.';
}
</file>

<file path="lib/utils/firebaseConfig.ts">
// lib/utils/firebaseConfig.ts
// Firebase configuration and initialization with proper error handling

import { initializeApp, type FirebaseApp, getApps } from 'firebase/app';
import { getFirestore, type Firestore, connectFirestoreEmulator } from 'firebase/firestore';
import { getAuth, type Auth, connectAuthEmulator } from 'firebase/auth';

// Firebase configuration from environment variables
const firebaseConfig = {
  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,
};

let app: FirebaseApp | null = null;
let db: Firestore | null = null;
let auth: Auth | null = null;
let initializationError: Error | null = null;

/**
 * Check if Firebase is properly configured
 */
function isFirebaseConfigured(): boolean {
  return !!(
    firebaseConfig.apiKey &&
    firebaseConfig.authDomain &&
    firebaseConfig.projectId
  );
}

/**
 * Initialize Firebase services
 * Returns null if Firebase is not configured
 */
export function initializeFirebase(): { app: FirebaseApp; db: Firestore; auth: Auth } | null {
  // Server-side check
  if (typeof window === 'undefined') return null;
  
  // Return existing instance
  if (app && db && auth) {
    return { app, db, auth };
  }
  
  try {
    // Check if Firebase is configured
    if (!isFirebaseConfigured()) {
      console.warn('Firebase not configured - using localStorage fallback');
      return null;
    }
    
    // Use existing app or initialize new one
    if (getApps().length === 0) {
      app = initializeApp(firebaseConfig);
    } else {
      app = getApps()[0];
    }
    
    // Initialize Firestore
    db = getFirestore(app);
    
    // Initialize Auth
    auth = getAuth(app);
    
    // Connect to emulators in development
    if (process.env.NODE_ENV === 'development' && process.env.NEXT_PUBLIC_USE_FIREBASE_EMULATOR === 'true') {
      try {
        connectFirestoreEmulator(db, 'localhost', 8080);
        connectAuthEmulator(auth, 'http://localhost:9099', { disableWarnings: true });
        console.log('Connected to Firebase emulators');
      } catch (e) {
        // Emulators already connected or not available
      }
    }
    
    return { app, db, auth };
  } catch (error) {
    initializationError = error as Error;
    console.error('Firebase initialization failed:', error);
    return null;
  }
}

/**
 * Get Firebase services (initializes if needed)
 */
export function getFirebaseServices(): { app: FirebaseApp; db: Firestore; auth: Auth } | null {
  if (app && db && auth) {
    return { app, db, auth };
  }
  return initializeFirebase();
}

/**
 * Get app ID from environment
 */
export function getAppId(): string {
  return process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID || 'pet-plates-app';
}

/**
 * Check if Firebase is available
 */
export function isFirebaseAvailable(): boolean {
  return getFirebaseServices() !== null;
}

/**
 * Get initialization error if any
 */
export function getInitializationError(): Error | null {
  return initializationError;
}
</file>

<file path="lib/utils/getAmazonBuyLink.ts">
// Runtime Amazon link finalizer - ensures all buy links are safe before display
// This is the ONLY function that should be used to get Amazon links in the UI

import { ensureSellerId, isValidAmazonUrl, extractASIN } from './affiliateLinks';

export type Region = 'US' | 'UK' | 'DE' | 'AU';

export interface BuyLinkResult {
  url: string | null;
  status: 'ok' | 'missing' | 'invalid' | 'region-unavailable';
  asin?: string;
}

/**
 * Runtime finalizer for Amazon buy links.
 * Guarantees:
 * - Affiliate tag is present (tag=robinfrench-20)
 * - URL is valid Amazon URL
 * - ASIN can be extracted (proves it's a product link, not search)
 * 
 * Returns null if link is broken/invalid - UI should handle gracefully.
 * 
 * @param rawUrl The raw Amazon URL from data files
 * @param region User's region (default: US)
 * @returns Finalized URL with affiliate tag, or null if invalid
 */
export function getAmazonBuyLink(
  rawUrl: string | undefined | null,
  region: Region = 'US'
): string | null {
  if (!rawUrl) return null;
  
  // Validate it's an Amazon URL
  if (!isValidAmazonUrl(rawUrl)) return null;
  
  // Extract ASIN to verify it's a product link (not a search)
  const asin = extractASIN(rawUrl);
  if (!asin) {
    // No ASIN means it's a search URL or malformed - reject it
    return null;
  }
  
  // Add affiliate tag
  const withTag = ensureSellerId(rawUrl);
  
  // Re-validate after mutation (defensive)
  if (!isValidAmazonUrl(withTag)) return null;
  
  return withTag;
}

/**
 * Extended version that returns detailed status for debugging.
 * Use this in admin/debug views to see why links are failing.
 */
export function getAmazonBuyLinkWithStatus(
  rawUrl: string | undefined | null,
  region: Region = 'US'
): BuyLinkResult {
  if (!rawUrl) {
    return { url: null, status: 'missing' };
  }
  
  if (!isValidAmazonUrl(rawUrl)) {
    return { url: null, status: 'invalid' };
  }
  
  const asin = extractASIN(rawUrl);
  if (!asin) {
    return { url: null, status: 'invalid' };
  }
  
  // TODO: Add region-specific validation when we support multi-region
  // For now, all links are US-only
  if (region !== 'US') {
    return { url: null, status: 'region-unavailable', asin };
  }
  
  const withTag = ensureSellerId(rawUrl);
  
  if (!isValidAmazonUrl(withTag)) {
    return { url: null, status: 'invalid', asin };
  }
  
  return { url: withTag, status: 'ok', asin };
}

/**
 * Fallback: Generate Amazon search link if no specific product link exists.
 * Only use this if you explicitly decide to allow generic searches (Policy B).
 * 
 * @param query Search query (e.g., ingredient name + brand)
 * @param region User's region
 * @returns Amazon search URL with affiliate tag
 */
export function getFallbackAmazonSearchLink(
  query: string,
  region: Region = 'US'
): string {
  const base = region === 'US' ? 'https://www.amazon.com/s' : 'https://www.amazon.co.uk/s';
  const url = `${base}?k=${encodeURIComponent(query)}`;
  return ensureSellerId(url);
}
</file>

<file path="lib/utils/healthConcernMatching.ts">
// lib/utils/healthConcernMatching.ts
// Health concern matching system for tiered scoring

export interface HealthConcernBenefits {
  beneficialIngredients: string[];
  avoidIngredients: string[];
  targetMacros?: {
    protein?: 'low' | 'moderate' | 'high';
    fat?: 'low' | 'moderate' | 'high' | 'very-low';
    fiber?: 'low' | 'moderate' | 'high';
    phosphorus?: 'low' | 'moderate' | 'high';
  };
  targetRatios?: {
    caP?: { min: number; max: number };
  };
}

export const HEALTH_CONCERN_BENEFITS: Record<string, HealthConcernBenefits> = {
  'kidney-disease': {
    beneficialIngredients: ['egg-whites', 'white-rice', 'fish-oil', 'low-phosphorus-vegetables', 'sweet-potato'],
    avoidIngredients: ['organ-meats', 'high-phosphorus-foods', 'excess-sodium', 'red-meat'],
    targetMacros: {
      protein: 'low',
      phosphorus: 'low',
      fat: 'moderate',
    },
  },
  'pancreatitis': {
    beneficialIngredients: ['lean-turkey', 'white-fish', 'sweet-potato', 'pumpkin', 'low-fat-protein'],
    avoidIngredients: ['high-fat-meats', 'oils', 'fried-foods', 'fatty-fish', 'pork'],
    targetMacros: {
      fat: 'very-low',
      fiber: 'high',
      protein: 'moderate',
    },
  },
  'allergies': {
    beneficialIngredients: ['novel-proteins', 'fish-oil', 'anti-inflammatory-foods'],
    avoidIngredients: ['common-allergens'], // Will be replaced with pet-specific allergens
    targetMacros: {
      protein: 'moderate',
    },
  },
  'weight-management': {
    beneficialIngredients: ['lean-protein', 'high-fiber-vegetables', 'pumpkin', 'green-beans'],
    avoidIngredients: ['high-calorie-foods', 'excess-fat'],
    targetMacros: {
      fat: 'low',
      fiber: 'high',
      protein: 'moderate',
    },
  },
  'digestive-health': {
    beneficialIngredients: ['pumpkin', 'sweet-potato', 'probiotic-foods', 'fiber-rich-vegetables'],
    avoidIngredients: ['irritating-foods', 'high-fat'],
    targetMacros: {
      fiber: 'high',
      fat: 'moderate',
    },
  },
  'joint-mobility': {
    beneficialIngredients: ['fish-oil', 'omega-3-sources', 'glucosamine-sources', 'anti-inflammatory-foods'],
    avoidIngredients: ['high-purine-foods'],
    targetMacros: {
      fat: 'moderate',
    },
  },
  'skin-coat': {
    beneficialIngredients: ['fish-oil', 'omega-3-sources', 'vitamin-e-sources', 'healthy-fats'],
    avoidIngredients: ['low-quality-fats'],
    targetMacros: {
      fat: 'moderate',
    },
  },
  'dental-health': {
    beneficialIngredients: ['crunchy-vegetables', 'dental-chews', 'raw-bones'],
    avoidIngredients: ['sticky-foods', 'sugary-foods'],
    targetMacros: {},
  },
  'urinary-support': {
    beneficialIngredients: ['moisture-rich-foods', 'low-magnesium-foods', 'cranberry'],
    avoidIngredients: ['high-magnesium-foods', 'excess-minerals'],
    targetMacros: {
      protein: 'moderate',
    },
  },
  'diabetes': {
    beneficialIngredients: ['low-glycemic-vegetables', 'high-fiber-foods', 'lean-protein'],
    avoidIngredients: ['high-sugar-foods', 'simple-carbohydrates'],
    targetMacros: {
      fiber: 'high',
      fat: 'moderate',
      protein: 'moderate',
    },
  },
  'heart-disease': {
    beneficialIngredients: ['omega-3-sources', 'low-sodium-foods', 'lean-protein'],
    avoidIngredients: ['high-sodium-foods', 'excess-fat'],
    targetMacros: {
      fat: 'low',
      protein: 'moderate',
    },
  },
};

/**
 * Normalize health concern name for matching
 */
export function normalizeHealthConcern(concern: string): string {
  return concern
    .toLowerCase()
    .replace(/\s+/g, '-')
    .replace(/[^a-z0-9-]/g, '');
}

/**
 * Get health concern benefits data
 */
export function getHealthConcernBenefits(concern: string): HealthConcernBenefits | null {
  const normalized = normalizeHealthConcern(concern);
  return HEALTH_CONCERN_BENEFITS[normalized] || null;
}

/**
 * Check if an ingredient name matches a beneficial ingredient
 */
export function isBeneficialIngredient(ingredientName: string, beneficialList: string[]): boolean {
  const normalized = ingredientName.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
  return beneficialList.some(beneficial => {
    const normalizedBeneficial = beneficial.toLowerCase().replace(/\s+/g, '-');
    return normalized.includes(normalizedBeneficial) || normalizedBeneficial.includes(normalized);
  });
}

/**
 * Check if an ingredient name matches an avoid ingredient
 */
export function isAvoidIngredient(ingredientName: string, avoidList: string[], petAllergies?: string[]): boolean {
  const normalized = ingredientName.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
  
  // Check against avoid list
  const matchesAvoid = avoidList.some(avoid => {
    if (avoid === 'common-allergens' && petAllergies) {
      // Check against pet's specific allergies
      return petAllergies.some(allergy => 
        normalized.includes(allergy.toLowerCase()) || 
        allergy.toLowerCase().includes(normalized)
      );
    }
    const normalizedAvoid = avoid.toLowerCase().replace(/\s+/g, '-');
    return normalized.includes(normalizedAvoid) || normalizedAvoid.includes(normalized);
  });
  
  return matchesAvoid;
}

/**
 * Check macro alignment with target macros
 */
export function checkMacroAlignment(
  nutrition: { protein: number; fat: number; fiber: number; phosphorus?: number },
  targetMacros?: HealthConcernBenefits['targetMacros']
): number {
  if (!targetMacros) return 50; // Neutral if no targets
  
  let alignmentScore = 0;
  let factors = 0;
  
  if (targetMacros.protein) {
    factors++;
    if (targetMacros.protein === 'low' && nutrition.protein < 20) alignmentScore += 30;
    else if (targetMacros.protein === 'moderate' && nutrition.protein >= 20 && nutrition.protein <= 30) alignmentScore += 30;
    else if (targetMacros.protein === 'high' && nutrition.protein > 30) alignmentScore += 30;
    else alignmentScore += 10; // Partial alignment
  }
  
  if (targetMacros.fat) {
    factors++;
    if (targetMacros.fat === 'very-low' && nutrition.fat < 8) alignmentScore += 30;
    else if (targetMacros.fat === 'low' && nutrition.fat < 12) alignmentScore += 30;
    else if (targetMacros.fat === 'moderate' && nutrition.fat >= 12 && nutrition.fat <= 18) alignmentScore += 30;
    else if (targetMacros.fat === 'high' && nutrition.fat > 18) alignmentScore += 30;
    else alignmentScore += 10;
  }
  
  if (targetMacros.fiber) {
    factors++;
    if (targetMacros.fiber === 'low' && nutrition.fiber < 5) alignmentScore += 30;
    else if (targetMacros.fiber === 'moderate' && nutrition.fiber >= 5 && nutrition.fiber <= 10) alignmentScore += 30;
    else if (targetMacros.fiber === 'high' && nutrition.fiber > 10) alignmentScore += 30;
    else alignmentScore += 10;
  }
  
  if (targetMacros.phosphorus && nutrition.phosphorus !== undefined) {
    factors++;
    if (targetMacros.phosphorus === 'low' && nutrition.phosphorus < 0.6) alignmentScore += 30;
    else if (targetMacros.phosphorus === 'moderate' && nutrition.phosphorus >= 0.6 && nutrition.phosphorus <= 1.0) alignmentScore += 30;
    else if (targetMacros.phosphorus === 'high' && nutrition.phosphorus > 1.0) alignmentScore += 30;
    else alignmentScore += 10;
  }
  
  return factors > 0 ? alignmentScore / factors : 50;
}
</file>

<file path="lib/utils/imageMapping.ts">
// Utility functions for image mapping and emoji groups
import { imageManifest, healthConcernStyles, petCategoryStyles, type ImageGroup } from '@/lib/data/imageManifest';

export type ImageVariant = keyof ImageGroup['variants'];

/**
 * Get the image group key for a given emoji
 */
export function getEmojiGroup(emoji: string): string | null {
  for (const [groupKey, group] of Object.entries(imageManifest)) {
    if (group.emojis.includes(emoji)) {
      return groupKey;
    }
  }
  return null;
}

/**
 * Get the image path for a specific emoji and variant
 */
export function getEmojiImagePath(emoji: string, variant: ImageVariant): string | null {
  const groupKey = getEmojiGroup(emoji);
  if (!groupKey) return null;

  const group = imageManifest[groupKey];
  const variantFile = group.variants[variant as keyof typeof group.variants];

  // Assuming images are in /assets/images/animals/{group}/
  return `/assets/images/animals/${groupKey}/${variantFile}`;
}

/**
 * Get the master icon path for an emoji group
 */
export function getMasterIconPath(groupKey: string): string | null {
  const group = imageManifest[groupKey];
  return group ? group.masterIcon : null;
}

/**
 * Get the master hero path for an emoji group
 */
export function getMasterHeroPath(groupKey: string): string | null {
  const group = imageManifest[groupKey];
  return group ? group.masterHero : null;
}

/**
 * Get health concern style information
 */
export function getHealthConcernStyle(concern: string) {
  return healthConcernStyles[concern] || null;
}

/**
 * Get pet category style information
 */
export function getPetCategoryStyle(category: string) {
  return petCategoryStyles[category] || null;
}

/**
 * Get all emojis in a group
 */
export function getGroupEmojis(groupKey: string): string[] {
  const group = imageManifest[groupKey];
  return group ? group.emojis : [];
}

/**
 * Get all available groups
 */
export function getAllGroups(): string[] {
  return Object.keys(imageManifest);
}

/**
 * Check if an emoji is supported
 */
export function isEmojiSupported(emoji: string): boolean {
  return getEmojiGroup(emoji) !== null;
}
</file>

<file path="lib/utils/improvedCompatibilityScoring.ts">
// lib/utils/improvedCompatibilityScoring.ts
// Improved compatibility scoring with more accuracy and score variation.

import type { Recipe } from '@/lib/types';
import { getIngredientComposition } from '@/lib/data/ingredientCompositions';
import {
  normalizeSpecies,
  getSpeciesCompatibility,
  getMaxInclusionPercent,
} from './ingredientCompatibility';
import { validateCriticalNutrients } from '@/lib/data/aafco-standards';

// -------- Config for quick tuning -------- //
const SCORE_CONFIG = {
  weights: {
    ingredientSafety: 0.20,
    nutritionalAdequacy: 0.26,
    healthAlignment: 0.14,
    lifeStageFit: 0.10,
    allergenSafety: 0.10,
    digestibility: 0.08,
    variety: 0.12,
  },
  safeFloor: 65, // applied if ingredientSafety >= 60 && allergenSafety >= 60
  jitter: {
    low: 0.4,
    mid: 0.3,
    high: 0.2,
  },
  normalize: {
    topKeep: 95,
    topBand: 85,
    midBand: 70,
    lift50: 1.02,
    lift30: 1.05,
    liftLow: 1.08,
  },
  debug: process.env.NEXT_PUBLIC_SCORE_DEBUG === 'true',
};

export interface ImprovedPet {
  id: string;
  name: string;
  type: string; // accepts dogs/cats/birds/reptiles/pocket-pets
  breed?: string;
  age?: string | number;
  weight?: number;
  activityLevel?: 'sedentary' | 'moderate' | 'active' | 'very-active';
  healthConcerns: string[];
  dietaryRestrictions?: string[];
  allergies?: string[];
}

export interface ImprovedScore {
  overallScore: number; // 0-100
  stars: number; // 1-5
  recommendation?: 'excellent' | 'good' | 'acceptable' | 'caution' | 'avoid';
  summaryReasoning?: string;
  factors: {
    ingredientSafety: number;
    nutritionalAdequacy: number;
    healthAlignment: number;
    lifeStageFit: number;
    allergenSafety: number;
    digestibility: number;
    variety: number;
  };
  reasoning: {
    strengths: string[];
    warnings: string[];
    recommendations: string[];
  };
}

/**
 * Entry point: calculate improved compatibility score with better distribution.
 */
export function calculateImprovedCompatibility(
  recipe: Recipe,
  pet: ImprovedPet
): ImprovedScore {
  const species = normalizeSpecies(pet.type);
  const ageNum = typeof pet.age === 'string' ? parseFloat(pet.age) || 0 : pet.age || 0;

  const ingredientSafety = scoreIngredientSafety(recipe, species);
  const nutritionalAdequacy = scoreNutritionalAdequacy(recipe, pet, species, ageNum);
  const healthAlignment = scoreHealthAlignment(recipe, pet);
  const lifeStageFit = scoreLifeStageFit(recipe, ageNum);
  const allergenSafety = scoreAllergenSafety(recipe, pet);
  const digestibility = scoreDigestibility(recipe, species);
  const variety = scoreIngredientVariety(recipe);

  const weighted =
    ingredientSafety * SCORE_CONFIG.weights.ingredientSafety +
    nutritionalAdequacy * SCORE_CONFIG.weights.nutritionalAdequacy +
    healthAlignment * SCORE_CONFIG.weights.healthAlignment +
    lifeStageFit * SCORE_CONFIG.weights.lifeStageFit +
    allergenSafety * SCORE_CONFIG.weights.allergenSafety +
    digestibility * SCORE_CONFIG.weights.digestibility +
    variety * SCORE_CONFIG.weights.variety;

  const normalized = normalizeScore(weighted);
  const variation = applyControlledVariation(normalized);
  const safeFloor =
    ingredientSafety >= 60 && allergenSafety >= 60 ? SCORE_CONFIG.safeFloor : 0; // keep safe recipes from tanking
  const finalScore = clamp(
    Number(Math.max(normalized + variation, safeFloor).toFixed(1)),
    0,
    100
  );

  const strengths: string[] = [];
  const warnings: string[] = [];
  const recommendations: string[] = [];

  if (ingredientSafety >= 90) strengths.push('All ingredients are species-safe');
  if (nutritionalAdequacy < 60) {
    warnings.push('Recipe has nutritional gaps');
    recommendations.push('Add supplements or adjust ingredients for balance');
  }
  if (healthAlignment >= 80) strengths.push('Supports key health concerns');
  if (allergenSafety < 100) warnings.push('Contains known allergens');

  const { stars, recommendation, summaryReasoning } = mapScoreToStarsWithReasoning(finalScore, {
    ingredientSafety,
    nutritionalAdequacy,
    healthAlignment,
    lifeStageFit,
    allergenSafety,
    digestibility,
  });

  if (SCORE_CONFIG.debug) {
    console.log('[ScoreDebug]', {
      recipe: recipe.name,
      finalScore,
      normalized,
      variation,
      safeFloor,
      factors: {
        ingredientSafety,
        nutritionalAdequacy,
        healthAlignment,
        lifeStageFit,
        allergenSafety,
        digestibility,
        variety,
      },
    });
  }

  return {
    overallScore: finalScore,
    stars,
    recommendation,
    summaryReasoning,
    factors: {
      ingredientSafety,
      nutritionalAdequacy,
      healthAlignment,
      lifeStageFit,
      allergenSafety,
      digestibility,
      variety,
    },
    reasoning: { strengths, warnings, recommendations },
  };
}

// ------------------ Factor Calculations ------------------ //

function scoreIngredientSafety(recipe: Recipe, species: string): number {
  const ingredients = recipe.ingredients || [];
  if (!ingredients.length) return 85;

  let score = 85;
  let avoidCount = 0;
  let unknownCount = 0;

  for (const ing of ingredients) {
    const name = typeof ing === 'string' ? ing : ing.name;
    const amount = typeof ing === 'string'
      ? 100
      : ing.amount
      ? parseFloat(String(ing.amount).replace(/[^0-9.]/g, '')) || 0
      : 0;

    const key = name.toLowerCase().replace(/\s+/g, '_');
    const compat = getSpeciesCompatibility(key, species);

    if (compat === 'avoid') {
      avoidCount++;
      score -= 25;
    } else if (compat === 'limit' || compat === 'caution') {
      const maxInclusion = getMaxInclusionPercent(key, species);
      if (maxInclusion && amount / 100 > maxInclusion) {
        score -= 18;
      } else {
        score -= 12;
      }
    } else if (compat === 'ok') {
      // mildly reward clear safe ingredients
      score += 1.5;
    } else {
      // Unknown ingredient: minor uncertainty
      unknownCount++;
      score -= 3;
    }
  }

  if (avoidCount > 1) {
    score -= avoidCount * 6; // gentle compounding
  }

  const unknownRatio = ingredients.length ? unknownCount / ingredients.length : 0;
  if (unknownRatio > 0.5) {
    score -= 10;
  }

  if (avoidCount > 0) {
    score = Math.min(score, 40); // still keep avoids meaningful
  } else if (unknownCount === 0) {
    // Safety floor for clean recipes
    score = Math.max(score, 80);
  }

  return clamp(score, 0, 100);
}

function scoreNutritionalAdequacy(
  recipe: Recipe,
  pet: ImprovedPet,
  species: string,
  ageNum: number
): number {
  let score = 90;
  const nutrition = calcNutrition(recipe);

  if (species === 'dog' || species === 'cat') {
    const lifeStage = ageNum < 1 ? 'growth' : 'adult';
    const validation = validateCriticalNutrients(
      recipe,
      species as 'dog' | 'cat',
      lifeStage
    );
    if (!validation.isValid) {
      const basePenalty = Math.min(validation.violations.length * 8, 40);
      const severe = validation.violations.some(v =>
        v.toLowerCase().includes('critical') || v.toLowerCase().includes('essential')
      );
      score -= basePenalty * (severe ? 1.3 : 1);
    }

    const minProtein = lifeStage === 'growth' ? 22 : 18;
    if (nutrition.protein < minProtein) {
      const deficit = minProtein - nutrition.protein;
      const proteinPenalty = Math.min(Math.pow(deficit, 1.3) * 1.5, 30);
      score -= proteinPenalty;
    }

    if (nutrition.calcium && nutrition.phosphorus) {
      const ratio = nutrition.calcium / nutrition.phosphorus;
      if (ratio < 1.0 || ratio > 2.5) {
        const deviation = ratio < 1.0 ? 1.0 - ratio : ratio - 2.5;
        score -= Math.min(deviation * 15, 20);
      }
    }
  } else {
    // Heuristics for non-dog/cat species
    switch (species) {
      case 'bird': {
        if (nutrition.calcium && nutrition.phosphorus) {
          const ratio = nutrition.calcium / nutrition.phosphorus;
          if (ratio < 1.5 || ratio > 2.5) {
            const deviation = ratio < 1.5 ? 1.5 - ratio : ratio - 2.5;
            score -= Math.min(deviation * 25, 30);
          }
        }
        
        const breed = (pet.breed || '').toLowerCase();
        // Macaws and African Greys need higher fat (nuts)
        const highFatNeeds = ['macaw', 'grey', 'african grey'].some(b => breed.includes(b));
        
        if (highFatNeeds) {
           if (nutrition.fat < 10) score -= 10; // Penalty for low fat in large parrots
        } else {
           // Small birds (parakeets)
           if (nutrition.fat > 12) score -= 5; // Penalty for too much fat
        }

        if ((recipe.ingredients || []).length < 3) {
          score -= 5;
        }
        break;
      }
      case 'reptile': {
        if (nutrition.calcium && nutrition.phosphorus) {
          const ratio = nutrition.calcium / nutrition.phosphorus;
          if (ratio < 1.5) {
            const deviation = 1.5 - ratio;
            score -= Math.min(deviation * 25, 30);
          }
        }
        // Expanded Herbivore/carnivore heuristic
        const breed = (pet.breed || '').toLowerCase();
        const herbivore = ['iguana', 'tortoise', 'uromastyx'].some(b => breed.includes(b));
        // Add 'boa', 'python', 'king' for snakes
        const carnivore = ['snake', 'monitor', 'tegu', 'boa', 'python', 'king'].some(b => breed.includes(b));
        
        if (herbivore && nutrition.protein > 25) score -= 12;
        // Carnivores need HIGH protein
        if (carnivore) {
            if (nutrition.protein < 30) score -= 15;
            if (nutrition.fat < 10) score -= 5;
        } 
        break;
      }
      case 'pocket-pet': {
        const breed = (pet.breed || '').toLowerCase();
        
        // Check Ca:P ratio (critical for all pocket-pets)
        if (nutrition.calcium && nutrition.phosphorus) {
          const ratio = nutrition.calcium / nutrition.phosphorus;
          if (ratio < 1.5 || ratio > 2.5) {
            const deviation = ratio < 1.5 ? 1.5 - ratio : ratio - 2.5;
            score -= Math.min(deviation * 20, 25);
          }
        }
        
        // Sugar gliders & omnivores need less fiber than rabbits
        const isLowFiber = ['sugar', 'glider', 'hamster', 'rat', 'mouse', 'ferret'].some(b => breed.includes(b));
        const isHayEater = ['rabbit', 'guinea', 'chinchilla'].some(b => breed.includes(b));
        
        if (isLowFiber) {
            // They need protein/fruit, not hay
            if (nutrition.fiber > 10) score -= 8; // Increased penalty
            if (nutrition.protein < 12) score -= 15; // Increased penalty
            // Ferrets are obligate carnivores - need very high protein
            if (breed.includes('ferret') && nutrition.protein < 30) {
              score -= 20;
            }
        } else if (isHayEater) {
            // Rabbits/Guinea Pigs (Hay eaters) - need high fiber
            if (nutrition.fiber < 15) {
              score -= Math.min((15 - nutrition.fiber) * 2.5, 25); // Increased penalty
            }
            if (nutrition.protein > 20) {
              score -= Math.min((nutrition.protein - 20) * 2, 20);
            }
        } else {
            // Generic pocket-pet validation
            if (nutrition.protein < 10) score -= 12;
            if (nutrition.fiber > 20) score -= 8;
        }
        break;
      }
      default:
        // Unknown species - apply basic validation
        if (nutrition.protein < 10) {
          score -= 10;
        }
        if (nutrition.calcium && nutrition.phosphorus) {
          const ratio = nutrition.calcium / nutrition.phosphorus;
          if (ratio < 1.0 || ratio > 3.0) {
            score -= 15;
          }
        }
        break;
    }
  }

  // Data quality penalty for limited nutrition info (softer)
  if (!nutrition.hasData) {
    score -= 15;
  } else if (nutrition.dataPoints !== undefined && nutrition.totalIngredients !== undefined) {
    const coverage = nutrition.totalIngredients
      ? (nutrition.dataPoints / nutrition.totalIngredients) * 100
      : 0;
    if (coverage < 30) {
      score -= 20;
    } else if (coverage < 50) {
      score -= 12;
    } else if (coverage < 70) {
      score -= 5;
    }
  }

  return clamp(score, 0, 100);
}

function scoreHealthAlignment(recipe: Recipe, pet: ImprovedPet): number {
  const petConcernsArr = pet.healthConcerns || [];
  if (!petConcernsArr.length) return 90;

  const recipeConcerns = (recipe.healthConcerns || []).map(c => c.toLowerCase());
  const notSuitable = (recipe.notSuitableFor || []).map(c => c.toLowerCase());
  const petConcerns = petConcernsArr.map(c => c.toLowerCase().replace(/\s+/g, '-'));

  const critical = ['kidney-disease', 'diabetes', 'heart-disease', 'pancreatitis'];
  const important = ['allergies', 'digestive-issues', 'urinary-health'];

  let weighted = 0;
  const maxScore = petConcerns.length * 20 || 1;

  for (const concern of petConcerns) {
    const isCritical = critical.some(c => concern.includes(c));
    const isImportant = important.some(c => concern.includes(c));

    const blocked = notSuitable.some(ns => ns.includes(concern) || concern.includes(ns));
    if (blocked) {
      weighted -= isCritical ? 25 : 15;
      continue;
    }

    const supports = recipeConcerns.some(rc => rc.includes(concern) || concern.includes(rc));
    if (supports) {
      weighted += isCritical ? 15 : isImportant ? 12 : 10;
    } else {
      weighted -= isImportant ? 5 : 3;
    }
  }

  const base = 75;
  const score = base + (weighted / maxScore) * 25;
  return clamp(score, 0, 100);
}

function scoreLifeStageFit(recipe: Recipe, ageNum: number): number {
  const petAgeGroup = ageNum < 1 ? 'baby' : ageNum < 2 ? 'young' : ageNum < 7 ? 'adult' : 'senior';
  const groups = recipe.ageGroup || [];
  if (groups.length === 0 || groups.includes('all')) return 100;
  if (groups.includes(petAgeGroup)) return 100;

  const order = ['baby', 'young', 'adult', 'senior'];
  const petIdx = order.indexOf(petAgeGroup);
  const recipeIdxs = groups.map(g => order.indexOf(g)).filter(i => i >= 0);
  if (!recipeIdxs.length) return 60;
  const distance = Math.min(...recipeIdxs.map(i => Math.abs(petIdx - i)));
  if (distance === 1) return 75;
  if (distance === 2) return 60;
  return 45;
}

function scoreAllergenSafety(recipe: Recipe, pet: ImprovedPet): number {
  const allergens = [
    ...((pet.allergies || []) as string[]),
    ...((pet.dietaryRestrictions || []) as string[]).filter(r =>
      ['chicken', 'beef', 'dairy', 'wheat', 'egg', 'fish', 'pork', 'soy', 'corn', 'lamb'].some(a =>
        r.toLowerCase().includes(a)
      )
    ),
  ];
  if (!allergens.length) return 100;

  const ingredientText = (recipe.ingredients || [])
    .map(i => (typeof i === 'string' ? i : i.name).toLowerCase())
    .join(' ');

  const hits = allergens.filter(a => ingredientText.includes(a.toLowerCase()));
  if (!hits.length) return 100;

  const penalty = hits.length === 1 ? 15 : hits.length === 2 ? 30 : hits.length === 3 ? 50 : 70;
  return Math.max(0, 100 - penalty);
}

function scoreDigestibility(recipe: Recipe, species: string): number {
  const ingredients = recipe.ingredients || [];
  if (!ingredients.length) return 50;

  let total = 0;
  let count = 0;

  for (const ing of ingredients) {
    const name = typeof ing === 'string' ? ing : ing.name;
    const key = name.toLowerCase().replace(/\s+/g, '_');
    const comp = getIngredientComposition(key);

    if (comp) {
      if (comp.protein && comp.protein > 15) total += 20;
      if (comp.fiber !== undefined) {
        if (species === 'dog' || species === 'cat') {
          // Dogs and cats: moderate fiber (2-5%) is ideal
          if (comp.fiber >= 2 && comp.fiber <= 5) {
            total += 15;
          } else if (comp.fiber > 10) {
            total -= 10; // Too much fiber for carnivores
          }
        } else if (species === 'bird') {
          // Birds: low to moderate fiber (2-8%) is ideal
          if (comp.fiber >= 2 && comp.fiber <= 8) {
            total += 12;
          } else if (comp.fiber > 15) {
            total -= 8; // Too much fiber for birds
          }
        } else if (species === 'reptile') {
          // Reptiles: fiber needs vary by type, but generally low
          if (comp.fiber > 10) {
            total -= 5; // Most reptiles need low fiber
          }
        } else if (species === 'pocket-pet') {
          // Pocket-pets: fiber needs vary dramatically
          // Hay eaters (rabbits, guinea pigs) need high fiber
          // Omnivores (hamsters, rats) need moderate fiber
          // Carnivores (ferrets) need very low fiber
          if (comp.fiber >= 5 && comp.fiber <= 20) {
            total += 10; // Acceptable range for most pocket-pets
          } else if (comp.fiber > 25) {
            total -= 5; // May be too high for some
          }
        } else {
          // Unknown species: generic handling
          if (comp.fiber > 10) {
            total -= 5;
          }
        }
      }
      if (comp.fat && comp.fat > 0) {
        // Fat digestibility varies by species
        if (species === 'dog' || species === 'cat') {
          total += comp.fat > 10 ? 5 : 10;
        } else if (species === 'bird') {
          // Birds can handle moderate fat
          total += comp.fat > 15 ? 3 : 8;
        } else if (species === 'reptile') {
          // Reptiles generally need lower fat
          total += comp.fat > 8 ? 2 : 6;
        } else if (species === 'pocket-pet') {
          // Pocket-pets vary: ferrets need high fat, rabbits need low
          total += comp.fat > 10 ? 3 : 7;
        } else {
          total += comp.fat > 10 ? 5 : 10;
        }
      }
    } else {
      total += 5; // unknown = modest neutral
    }
    count++;
  }

  return clamp((total / Math.max(1, count)) * 5, 0, 100);
}

function scoreIngredientVariety(recipe: Recipe): number {
  const ingredients = recipe.ingredients || [];
  if (!ingredients.length) return 50;

  const categories = {
    protein: ['chicken', 'beef', 'fish', 'turkey', 'egg', 'meat', 'lamb', 'pork'],
    vegetable: ['carrot', 'spinach', 'kale', 'broccoli', 'pumpkin', 'squash', 'zucchini'],
    fruit: ['apple', 'berry', 'banana', 'melon', 'pear'],
    grain: ['rice', 'oat', 'quinoa', 'barley', 'corn', 'wheat'],
    fat: ['oil', 'butter', 'tallow', 'lard', 'flax', 'omega'],
    supplement: ['vitamin', 'mineral', 'calcium', 'taurine', 'supplement'],
  };

  const found = new Set<string>();
  for (const ing of ingredients) {
    const name = (typeof ing === 'string' ? ing : ing.name).toLowerCase();
    for (const [cat, terms] of Object.entries(categories)) {
      if (terms.some(t => name.includes(t))) {
        found.add(cat);
      }
    }
  }

  const categoriesUsed = found.size;
  let score = 30 + categoriesUsed * 12; // 3 cats => 66, 5 => 90
  if (ingredients.length < 4) {
    score -= 15;
  } else if (ingredients.length > 10) {
    score += 5;
  }
  return clamp(score, 0, 100);
}

// ------------------ Helpers ------------------ //

function calcNutrition(recipe: Recipe) {
  const ingredients = recipe.ingredients || [];
  let totalProtein = 0;
  let totalFat = 0;
  let totalCa = 0;
  let totalP = 0;
  let totalFiber = 0;
  let totalWeight = 0;
  let realData = 0;

  for (const ing of ingredients) {
    const name = typeof ing === 'string' ? ing : ing.name;
    const amount = typeof ing === 'string'
      ? 100
      : ing.amount
      ? parseFloat(String(ing.amount).replace(/[^0-9.]/g, '')) || 0
      : 0;
    const comp = getIngredientComposition(name.toLowerCase().replace(/\s+/g, '_'));
    if (comp && comp.protein !== undefined) {
      totalProtein += (comp.protein || 0) * (amount / 100);
      totalFat += (comp.fat || 0) * (amount / 100);
      totalCa += (comp.calcium || 0) * (amount / 100);
      totalP += (comp.phosphorus || 0) * (amount / 100);
      totalFiber += (comp.fiber || 0) * (amount / 100);
      totalWeight += amount;
      realData++;
    }
  }

  return {
    protein: totalWeight ? (totalProtein / totalWeight) * 100 : 25,
    fat: totalWeight ? (totalFat / totalWeight) * 100 : 15,
    calcium: totalWeight ? (totalCa / totalWeight) * 100 : 0.8,
    phosphorus: totalWeight ? (totalP / totalWeight) * 100 : 0.6,
    fiber: totalWeight ? (totalFiber / totalWeight) * 100 : 2,
    hasData: realData > 0 && totalWeight > 0,
    dataPoints: realData,
    totalIngredients: ingredients.length,
  };
}

function normalizeScore(raw: number): number {
  const n = SCORE_CONFIG.normalize;
  if (raw >= n.topKeep) return raw; // leave excellent scores alone
  if (raw >= n.topBand) return 90 + (raw - n.topBand) * 0.8; // light compression at top
  if (raw >= n.midBand) return raw; // keep solid recipes intact
  if (raw >= 50) return raw * n.lift50; // small lift to mid-low
  if (raw >= 30) return raw * n.lift30; // gentle boost to lows
  return raw * n.liftLow; // slightly more help for very low
}

function applyControlledVariation(score: number): number {
  // deterministic-ish tiny jitter: ¬±0.4 max
  const { high, mid, low } = SCORE_CONFIG.jitter;
  const range = score > 90 || score < 30 ? high : score > 70 ? mid : low;
  return (Math.random() - 0.5) * 2 * range;
}

function mapScoreToStarsWithReasoning(
  score: number,
  factors: {
    ingredientSafety: number;
    nutritionalAdequacy: number;
    healthAlignment: number;
    lifeStageFit: number;
    allergenSafety: number;
    digestibility: number;
  }
): { stars: number; recommendation: ImprovedScore['recommendation']; summaryReasoning: string } {
  // Safety overrides
  if (factors.allergenSafety < 50) {
    return {
      stars: 1,
      recommendation: 'avoid',
      summaryReasoning: 'Contains allergens for this pet',
    };
  }
  if (factors.ingredientSafety < 40) {
    return {
      stars: 1,
      recommendation: 'avoid',
      summaryReasoning: 'Unsafe ingredients detected for this species',
    };
  }

  let recommendation: ImprovedScore['recommendation'] = 'acceptable';
  if (score >= 90) recommendation = 'excellent';
  else if (score >= 80) recommendation = 'good';
  else if (score >= 70) recommendation = 'acceptable';
  else if (score >= 60) recommendation = 'caution';
  else recommendation = 'avoid';

  let summaryReasoning = 'Well-rounded recipe';
  if (score < 60) summaryReasoning = 'Significant concerns detected';
  else if (factors.nutritionalAdequacy < 65) summaryReasoning = 'Not balanced for this pet';
  else if (factors.ingredientSafety < 70) summaryReasoning = 'Ingredient safety concerns';
  else if (factors.allergenSafety < 80) summaryReasoning = 'Possible allergens detected';

  return {
    stars: mapScoreToStars(score),
    recommendation,
    summaryReasoning,
  };
}

function mapScoreToStars(score: number): number {
  if (score >= 90) return 5;
  if (score >= 75) return 4;
  if (score >= 55) return 3;
  if (score >= 30) return 2;
  return 1;
}

function clamp(val: number, min: number, max: number) {
  return Math.min(max, Math.max(min, val));
}
</file>

<file path="lib/utils/ingredientCompatibility.ts">
// lib/utils/ingredientCompatibility.ts
// Utility functions for checking ingredient compatibility with species

import { INGREDIENT_COMPOSITIONS, type SpeciesCompatibility, type FeedingRole } from '@/lib/data/ingredientCompositions';
import { getIngredientComposition } from '@/lib/data/ingredientCompositions';

export type Species = 'dog' | 'cat' | 'bird' | 'reptile' | 'pocket-pet';

/**
 * Normalize species string to standard format
 */
export function normalizeSpecies(species: string): Species | string {
  const s = (species || '').toLowerCase();
  if (s.includes('dog')) return 'dog';
  if (s.includes('cat')) return 'cat';
  if (s.includes('bird') || s.includes('parrot') || s.includes('finch')) return 'bird';
  if (s.includes('reptile') || s.includes('lizard') || s.includes('bearded') || s.includes('dragon')) return 'reptile';
  if (s.includes('pocket') || s.includes('rabbit') || s.includes('guinea') || s.includes('hamster') || s.includes('gerbil')) return 'pocket-pet';
  return s;
}

/**
 * Get species compatibility for an ingredient
 */
export function getSpeciesCompatibility(ingredientKey: string, species: string): SpeciesCompatibility | null {
  const normalizedSpecies = normalizeSpecies(species);
  const composition = getIngredientComposition(ingredientKey);
  
  if (!composition?.speciesCompatibility) return null;
  
  return composition.speciesCompatibility[normalizedSpecies as keyof typeof composition.speciesCompatibility] || null;
}

/**
 * Get max inclusion percentage for an ingredient by species
 */
export function getMaxInclusionPercent(ingredientKey: string, species: string): number | null {
  const normalizedSpecies = normalizeSpecies(species);
  const composition = getIngredientComposition(ingredientKey);
  
  if (!composition?.maxInclusionPercentBySpecies) return null;
  
  return composition.maxInclusionPercentBySpecies[normalizedSpecies as keyof typeof composition.maxInclusionPercentBySpecies] || null;
}

/**
 * Get species-specific notes for an ingredient
 */
export function getSpeciesNotes(ingredientKey: string, species: string): string | null {
  const normalizedSpecies = normalizeSpecies(species);
  const composition = getIngredientComposition(ingredientKey);
  
  if (!composition?.notesBySpecies) return null;
  
  return composition.notesBySpecies[normalizedSpecies as keyof typeof composition.notesBySpecies] || null;
}

/**
 * Get feeding role for an ingredient
 */
export function getFeedingRole(ingredientKey: string): FeedingRole | null {
  const composition = getIngredientComposition(ingredientKey);
  return composition?.feedingRole || null;
}

/**
 * Check if ingredient is compatible with species
 */
export function isCompatible(ingredientKey: string, species: string): boolean {
  const compat = getSpeciesCompatibility(ingredientKey, species);
  return compat === 'ok' || compat === 'limit' || compat === 'caution';
}

/**
 * Check if ingredient should be avoided for species
 */
export function shouldAvoid(ingredientKey: string, species: string): boolean {
  const compat = getSpeciesCompatibility(ingredientKey, species);
  return compat === 'avoid';
}

/**
 * Check if ingredient should be limited for species
 */
export function shouldLimit(ingredientKey: string, species: string): boolean {
  const compat = getSpeciesCompatibility(ingredientKey, species);
  return compat === 'limit' || compat === 'caution';
}
</file>

<file path="lib/utils/ingredientNameNormalizer.ts">
// Centralized ingredient name normalization
// Maps between display names, composition keys, and price lookup names

const INGREDIENT_NAME_MAP: Record<string, {
  display: string;
  compositionKey: string;
  priceKey: string;
}> = {
  // Proteins
  'ground chicken': {
    display: 'ground chicken',
    compositionKey: 'ground_chicken',
    priceKey: 'ground chicken'
  },
  'ground turkey': {
    display: 'ground turkey',
    compositionKey: 'ground_turkey',
    priceKey: 'ground turkey'
  },
  'ground beef (lean)': {
    display: 'ground beef (lean)',
    compositionKey: 'ground_beef_lean',
    priceKey: 'ground beef (lean)'
  },
  'ground lamb': {
    display: 'ground lamb',
    compositionKey: 'ground_lamb',
    priceKey: 'ground lamb'
  },
  'salmon (boneless)': {
    display: 'salmon (boneless)',
    compositionKey: 'salmon_atlantic',
    priceKey: 'salmon (boneless)'
  },
  'chicken breast': {
    display: 'chicken breast',
    compositionKey: 'chicken_breast',
    priceKey: 'chicken breast'
  },
  'chicken thighs': {
    display: 'chicken thighs',
    compositionKey: 'chicken_thighs',
    priceKey: 'chicken thighs'
  },
  'turkey breast': {
    display: 'turkey breast',
    compositionKey: 'turkey_breast',
    priceKey: 'turkey breast'
  },
  'beef liver': {
    display: 'beef liver',
    compositionKey: 'beef_liver',
    priceKey: 'beef liver'
  },
  'chicken liver': {
    display: 'chicken liver',
    compositionKey: 'chicken_liver',
    priceKey: 'chicken liver'
  },
  'chicken hearts': {
    display: 'chicken hearts',
    compositionKey: 'chicken_hearts',
    priceKey: 'chicken hearts'
  },
  'sardines (canned in water)': {
    display: 'sardines (canned in water)',
    compositionKey: 'sardines_water',
    priceKey: 'sardines (canned in water)'
  },
  'eggs': {
    display: 'eggs',
    compositionKey: 'eggs_whole',
    priceKey: 'eggs'
  },
  'quail': {
    display: 'quail',
    compositionKey: 'quail',
    priceKey: 'quail'
  },
  'ground pork (lean)': {
    display: 'ground pork (lean)',
    compositionKey: 'ground_pork_lean',
    priceKey: 'ground pork (lean)'
  },
  'turkey necks': {
    display: 'turkey necks',
    compositionKey: 'turkey_necks',
    priceKey: 'turkey necks'
  },
  'tuna': {
    display: 'tuna',
    compositionKey: 'tuna_water',
    priceKey: 'tuna'
  },

  // Carbs
  'brown rice': {
    display: 'brown rice',
    compositionKey: 'brown_rice_cooked',
    priceKey: 'brown rice'
  },
  'white rice': {
    display: 'white rice',
    compositionKey: 'white_rice_cooked',
    priceKey: 'white rice'
  },
  'quinoa': {
    display: 'quinoa',
    compositionKey: 'quinoa_cooked',
    priceKey: 'quinoa'
  },
  'sweet potato': {
    display: 'sweet potato',
    compositionKey: 'sweet_potato',
    priceKey: 'sweet potato'
  },
  'oats': {
    display: 'oats',
    compositionKey: 'oats',
    priceKey: 'oats'
  },
  'pumpkin': {
    display: 'pumpkin',
    compositionKey: 'pumpkin',
    priceKey: 'pumpkin'
  },
  'lentils': {
    display: 'lentils',
    compositionKey: 'lentils',
    priceKey: 'lentils'
  },
  'chickpeas': {
    display: 'chickpeas',
    compositionKey: 'chickpeas',
    priceKey: 'chickpeas'
  },
  'black beans': {
    display: 'black beans',
    compositionKey: 'black_beans',
    priceKey: 'black beans'
  },
  'green peas': {
    display: 'green peas',
    compositionKey: 'green_peas',
    priceKey: 'green peas'
  },

  // Vegetables
  'carrots': {
    display: 'carrots',
    compositionKey: 'carrots_raw',
    priceKey: 'carrots'
  },
  'green beans': {
    display: 'green beans',
    compositionKey: 'green_beans_raw',
    priceKey: 'green beans'
  },
  'spinach': {
    display: 'spinach',
    compositionKey: 'spinach_raw',
    priceKey: 'spinach'
  },
  'broccoli': {
    display: 'broccoli',
    compositionKey: 'broccoli_raw',
    priceKey: 'broccoli'
  },
  'zucchini': {
    display: 'zucchini',
    compositionKey: 'zucchini',
    priceKey: 'zucchini'
  },
  'kale': {
    display: 'kale',
    compositionKey: 'kale_raw',
    priceKey: 'kale'
  },
  'celery': {
    display: 'celery',
    compositionKey: 'celery_raw',
    priceKey: 'celery'
  },
  'brussels sprouts': {
    display: 'brussels sprouts',
    compositionKey: 'brussels_sprouts',
    priceKey: 'brussels sprouts'
  },
  'asparagus': {
    display: 'asparagus',
    compositionKey: 'asparagus',
    priceKey: 'asparagus'
  },
  'parsley': {
    display: 'parsley',
    compositionKey: 'parsley',
    priceKey: 'parsley'
  },
  'cucumber': {
    display: 'cucumber',
    compositionKey: 'celery_raw',
    priceKey: 'cucumber'
  },
  'lettuce (romaine)': {
    display: 'lettuce (romaine)',
    compositionKey: 'lettuce_romaine',
    priceKey: 'lettuce (romaine)'
  },
  'arugula': {
    display: 'arugula',
    compositionKey: 'arugula',
    priceKey: 'arugula'
  },
  'bok choy': {
    display: 'bok choy',
    compositionKey: 'bok_choy',
    priceKey: 'bok choy'
  },

  // Fruits
  'blueberries': {
    display: 'blueberries',
    compositionKey: 'blueberries_raw',
    priceKey: 'blueberries'
  },
  'bananas': {
    display: 'bananas',
    compositionKey: 'bananas_raw',
    priceKey: 'bananas'
  },

  // Additional proteins
  'turkey giblets': {
    display: 'turkey giblets',
    compositionKey: 'turkey_giblets',
    priceKey: 'turkey giblets'
  },
  'chicken giblets': {
    display: 'chicken giblets',
    compositionKey: 'chicken_giblets',
    priceKey: 'chicken giblets'
  },
  'duck breast': {
    display: 'duck breast',
    compositionKey: 'duck_breast',
    priceKey: 'duck breast'
  },
  'venison': {
    display: 'venison',
    compositionKey: 'venison',
    priceKey: 'venison'
  },
  'rabbit meat': {
    display: 'rabbit meat',
    compositionKey: 'rabbit_meat',
    priceKey: 'rabbit meat'
  },

  // Additional carbs
  'barley': {
    display: 'barley',
    compositionKey: 'barley',
    priceKey: 'barley'
  },
  'butternut squash': {
    display: 'butternut squash',
    compositionKey: 'butternut_squash',
    priceKey: 'butternut squash'
  },
  'acorn squash': {
    display: 'acorn squash',
    compositionKey: 'acorn_squash',
    priceKey: 'acorn squash'
  },

  // Additional vegetables
  'bell peppers': {
    display: 'bell peppers',
    compositionKey: 'bell_peppers',
    priceKey: 'bell peppers'
  },
  'bell peppers (red/green)': {
    display: 'bell peppers (red/green)',
    compositionKey: 'bell_peppers',
    priceKey: 'bell peppers'
  },
  'peas': {
    display: 'peas',
    compositionKey: 'peas',
    priceKey: 'peas'
  },
  'endive': {
    display: 'endive',
    compositionKey: 'endive',
    priceKey: 'endive'
  },
  'collard greens': {
    display: 'collard greens',
    compositionKey: 'collard_greens',
    priceKey: 'collard greens'
  },
  'mustard greens': {
    display: 'mustard greens',
    compositionKey: 'mustard_greens',
    priceKey: 'mustard greens'
  },
  'swiss chard': {
    display: 'swiss chard',
    compositionKey: 'swiss_chard',
    priceKey: 'swiss chard'
  },
  'cauliflower': {
    display: 'cauliflower',
    compositionKey: 'cauliflower',
    priceKey: 'cauliflower'
  },

  // Oils and fats
  'salmon oil': {
    display: 'salmon oil',
    compositionKey: 'salmon_oil',
    priceKey: 'salmon oil'
  },
  'fish oil': {
    display: 'fish oil',
    compositionKey: 'fish_oil',
    priceKey: 'fish oil'
  },
  'cod liver oil': {
    display: 'cod liver oil',
    compositionKey: 'cod_liver_oil',
    priceKey: 'cod liver oil'
  },
  'coconut oil': {
    display: 'coconut oil',
    compositionKey: 'coconut_oil',
    priceKey: 'coconut oil'
  },
  'olive oil': {
    display: 'olive oil',
    compositionKey: 'olive_oil',
    priceKey: 'olive oil'
  },

  // Supplements
  'calcium carbonate': {
    display: 'calcium carbonate',
    compositionKey: 'calcium_carbonate',
    priceKey: 'calcium carbonate'
  },
  'taurine powder': {
    display: 'taurine powder',
    compositionKey: 'taurine_powder',
    priceKey: 'taurine powder'
  },
};

export function getCompositionKey(displayName: string): string {
  const normalized = displayName.toLowerCase().trim();
  const mapping = INGREDIENT_NAME_MAP[normalized];
  if (mapping) {
    return mapping.compositionKey;
  }
  // Fallback: normalize to underscore format (handles unmapped ingredients)
  return normalized
    .replace(/\s*\([^)]*\)/g, '')
    .replace(/\s+/g, '_')
    .replace(/[^a-z0-9_]/g, '');
}

export function getPriceKey(displayName: string): string {
  const normalized = displayName.toLowerCase().trim();
  const mapping = INGREDIENT_NAME_MAP[normalized];
  if (mapping) {
    return mapping.priceKey;
  }
  // Fallback: use lowercase version for price lookup
  return normalized;
}

export function getDisplayName(compositionKeyOrPrice: string): string {
  const normalized = compositionKeyOrPrice.toLowerCase().trim();
  // Search through map for matching composition key or price key
  for (const [display, mapping] of Object.entries(INGREDIENT_NAME_MAP)) {
    if (mapping.compositionKey === normalized || mapping.priceKey === normalized) {
      return mapping.display;
    }
  }
  // Fallback: convert underscore format back to display format
  return normalized
    .replace(/_/g, ' ')
    .split(' ')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}
</file>

<file path="lib/utils/ingredientRegistry.ts">
// lib/utils/ingredientRegistry.ts
// Utility functions for accessing the unified ingredient registry
// Provides convenient accessors and normalization functions

import {
  getIngredientById,
  getIngredientByName,
  normalizeIngredientName,
  getIngredientsForSpecies,
  getIngredientsByCategory,
  getAllIngredients,
  searchIngredients,
  type UnifiedIngredient,
  type Species,
  type IngredientCategory,
} from '../data/unifiedIngredientRegistry';

// Re-export types and functions for convenience
export {
  getIngredientById,
  getIngredientByName,
  normalizeIngredientName,
  getIngredientsForSpecies,
  getIngredientsByCategory,
  getAllIngredients,
  searchIngredients,
  type UnifiedIngredient,
  type Species,
  type IngredientCategory,
};

/**
 * Convert between different ingredient name formats
 */
export function convertIngredientName(
  name: string,
  targetFormat: 'id' | 'display' | 'normalized'
): string {
  const ingredient = getIngredientByName(name);
  
  if (!ingredient) {
    // If not found, return normalized version
    if (targetFormat === 'id' || targetFormat === 'normalized') {
      return normalizeIngredientName(name);
    }
    return name; // Return original for display
  }
  
  switch (targetFormat) {
    case 'id':
      return ingredient.id;
    case 'display':
      return ingredient.primaryDisplayName;
    case 'normalized':
      return ingredient.id;
    default:
      return name;
  }
}

/**
 * Check if an ingredient name matches any known ingredient (fuzzy)
 */
export function isKnownIngredient(name: string): boolean {
  return getIngredientByName(name) !== null;
}

/**
 * Get all display name variations for an ingredient
 */
export function getIngredientNameVariations(name: string): string[] {
  const ingredient = getIngredientByName(name);
  return ingredient?.displayNames || [name];
}

/**
 * Find best matching ingredient name from a list of candidates
 */
export function findBestMatch(
  query: string,
  candidates: string[]
): string | null {
  const normalizedQuery = normalizeIngredientName(query);
  const queryIngredient = getIngredientByName(query);
  
  if (!queryIngredient) {
    return null;
  }
  
  // Find candidate that matches the same ingredient
  for (const candidate of candidates) {
    const candidateIngredient = getIngredientByName(candidate);
    if (candidateIngredient && candidateIngredient.id === queryIngredient.id) {
      return candidate;
    }
  }
  
  return null;
}

/**
 * Get nutrition data for an ingredient (with fallback)
 */
export function getIngredientNutrition(name: string) {
  const ingredient = getIngredientByName(name);
  return ingredient?.nutrition || null;
}

/**
 * Check if ingredient is compatible with species
 */
export function isIngredientCompatibleWithSpecies(
  name: string,
  species: Species
): boolean {
  const ingredient = getIngredientByName(name);
  if (!ingredient) return false;
  
  const compat = ingredient.speciesCompatibility[species];
  return compat === 'ok' || compat === 'limit' || compat === 'caution';
}

/**
 * Check if ingredient should be avoided for species
 */
export function shouldAvoidIngredient(name: string, species: Species): boolean {
  const ingredient = getIngredientByName(name);
  if (!ingredient) return false;
  
  const compat = ingredient.speciesCompatibility[species];
  return compat === 'avoid';
}

/**
 * Get vetted products for an ingredient
 */
export function getIngredientVettedProducts(name: string) {
  const ingredient = getIngredientByName(name);
  return ingredient?.vettedProducts || [];
}
</file>

<file path="lib/utils/ingredientSuggestions.ts">
// lib/utils/ingredientSuggestions.ts
// Generate ingredient suggestions based on pet profile

import { ALL_INGREDIENTS } from './allIngredients';

export interface SuggestedIngredient {
  name: string;
  reason: string;
  category: string;
}

interface PetProfile {
  type: string;
  age?: string;
  healthConcerns?: string[];
  breed?: string;
}

export function generateIngredientSuggestions(pet: PetProfile): SuggestedIngredient[] {
  if (!pet) return [];
  
  const suggestions: SuggestedIngredient[] = [];
  const normalizedSpecies = pet.type === 'dog' ? 'dogs' : 
                           pet.type === 'cat' ? 'cats' :
                           pet.type === 'bird' ? 'birds' :
                           pet.type === 'reptile' ? 'reptiles' :
                           pet.type === 'pocket-pet' ? 'pocket-pets' : pet.type;
  
  const speciesData = ALL_INGREDIENTS[normalizedSpecies as keyof typeof ALL_INGREDIENTS];
  if (!speciesData) return [];

  const healthConcerns = (pet.healthConcerns || []).map(hc => hc.toLowerCase());
  const age = pet.age?.toLowerCase() || '';

  // Safe property access helper
  const getProperty = <T>(obj: any, key: string, defaultValue: T[] = []): T[] => {
    return (key in obj ? obj[key] : defaultValue) || defaultValue;
  };

  const addUnique = (name: string, reason: string, category: string) => {
    if (suggestions.some((s) => s.name === name)) return;
    suggestions.push({ name, reason, category });
  };

  const proteins = getProperty<string>(speciesData, 'proteins');
  const vegetables = getProperty<string>(speciesData, 'vegetables');
  const carbs = getProperty<string>(speciesData, 'carbs');
  const fruits = getProperty<string>(speciesData, 'fruits');
  const fats = getProperty<string>(speciesData, 'fats');
  const supplements = getProperty<string>(speciesData, 'supplements');
  const insects = getProperty<string>(speciesData, 'insects');
  const hay = getProperty<string>(speciesData, 'hay');
  const seeds = getProperty<string>(speciesData, 'seeds');
  const pellets = getProperty<string>(speciesData, 'pellets');

  // Species-specific essentials
  if (normalizedSpecies === 'cats') {
    // Taurine is essential for cats
    if (supplements.includes('Taurine Powder')) {
      suggestions.push({
        name: 'Taurine Powder',
        reason: 'Essential amino acid required for cats - supports heart and eye health',
        category: 'Supplements'
      });
    }
    // High-taurine proteins
    if (proteins.includes('Chicken Liver')) {
      suggestions.push({
        name: 'Chicken Liver',
        reason: 'Rich in taurine and essential nutrients for cats',
        category: 'Proteins'
      });
    }
  }

  if (normalizedSpecies === 'reptiles') {
    // Calcium is essential for reptiles
    if (vegetables.includes('Collard Greens')) {
      suggestions.push({
        name: 'Collard Greens',
        reason: 'High in calcium - essential for bone health in reptiles',
        category: 'Greens & Veggies'
      });
    }
    // Insects for protein
    if (insects.includes('Dubia Roaches')) {
      suggestions.push({
        name: 'Dubia Roaches',
        reason: 'Excellent protein source with ideal calcium-to-phosphorus ratio',
        category: 'Proteins'
      });
    }
  }

  if (normalizedSpecies === 'pocket-pets') {
    // Hay is essential
    if (hay.includes('Timothy Hay')) {
      suggestions.push({
        name: 'Timothy Hay',
        reason: 'Essential fiber source for digestive health',
        category: 'Hay'
      });
    }
    // Vitamin C rich vegetables
    if (vegetables.includes('Bell Peppers (high vitamin C)')) {
      suggestions.push({
        name: 'Bell Peppers (high vitamin C)',
        reason: 'High in vitamin C - essential for guinea pigs and other pocket pets',
        category: 'Greens & Veggies'
      });
    }
  }

  // Age-based suggestions
  if (age.includes('baby') || age.includes('puppy') || age.includes('kitten')) {
    if (proteins.includes('Ground Chicken')) {
      suggestions.push({
        name: 'Ground Chicken',
        reason: 'Easy to digest protein perfect for growing pets',
        category: 'Proteins'
      });
    }
    if (carbs.includes('Sweet Potato') || carbs.includes('Sweet Potato (cooked)')) {
      suggestions.push({
        name: carbs.includes('Sweet Potato') ? 'Sweet Potato' : 'Sweet Potato (cooked)',
        reason: 'Gentle on developing digestive systems and rich in nutrients',
        category: 'Grains & Carbs'
      });
    }
  }

  if (age.includes('senior')) {
    if (supplements.includes('Glucosamine Sulfate')) {
      suggestions.push({
        name: 'Glucosamine Sulfate',
        reason: 'Supports joint health in older pets',
        category: 'Supplements'
      });
    }
    if (fats.includes('Fish Oil') || supplements.includes('Fish Oil')) {
      suggestions.push({
        name: 'Fish Oil',
        reason: 'Omega-3 fatty acids support brain and joint health in seniors',
        category: 'Supplements'
      });
    }
  }

  // Health concern-based suggestions
  if (healthConcerns.some(hc => hc.includes('kidney') || hc.includes('urinary'))) {
    if (vegetables.includes('Green Beans') || vegetables.includes('Green Beans (cooked)')) {
      suggestions.push({
        name: vegetables.includes('Green Beans') ? 'Green Beans' : 'Green Beans (cooked)',
        reason: 'Low in phosphorus - ideal for kidney support',
        category: 'Greens & Veggies'
      });
    }
    if (normalizedSpecies === 'cats' && supplements.includes('Cranberry Extract')) {
      suggestions.push({
        name: 'Cranberry Extract',
        reason: 'Supports urinary tract health',
        category: 'Supplements'
      });
    }
  }

  if (healthConcerns.some(hc => hc.includes('joint') || hc.includes('mobility'))) {
    if (supplements.includes('Glucosamine Sulfate')) addUnique('Glucosamine Sulfate', 'Supports joint cartilage and mobility', 'Supplements');
    if (fats.includes('Fish Oil') || supplements.includes('Fish Oil')) addUnique('Fish Oil', 'Anti-inflammatory omega-3s help reduce joint inflammation', 'Supplements');
  }

  if (healthConcerns.some(hc => hc.includes('weight') || hc.includes('obesity'))) {
    if (proteins.includes('Ground Turkey')) {
      addUnique('Ground Turkey', 'Lean protein helps maintain muscle while managing weight', 'Proteins');
    }
    if (vegetables.includes('Green Beans') || vegetables.includes('Green Beans (cooked)')) {
      addUnique(vegetables.includes('Green Beans') ? 'Green Beans' : 'Green Beans (cooked)', 'Low calorie, high fiber - helps with satiety', 'Greens & Veggies');
    }
  }

  if (healthConcerns.some(hc => hc.includes('digestive') || hc.includes('gi'))) {
    if (carbs.includes('Pumpkin Puree') || carbs.includes('Pumpkin Puree (small amounts)')) {
      addUnique(carbs.includes('Pumpkin Puree') ? 'Pumpkin Puree' : 'Pumpkin Puree (small amounts)', 'Soluble fiber helps regulate digestion', 'Grains & Carbs');
    }
    if (supplements.includes('Probiotic Powder')) {
      addUnique('Probiotic Powder', 'Supports healthy gut bacteria and digestive function', 'Supplements');
    }
  }

  if (healthConcerns.some(hc => hc.includes('skin') || hc.includes('coat'))) {
    if (fats.includes('Salmon Oil') || supplements.includes('Salmon Oil')) {
      addUnique('Salmon Oil', 'Omega-3 fatty acids promote healthy skin and shiny coat', 'Supplements');
    }
    const salmonOptions = proteins.filter(p => p.toLowerCase().includes('salmon'));
    if (salmonOptions.length > 0) {
      addUnique(salmonOptions[0], 'Rich in omega-3s for healthy skin and coat', 'Proteins');
    }
  }

  // Baseline species recommendations to ensure multiple options
  if (normalizedSpecies === 'dogs') {
    addUnique('Chicken Breast', 'Lean, versatile protein for most dogs', 'Proteins');
    addUnique('Brown Rice', 'Gentle carb to mix meals', 'Grains & Carbs');
    addUnique('Carrots', 'Great source of beta-carotene and fiber for dogs', 'Greens & Veggies');
  }

  if (normalizedSpecies === 'cats') {
    const sardineOptions = proteins.filter(p => p.toLowerCase().includes('sardine'));
    if (sardineOptions.length > 0) {
      addUnique(sardineOptions[0], 'High in taurine and omega-3s - excellent for cats', 'Proteins');
    }
    addUnique('Chicken Liver', 'Taurine-rich organ meat for cats', 'Proteins');
    addUnique('Pumpkin Puree (small amounts)', 'Fiber to help digestion', 'Grains & Carbs');
  }

  if (normalizedSpecies === 'birds') {
    addUnique('Millet (white/red)', 'Staple seed birds readily accept', 'Seeds');
    addUnique('Carrots (grated)', 'Vitamin A-rich veggie for birds', 'Greens & Veggies');
    addUnique('Apples (no seeds)', 'Common fruit treat (seed-free)', 'Fruits');
  }

  if (normalizedSpecies === 'reptiles') {
    addUnique('Collard Greens', 'High-calcium staple green', 'Greens & Veggies');
    addUnique('Dubia Roaches', 'Staple insect protein with good Ca:P', 'Proteins');
    addUnique('Blueberries', 'Occasional fruit treat many reptiles accept', 'Fruits');
  }

  if (normalizedSpecies === 'pocket-pets') {
    addUnique('Timothy Hay', 'Essential daily fiber source', 'Hay');
    addUnique('Bell Peppers (high vitamin C)', 'Vitamin C boost for pocket pets', 'Greens & Veggies');
    addUnique('Carrots', 'Crunchy, familiar veggie treat', 'Greens & Veggies');
  }

  // Remove duplicates and keep a healthy list (up to 12)
  const unique = suggestions.filter((sug, idx, self) =>
    idx === self.findIndex(s => s.name === sug.name)
  );

  return unique.slice(0, 12);
}
</file>

<file path="lib/utils/ingredientWhitelists.ts">
// lib/utils/ingredientWhitelists.ts
// Species-specific ingredient whitelists for safe meal building
// This provides a curated "safe" list per species to prevent dangerous combinations
// Now uses global ingredient pool + subtype-based normalization

import { getIngredientComposition, INGREDIENT_COMPOSITIONS, type SpeciesCompatibility } from '@/lib/data/ingredientCompositions';
import { ALL_INGREDIENTS } from './allIngredients';
import { GLOBAL_INGREDIENTS, type GlobalIngredient } from '@/lib/data/globalIngredients';

export type Species = 'dog' | 'cat' | 'bird' | 'reptile' | 'pocket-pet';
export type ReptileType = 'herbivore' | 'insectivore' | 'omnivore';
export type PocketPetType = 'rabbit' | 'guinea-pig' | 'hamster' | 'gerbil';
export type Subtype = 
  | 'bird_small' | 'bird_large'
  | 'reptile_herbivore' | 'reptile_insectivore' | 'reptile_omnivore' | 'reptile_carnivore'
  | 'pocket_hay' | 'pocket_varied' | 'pocket_carnivore' | 'pocket_insectivore'
  | 'dog' | 'cat';

/**
 * Normalize species + breed to subtype
 */
export function normalizeToSubtype(species: Species, breed?: string): Subtype {
  if (species === 'bird') {
    const largeBirds = ['parrot', 'cockatoo', 'african grey', 'macaw', 'conure', 'quaker'];
    const breedLower = breed?.toLowerCase() || '';
    return largeBirds.some(lb => breedLower.includes(lb)) ? 'bird_large' : 'bird_small';
  }
  
  if (species === 'reptile') {
    const herbivores = ['bearded dragon', 'iguana', 'slider', 'tortoise', 'uromastyx'];
    const carnivores = ['python', 'snake', 'monitor', 'chameleon', 'corn snake', 'ball python'];
    const insectivores = ['leopard gecko', 'crested gecko', 'gecko'];
    const breedLower = breed?.toLowerCase() || '';
    
    if (herbivores.some(h => breedLower.includes(h))) return 'reptile_herbivore';
    if (carnivores.some(c => breedLower.includes(c))) return 'reptile_carnivore';
    if (insectivores.some(i => breedLower.includes(i))) return 'reptile_insectivore';
    return 'reptile_omnivore'; // Default for mixed/unknown
  }
  
  if (species === 'pocket-pet') {
    const breedLower = breed?.toLowerCase() || '';
    if (breedLower.includes('rabbit') || breedLower.includes('guinea') || breedLower.includes('chinchilla')) {
      return 'pocket_hay';
    }
    if (breedLower.includes('ferret')) {
      return 'pocket_carnivore';
    }
    if (breedLower.includes('hedgehog')) {
      return 'pocket_insectivore';
    }
    return 'pocket_varied'; // Hamster, gerbil, rat, mouse
  }
  
  return species; // dog, cat
}

/**
 * Base whitelists by subtype - these ensure we always have something to show
 */
export const BASE_WHITELISTS: Record<Subtype, string[]> = {
  bird_small: [
    'millet', 'canary_seed', 'niger_seed', 'oat_groats',
    'carrot_grated', 'broccoli', 'spinach', 'kale',
    'apple_no_seeds', 'blueberries', 'strawberries',
    'egg_hard_boiled', 'pellets_fortified', 'cuttlebone'
  ],
  bird_large: [
    // All bird_small plus:
    'quinoa_cooked', 'brown_rice_cooked', 'oats',
    'bell_peppers', 'sweet_potato_cooked', 'mango', 'papaya',
    'parrot_pellets', 'nuts_unsalted', 'pumpkin', 'carrots'
  ],
  reptile_herbivore: [
    'collard_greens', 'turnip_greens', 'dandelion_greens',
    'butternut_squash', 'bell_peppers', 'carrot_grated', 'zucchini',
    'blueberries', 'mango', 'papaya', 'strawberries',
    'calcium_carbonate', 'vitamin_d3', 'kale', 'spinach'
  ],
  reptile_insectivore: [
    'dubia_roaches', 'crickets', 'mealworms', 'superworms',
    'black_soldier_fly_larvae', 'hornworms', 'calcium_carbonate', 'waxworms'
  ],
  reptile_omnivore: [
    // Combination of herbivore + insectivore
    'collard_greens', 'dandelion_greens',
    'crickets', 'dubia_roaches', 'mealworms',
    'blueberries', 'mango', 'calcium_carbonate'
  ],
  reptile_carnivore: [
    // Placeholder - whole prey items (will need special handling)
    'whole_prey_rodent', 'whole_prey_bird', 'protein_block',
    'chicken_breast', 'ground_turkey'
  ],
  pocket_hay: [
    'timothy_hay', 'orchard_grass_hay', 'alfalfa_hay',
    'romaine_lettuce', 'bell_peppers', 'carrots', 'cucumber',
    'parsley', 'cilantro', 'guinea_pig_pellets', 'rabbit_pellets',
    'vitamin_c_supplement', 'kale', 'spinach'
  ],
  pocket_varied: [
    'hamster_pellets', 'gerbil_pellets', 'oats', 'quinoa_cooked',
    'carrots', 'broccoli', 'apple_no_seeds', 'blueberries',
    'mealworms_freeze_dried', 'sunflower_seeds_unsalted', 'pumpkin_seeds'
  ],
  pocket_carnivore: [
    'chicken_breast', 'ground_turkey', 'salmon', 'egg_whole',
    'organ_meat', 'taurine_supplement', 'heart', 'liver'
  ],
  pocket_insectivore: [
    'mealworms', 'crickets', 'waxworms', 'egg_whole',
    'insectivore_diet_powder', 'superworms'
  ],
  dog: [], // Will be populated from global pool
  cat: []  // Will be populated from global pool
};

/**
 * Get whitelist of safe ingredients for a species
 * Returns ingredient display names that are marked as 'ok' or 'limit' (not 'avoid')
 * Now uses global pool + base whitelists
 */
export function getWhitelistForSpecies(species: Species, breed?: string, subtype?: ReptileType | PocketPetType): string[] {
  const normalizedSubtype = normalizeToSubtype(species, breed);
  const whitelist: Set<string> = new Set();
  
  // 1. Add base whitelist for this subtype (ensures we always have something)
  const baseList = BASE_WHITELISTS[normalizedSubtype] || [];
  baseList.forEach(ing => whitelist.add(ing));
  
  // 2. Add from existing ALL_INGREDIENTS (backward compatibility)
  // Map species to ALL_INGREDIENTS key format
  const speciesKey = species === 'dog' ? 'dogs' : 
                     species === 'cat' ? 'cats' :
                     species === 'bird' ? 'birds' :
                     species === 'reptile' ? 'reptiles' :
                     species === 'pocket-pet' ? 'pocket-pets' : species;
  
  const speciesData = ALL_INGREDIENTS[speciesKey as keyof typeof ALL_INGREDIENTS];
  if (speciesData) {
    Object.values(speciesData).forEach(category => {
      if (Array.isArray(category)) {
        category.forEach(ingName => whitelist.add(ingName));
      }
    });
  }
  
  // 3. Add from global ingredient pool (new approach)
  Object.values(GLOBAL_INGREDIENTS).forEach(globalIng => {
    // Try to find composition data
    const compositionKey = globalIng.compositionKey || globalIng.id;
    const composition = getIngredientComposition(compositionKey);
    
    if (composition?.speciesCompatibility) {
      const compat = composition.speciesCompatibility[species];
      if (compat === 'ok' || compat === 'limit' || compat === 'caution') {
        whitelist.add(globalIng.displayName);
      }
    } else {
      // If no compatibility data but it's in global pool, include it with low confidence
      // This allows discovery of new ingredients
      if (globalIng.confidenceLevel === 'high' || globalIng.confidenceLevel === 'medium') {
        whitelist.add(globalIng.displayName);
      }
    }
  });
  
  // 4. Filter by compatibility from INGREDIENT_COMPOSITIONS
  const filtered: string[] = [];
  whitelist.forEach(ingName => {
    // Try multiple key formats
    const keys = [
      ingName.toLowerCase().replace(/\s+/g, '_').replace(/[^a-z0-9_]/g, ''),
      ingName.toLowerCase().replace(/[^a-z0-9_]/g, '_'),
      ingName.toLowerCase()
    ];
    
    let found = false;
    let shouldInclude = true;
    
    for (const key of keys) {
      const composition = getIngredientComposition(key);
      if (composition?.speciesCompatibility) {
        const compat = composition.speciesCompatibility[species];
        if (compat === 'ok' || compat === 'limit' || compat === 'caution') {
          shouldInclude = true;
          found = true;
          break;
        } else if (compat === 'avoid') {
          shouldInclude = false; // Explicitly avoid, don't add
          found = true;
          break;
        }
      }
    }
    
    // If no composition data found, include it anyway (allows ingredients from ALL_INGREDIENTS)
    // This is important because ALL_INGREDIENTS already contains species-specific safe ingredients
    if (!found || shouldInclude) {
      filtered.push(ingName);
    }
  });
  
  // 5. Apply subtype-specific filters
  if (species === 'reptile' && subtype) {
    const reptileTypes: ReptileType[] = ['herbivore', 'insectivore', 'omnivore'];
    if (reptileTypes.includes(subtype as ReptileType)) {
      return filterByReptileType(filtered, subtype as ReptileType);
    }
  }
  
  if (species === 'pocket-pet' && subtype) {
    const pocketPetTypes: PocketPetType[] = ['rabbit', 'guinea-pig', 'hamster', 'gerbil'];
    if (pocketPetTypes.includes(subtype as PocketPetType)) {
      return filterByPocketPetType(filtered, subtype as PocketPetType);
    }
  }
  
  return filtered;
}

/**
 * Filter ingredients by reptile type
 */
function filterByReptileType(ingredients: string[], type: ReptileType): string[] {
  // Herbivores: no meat, focus on greens/veggies
  if (type === 'herbivore') {
    return ingredients.filter(ing => {
      const lower = ing.toLowerCase();
      return !lower.includes('chicken') && !lower.includes('beef') && 
             !lower.includes('turkey') && !lower.includes('meat') &&
             !lower.includes('salmon') && !lower.includes('fish');
    });
  }
  
  // Insectivores: no plant matter, focus on proteins
  if (type === 'insectivore') {
    return ingredients.filter(ing => {
      const lower = ing.toLowerCase();
      return lower.includes('insect') || lower.includes('cricket') || 
             lower.includes('mealworm') || lower.includes('protein');
    });
  }
  
  // Omnivores: allow both
  return ingredients;
}

/**
 * Filter ingredients by pocket pet type
 */
function filterByPocketPetType(ingredients: string[], type: PocketPetType): string[] {
  // Rabbits and guinea pigs: hay-based, limit fruits
  if (type === 'rabbit' || type === 'guinea-pig') {
    return ingredients.filter(ing => {
      const lower = ing.toLowerCase();
      // Prioritize hay, greens, limit high-sugar fruits
      return lower.includes('hay') || lower.includes('green') || 
             lower.includes('kale') || lower.includes('carrot') ||
             (lower.includes('fruit') && !lower.includes('banana') && !lower.includes('grape'));
    });
  }
  
  // Hamsters and gerbils: more variety, can handle more fruits/grains
  return ingredients;
}

/**
 * Check if an ingredient is in the whitelist for a species
 * Also checks if ingredient is in ALL_INGREDIENTS for that species (even without composition data)
 */
export function isWhitelisted(ingredientName: string, species: Species, subtype?: ReptileType | PocketPetType): boolean {
  // First check the whitelist
  const whitelist = getWhitelistForSpecies(species, subtype);
  const inWhitelist = whitelist.some(ing => 
    ing.toLowerCase() === ingredientName.toLowerCase() ||
    ing.toLowerCase().includes(ingredientName.toLowerCase()) ||
    ingredientName.toLowerCase().includes(ing.toLowerCase())
  );
  
  if (inWhitelist) return true;
  
  // Also check if ingredient is in ALL_INGREDIENTS for this species
  // This ensures ingredients from ALL_INGREDIENTS are included even without composition data
  const speciesKey = species === 'dog' ? 'dogs' : 
                     species === 'cat' ? 'cats' :
                     species === 'bird' ? 'birds' :
                     species === 'reptile' ? 'reptiles' :
                     species === 'pocket-pet' ? 'pocket-pets' : species;
  
  const speciesData = ALL_INGREDIENTS[speciesKey as keyof typeof ALL_INGREDIENTS];
  if (speciesData) {
    for (const category of Object.values(speciesData)) {
      if (Array.isArray(category)) {
        const found = category.some(ing => 
          ing.toLowerCase() === ingredientName.toLowerCase() ||
          ing.toLowerCase().includes(ingredientName.toLowerCase()) ||
          ingredientName.toLowerCase().includes(ing.toLowerCase())
        );
        if (found) return true;
      }
    }
  }
  
  return false;
}

/**
 * Get "do not use" list for a species (ingredients marked as 'avoid')
 */
export function getBlacklistForSpecies(species: Species): string[] {
  const blacklist: string[] = [];
  
  // Check all ingredients in composition database
  const allCompositions = Object.keys(INGREDIENT_COMPOSITIONS);
  
  for (const key of allCompositions) {
    const composition = getIngredientComposition(key);
    if (composition?.speciesCompatibility) {
      const compat = composition.speciesCompatibility[species];
      if (compat === 'avoid') {
        blacklist.push(key.replace(/_/g, ' ')); // Convert to display name
      }
    }
  }
  
  return blacklist;
}

/**
 * Get confidence level for species ingredient coverage
 * 'full' = comprehensive data, 'beta' = partial data, 'limited' = minimal data
 */
export function getSpeciesCoverageLevel(species: Species): 'full' | 'beta' | 'limited' {
  const coverage: Record<Species, 'full' | 'beta' | 'limited'> = {
    'dog': 'full',
    'cat': 'full',
    'bird': 'beta',
    'reptile': 'beta',
    'pocket-pet': 'beta'
  };
  
  return coverage[species] || 'limited';
}
</file>

<file path="lib/utils/localStorageSafe.ts">
// lib/utils/localStorageSafe.ts
// Safe localStorage operations with error handling and transaction support

import { logger } from './logger';

/**
 * Safe localStorage get with error handling
 */
export function safeGetItem(key: string): string | null {
  if (typeof window === 'undefined') return null;
  
  try {
    return localStorage.getItem(key);
  } catch (error) {
    logger.error('Failed to read from localStorage', error, { key });
    return null;
  }
}

/**
 * Safe localStorage set with error handling and quota management
 */
export function safeSetItem(key: string, value: string): { success: boolean; error?: string } {
  if (typeof window === 'undefined') {
    return { success: false, error: 'localStorage not available' };
  }
  
  try {
    localStorage.setItem(key, value);
    return { success: true };
  } catch (error: any) {
    // Handle quota exceeded error
    if (error.name === 'QuotaExceededError' || error.code === 22) {
      logger.error('localStorage quota exceeded', error, { key, valueLength: value.length });
      return { success: false, error: 'Storage limit reached. Please clear some data or use a different browser.' };
    }
    
    // Handle other errors
    logger.error('Failed to write to localStorage', error, { key });
    return { success: false, error: 'Failed to save data. Please try again.' };
  }
}

/**
 * Safe JSON parse with error handling
 */
export function safeParseJSON<T>(jsonString: string | null, defaultValue: T): T {
  if (!jsonString) return defaultValue;
  
  try {
    const parsed = JSON.parse(jsonString);
    return parsed as T;
  } catch (error) {
    logger.error('Failed to parse JSON from localStorage', error, { jsonString: jsonString.substring(0, 100) });
    return defaultValue;
  }
}

/**
 * Safe JSON stringify with error handling
 */
export function safeStringifyJSON(data: any): string | null {
  try {
    return JSON.stringify(data);
  } catch (error) {
    logger.error('Failed to stringify JSON', error, { dataType: typeof data });
    return null;
  }
}

/**
 * Transaction-safe localStorage update
 * Reads, modifies, and writes atomically to prevent race conditions
 */
export function safeUpdateItem<T>(
  key: string,
  updateFn: (currentValue: T | null) => T
): { success: boolean; error?: string; data?: T } {
  if (typeof window === 'undefined') {
    return { success: false, error: 'localStorage not available' };
  }
  
  try {
    // Read current value
    const current = safeGetItem(key);
    const currentData = current ? safeParseJSON<T>(current, null as T) : null;
    
    // Update
    const newData = updateFn(currentData);
    
    // Write back
    const jsonString = safeStringifyJSON(newData);
    if (!jsonString) {
      return { success: false, error: 'Failed to serialize data' };
    }
    
    const writeResult = safeSetItem(key, jsonString);
    if (!writeResult.success) {
      return { success: false, error: writeResult.error };
    }
    
    return { success: true, data: newData };
  } catch (error) {
    logger.error('Failed to update localStorage item', error, { key });
    return { success: false, error: 'Failed to update data' };
  }
}

/**
 * Check if localStorage is available and has space
 */
export function isLocalStorageAvailable(): boolean {
  if (typeof window === 'undefined') return false;
  
  try {
    const testKey = '__localStorage_test__';
    localStorage.setItem(testKey, 'test');
    localStorage.removeItem(testKey);
    return true;
  } catch {
    return false;
  }
}

/**
 * Get estimated localStorage usage
 */
export function getLocalStorageUsage(): { used: number; available: boolean } {
  if (typeof window === 'undefined') {
    return { used: 0, available: false };
  }
  
  try {
    let total = 0;
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key) {
        const value = localStorage.getItem(key);
        if (value) {
          total += key.length + value.length;
        }
      }
    }
    return { used: total, available: true };
  } catch {
    return { used: 0, available: false };
  }
}
</file>

<file path="lib/utils/logger.ts">
// lib/utils/logger.ts
// Centralized logging utility for production-ready logging

type LogLevel = 'debug' | 'info' | 'warn' | 'error';

class Logger {
  private isDevelopment = process.env.NODE_ENV === 'development';

  private log(level: LogLevel, message: string, ...args: any[]): void {
    if (!this.isDevelopment && level === 'debug') {
      return; // Skip debug logs in production
    }

    const timestamp = new Date().toISOString();
    const prefix = `[${timestamp}] [${level.toUpperCase()}]`;

    switch (level) {
      case 'error':
        console.error(prefix, message, ...args);
        // In production, you might want to send to error tracking service
        // e.g., Sentry.captureException(new Error(message));
        break;
      case 'warn':
        console.warn(prefix, message, ...args);
        break;
      case 'info':
        if (this.isDevelopment) {
          console.info(prefix, message, ...args);
        }
        break;
      case 'debug':
        if (this.isDevelopment) {
          console.debug(prefix, message, ...args);
        }
        break;
    }
  }

  debug(message: string, ...args: any[]): void {
    this.log('debug', message, ...args);
  }

  info(message: string, ...args: any[]): void {
    this.log('info', message, ...args);
  }

  warn(message: string, ...args: any[]): void {
    this.log('warn', message, ...args);
  }

  error(message: string, error?: Error | unknown, ...args: any[]): void {
    if (error instanceof Error) {
      this.log('error', message, error.message, error.stack, ...args);
    } else {
      this.log('error', message, error, ...args);
    }
  }
}

export const logger = new Logger();
</file>

<file path="lib/utils/mascotImageMapping.ts">
// lib/utils/mascotImageMapping.ts
// Maps recipe categories to mascot images in /images/emojis/Mascots/

/**
 * Get the mascot image path for a recipe category
 * @param category - Recipe category (dogs, cats, birds, reptiles, pocket-pets)
 * @returns Path to the mascot image for that category
 */
export function getMascotImageForCategory(category: string): string {
  const categoryLower = (category || '').toLowerCase();
  
  const categoryToMascot: Record<string, string> = {
    'dogs': '/images/emojis/Mascots/Prep Puppy.jpg',
    'cats': '/images/emojis/Mascots/ProfessorPurffesor.jpg',
    'birds': '/images/emojis/Mascots/RobinRed-Route.jpg',
    'reptiles': '/images/emojis/Mascots/SherlockShells.jpg',
    'pocket-pets': '/images/emojis/Mascots/harvesthamster.jpg',
    // Handle plural forms
    'dog': '/images/emojis/Mascots/Prep Puppy.jpg',
    'cat': '/images/emojis/Mascots/ProfessorPurffesor.jpg',
    'bird': '/images/emojis/Mascots/RobinRed-Route.jpg',
    'reptile': '/images/emojis/Mascots/SherlockShells.jpg',
    'pocket-pet': '/images/emojis/Mascots/harvesthamster.jpg',
  };
  
  return categoryToMascot[categoryLower] || '/images/emojis/Mascots/Mascot-Emoji-Faces.png';
}
</file>

<file path="lib/utils/mealCalculator.ts">
/**
 * Utility functions for calculating how many meals a shopping list will provide
 */

/**
 * Parse an amount string (e.g., "200g", "1 cup", "500g") and return grams
 * Assumes "g" means grams, otherwise returns 0 if unable to parse
 */
export function parseAmountToGrams(amount: string): number {
  if (!amount) return 0;
  
  // Try to extract number from string like "200g", "500g", etc.
  const match = amount.match(/(\d+(?:\.\d+)?)\s*g/i);
  if (match) {
    return parseFloat(match[1]);
  }
  
  // Try to extract just a number if it's only a number
  const numberMatch = amount.match(/(\d+(?:\.\d+)?)/);
  if (numberMatch) {
    return parseFloat(numberMatch[1]);
  }
  
  return 0;
}

/**
 * Calculate how many meals a shopping list will provide based on recommended servings
 * @param ingredients - Shopping list ingredients with amounts
 * @param selectedIngredients - Original ingredient selections with grams
 * @param totalGrams - Total grams in the recipe
 * @param recommendedServingGrams - Recommended serving size in grams for the entire meal
 * @returns Number of meals the shopping list will provide (minimum across all ingredients)
 */
export function calculateMealsFromShoppingList(
  ingredients: Array<{ id: string; name: string; amount: string }>,
  selectedIngredients: Array<{ key: string; grams: number }>,
  totalGrams: number,
  recommendedServingGrams: number
): number {
  console.log('[calculateMealsFromShoppingList] Starting calculation with:', {
    ingredientsCount: ingredients.length,
    selectedIngredientsCount: selectedIngredients.length,
    totalGrams,
    recommendedServingGrams
  });

  if (!ingredients.length || !selectedIngredients.length || totalGrams === 0 || recommendedServingGrams === 0) {
    console.log('[calculateMealsFromShoppingList] Early return - invalid inputs');
    return 0;
  }

  // Create a map of ingredient key to grams per meal
  const ingredientGramsMap = new Map<string, number>();
  selectedIngredients.forEach(ing => {
    const gramsPerMeal = (ing.grams / totalGrams) * recommendedServingGrams;
    ingredientGramsMap.set(ing.key, gramsPerMeal);
    console.log(`[calculateMealsFromShoppingList] Mapped ${ing.key} -> ${gramsPerMeal.toFixed(2)}g per meal`);
  });

  // Calculate meals for each ingredient
  const mealsPerIngredient: number[] = [];

  ingredients.forEach(ing => {
    const purchasedGrams = parseAmountToGrams(ing.amount);
    console.log(`[calculateMealsFromShoppingList] Processing ingredient: ${ing.name} (id: ${ing.id}), purchased: ${purchasedGrams}g`);
    
    // Try to find by id first
    let gramsPerMeal = ingredientGramsMap.get(ing.id);
    
    // Fallback: try to match by name (for cases where id doesn't match key exactly)
    if (!gramsPerMeal) {
      console.log(`[calculateMealsFromShoppingList] No match by id ${ing.id}, trying name matching...`);
      // Try to find a matching selected ingredient by comparing normalized names
      const normalizedIngName = ing.name.toLowerCase().replace(/\s+/g, '_').replace(/[^a-z0-9_]/g, '');
      for (const [key, grams] of ingredientGramsMap.entries()) {
        const normalizedKey = key.toLowerCase().replace(/\s+/g, '_').replace(/[^a-z0-9_]/g, '');
        if (normalizedKey === normalizedIngName || normalizedIngName.includes(normalizedKey) || normalizedKey.includes(normalizedIngName)) {
          gramsPerMeal = grams;
          console.log(`[calculateMealsFromShoppingList] Found match by name: ${key} -> ${gramsPerMeal.toFixed(2)}g per meal`);
          break;
        }
      }
    } else {
      console.log(`[calculateMealsFromShoppingList] Found match by id: ${ing.id} -> ${gramsPerMeal.toFixed(2)}g per meal`);
    }
    
    if (purchasedGrams > 0 && gramsPerMeal && gramsPerMeal > 0) {
      const meals = purchasedGrams / gramsPerMeal;
      console.log(`[calculateMealsFromShoppingList] ${ing.name}: ${purchasedGrams}g / ${gramsPerMeal.toFixed(2)}g = ${meals.toFixed(2)} meals`);
      mealsPerIngredient.push(meals);
    } else {
      console.log(`[calculateMealsFromShoppingList] Skipping ${ing.name}: purchasedGrams=${purchasedGrams}, gramsPerMeal=${gramsPerMeal}`);
    }
  });

  if (mealsPerIngredient.length === 0) {
    console.log('[calculateMealsFromShoppingList] No valid meal calculations found');
    return 0;
  }

  // Return the minimum (bottleneck ingredient)
  const minMeals = Math.floor(Math.min(...mealsPerIngredient));
  console.log(`[calculateMealsFromShoppingList] Final result: ${minMeals} meals (from ${mealsPerIngredient.map(m => m.toFixed(2)).join(', ')})`);
  return minMeals;
}
</file>

<file path="lib/utils/mealCountCalculator.ts">
/**
 * Meal Count Calculator
 * 
 * Calculates dynamic meal counts based on pet profile characteristics.
 * This makes the count feel more personalized and organic rather than static.
 */

interface PetProfile {
  species: string;
  age?: string | number;
  healthConcerns?: string[];
  allergies?: string[];
}

/**
 * Calculates meal count variation based on pet profile characteristics.
 * 
 * Factors considered:
 * - Species: Different species have different recipe availability
 * - Health concerns: More concerns = fewer suitable options
 * - Allergies: More allergies = fewer safe options
 * - Age: Young and senior animals have more specialized needs
 * 
 * @param baseCount The actual number of filtered recipes
 * @param pet Pet profile information
 * @returns Adjusted count with organic variation
 */
export function calculateMealCountVariation(
  baseCount: number,
  pet: PetProfile
): number {
  let adjustedCount = baseCount;
  
  // 1. Species factor - different species have different recipe availability
  const speciesFactors: Record<string, number> = {
    'dog': 1.2,      // Dogs have more recipe options
    'dogs': 1.2,
    'cat': 1.0,
    'cats': 1.0,
    'bird': 0.8,     // Birds have fewer options
    'birds': 0.8,
    'reptile': 0.7,
    'reptiles': 0.7,
    'pocket-pet': 0.6,
    'pocket-pets': 0.6,
  };
  
  const species = pet.species?.toLowerCase() || 'dog';
  adjustedCount *= speciesFactors[species] || 1.0;
  
  // 2. Health concerns factor - more concerns = more specialized = fewer options
  const healthConcerns = pet.healthConcerns || [];
  const healthFactor = 1.0 - (healthConcerns.length * 0.1);
  adjustedCount *= Math.max(0.5, healthFactor);
  
  // 3. Allergies factor - more allergies = fewer safe options
  const allergies = pet.allergies || [];
  const allergyFactor = 1.0 - (allergies.length * 0.15);
  adjustedCount *= Math.max(0.3, allergyFactor);
  
  // 4. Age factor - young and senior animals have more specialized needs
  let ageFactor = 1.0;
  if (pet.age) {
    const ageNum = typeof pet.age === 'number' 
      ? pet.age 
      : parseFloat(String(pet.age)) || 3;
    
    if (ageNum < 1) {
      ageFactor = 1.3;  // Young animals have more specialized options
    } else if (ageNum > 7) {
      ageFactor = 0.9;  // Senior animals have fewer options
    }
  } else if (typeof pet.age === 'string') {
    const ageStr = pet.age.toLowerCase();
    if (ageStr === 'baby' || ageStr === 'young') {
      ageFactor = 1.3;
    } else if (ageStr === 'senior') {
      ageFactor = 0.9;
    }
  }
  adjustedCount *= ageFactor;
  
  // 5. Add small deterministic variation (¬±10%) for organic feel
  // Use a hash of pet profile to get stable "random" value
  const profileHash = JSON.stringify(pet).split('').reduce((acc, char) => {
    const hash = ((acc << 5) - acc) + char.charCodeAt(0);
    return hash & hash;
  }, 0);
  const stableVariation = 0.9 + ((Math.abs(profileHash) % 20) / 100); // 0.9 to 1.1, stable per pet
  adjustedCount *= stableVariation;
  
  // 6. Ensure reasonable bounds
  adjustedCount = Math.round(adjustedCount);
  adjustedCount = Math.max(8, adjustedCount);   // Never show less than 8
  adjustedCount = Math.min(85, adjustedCount);  // Never show more than 85
  
  return adjustedCount;
}
</file>

<file path="lib/utils/mealEstimation.ts">
/**
 * Meal Estimation Utilities
 * Calculate realistic meal counts based on actual package sizes
 */

import { getPackageSize } from '@/lib/data/packageSizes';
import { getProductPrice, getProductQuantity, getProductByIngredient } from '@/lib/data/product-prices';

export interface MealEstimate {
  estimatedMeals: number;
  totalCost: number;
  costPerMeal: number;
  breakdown: Array<{
    ingredient: string;
    recipeAmount: number; // grams needed per meal
    packageSize: number; // grams in package
    mealsFromPackage: number;
    packageCost: number;
  }>;
  notes: string[];
  exceedsBudget?: boolean; // True if costPerMeal > MAX_COST_PER_MEAL
}

// Maximum cost per meal threshold (matched to commercial pet food pricing)
// Dog: $0.50-$3.50/meal, Cat: $0.75-$4.00/meal, Bird: $0.10-$0.50/meal, Reptile: $1.00-$3.00/meal
// Using $4.00 to allow better ingredient variety and quality
export const MAX_COST_PER_MEAL = 4.00;

export interface ShoppingListItem {
  id: string;
  name: string;
  amount: string; // Recipe amount (e.g., "200g", "2 tbsp", "1 tsp")
  asinLink?: string;
  category?: string;
}

/**
 * Convert Amazon quantity strings to grams
 * Examples: "2 lbs", "24 oz", "18 count", "500 count", "32 oz", "1 head", "2 lbs"
 */
export function quantityToGrams(quantity: string): number {
  if (!quantity) return 0;
  
  const q = quantity.toLowerCase().trim();
  
  // Weight conversions
  const lbMatch = q.match(/(\d+(?:\.\d+)?)\s*(?:lb|lbs|pound|pounds)/);
  if (lbMatch) {
    return parseFloat(lbMatch[1]) * 453.592; // 1 lb = 453.592g
  }
  
  const ozMatch = q.match(/(\d+(?:\.\d+)?)\s*(?:oz|ounce|fl oz|fluid ounce)/);
  if (ozMatch) {
    return parseFloat(ozMatch[1]) * 28.3495; // 1 oz = 28.3495g
  }
  
  const kgMatch = q.match(/(\d+(?:\.\d+)?)\s*(?:kg|kilogram)/);
  if (kgMatch) {
    return parseFloat(kgMatch[1]) * 1000;
  }
  
  const gMatch = q.match(/(\d+(?:\.\d+)?)\s*(?:g|gram)/);
  if (gMatch) {
    return parseFloat(gMatch[1]);
  }
  
  // Count-based items (assume average weights)
  const countMatch = q.match(/(\d+)\s*(?:count|piece|pieces|can|cans|jar|jars|box|boxes|bag|bags|head|heads|bunch|bunches)/);
  if (countMatch) {
    const count = parseInt(countMatch[1]);
    const unit = countMatch[0].toLowerCase();
    
    // Estimate weights based on common items
    if (unit.includes('egg') || unit.includes('count')) {
      // Eggs: ~50g each
      if (q.includes('egg')) return count * 50;
      // Generic count: assume 100g per unit
      return count * 100;
    }
    if (unit.includes('can')) return count * 400; // Average can ~400g
    if (unit.includes('jar')) return count * 500; // Average jar ~500g
    if (unit.includes('box')) return count * 300; // Average box ~300g
    if (unit.includes('bag')) return count * 500; // Average bag ~500g
    if (unit.includes('head')) return count * 500; // Lettuce head ~500g
    if (unit.includes('bunch')) return count * 200; // Bunch of herbs ~200g
    
    return count * 100; // Default 100g per unit
  }
  
  return 0;
}

/**
 * Convert various units to grams
 */
export function parseAmountToGrams(amount: string | number, unit?: string): number {
  console.log('[parseAmountToGrams] Input - amount:', amount, 'unit:', unit);
  
  let numAmount: number;
  let unitStr: string;
  
  if (typeof amount === 'string') {
    // Try to parse amount and unit from string like "200g", "2 tbsp", etc.
    const match = amount.match(/(\d+(?:\.\d+)?)\s*(.*)/i);
    console.log('[parseAmountToGrams] Regex match result:', match);
    if (match) {
      numAmount = parseFloat(match[1]);
      unitStr = (match[2] || unit || 'g').trim().toLowerCase();
      console.log('[parseAmountToGrams] Parsed - numAmount:', numAmount, 'unitStr:', unitStr);
    } else {
      numAmount = parseFloat(amount) || 0;
      unitStr = (unit || 'g').toLowerCase();
      console.log('[parseAmountToGrams] No match, using parseFloat - numAmount:', numAmount, 'unitStr:', unitStr);
    }
  } else {
    numAmount = amount;
    unitStr = (unit || 'g').toLowerCase();
    console.log('[parseAmountToGrams] Number input - numAmount:', numAmount, 'unitStr:', unitStr);
  }
  
  if (!numAmount || isNaN(numAmount)) {
    console.log('[parseAmountToGrams] ‚ùå Invalid amount, returning 0');
    return 0;
  }
  
  // Weight conversions
  if (unitStr === 'g' || unitStr === 'gram' || unitStr === 'grams') {
    console.log('[parseAmountToGrams] ‚úÖ Weight (g) conversion:', numAmount);
    return numAmount;
  }
  if (unitStr === 'kg' || unitStr === 'kilogram' || unitStr === 'kilograms') {
    const result = numAmount * 1000;
    console.log('[parseAmountToGrams] ‚úÖ Weight (kg) conversion:', result);
    return result;
  }
  if (unitStr === 'lb' || unitStr === 'pound' || unitStr === 'pounds') {
    const result = numAmount * 453.592;
    console.log('[parseAmountToGrams] ‚úÖ Weight (lb) conversion:', result);
    return result;
  }
  if (unitStr === 'oz' || unitStr === 'ounce' || unitStr === 'ounces') {
    const result = numAmount * 28.3495;
    console.log('[parseAmountToGrams] ‚úÖ Weight (oz) conversion:', result);
    return result;
  }
  
  // Volume conversions (approximate, assuming water density for liquids)
  if (unitStr === 'ml' || unitStr === 'milliliter' || unitStr === 'milliliters') {
    console.log('[parseAmountToGrams] ‚úÖ Volume (ml) conversion:', numAmount);
    return numAmount; // ~1:1 for water
  }
  if (unitStr === 'l' || unitStr === 'liter' || unitStr === 'liters') {
    const result = numAmount * 1000;
    console.log('[parseAmountToGrams] ‚úÖ Volume (l) conversion:', result);
    return result;
  }
  if (unitStr === 'cup' || unitStr === 'cups') {
    const result = numAmount * 240;
    console.log('[parseAmountToGrams] ‚úÖ Volume (cup) conversion:', result);
    return result; // ~240g for water
  }
  if (unitStr === 'tbsp' || unitStr === 'tablespoon' || unitStr === 'tablespoons') {
    const result = numAmount * 15;
    console.log('[parseAmountToGrams] ‚úÖ Volume (tbsp) conversion:', result);
    return result; // ~15g for water
  }
  if (unitStr === 'tsp' || unitStr === 'teaspoon' || unitStr === 'teaspoons') {
    const result = numAmount * 5;
    console.log('[parseAmountToGrams] ‚úÖ Volume (tsp) conversion:', result);
    return result; // ~5g for water
  }
  
  // Count conversions (rough estimates)
  if (unitStr === 'piece' || unitStr === 'pieces' || unitStr === 'whole' || unitStr === 'pinch' || unitStr === 'pinches') {
    const result = numAmount * 10;
    console.log('[parseAmountToGrams] ‚úÖ Count conversion:', result);
    return result; // Assume 10g per piece/pinch (conservative estimate)
  }
  
  // Default: assume grams
  console.log('[parseAmountToGrams] ‚ö†Ô∏è Unknown unit, defaulting to grams:', numAmount);
  return numAmount;
}

/**
 * Calculate how many meals can be made from a shopping list
 * based on actual package sizes
 */
export function calculateMealsFromGroceryList(
  shoppingList: ShoppingListItem[],
  recipeGramsPerMeal?: number, // Optional: total recipe grams per meal
  species?: string, // Optional: species for species-aware product matching
  preferBudget: boolean = true // Default to true for cost calculations - prefer budget-tier products
): MealEstimate {
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/0b2cb572-34bf-468c-9297-dd079c8c4c2d',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'mealEstimation.ts:136',message:'calculateMealsFromGroceryList entry',data:{preferBudget},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
  // #endregion
  console.log('[calculateMealsFromGroceryList] ========== Starting calculation ==========');
  console.log('[calculateMealsFromGroceryList] Input shoppingList:', shoppingList);
  console.log('[calculateMealsFromGroceryList] shoppingList.length:', shoppingList?.length);
  console.log('[calculateMealsFromGroceryList] getProductPrice available:', typeof getProductPrice !== 'undefined');
  
  const breakdown: MealEstimate['breakdown'] = [];
  const notes: string[] = [];
  let totalCost = 0;
  
  if (!shoppingList || shoppingList.length === 0) {
    console.log('[calculateMealsFromGroceryList] ‚ùå Empty shopping list, returning 0 meals');
    return {
      estimatedMeals: 0,
      totalCost: 0,
      costPerMeal: 0,
      breakdown: [],
      notes: ['No ingredients in shopping list']
    };
  }
  
  // Calculate for each ingredient
  for (let i = 0; i < shoppingList.length; i++) {
    const item = shoppingList[i];
    console.log(`[calculateMealsFromGroceryList] Processing item ${i + 1}/${shoppingList.length}:`, item);
    
    const ingredientNameLower = item.name.toLowerCase();
    
    // Try to get product data from product-prices.json first
    let packageSizeGrams = 0;
    let itemCost = 0;
    let priceSource = 'package-estimate';
    
    const product = getProductByIngredient(ingredientNameLower);
    if (product) {
      // Use actual product quantity from Amazon
      if (product.quantity) {
        packageSizeGrams = quantityToGrams(product.quantity);
        console.log(`[calculateMealsFromGroceryList]   ‚úÖ Got quantity from product-prices.json: "${product.quantity}" = ${packageSizeGrams}g`);
      }
      
      // Use actual product price
      if (product.price?.amount) {
        itemCost = product.price.amount;
        priceSource = 'product-prices-json';
        console.log(`[calculateMealsFromGroceryList]   ‚úÖ Using product-prices.json price: $${itemCost}`);
      }
    }
    
    // Fall back to package size estimates if no product data
    if (packageSizeGrams === 0) {
      const packageInfo = getPackageSize(item.name, item.category);
      packageSizeGrams = packageInfo.typicalSize;
      if (!itemCost) {
        itemCost = packageInfo.estimatedCost;
      }
      console.log(`[calculateMealsFromGroceryList]   ‚ö†Ô∏è Using package estimate: ${packageSizeGrams}g, $${itemCost}`);
    }
    
    // Parse recipe amount to grams
    const recipeGrams = parseAmountToGrams(item.amount);
    console.log(`[calculateMealsFromGroceryList]   Recipe amount input: "${item.amount}" (type: ${typeof item.amount})`);
    console.log(`[calculateMealsFromGroceryList]   Recipe grams parsed:`, recipeGrams);
    
    if (recipeGrams <= 0) {
      console.log(`[calculateMealsFromGroceryList]   ‚ùå Skipping - invalid recipeGrams:`, recipeGrams);
      notes.push(`‚ö†Ô∏è Could not parse amount for ${item.name}: "${item.amount}"`);
      continue;
    }
    
    // How many meals can this package make? Keep as decimal for accurate calculation
    const mealsFromPackage = packageSizeGrams / recipeGrams;
    console.log(`[calculateMealsFromGroceryList]   Meals from package: ${packageSizeGrams} / ${recipeGrams} = ${mealsFromPackage}`);
    
    const breakdownItem = {
      ingredient: item.name,
      recipeAmount: recipeGrams,
      packageSize: packageSizeGrams,
      mealsFromPackage: mealsFromPackage,
      packageCost: itemCost,
    };
    breakdown.push(breakdownItem);
    console.log(`[calculateMealsFromGroceryList]   ‚úÖ Added to breakdown (price source: ${priceSource}):`, breakdownItem);
    
    totalCost += itemCost;
    
    // Add notes for very small or very large ratios
    if (mealsFromPackage > 100) {
      notes.push(`${item.name}: Package will last 100+ meals`);
    } else if (mealsFromPackage < 5) {
      notes.push(`${item.name}: Package only makes ${Math.round(mealsFromPackage)} meals - consider larger size`);
    }
  }
  
  console.log('[calculateMealsFromGroceryList] Breakdown array after processing:', breakdown);
  console.log('[calculateMealsFromGroceryList] breakdown.length:', breakdown.length);
  console.log('[calculateMealsFromGroceryList] Total cost so far:', totalCost);
  
  if (breakdown.length === 0) {
    console.log('[calculateMealsFromGroceryList] ‚ùå No valid breakdown items, returning 0 meals');
    return {
      estimatedMeals: 0,
      totalCost: 0,
      costPerMeal: 0,
      breakdown: [],
      notes: ['Could not parse ingredient amounts']
    };
  }
  
  // Filter out staples (ingredients lasting 100+ meals) - they shouldn't limit the calculation
  const substantialIngredients = breakdown.filter(b => b.mealsFromPackage < 100);
  console.log('[calculateMealsFromGroceryList] Substantial ingredients (< 100 meals):', substantialIngredients);
  console.log('[calculateMealsFromGroceryList] substantialIngredients.length:', substantialIngredients.length);
  
  // ‚úÖ FIX: Handle empty array from Math.min - ensure we never pass empty array
  let estimatedMeals = 0;
  if (substantialIngredients.length > 0) {
    estimatedMeals = Math.min(...substantialIngredients.map(b => b.mealsFromPackage));
  } else if (breakdown.length > 0) {
    estimatedMeals = Math.min(...breakdown.map(b => b.mealsFromPackage));
  } else {
    console.error('[calculateMealsFromGroceryList] ‚ùå No valid ingredients in breakdown after processing');
    return {
      estimatedMeals: 0,
      totalCost: 0,
      costPerMeal: 0,
      breakdown: [],
      notes: ['Could not calculate meals from provided ingredients - no valid data after processing']
    };
  }
  console.log('[calculateMealsFromGroceryList] Estimated meals (before rounding):', estimatedMeals);
  
  // ‚úÖ FIX: Floor the final result (not individual ingredients) to get whole meals
  // This gives accurate estimates without compounding rounding errors
  const finalMeals = Math.max(1, Math.floor(estimatedMeals));
  const costPerMeal = finalMeals > 0 ? totalCost / finalMeals : 0;
  console.log('[calculateMealsFromGroceryList] Final meals after rounding:', finalMeals);
  console.log('[calculateMealsFromGroceryList] Cost per meal:', costPerMeal);
  
  // Check if cost exceeds budget threshold
  const finalCostPerMeal = Math.round(costPerMeal * 100) / 100;
  const exceedsBudget = finalCostPerMeal > MAX_COST_PER_MEAL;
  
  // Add general notes
  if (finalMeals < 5) {
    notes.push('‚ö†Ô∏è Some packages are small - consider buying larger sizes');
  } else if (finalMeals > 20) {
    notes.push('‚úì Great value - ingredients will last many meals');
  }
  
  // Add budget warning if exceeded
  if (exceedsBudget) {
    notes.push(`‚ö†Ô∏è Cost per meal ($${finalCostPerMeal.toFixed(2)}) exceeds the $${MAX_COST_PER_MEAL} target. Consider choosing cheaper ingredient alternatives.`);
  }
  
  const finalResult = {
    estimatedMeals: finalMeals,
    totalCost: Math.round(totalCost * 100) / 100,
    costPerMeal: finalCostPerMeal,
    breakdown,
    notes: [...new Set(notes)], // Remove duplicates
    exceedsBudget,
  };
  
  console.log('[calculateMealsFromGroceryList] ‚úÖ Final result:', finalResult);
  if (exceedsBudget) {
    console.log(`[calculateMealsFromGroceryList] ‚ö†Ô∏è  WARNING: Cost per meal exceeds $${MAX_COST_PER_MEAL}`);
  }
  console.log('[calculateMealsFromGroceryList] ============================================');
  
  return finalResult;
}
</file>

<file path="lib/utils/mealImageAssignment.ts">
/**
 * Utility to assign meal images to recipes based on hash of recipe ID
 * Cycles through 25 images per species for consistent assignment
 */

/**
 * Hash a string to a number (deterministic)
 */
function hashStringToNumber(s: string): number {
  let hash = 0;
  for (let i = 0; i < s.length; i++) {
    const char = s.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  return Math.abs(hash);
}

/**
 * Get meal image path for a recipe based on its ID and category
 * Returns path like: /images/meals/dogs-meal-01.png
 * 
 * @param recipeId - Unique recipe identifier
 * @param category - Recipe category (dogs, cats, birds, reptiles, pocket-pets)
 * @returns Image path string
 */
export function getMealImageForRecipe(recipeId: string, category: string): string {
  // Normalize category to match image naming
  const categoryMap: Record<string, string> = {
    'dogs': 'dogs',
    'cats': 'cats',
    'birds': 'birds',
    'reptiles': 'reptiles',
    'pocket-pets': 'pocket-pets'
  };
  
  const normalizedCategory = categoryMap[category.toLowerCase()] || 'dogs';
  
  // Hash the recipe ID to get a number between 0-24 (for 25 images)
  const hash = hashStringToNumber(recipeId);
  const imageNumber = (hash % 25) + 1; // 1-25
  
  // Format as 01-25
  const imageNumberStr = imageNumber.toString().padStart(2, '0');
  
  return `/images/meals/${normalizedCategory}-meal-${imageNumberStr}.png`;
}

/**
 * Get all available meal images for a species
 * Useful for checking which images exist
 */
export function getAvailableMealImages(category: string): string[] {
  const categoryMap: Record<string, string> = {
    'dogs': 'dogs',
    'cats': 'cats',
    'birds': 'birds',
    'reptiles': 'reptiles',
    'pocket-pets': 'pocket-pets'
  };
  
  const normalizedCategory = categoryMap[category.toLowerCase()] || 'dogs';
  const images: string[] = [];
  
  for (let i = 1; i <= 25; i++) {
    const imageNumber = i.toString().padStart(2, '0');
    images.push(`/images/meals/${normalizedCategory}-meal-${imageNumber}.png`);
  }
  
  return images;
}
</file>

<file path="lib/utils/mealNameGenerator.ts">
// lib/utils/mealNameGenerator.ts
// Enhanced meal naming system with semantic awareness, health context, and pet personalization

import { getIngredientById, getIngredientByName, type UnifiedIngredient, type IngredientCategory } from '../data/unifiedIngredientRegistry';
import type { Recipe } from '../types';

// =================================================================
// Phase 1: Foundation - Ingredient Display Name Integration
// =================================================================

/**
 * Get display name for an ingredient from unified registry
 */
function getIngredientDisplayName(ingredientKey: string): string {
  // Try to find ingredient by ID (snake_case)
  let ingredient: UnifiedIngredient | null = getIngredientById(ingredientKey);
  
  // If not found, try by name
  if (!ingredient) {
    ingredient = getIngredientByName(ingredientKey);
  }
  
  // If found, return primary display name
  if (ingredient) {
    return ingredient.primaryDisplayName;
  }
  
  // Fallback: format key to Title Case
  return ingredientKey
    .split(/[_\s-]+/)
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(' ');
}

/**
 * Categorize ingredients by type using unified registry
 */
function categorizeIngredients(ingredientKeys: string[]): {
  proteins: string[];
  carbs: string[];
  vegetables: string[];
  fruits: string[];
  supplements: string[];
} {
  const categories = {
    proteins: [] as string[],
    carbs: [] as string[],
    vegetables: [] as string[],
    fruits: [] as string[],
    supplements: [] as string[],
  };
  
  for (const key of ingredientKeys) {
    let ingredient: UnifiedIngredient | null = getIngredientById(key);
    if (!ingredient) {
      ingredient = getIngredientByName(key);
    }
    
    if (ingredient) {
      const category = ingredient.category;
      const displayName = getIngredientDisplayName(key);
      
      switch (category) {
        case 'protein':
        case 'insect':
          categories.proteins.push(displayName);
          break;
        case 'grain':
          categories.carbs.push(displayName);
          break;
        case 'vegetable':
          categories.vegetables.push(displayName);
          break;
        case 'fruit':
          categories.fruits.push(displayName);
          break;
        case 'supplement':
          categories.supplements.push(displayName);
          break;
        default:
          // Try to infer from name
          const lower = key.toLowerCase();
          if (lower.match(/\b(chicken|turkey|beef|lamb|fish|salmon|tuna|meat|protein|pork|duck|organ|heart|liver|kidney|venison|rabbit|quail)\b/)) {
            categories.proteins.push(displayName);
          } else if (lower.match(/\b(rice|oats|quinoa|barley|wheat|grain|seed|millet|potato|sweet.*potato|pumpkin|squash)\b/)) {
            categories.carbs.push(displayName);
          } else if (lower.match(/\b(carrot|broccoli|spinach|kale|lettuce|pepper|vegetable|green)\b/)) {
            categories.vegetables.push(displayName);
          }
          break;
      }
    } else {
      // Fallback categorization by name
      const lower = key.toLowerCase();
      if (lower.match(/\b(chicken|turkey|beef|lamb|fish|salmon|tuna|meat|protein|pork|duck|organ|heart|liver|kidney|venison|rabbit|quail)\b/)) {
        categories.proteins.push(getIngredientDisplayName(key));
      } else if (lower.match(/\b(rice|oats|quinoa|barley|wheat|grain|seed|millet|potato|sweet.*potato|pumpkin|squash)\b/)) {
        categories.carbs.push(getIngredientDisplayName(key));
      } else if (lower.match(/\b(carrot|broccoli|spinach|kale|lettuce|pepper|vegetable|green)\b/)) {
        categories.vegetables.push(getIngredientDisplayName(key));
      }
    }
  }
  
  return categories;
}

// =================================================================
// Phase 2: Semantic Metadata Extraction
// =================================================================

interface MealSemantics {
  dominantProtein: string;
  dominantCarb: string;
  dominantVeg: string;
  nutritionalAngle: 'High Protein' | 'Low Fat' | 'High Fiber' | 'Balanced';
  cookingStyle: 'Slow-Cooked' | 'Oven-Baked' | 'Fresh' | 'Stewed' | 'Raw' | null;
  healthTags: string[];
}

/**
 * Extract semantic metadata from recipe/ingredients
 */
function extractMealSemantics(
  ingredientKeys: string[],
  options?: {
    nutritionalProfile?: {
      protein?: number;
      fat?: number;
      fiber?: number;
    };
    healthConcerns?: string[];
    recipe?: Recipe;
  }
): MealSemantics {
  const categorized = categorizeIngredients(ingredientKeys);
  
  // Determine dominant ingredients
  const dominantProtein = categorized.proteins[0] || '';
  const dominantCarb = categorized.carbs[0] || '';
  const dominantVeg = categorized.vegetables[0] || '';
  
  // Determine nutritional angle
  let nutritionalAngle: 'High Protein' | 'Low Fat' | 'High Fiber' | 'Balanced' = 'Balanced';
  if (options?.nutritionalProfile) {
    const { protein, fat, fiber } = options.nutritionalProfile;
    if (protein && protein > 30) {
      nutritionalAngle = 'High Protein';
    } else if (fat && fat < 10) {
      nutritionalAngle = 'Low Fat';
    } else if (fiber && fiber > 5) {
      nutritionalAngle = 'High Fiber';
    }
  }
  
  // Determine cooking style (from recipe metadata or infer)
  let cookingStyle: 'Slow-Cooked' | 'Oven-Baked' | 'Fresh' | 'Stewed' | 'Raw' | null = null;
  if (options?.recipe) {
    const recipe = options.recipe;
    const nameLower = recipe.name?.toLowerCase() || '';
    const descLower = recipe.description?.toLowerCase() || '';
    const instructions = (recipe.instructions || []).join(' ').toLowerCase();
    
    if (nameLower.includes('slow') || instructions.includes('slow cook')) {
      cookingStyle = 'Slow-Cooked';
    } else if (nameLower.includes('baked') || instructions.includes('bake') || instructions.includes('oven')) {
      cookingStyle = 'Oven-Baked';
    } else if (nameLower.includes('fresh') || descLower.includes('fresh')) {
      cookingStyle = 'Fresh';
    } else if (nameLower.includes('stew') || instructions.includes('stew')) {
      cookingStyle = 'Stewed';
    } else if (nameLower.includes('raw') || instructions.includes('raw')) {
      cookingStyle = 'Raw';
    }
  }
  
  // Map health concerns to naming tags
  const healthTags: string[] = [];
  if (options?.healthConcerns && options.healthConcerns.length > 0) {
    healthTags.push(...options.healthConcerns);
  }
  
  return {
    dominantProtein,
    dominantCarb,
    dominantVeg,
    nutritionalAngle,
    cookingStyle,
    healthTags,
  };
}

// =================================================================
// Phase 5: Health Concern Lexicon
// =================================================================

const HEALTH_CONCERN_NAMING_MAP: Record<string, string> = {
  'joint-health': 'Mobility',
  'joint health': 'Mobility',
  'kidney-disease': 'Renal Support',
  'kidney disease': 'Renal Support',
  'digestive-health': 'Digestive Ease',
  'digestive health': 'Digestive Ease',
  'weight-management': 'Weight Control',
  'weight management': 'Weight Control',
  'allergies': 'Hypoallergenic',
  'diabetes': 'Blood Sugar Balance',
  'dental-health': 'Dental Care',
  'dental health': 'Dental Care',
  'pancreatitis': 'Low-Fat',
  'urinary-health': 'Urinary Support',
  'urinary health': 'Urinary Support',
  'skin-health': 'Skin & Coat',
  'skin health': 'Skin & Coat',
  'heart-health': 'Heart Health',
  'heart health': 'Heart Health',
  'immune-support': 'Immune Support',
  'immune support': 'Immune Support',
  'senior-health': 'Senior Support',
  'senior health': 'Senior Support',
};

/**
 * Map health concern to naming-friendly tag
 */
function mapHealthConcernToTag(concern: string): string {
  const normalized = concern.toLowerCase().trim();
  return HEALTH_CONCERN_NAMING_MAP[normalized] || concern;
}

// =================================================================
// Phase 3: Naming Families (25+ Patterns)
// =================================================================

type NamingFamily = 'ingredient-driven' | 'health-focused' | 'pet-personalized' | 'nutritional-style' | 'creative';

interface NamingPattern {
  family: NamingFamily;
  pattern: string;
  requires?: {
    protein?: boolean;
    carb?: boolean;
    veggie?: boolean;
    healthTag?: boolean;
    petName?: boolean;
  };
}

const NAMING_PATTERNS: NamingPattern[] = [
  // Family 1: Ingredient-Driven (Classic)
  { family: 'ingredient-driven', pattern: '{protein} & {carb} Bowl', requires: { protein: true, carb: true } },
  { family: 'ingredient-driven', pattern: '{protein} with {veggie} Medley', requires: { protein: true, veggie: true } },
  { family: 'ingredient-driven', pattern: 'Fresh {protein} & {secondIngredient}', requires: { protein: true } },
  { family: 'ingredient-driven', pattern: '{protein} {carb} Harmony', requires: { protein: true, carb: true } },
  { family: 'ingredient-driven', pattern: '{protein} Garden Blend', requires: { protein: true } },
  
  // Family 2: Health-Focused
  { family: 'health-focused', pattern: '{healthFocus} {protein} Recipe', requires: { protein: true, healthTag: true } },
  { family: 'health-focused', pattern: 'Balanced {protein} & {carb} Plate', requires: { protein: true, carb: true } },
  { family: 'health-focused', pattern: '{protein} {healthTag} Formula', requires: { protein: true, healthTag: true } },
  { family: 'health-focused', pattern: 'Supportive {protein} Blend', requires: { protein: true, healthTag: true } },
  { family: 'health-focused', pattern: 'Gentle {protein} Medley', requires: { protein: true, healthTag: true } },
  
  // Family 3: Pet-Personalized (only for custom meals)
  { family: 'pet-personalized', pattern: "{petName}'s {protein} Dinner", requires: { protein: true, petName: true } },
  { family: 'pet-personalized', pattern: "{petName}'s Favorite {protein} Bowl", requires: { protein: true, petName: true } },
  { family: 'pet-personalized', pattern: 'Special {protein} for {petName}', requires: { protein: true, petName: true } },
  { family: 'pet-personalized', pattern: "{petName}'s {healthTag} {protein}", requires: { protein: true, petName: true, healthTag: true } },
  { family: 'pet-personalized', pattern: '{breed} {protein} Feast', requires: { protein: true } },
  
  // Family 4: Nutritional-Style
  { family: 'nutritional-style', pattern: 'High-Protein {protein} Power Bowl', requires: { protein: true } },
  { family: 'nutritional-style', pattern: 'Lean {protein} & {carb} Mix', requires: { protein: true, carb: true } },
  { family: 'nutritional-style', pattern: 'Nutrient-Rich {protein} Medley', requires: { protein: true } },
  { family: 'nutritional-style', pattern: 'Complete {protein} Formula', requires: { protein: true } },
  { family: 'nutritional-style', pattern: 'Premium {protein} Blend', requires: { protein: true } },
  
  // Family 5: Creative/Descriptive
  { family: 'creative', pattern: 'Rustic {protein} Farmhouse Bowl', requires: { protein: true } },
  { family: 'creative', pattern: 'Savory {protein} Kitchen Creation', requires: { protein: true } },
  { family: 'creative', pattern: 'Golden {protein} & {carb} Plate', requires: { protein: true, carb: true } },
  { family: 'creative', pattern: 'Ultimate {protein} Feast', requires: { protein: true } },
  { family: 'creative', pattern: "Chef's Choice {protein} Blend", requires: { protein: true } },
  { family: 'creative', pattern: 'Heritage {protein} & {veggie} Bowl', requires: { protein: true, veggie: true } },
  { family: 'creative', pattern: 'Wholesome {protein} Delight', requires: { protein: true } },
  { family: 'creative', pattern: 'Gourmet {protein} & {carb} Mix', requires: { protein: true, carb: true } },
  { family: 'creative', pattern: 'Premium {protein} Medley', requires: { protein: true } },
  { family: 'creative', pattern: 'Classic {protein} & {veggie} Recipe', requires: { protein: true, veggie: true } },
  
  // More ingredient-driven patterns for variety
  { family: 'ingredient-driven', pattern: '{protein} Power Bowl', requires: { protein: true } },
  { family: 'ingredient-driven', pattern: '{protein} & {veggie} Delight', requires: { protein: true, veggie: true } },
  { family: 'ingredient-driven', pattern: '{protein} {carb} Fusion', requires: { protein: true, carb: true } },
  
  // More nutritional-style patterns
  { family: 'nutritional-style', pattern: 'Vital {protein} Formula', requires: { protein: true } },
  { family: 'nutritional-style', pattern: 'Optimal {protein} & {carb} Blend', requires: { protein: true, carb: true } },
];

// =================================================================
// Phase 4: Pattern Selection Logic
// =================================================================

/**
 * Simple hash function for deterministic pattern selection
 */
function hashString(str: string): number {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32-bit integer
  }
  return Math.abs(hash);
}

/**
 * Select naming family based on context
 */
function selectNamingFamily(
  semantics: MealSemantics,
  options?: {
    petName?: string;
    isCustomMeal?: boolean;
    recipeId?: string;
  }
): NamingFamily {
  // For custom meals, add randomness using timestamp + ingredients for variety
  const seed = options?.recipeId || 
    (options?.isCustomMeal ? `${Date.now()}-${semantics.dominantProtein}-${semantics.dominantCarb}` : '');
  
  if (seed) {
    const hash = hashString(seed);
    const families: NamingFamily[] = ['ingredient-driven', 'health-focused', 'nutritional-style', 'creative', 'pet-personalized'];
    return families[hash % families.length];
  }
  
  // Prioritize health-focused if health concerns present
  if (semantics.healthTags.length > 0) {
    return 'health-focused';
  }
  
  // Use pet-personalized for custom meals (30% chance to avoid repetition)
  if (options?.isCustomMeal && options?.petName) {
    const hash = hashString(options.petName + seed);
    if (hash % 10 < 3) { // 30% chance
      return 'pet-personalized';
    }
  }
  
  // Use nutritional-style if nutritional angle is strong
  if (semantics.nutritionalAngle !== 'Balanced') {
    return 'nutritional-style';
  }
  
  // Default to ingredient-driven
  return 'ingredient-driven';
}

/**
 * Select a pattern from the chosen family
 */
function selectPattern(
  family: NamingFamily,
  semantics: MealSemantics,
  options?: {
    petName?: string;
    petBreed?: string;
    recipeId?: string;
    isCustomMeal?: boolean;
  }
): NamingPattern {
  // Filter patterns by family and requirements
  const familyPatterns = NAMING_PATTERNS.filter(p => p.family === family);
  
  // Filter by requirements
  const availablePatterns = familyPatterns.filter(pattern => {
    if (pattern.requires) {
      if (pattern.requires.protein && !semantics.dominantProtein) return false;
      if (pattern.requires.carb && !semantics.dominantCarb) return false;
      if (pattern.requires.veggie && !semantics.dominantVeg) return false;
      if (pattern.requires.healthTag && semantics.healthTags.length === 0) return false;
      if (pattern.requires.petName && !options?.petName) return false;
    }
    return true;
  });
  
  if (availablePatterns.length === 0) {
    // Fallback to any pattern in family
    return familyPatterns[0] || NAMING_PATTERNS[0];
  }
  
  // For custom meals, add timestamp for more variety
  const seed = options?.recipeId || 
    (options?.isCustomMeal 
      ? `${Date.now()}-${semantics.dominantProtein}-${semantics.dominantCarb}-${semantics.dominantVeg}`
      : `${semantics.dominantProtein}-${semantics.dominantCarb}-${semantics.dominantVeg}`);
  const hash = hashString(seed);
  return availablePatterns[hash % availablePatterns.length];
}

/**
 * Clean breed/pet type by removing parenthetical content like "(budgie)"
 */
function cleanBreedOrSpecies(text: string | undefined): string | undefined {
  if (!text) return undefined;
  // Remove content in parentheses like "(budgie)" or "(common)"
  return text.replace(/\s*\([^)]*\)/g, '').trim();
}

/**
 * Fill pattern with actual values
 */
function fillPattern(
  pattern: NamingPattern,
  semantics: MealSemantics,
  options?: {
    petName?: string;
    petBreed?: string;
    secondIngredient?: string;
  }
): string {
  let result = pattern.pattern;
  
  // Replace placeholders
  result = result.replace(/{protein}/g, semantics.dominantProtein || 'Protein');
  result = result.replace(/{carb}/g, semantics.dominantCarb || 'Grain');
  result = result.replace(/{veggie}/g, semantics.dominantVeg || 'Vegetable');
  result = result.replace(/{secondIngredient}/g, options?.secondIngredient || semantics.dominantCarb || semantics.dominantVeg || 'Mix');
  
  // Health tags
  if (semantics.healthTags.length > 0) {
    const healthTag = mapHealthConcernToTag(semantics.healthTags[0]);
    result = result.replace(/{healthTag}/g, healthTag);
    result = result.replace(/{healthFocus}/g, healthTag);
  }
  
  // Pet context - clean breed to remove parentheses
  if (options?.petName) {
    result = result.replace(/{petName}/g, options.petName);
  }
  if (options?.petBreed) {
    const cleanedBreed = cleanBreedOrSpecies(options.petBreed);
    if (cleanedBreed) {
      result = result.replace(/{breed}/g, cleanedBreed);
    }
  }
  
  return result;
}

// =================================================================
// Phase 6: Collision Avoidance
// =================================================================

// In-memory collision map (per session)
const nameCollisionMap = new Map<string, number>();

/**
 * Ensure unique name by appending suffix if needed
 */
function ensureUniqueName(
  baseName: string,
  ingredientSignature: string
): string {
  // Check if we've seen this signature before
  const existingCount = nameCollisionMap.get(ingredientSignature);
  
  if (existingCount === undefined) {
    // First time seeing this signature - don't add any suffix
    nameCollisionMap.set(ingredientSignature, 1);
    return baseName;
  }
  
  // Collision detected - append numeric suffix (skip 0, start at 2)
  const suffix = existingCount + 1;
  nameCollisionMap.set(ingredientSignature, suffix);
  return `${baseName} ${suffix}`;
}

/**
 * Create ingredient signature for collision detection
 */
function createIngredientSignature(ingredientKeys: string[]): string {
  return ingredientKeys
    .map(k => k.toLowerCase().trim())
    .sort()
    .join('|');
}

// =================================================================
// Phase 7: Short Name Generation
// =================================================================

/**
 * Generate short name (max 20 characters)
 */
function generateShortName(semantics: MealSemantics): string {
  const parts: string[] = [];
  
  if (semantics.dominantProtein) {
    parts.push(semantics.dominantProtein);
  }
  
  if (semantics.dominantCarb) {
    parts.push(semantics.dominantCarb);
  } else if (semantics.dominantVeg) {
    parts.push(semantics.dominantVeg);
  }
  
  if (parts.length === 0) {
    return 'Custom Meal';
  }
  
  const shortName = parts.join(' & ');
  
  // Truncate if too long
  if (shortName.length > 20) {
    return shortName.substring(0, 17) + '...';
  }
  
  return shortName;
}

// =================================================================
// Phase 9: Quality Assurance
// =================================================================

/**
 * Validate and format meal name
 */
function validateMealName(name: string): string {
  // Remove underscores
  let cleaned = name.replace(/_/g, ' ');
  
  // Remove any trailing numbers or "0" that might have been added
  cleaned = cleaned.replace(/\s+0+\s*$/, '').trim();
  
  // Remove any parenthetical content that might have slipped through
  cleaned = cleaned.replace(/\s*\([^)]*\)\s*/g, ' ');
  
  // Fix spacing
  cleaned = cleaned.replace(/\s+/g, ' ').trim();
  
  // Ensure proper capitalization (Title Case)
  cleaned = cleaned
    .split(' ')
    .map(word => {
      // Skip small words unless they're the first word
      const smallWords = ['a', 'an', 'and', 'as', 'at', 'but', 'by', 'for', 'if', 'in', 'of', 'on', 'or', 'the', 'to'];
      if (smallWords.includes(word.toLowerCase()) && cleaned.indexOf(word) > 0) {
        return word.toLowerCase();
      }
      return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
    })
    .join(' ');
  
  // Check for generic patterns and add descriptor if needed
  const genericPatterns = [
    /^Chicken Bowl$/i,
    /^Beef Mix$/i,
    /^Salmon Bowl$/i,
  ];
  
  for (const pattern of genericPatterns) {
    if (pattern.test(cleaned)) {
      cleaned = cleaned.replace(/Bowl|Mix/, 'Power Bowl');
    }
  }
  
  // Validate length
  if (cleaned.length < 10) {
    cleaned = cleaned + ' Meal';
  } else if (cleaned.length > 60) {
    cleaned = cleaned.substring(0, 57) + '...';
  }
  
  // Final cleanup - remove any trailing whitespace or special characters
  cleaned = cleaned.trim();
  
  return cleaned;
}

// =================================================================
// Main Export: generateMealName
// =================================================================

export interface MealNameOptions {
  petName?: string;
  petBreed?: string;
  petSpecies?: string;
  healthConcerns?: string[];
  nutritionalProfile?: {
    protein?: number;
    fat?: number;
    fiber?: number;
  };
  mealType?: 'complete' | 'treat' | 'supplement';
  recipeId?: string;
  recipe?: Recipe;
  isCustomMeal?: boolean;
}

export interface MealNameResult {
  fullName: string;
  shortName: string;
}

/**
 * Generate meal name with full context awareness
 */
export function generateMealName(
  ingredients: string[],
  options?: MealNameOptions
): MealNameResult {
  if (ingredients.length === 0) {
    return {
      fullName: 'Custom Meal',
      shortName: 'Custom Meal',
    };
  }
  
  // Extract semantics
  const semantics = extractMealSemantics(ingredients, {
    nutritionalProfile: options?.nutritionalProfile,
    healthConcerns: options?.healthConcerns,
    recipe: options?.recipe,
  });
  
  // Select naming family
  const family = selectNamingFamily(semantics, {
    petName: options?.petName,
    isCustomMeal: options?.isCustomMeal,
    recipeId: options?.recipeId,
  });
  
  // Clean petBreed to remove parenthetical content
  const cleanedBreed = options?.petBreed ? cleanBreedOrSpecies(options.petBreed) : undefined;
  
  // Select pattern
  const pattern = selectPattern(family, semantics, {
    petName: options?.petName,
    petBreed: cleanedBreed,
    recipeId: options?.recipeId,
    isCustomMeal: options?.isCustomMeal,
  });
  
  // Get second ingredient for patterns that need it
  const categorized = categorizeIngredients(ingredients);
  const secondIngredient = categorized.proteins[1] || categorized.carbs[0] || categorized.vegetables[0];
  
  // Fill pattern (use cleaned breed)
  let fullName = fillPattern(pattern, semantics, {
    petName: options?.petName,
    petBreed: cleanedBreed,
    secondIngredient,
  });
  
  // Clean up any remaining parenthetical content that might have been in the name
  fullName = fullName.replace(/\s*\([^)]*\)\s*/g, ' ').replace(/\s+/g, ' ').trim();
  
  // Handle nutritional angle in name
  if (semantics.nutritionalAngle === 'High Protein' && !fullName.includes('High-Protein') && !fullName.includes('Power')) {
    fullName = fullName.replace(/{protein}/g, 'High-Protein ' + semantics.dominantProtein);
  }
  
  // Create ingredient signature for collision detection
  const ingredientSignature = createIngredientSignature(ingredients);
  
  // Ensure uniqueness
  fullName = ensureUniqueName(fullName, ingredientSignature);
  
  // Validate and format
  fullName = validateMealName(fullName);
  
  // Generate short name
  const shortName = generateShortName(semantics);
  
  return {
    fullName,
    shortName,
  };
}

/**
 * Legacy function for backward compatibility
 * @deprecated Use generateMealName with options instead
 */
export function getShortMealName(ingredients: string[]): string {
  const result = generateMealName(ingredients);
  return result.shortName;
}
</file>

<file path="lib/utils/nutritionalRecommendations.ts">
// lib/utils/nutritionalRecommendations.ts
// Maps nutritional deficiencies to recommended supplements and ingredients

import { petSupplements, type Supplement } from '@/lib/data/supplements';
import { getVettedProduct } from '@/lib/data/vetted-products';

export interface RecommendedSupplement {
  name: string;
  description: string;
  benefits: string;
  addressesDeficiency: string;
  defaultAmount: string;
  amazonLink?: string;
  asinLink?: string;
  isIngredient?: boolean;
  productName?: string;
  vetNote?: string;
}

/**
 * Map nutritional gaps to recommended supplements/ingredients
 */
export function getRecommendationsForDeficiency(
  deficiency: string,
  species: 'dog' | 'cat' | 'bird' | 'reptile' | 'pocket-pet',
  healthConcerns: string[] = []
): RecommendedSupplement[] {
  const recommendations: RecommendedSupplement[] = [];
  const lowerDeficiency = deficiency.toLowerCase();

  // Normalize species for supplement lookup
  const supplementSpecies = species === 'pocket-pet' ? 'pocket-pets' : 
                            species === 'reptile' ? 'reptiles' : 
                            species;

  // Map deficiency patterns to supplement categories
  const deficiencyMappings: Record<string, string[]> = {
    'protein': ['allergy-support', 'digestive-health'],
    'calcium': ['joint-mobility', 'digestive-health'],
    'phosphorus': ['joint-mobility'],
    'ca:p': ['joint-mobility'],
    'taurine': ['allergy-support'],
    'fiber': ['digestive-health', 'weight-management'],
    'vitamin': ['skin-coat'],
    'omega': ['skin-coat', 'allergy-support'],
    'fat': ['skin-coat', 'allergy-support'],
  };

  // Find matching supplement categories
  const matchingCategories: string[] = [];
  for (const [pattern, categories] of Object.entries(deficiencyMappings)) {
    if (lowerDeficiency.includes(pattern)) {
      matchingCategories.push(...categories);
    }
  }

  // Get supplements from petSupplements data
  const speciesSupplements = petSupplements[supplementSpecies as keyof typeof petSupplements];
  if (speciesSupplements) {
    for (const category of matchingCategories) {
      const categorySupplements = speciesSupplements[category as keyof typeof speciesSupplements];
      if (Array.isArray(categorySupplements)) {
        for (const supplement of categorySupplements) {
          // Check if vetted product exists
          const vettedProduct = getVettedProduct(supplement.name);
          
          recommendations.push({
            name: supplement.name,
            description: supplement.description,
            benefits: supplement.benefits,
            addressesDeficiency: deficiency,
            defaultAmount: 'As directed',
            amazonLink: supplement.amazonLink,
            asinLink: vettedProduct?.asinLink || supplement.amazonLink,
            productName: vettedProduct?.productName || supplement.name,
            vetNote: vettedProduct?.vetNote,
          });
        }
      }
    }
  }

  // Species-specific ingredient recommendations
  if (lowerDeficiency.includes('protein') && species === 'cat') {
    recommendations.push({
      name: 'Taurine Supplement',
      description: 'Essential amino acid for cats',
      benefits: 'Prevents taurine deficiency, supports heart and eye health',
      addressesDeficiency: 'Low protein / Taurine deficiency',
      defaultAmount: '250-500mg per day',
      isIngredient: false,
    });
  }

  if (lowerDeficiency.includes('calcium') || lowerDeficiency.includes('ca:p')) {
    if (species === 'reptile' || species === 'bird') {
      recommendations.push({
        name: 'Calcium with Vitamin D3',
        description: 'Essential for bone health',
        benefits: 'Prevents metabolic bone disease, supports proper Ca:P ratio',
        addressesDeficiency: 'Calcium deficiency / Ca:P imbalance',
        defaultAmount: 'Lightly dust food 2-3x per week',
        isIngredient: false,
      });
    } else {
      recommendations.push({
        name: 'Calcium Supplement',
        description: 'Calcium for bone and dental health',
        benefits: 'Supports proper Ca:P ratio, bone strength',
        addressesDeficiency: 'Calcium deficiency / Ca:P imbalance',
        defaultAmount: 'As directed on package',
        isIngredient: false,
      });
    }
  }

  if (lowerDeficiency.includes('fiber')) {
    recommendations.push({
      name: 'Pumpkin Powder',
      description: 'Natural fiber source',
      benefits: 'Promotes digestive regularity and satiety',
      addressesDeficiency: 'Low fiber',
      defaultAmount: '1-2 tsp per meal',
      isIngredient: true,
    });
  }

  // Health concern-based recommendations
  if (healthConcerns.includes('joint-health') || healthConcerns.includes('joint-mobility')) {
    recommendations.push({
      name: 'Glucosamine & Chondroitin',
      description: 'Joint health supplements',
      benefits: 'Supports cartilage health and joint mobility',
      addressesDeficiency: 'Joint support needed',
      defaultAmount: 'As directed on package',
      isIngredient: false,
    });
  }

  // Remove duplicates based on name
  const uniqueRecommendations = recommendations.filter((rec, index, self) =>
    index === self.findIndex(r => r.name === rec.name)
  );

  return uniqueRecommendations;
}

/**
 * Get all recommendations for a recipe based on nutritional gaps
 */
export function getRecommendationsForRecipe(
  nutritionalGaps: string[],
  species: 'dog' | 'cat' | 'bird' | 'reptile' | 'pocket-pet',
  healthConcerns: string[] = []
): RecommendedSupplement[] {
  const allRecommendations: RecommendedSupplement[] = [];

  for (const gap of nutritionalGaps) {
    const recommendations = getRecommendationsForDeficiency(gap, species, healthConcerns);
    allRecommendations.push(...recommendations);
  }

  // Remove duplicates
  const uniqueRecommendations = allRecommendations.filter((rec, index, self) =>
    index === self.findIndex(r => r.name === rec.name)
  );

  return uniqueRecommendations;
}
</file>

<file path="lib/utils/nutritionFallbacks.ts">
// lib/utils/nutritionFallbacks.ts
// Category-based nutrition fallback data for ingredients missing from INGREDIENT_COMPOSITIONS
// Used when ingredient lookup fails to ensure recipe generation can continue

import type { IngredientComposition } from '@/lib/data/ingredientCompositions';

/**
 * Category-based nutrition templates for fallback data
 * Based on USDA averages and research-based estimates for common ingredient categories
 */
export const CATEGORY_NUTRITION_FALLBACKS: Record<string, IngredientComposition> = {
  poultry: {
    protein: 20.0,
    fat: 8.0,
    carbs: 0,
    fiber: 0,
    moisture: 70,
    calcium: 10,
    phosphorus: 180,
    kcal: 145,
    source: 'estimated_fallback',
    needsReview: true,
  },
  red_meat: {
    protein: 22.0,
    fat: 12.0,
    carbs: 0,
    fiber: 0,
    moisture: 65,
    calcium: 12,
    phosphorus: 190,
    kcal: 180,
    source: 'estimated_fallback',
    needsReview: true,
  },
  fish: {
    protein: 19.0,
    fat: 6.0,
    carbs: 0,
    fiber: 0,
    moisture: 75,
    calcium: 25,
    phosphorus: 220,
    omega3: 1.5,
    kcal: 130,
    source: 'estimated_fallback',
    needsReview: true,
  },
  insect: {
    protein: 15.0,
    fat: 8.0,
    carbs: 5,
    fiber: 2,
    moisture: 70,
    calcium: 30,
    phosphorus: 200,
    kcal: 140,
    source: 'estimated_fallback',
    needsReview: true,
  },
  vegetable: {
    protein: 2.0,
    fat: 0.5,
    carbs: 12,
    fiber: 3,
    moisture: 85,
    calcium: 30,
    phosphorus: 40,
    kcal: 50,
    source: 'estimated_fallback',
    needsReview: true,
  },
  fruit: {
    protein: 1.0,
    fat: 0.3,
    carbs: 15,
    fiber: 2,
    moisture: 80,
    calcium: 10,
    phosphorus: 20,
    kcal: 60,
    source: 'estimated_fallback',
    needsReview: true,
  },
  supplement: {
    protein: 0,
    fat: 0,
    carbs: 0,
    fiber: 0,
    moisture: 5,
    calcium: 500, // High calcium for supplements
    phosphorus: 300,
    kcal: 0,
    source: 'estimated_fallback',
    needsReview: true,
  },
  grain: {
    protein: 8.0,
    fat: 2.0,
    carbs: 75,
    fiber: 5,
    moisture: 10,
    calcium: 20,
    phosphorus: 150,
    kcal: 350,
    source: 'estimated_fallback',
    needsReview: true,
  },
  seed: {
    protein: 15.0,
    fat: 10.0,
    carbs: 50,
    fiber: 8,
    moisture: 8,
    calcium: 50,
    phosphorus: 400,
    kcal: 500,
    source: 'estimated_fallback',
    needsReview: true,
  },
  hay: {
    protein: 8.0,
    fat: 2.0,
    carbs: 60,
    fiber: 30,
    moisture: 10,
    calcium: 40,
    phosphorus: 30,
    kcal: 200,
    source: 'estimated_fallback',
    needsReview: true,
  },
  // Enhanced categories
  leafy_green: {
    protein: 2.5,
    fat: 0.4,
    carbs: 3,
    fiber: 2.5,
    moisture: 92,
    calcium: 100,
    phosphorus: 50,
    kcal: 20,
    source: 'estimated_fallback',
    needsReview: true,
  },
  starchy_veg: {
    protein: 2.0,
    fat: 0.2,
    carbs: 20,
    fiber: 3,
    moisture: 75,
    calcium: 30,
    phosphorus: 50,
    kcal: 85,
    source: 'estimated_fallback',
    needsReview: true,
  },
  fatty_protein: {
    protein: 18.0,
    fat: 15.0,
    carbs: 0,
    fiber: 0,
    moisture: 65,
    calcium: 15,
    phosphorus: 200,
    kcal: 220,
    source: 'estimated_fallback',
    needsReview: true,
  },
  lean_protein: {
    protein: 28.0,
    fat: 3.0,
    carbs: 0,
    fiber: 0,
    moisture: 68,
    calcium: 10,
    phosphorus: 200,
    kcal: 140,
    source: 'estimated_fallback',
    needsReview: true,
  },
};

/**
 * Confidence levels for fallback categories
 */
export const FALLBACK_CONFIDENCE: Record<string, 'high' | 'medium' | 'low'> = {
  poultry: 'medium',
  red_meat: 'medium',
  fish: 'medium',
  insect: 'low',
  vegetable: 'medium',
  fruit: 'medium',
  supplement: 'low',
  grain: 'medium',
  seed: 'medium',
  hay: 'medium',
  leafy_green: 'medium',
  starchy_veg: 'medium',
  fatty_protein: 'medium',
  lean_protein: 'medium',
};

/**
 * Species-specific fallback adjustments
 */
export const SPECIES_FALLBACK_ADJUSTMENTS: Record<string, Partial<IngredientComposition>> = {
  // Cats need more protein and taurine
  cat: {
    // No direct adjustment, but recipes should be tagged
  },
  // Birds need more calcium
  bird: {
    // No direct adjustment, but recipes should be tagged
  },
  // Reptiles need specific Ca:P ratios
  reptile: {
    // No direct adjustment, but recipes should be tagged
  },
};

/**
 * Get fallback nutrition data for an ingredient based on its name patterns
 * @param ingredientName - The ingredient name to match
 * @returns IngredientComposition with estimated values, or default fallback
 */
export function getFallbackNutrition(ingredientName: string): IngredientComposition {
  const lowerName = ingredientName.toLowerCase().trim();
  
  // Lean protein patterns (breast, fillet)
  if ((lowerName.includes('chicken') || lowerName.includes('turkey')) && 
      (lowerName.includes('breast') || lowerName.includes('fillet'))) {
    return { ...CATEGORY_NUTRITION_FALLBACKS.lean_protein };
  }
  
  // Fatty protein patterns (thigh, dark meat, organ meats)
  if (lowerName.includes('thigh') || lowerName.includes('dark meat') ||
      lowerName.includes('liver') || lowerName.includes('heart') ||
      lowerName.includes('kidney') || lowerName.includes('giblet')) {
    return { ...CATEGORY_NUTRITION_FALLBACKS.fatty_protein };
  }
  
  // Poultry patterns (general)
  if (lowerName.includes('chicken') || lowerName.includes('turkey') || 
      lowerName.includes('duck') || lowerName.includes('quail') ||
      lowerName.includes('pheasant')) {
    return { ...CATEGORY_NUTRITION_FALLBACKS.poultry };
  }
  
  // Red meat patterns
  if (lowerName.includes('beef') || lowerName.includes('lamb') || 
      lowerName.includes('venison') || lowerName.includes('rabbit') ||
      lowerName.includes('bison') || lowerName.includes('elk') ||
      lowerName.includes('goat')) {
    return { ...CATEGORY_NUTRITION_FALLBACKS.red_meat };
  }
  
  // Fish patterns
  if (lowerName.includes('fish') || lowerName.includes('salmon') || 
      lowerName.includes('sardine') || lowerName.includes('tuna') ||
      lowerName.includes('mackerel') || lowerName.includes('herring') ||
      lowerName.includes('trout') || lowerName.includes('cod')) {
    return { ...CATEGORY_NUTRITION_FALLBACKS.fish };
  }
  
  // Insect patterns
  if (lowerName.includes('mealworm') || lowerName.includes('cricket') || 
      lowerName.includes('insect') || lowerName.includes('waxworm') ||
      lowerName.includes('superworm') || lowerName.includes('roach') ||
      lowerName.includes('locust')) {
    return { ...CATEGORY_NUTRITION_FALLBACKS.insect };
  }
  
  // Leafy green patterns (more specific)
  if (lowerName.includes('spinach') || lowerName.includes('kale') || 
      lowerName.includes('lettuce') || lowerName.includes('arugula') ||
      lowerName.includes('endive') || lowerName.includes('escarole') ||
      lowerName.includes('collard') || lowerName.includes('mustard') ||
      lowerName.includes('turnip') || lowerName.includes('dandelion') ||
      lowerName.includes('watercress') || lowerName.includes('mache') ||
      lowerName.includes('frisee') || lowerName.includes('radicchio') ||
      lowerName.includes('swiss chard') || lowerName.includes('beet green')) {
    return { ...CATEGORY_NUTRITION_FALLBACKS.leafy_green };
  }
  
  // Starchy vegetable patterns
  if (lowerName.includes('potato') || lowerName.includes('sweet potato') || 
      lowerName.includes('yam') || lowerName.includes('butternut') ||
      lowerName.includes('acorn squash') || lowerName.includes('pumpkin') ||
      lowerName.includes('winter squash') || lowerName.includes('kabocha')) {
    return { ...CATEGORY_NUTRITION_FALLBACKS.starchy_veg };
  }
  
  // Other vegetable patterns
  if (lowerName.includes('broccoli') || lowerName.includes('carrot') || 
      lowerName.includes('pea') || lowerName.includes('bean') ||
      lowerName.includes('cabbage') || lowerName.includes('celery') ||
      lowerName.includes('zucchini') || lowerName.includes('pepper') ||
      lowerName.includes('cucumber') || lowerName.includes('bok') ||
      lowerName.includes('radish') || lowerName.includes('asparagus') ||
      lowerName.includes('fennel') || lowerName.includes('leek')) {
    return { ...CATEGORY_NUTRITION_FALLBACKS.vegetable };
  }
  
  // Fruit patterns
  if (lowerName.includes('apple') || lowerName.includes('berry') || 
      lowerName.includes('banana') || lowerName.includes('melon') ||
      lowerName.includes('pear') || lowerName.includes('peach') ||
      lowerName.includes('plum') || lowerName.includes('cherry') ||
      lowerName.includes('grape') || lowerName.includes('mango') ||
      lowerName.includes('papaya') || lowerName.includes('fig')) {
    return { ...CATEGORY_NUTRITION_FALLBACKS.fruit };
  }
  
  // Supplement patterns
  if (lowerName.includes('supplement') || lowerName.includes('powder') || 
      lowerName.includes('vitamin') || lowerName.includes('mineral') ||
      lowerName.includes('calcium') || lowerName.includes('kelp') ||
      lowerName.includes('spirulina') || lowerName.includes('probiotic')) {
    return { ...CATEGORY_NUTRITION_FALLBACKS.supplement };
  }
  
  // Grain patterns
  if (lowerName.includes('rice') || lowerName.includes('oats') || 
      lowerName.includes('barley') || lowerName.includes('wheat') ||
      lowerName.includes('quinoa') || lowerName.includes('buckwheat') ||
      lowerName.includes('millet') || lowerName.includes('corn')) {
    return { ...CATEGORY_NUTRITION_FALLBACKS.grain };
  }
  
  // Seed patterns
  if (lowerName.includes('seed') || lowerName.includes('sunflower') || 
      lowerName.includes('pumpkin') || lowerName.includes('flax') ||
      lowerName.includes('chia') || lowerName.includes('hemp')) {
    return { ...CATEGORY_NUTRITION_FALLBACKS.seed };
  }
  
  // Hay patterns
  if (lowerName.includes('hay') || lowerName.includes('timothy') || 
      lowerName.includes('alfalfa') || lowerName.includes('orchard')) {
    return { ...CATEGORY_NUTRITION_FALLBACKS.hay };
  }
  
  // Default fallback (average of all categories)
  return {
    protein: 12.0,
    fat: 6.0,
    carbs: 6,
    fiber: 1.5,
    moisture: 70,
    calcium: 86,
    phosphorus: 150,
    kcal: 110,
    source: 'estimated_fallback',
    needsReview: true,
  };
}
</file>

<file path="lib/utils/organicCount.ts">
/**
 * Organic Count Utilities
 * 
 * Makes numeric counts feel more natural and less robotic by:
 * - Avoiding perfect multiples of 10/5
 * - Adding subtle variation
 * - Providing contextual messaging
 */

/**
 * Makes a count look more organic by avoiding "perfect" numbers.
 * Uses deterministic variation based on the count itself to ensure stability.
 * 
 * Examples:
 * - 40 ‚Üí 42 or 38 (avoids multiples of 10)
 * - 35 ‚Üí 36 or 34 (sometimes avoids multiples of 5)
 * - Adds subtle variation (¬±2) to make numbers feel less robotic
 * 
 * @param count The base count to make organic
 * @returns An organic-looking count (stable for the same input)
 */
export function makeCountOrganic(count: number): number {
  let organic = count;
  
  // Use count as seed for deterministic "random" variation
  const seed = count * 17 + 23; // Simple hash function
  
  // Don't show "perfect" multiples of 10
  if (count % 10 === 0) {
    // Convert 40 ‚Üí 42, 50 ‚Üí 47, etc. (deterministic based on count)
    organic = count + ((seed % 2 === 0) ? 2 : -3);
  }
  
  // Don't show "perfect" multiples of 5 (sometimes, deterministic)
  if (count % 5 === 0 && (seed % 10) > 2) {
    organic = count + 1;
  }
  
  // Add subtle variation (¬±2) to make numbers feel less robotic (deterministic)
  const variation = ((seed % 5) - 2); // -2 to +2, stable per count
  organic += variation;
  
  // Ensure it doesn't go below 1
  organic = Math.max(1, organic);
  
  // Round to nearest integer
  organic = Math.round(organic);
  
  return organic;
}

/**
 * Gets a contextual message based on the meal count.
 * 
 * @param count The number of meals found
 * @param species The pet species (optional, for personalization)
 * @returns A contextual message string
 */
export function getCountMessage(count: number, species?: string): string {
  if (count > 60) {
    return `Amazing! We found ${count} perfect meals`;
  }
  if (count > 40) {
    return `Great news! We found ${count} excellent meals`;
  }
  if (count > 25) {
    return `We found ${count} great meal options`;
  }
  if (count > 15) {
    return `We found ${count} good meal options`;
  }
  if (count > 5) {
    return `We found ${count} suitable meals`;
  }
  return `We found ${count} meal option${count !== 1 ? 's' : ''}`;
}

/**
 * Gets subtext based on the meal count.
 * 
 * @param count The number of meals found
 * @param species The pet species (optional, for personalization)
 * @returns A subtext string
 */
export function getSubtext(count: number, species?: string): string {
  const speciesName = species || 'pet';
  
  if (count > 50) {
    return `That's a lot of options! Your ${speciesName} is going to love these.`;
  }
  if (count > 30) {
    return `Plenty of variety for your ${speciesName}.`;
  }
  if (count > 15) {
    return `Good selection for your ${speciesName}'s needs.`;
  }
  if (count > 5) {
    return `Curated selection based on your ${speciesName}'s profile.`;
  }
  return `Limited options due to specific dietary requirements.`;
}
</file>

<file path="lib/utils/petPurchaseTracking.ts">
// lib/utils/petPurchaseTracking.ts
// Per-pet purchase tracking (separate from global village purchase tracking)

import { safeGetItem, safeSetItem, safeParseJSON, safeUpdateItem } from './localStorageSafe';
import { logger } from './logger';
import { validateUserId } from './validation';

export interface PetPurchaseRecord {
  ingredientId: string;
  ingredientName?: string;
  recipeId?: string; // Optional: which recipe this purchase was for
  purchaseDate: string; // ISO string
  confirmed: boolean;
  amazonOrderId?: string;
}

const PREFIX = 'pet_purchases_';

/**
 * Get storage key for pet purchases
 */
function getStorageKey(userId: string, petId: string): string {
  return `${PREFIX}${userId}_${petId}`;
}

/**
 * Load purchases for a pet
 */
export function getPetPurchases(userId: string, petId: string): PetPurchaseRecord[] {
  if (!userId || !petId) {
    return [];
  }

  const userIdValidation = validateUserId(userId);
  if (!userIdValidation.valid) {
    logger.warn('Invalid userId in getPetPurchases', { userId, petId });
    return [];
  }

  try {
    const key = getStorageKey(userId, petId);
    const stored = safeGetItem(key);
    
    if (!stored) {
      return [];
    }

    const parsed = safeParseJSON<PetPurchaseRecord[]>(stored, []);
    if (Array.isArray(parsed)) {
      return parsed;
    }

    return [];
  } catch (error) {
    logger.error('Failed to load pet purchases', error as Error, { userId, petId });
    return [];
  }
}

/**
 * Get count of confirmed purchases for a pet
 */
export function getPetPurchaseCount(userId: string, petId: string): number {
  const purchases = getPetPurchases(userId, petId);
  return purchases.filter(p => p.confirmed).length;
}

/**
 * Add a purchase record for a pet
 */
export function addPetPurchase(
  userId: string,
  petId: string,
  ingredientId: string,
  ingredientName?: string,
  recipeId?: string,
  amazonOrderId?: string
): PetPurchaseRecord[] {
  if (!userId || !petId || !ingredientId) {
    logger.warn('Missing required parameters in addPetPurchase', { userId, petId, ingredientId });
    return getPetPurchases(userId, petId);
  }

  const userIdValidation = validateUserId(userId);
  if (!userIdValidation.valid) {
    logger.warn('Invalid userId in addPetPurchase', { userId, petId });
    return getPetPurchases(userId, petId);
  }

  const key = getStorageKey(userId, petId);
  const result = safeUpdateItem<PetPurchaseRecord[]>(key, (records) => {
    const currentRecords = records || [];
    
    // Check if purchase already exists (avoid duplicates)
    const exists = currentRecords.some(
      r => r.ingredientId === ingredientId && r.confirmed
    );
    
    if (exists) {
      return currentRecords; // Already exists
    }

    // Add new purchase record
    const newRecord: PetPurchaseRecord = {
      ingredientId,
      ingredientName,
      recipeId,
      purchaseDate: new Date().toISOString(),
      confirmed: false,
      ...(amazonOrderId && { amazonOrderId }),
    };

    return [...currentRecords, newRecord];
  });

  if (!result.success) {
    logger.error('Failed to add pet purchase', undefined, { userId, petId, ingredientId, error: result.error });
    return getPetPurchases(userId, petId);
  }

  return result.data || [];
}

/**
 * Confirm a purchase for a pet
 */
export function confirmPetPurchase(
  userId: string,
  petId: string,
  ingredientId: string,
  ingredientName?: string,
  recipeId?: string,
  amazonOrderId?: string
): { success: boolean; error?: string } {
  if (!userId || !petId || !ingredientId) {
    return { success: false, error: 'Missing required parameters' };
  }

  const userIdValidation = validateUserId(userId);
  if (!userIdValidation.valid) {
    return { success: false, error: userIdValidation.error };
  }

  const key = getStorageKey(userId, petId);
  const result = safeUpdateItem<PetPurchaseRecord[]>(key, (records) => {
    const currentRecords = records || [];
    
    // Find existing unconfirmed record
    const existingIndex = currentRecords.findIndex(
      r => r.ingredientId === ingredientId && !r.confirmed
    );

    if (existingIndex >= 0) {
      // Update existing record
      const updated = [...currentRecords];
      updated[existingIndex] = {
        ...updated[existingIndex],
        ingredientName: ingredientName || updated[existingIndex].ingredientName,
        recipeId: recipeId || updated[existingIndex].recipeId,
        confirmed: true,
        purchaseDate: new Date().toISOString(),
        ...(amazonOrderId && { amazonOrderId }),
      };
      return updated;
    }

    // Add new confirmed record
    return [
      ...currentRecords,
      {
        ingredientId,
        ingredientName,
        recipeId,
        purchaseDate: new Date().toISOString(),
        confirmed: true,
        ...(amazonOrderId && { amazonOrderId }),
      },
    ];
  });

  if (!result.success) {
    logger.error('Failed to confirm pet purchase', undefined, { userId, petId, ingredientId, error: result.error });
    return { success: false, error: result.error };
  }

  return { success: true };
}
</file>

<file path="lib/utils/petRatingSystem.ts">
// lib/utils/petRatingSystem.ts
import type { Recipe as BaseRecipe } from '@/lib/types';
import { INGREDIENT_COMPOSITIONS, getIngredientComposition } from '@/lib/data/ingredientCompositions';
import { AVIAN_NUTRITION_STANDARDS, getAvianStandards } from '@/lib/data/avian-nutrition-standards';
import { AAFCO_NUTRIENT_PROFILES, getAAFCOStandards, validateCriticalNutrients } from '@/lib/data/aafco-standards';
import { REPTILE_NUTRITION_STANDARDS, getReptileStandards, validateReptileNutrition } from '@/lib/data/reptile-nutrition';
import { BALANCEIT_ANALYSIS } from '@/lib/competitors/balanceit-analysis';

export interface Pet {
  id: string;
  name: string;
  type: 'dog' | 'cat' | 'bird' | 'reptile' | 'pocket-pet';
  breed: string;
  age: number;
  weight?: number;
  activityLevel?: 'sedentary' | 'moderate' | 'active' | 'very-active';
  healthConcerns: string[];
  dietaryRestrictions: string[];
  allergies?: string[];
  dislikes?: string[];
  savedRecipes?: string[];
  names?: string[];
  weightKg?: number;
}

// Helper to detect if data is just the auto-generated placeholder
function isGenericNutrition(n: any): boolean {
  if (!n) return true;
  // Checks for the specific ranges found in your recipes-complete.ts
  return n.protein?.min === 25 && n.fat?.min === 10 && n.fiber?.min === 2;
}

function extractNutrition(recipe: any): {
  protein: number;
  fat: number;
  fiber: number;
  calories: number;
  phosphorus: number;
  isGeneric: boolean;
} | null {
  // Check for nutritionalInfo object
  if (recipe.nutritionalInfo) {
    const isGeneric = isGenericNutrition(recipe.nutritionalInfo);
    return {
      protein: recipe.nutritionalInfo.protein?.min || 0,
      fat: recipe.nutritionalInfo.fat?.min || 0,
      fiber: recipe.nutritionalInfo.fiber?.min || 0,
      calories: recipe.nutritionalInfo.calories?.min || 0,
      phosphorus: recipe.nutritionalInfo.phosphorus?.min || 0,
      isGeneric
    };
  }
  return null;
}

function enrichRecipeFromIngredients(recipe: any): {
  estimatedProtein: number;
  estimatedFat: number;
  estimatedPhosphorus: 'low' | 'moderate' | 'high';
  healthBenefits: string[];
  allergens: string[];
} {
  const name = recipe.name?.toLowerCase() || '';
  const ingredients = recipe.ingredients
    ?.map((i: any) => (typeof i === 'string' ? i : i.name).toLowerCase())
    .join(' ') || '';

  const allText = `${name} ${ingredients}`;

  // Create variation based on protein source
  let estimatedProtein = 25;
  if (allText.includes('venison')) estimatedProtein = 34; // Leaner, high protein
  else if (allText.includes('rabbit')) estimatedProtein = 33;
  else if (allText.includes('salmon') || allText.includes('fish')) estimatedProtein = 32;
  else if (allText.includes('chicken')) estimatedProtein = 30;
  else if (allText.includes('turkey')) estimatedProtein = 29;
  else if (allText.includes('beef')) estimatedProtein = 28;
  else if (allText.includes('pork')) estimatedProtein = 27;

  // Fat estimation
  let estimatedFat = 15;
  if (allText.includes('salmon') || allText.includes('duck')) estimatedFat = 18;
  else if (allText.includes('lean') || allText.includes('turkey')) estimatedFat = 10;
  else if (allText.includes('pork') || allText.includes('lamb')) estimatedFat = 16;

  // Phosphorus estimation
  let estimatedPhosphorus: 'low' | 'moderate' | 'high' = 'moderate';
  if (allText.includes('liver') || allText.includes('kidney') || allText.includes('organ')) {
    estimatedPhosphorus = 'high';
  } else if (allText.includes('egg whites') || allText.includes('rice')) {
    estimatedPhosphorus = 'low';
  }

  // Auto-detect Health benefits if tags are missing
  const healthBenefits: string[] = [];
  if (allText.includes('salmon') || allText.includes('fish oil') || allText.includes('flaxseed')) {
    healthBenefits.push('joint-health', 'skin-conditions');
  }
  if (allText.includes('pumpkin') || allText.includes('rice')) {
    healthBenefits.push('digestive-issues');
  }
  if (allText.includes('lean') || allText.includes('turkey') || allText.includes('white fish')) {
    healthBenefits.push('weight-management', 'pancreatitis');
  }
  if (allText.includes('liver') || allText.includes('organ')) {
    // Often good for general vitality but bad for kidney
    healthBenefits.push('recovery');
  }

  // Allergens
  const allergens: string[] = [];
  if (allText.includes('chicken')) allergens.push('chicken');
  if (allText.includes('beef')) allergens.push('beef');
  if (allText.includes('dairy') || allText.includes('milk')) allergens.push('dairy');
  if (allText.includes('wheat') || allText.includes('grain')) allergens.push('grain');
  if (allText.includes('egg')) allergens.push('egg');

  return {
    estimatedProtein,
    estimatedFat,
    estimatedPhosphorus,
    healthBenefits,
    allergens
  };
}

// Enhanced nutrition calculation using real USDA data
function calculateRecipeNutrition(recipe: any): {
  protein: number;
  fat: number;
  calcium: number;
  phosphorus: number;
  calories: number;
  omega3?: number;
  vitaminA?: number;
  vitaminC?: number;
  source: 'real' | 'estimated';
} {
  const ingredients = recipe.ingredients || [];
  let totalProtein = 0;
  let totalFat = 0;
  let totalCalcium = 0;
  let totalPhosphorus = 0;
  let totalCalories = 0;
  let totalOmega3 = 0;
  let totalVitaminA = 0;
  let totalVitaminC = 0;
  let totalWeight = 0;

  // Try to get real nutritional data
  for (const ingredient of ingredients) {
    const name = typeof ingredient === 'string' ? ingredient : ingredient.name;
    const amount = typeof ingredient === 'string' ? 100 : (ingredient.amount || 100); // Assume 100g if not specified

    const composition = getIngredientComposition(name);
    if (composition) {
      totalProtein += (composition.protein || 0) * (amount / 100);
      totalFat += (composition.fat || 0) * (amount / 100);
      totalCalcium += (composition.calcium || 0) * (amount / 100);
      totalPhosphorus += (composition.phosphorus || 0) * (amount / 100);
      totalCalories += (composition.kcal || 0) * (amount / 100);
      totalOmega3 += (composition.omega3 || 0) * (amount / 100);
      totalVitaminA += (composition.vitaminA || 0) * (amount / 100);
      totalVitaminC += (composition.vitaminC || 0) * (amount / 100);
      totalWeight += amount;
    }
  }

  // If we have real data for at least 50% of ingredients, use it
  const realDataRatio = totalWeight / (ingredients.length * 100);
  if (realDataRatio >= 0.5) {
    return {
      protein: totalProtein / totalWeight * 100,
      fat: totalFat / totalWeight * 100,
      calcium: totalCalcium / totalWeight * 100,
      phosphorus: totalPhosphorus / totalWeight * 100,
      calories: totalCalories / totalWeight * 100,
      omega3: totalOmega3 > 0 ? totalOmega3 / totalWeight * 100 : undefined,
      vitaminA: totalVitaminA > 0 ? totalVitaminA / totalWeight * 100 : undefined,
      vitaminC: totalVitaminC > 0 ? totalVitaminC / totalWeight * 100 : undefined,
      source: 'real'
    };
  }

  // Fall back to estimated values
  const enriched = enrichRecipeFromIngredients(recipe);
  return {
    protein: enriched.estimatedProtein,
    fat: enriched.estimatedFat,
    calcium: 0.8, // Estimated
    phosphorus: enriched.estimatedPhosphorus === 'high' ? 0.8 : enriched.estimatedPhosphorus === 'low' ? 0.3 : 0.5,
    calories: 150, // Estimated
    source: 'estimated'
  };
}

// Species-specific compatibility scoring
function calculateAvianCompatibility(recipe: any, pet: Pet): number {
  const standards = getAvianStandards(pet.breed) || AVIAN_NUTRITION_STANDARDS.psittacines;
  const nutrition = calculateRecipeNutrition(recipe);

  let score = 100;

  // Check Ca:P ratio (most critical for birds)
  const caPRatio = nutrition.calcium / nutrition.phosphorus;
  const caPMin = standards.CaP_ratio?.min || 1.5;
  const caPMax = standards.CaP_ratio?.max || 2.5;
  const caPIdeal = (standards.CaP_ratio as any)?.ideal || 2.0;

  if (caPRatio < caPMin || caPRatio > caPMax) {
    score -= 40; // Major penalty for improper ratio
  } else if (Math.abs(caPRatio - caPIdeal) < 0.5) {
    score += 10; // Bonus for ideal ratio
  }

  // Check protein levels
  const proteinMin = standards.protein?.min || 12;
  const proteinMax = standards.protein?.max || 18;
  if (nutrition.protein < proteinMin || nutrition.protein > proteinMax) {
    score -= 20;
  }

  // Check fat levels
  const fatMin = standards.fat?.min || 4;
  const fatMax = standards.fat?.max || 10;
  if (nutrition.fat < fatMin || nutrition.fat > fatMax) {
    score -= 15;
  }

  return Math.max(0, Math.min(100, score));
}

function calculateReptileCompatibility(recipe: any, pet: Pet): number {
  const standards = getReptileStandards(pet.breed);
  if (!standards) return 75; // Default score if species not found

  const nutrition = calculateRecipeNutrition(recipe);
  let score = 100;

  // Check Ca:P ratio (critical for reptiles)
  const caPRatio = nutrition.calcium / nutrition.phosphorus;
  if (caPRatio < standards.CaP_ratio.min || caPRatio > standards.CaP_ratio.max) {
    score -= 50; // Severe penalty for improper ratio
  } else if (Math.abs(caPRatio - standards.CaP_ratio.ideal) < 0.5) {
    score += 15; // Bonus for ideal ratio
  }

  // Check calcium levels
  if (nutrition.calcium < standards.calcium.min) {
    score -= 30;
  }

  // Check protein levels
  if (nutrition.protein < standards.protein.min || nutrition.protein > standards.protein.max) {
    score -= 20;
  }

  return Math.max(0, Math.min(100, score));
}

function calculateSpeciesSpecificScore(recipe: any, pet: Pet): number {
  switch (pet.type) {
    case 'bird':
      return calculateAvianCompatibility(recipe, pet);
    case 'reptile':
      return calculateReptileCompatibility(recipe, pet);
    case 'dog':
    case 'cat':
      // Use AAFCO validation for mammals
      const lifeStage = pet.age < 1 ? 'growth' : 'adult';
      const validation = validateCriticalNutrients(recipe, pet.type as 'dog' | 'cat', lifeStage);
      return validation.isValid ? 95 : Math.max(60, 95 - (validation.violations.length * 15));
    default:
      return 85; // Default score for pocket pets
  }
}

interface RatingFactor {
  score: number;
  weight: number;
  reason: string;
}

export interface CompatibilityRating {
  overallScore: number;
  compatibility: 'excellent' | 'good' | 'fair' | 'poor';
  breakdown: Record<string, RatingFactor>;
  warnings: string[];
  strengths: string[];
  recommendations: string[];
}

// Helper to normalize health concern keys
function normalizeHealthConcernKey(concern: string): string {
  const normalized = concern.toLowerCase().trim()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-|-$/g, '');
  
  // Map variations to standard keys
  const mapping: Record<string, string> = {
    'pancreatitis': 'pancreatitis',
    'pancreatic': 'pancreatitis',
    'heart-disease': 'heart-disease',
    'heart disease': 'heart-disease',
    'heart': 'heart-disease',
    'diabetes': 'diabetes',
    'diabetic': 'diabetes',
    'skin-conditions': 'skin-conditions',
    'skin conditions': 'skin-conditions',
    'skin condition': 'skin-conditions',
    'skin-coat': 'skin-conditions',
    'allergies': 'allergies',
    'allergy': 'allergies',
    'skin-issues': 'allergies',
    'skin issues': 'allergies',
    'kidney-disease': 'kidney-disease',
    'kidney disease': 'kidney-disease',
    'kidney': 'kidney-disease',
    'digestive-issues': 'digestive-issues',
    'digestive issues': 'digestive-issues',
    'digestive': 'digestive-issues',
    'joint-health': 'joint-health',
    'joint health': 'joint-health',
    'arthritis': 'joint-health',
    'joint pain': 'joint-health',
    'weight-management': 'weight-management',
    'weight management': 'weight-management',
    'obesity': 'weight-management',
    'dental-issues': 'dental-issues',
    'dental issues': 'dental-issues',
    'dental': 'dental-issues'
  };
  
  return mapping[normalized] || normalized;
}

const HEALTH_CONCERNS: Record<string, { maxPhosphorus?: number; maxFat?: number; maxProtein?: number; minProtein?: number; restrictions: string[]; requires?: string[] }> = {
  'kidney-disease': { maxPhosphorus: 200, restrictions: ['liver', 'kidney', 'organ'], requires: ['low-phosphorus', 'high-quality-protein'] },
  'pancreatitis': { maxFat: 12, restrictions: ['high-fat', 'pork', 'lamb', 'duck', 'fried', 'greasy'], requires: ['low-fat', 'easily-digestible'] },
  'obesity': { maxFat: 12, maxProtein: 30, restrictions: ['high-calorie', 'treats'], requires: ['low-calorie', 'high-fiber'] },
  'digestive-issues': { restrictions: ['spicy', 'raw', 'high-fiber', 'dairy'], requires: ['easily-digestible', 'bland'] },
  'allergies': { restrictions: ['chicken', 'beef', 'dairy', 'wheat', 'corn', 'soy', 'eggs'], requires: ['novel-protein', 'hypoallergenic'] },
  'joint-health': { restrictions: [], requires: ['omega-3', 'glucosamine', 'chondroitin'] },
  'skin-conditions': { restrictions: ['artificial-colors', 'preservatives'], requires: ['omega-3', 'quality-protein', 'vitamin-e'] },
  'heart-disease': { maxFat: 15, restrictions: ['high-sodium', 'processed'], requires: ['taurine', 'omega-3', 'low-sodium'] },
  'diabetes': { maxFat: 15, restrictions: ['high-sugar', 'simple-carbs', 'corn-syrup'], requires: ['complex-carbs', 'high-fiber', 'low-glycemic'] }
};

/**
 * Calculates compatibility rating between a recipe and a pet profile.
 * 
 * @param recipe - Recipe object from recipes-complete.ts
 * @param pet - Pet profile with type, age, weight, health concerns, etc.
 * @returns CompatibilityRating with overall score (0-100), breakdown, warnings, and recommendations
 * 
 * @example
 * ```ts
 * const rating = rateRecipeForPet(recipe, pet);
 * console.log(rating.overallScore); // 85
 * console.log(rating.compatibility); // 'excellent'
 * ```
 * 
 * @contract
 * - Input: Recipe from lib/data/recipes-complete.ts, Pet from localStorage/backend
 * - Output: CompatibilityRating with standardized structure
 * - Side effects: None (pure function)
 * - Migration: Compatible with Firebase/Supabase (receives Pet object, not storage)
 */
export function rateRecipeForPet(recipe: any, pet: Pet): CompatibilityRating {
  // Normalize array-like fields to avoid runtime errors
  const safePet: Pet = {
    ...pet,
    dietaryRestrictions: Array.isArray((pet as any).dietaryRestrictions) ? (pet as any).dietaryRestrictions : [],
    allergies: Array.isArray(pet.allergies) ? pet.allergies : [],
    healthConcerns: Array.isArray(pet.healthConcerns) ? pet.healthConcerns : [],
    dislikes: Array.isArray((pet as any).dislikes) ? (pet as any).dislikes : [],
  };

  const warnings: string[] = [];
  const strengths: string[] = [];
  const recommendations: string[] = [];

  const nutrition = extractNutrition(recipe);
  const enriched = enrichRecipeFromIngredients(recipe);
  const realNutrition = calculateRecipeNutrition(recipe);

  // 1. Pet Type Match (20%)
  const petTypeMatch = (recipe.category === safePet.type || recipe.category === `${safePet.type}s`) ? 100 : 0;

  // 2. Age Appropriate (15%)
  const petAgeGroup = safePet.age < 1 ? 'baby' : safePet.age < 2 ? 'young' : safePet.age < 7 ? 'adult' : 'senior';
  const ageMatch = (recipe.ageGroup || []).includes(petAgeGroup) || (recipe.ageGroup || []).includes('all');
  const ageScore = ageMatch ? 100 : 70;

  // 3. Species-Specific Nutritional Fit (30%)
  const speciesScore = calculateSpeciesSpecificScore(recipe, safePet);

  // 4. Health Compatibility (25%)
  // Fix: Start at 100 for pets with no health concerns, not 90
  let healthScore = safePet.healthConcerns.length === 0 ? 100 : 90;

  // Use recipe tags if available, otherwise fallback to ingredient inference
  const effectiveHealthTags = (recipe.healthConcerns && recipe.healthConcerns.length > 0)
    ? recipe.healthConcerns
    : enriched.healthBenefits;

  if (safePet.healthConcerns.length > 0) {
    healthScore = 70; // Start lower

    for (const concern of safePet.healthConcerns) {
      // Bonus for matching benefits
      if (effectiveHealthTags.some((tag: string) => tag.includes(concern) || concern.includes(tag))) {
        healthScore += 20;
        strengths.push(`Great for ${concern}`);
      }

      // Penalties for contradictions
      const normalizedConcern = normalizeHealthConcernKey(concern);
      const rules = HEALTH_CONCERNS[normalizedConcern];
      if (rules) {
        // Check Fat cap
        const fatVal = (nutrition && !nutrition.isGeneric) ? nutrition.fat : enriched.estimatedFat;
        if (rules.maxFat && fatVal > rules.maxFat) {
          healthScore -= 25;
          warnings.push(`Fat content slightly high for ${concern}`);
        }

        // Check ingredient restrictions
        const hasRestricted = rules.restrictions.some(r => enriched.allergens.includes(r));
        if (hasRestricted) {
           healthScore -= 30;
        }
      }
    }
  }

  // 5. Allergen Safety (10%)
  let allergenScore = 100;
  const allRestrictions = [...(safePet.dietaryRestrictions || []), ...(safePet.healthConcerns?.includes('allergies') ? safePet.allergies || [] : [])];

  for (const restriction of allRestrictions) {
    const rLower = restriction.toLowerCase();
    // Check against inferred allergens from ingredients
    if (enriched.allergens.some(a => rLower.includes(a) || a.includes(rLower))) {
      allergenScore = 0;
      warnings.push(`Contains ${restriction}`);
    }
  }

  // 6. Picky Eater Check (5% penalty for disliked ingredients)
  let pickyEaterPenalty = 0;
  if (pet.dislikes && pet.dislikes.length > 0) {
    for (const dislike of pet.dislikes) {
      const dLower = dislike.toLowerCase();
      // Check if recipe contains disliked ingredients
      if (enriched.allergens.some(a => dLower.includes(a) || a.includes(dLower))) {
        pickyEaterPenalty = 5; // Small penalty
        warnings.push(`Contains ${dislike} (pet may not like)`);
        break; // Only penalize once
      }
    }
  }

  // Calculate Overall
  const overallScore = Math.max(0, Math.min(100, Math.round(
    (petTypeMatch * 0.20) +
    (ageScore * 0.15) +
    (speciesScore * 0.30) +
    (healthScore * 0.25) +
    (allergenScore * 0.10)
  ) - pickyEaterPenalty));

  let compatibility: 'excellent' | 'good' | 'fair' | 'poor';
  if (overallScore >= 85) compatibility = 'excellent';
  else if (overallScore >= 70) compatibility = 'good';
  else if (overallScore >= 50) compatibility = 'fair';
  else compatibility = 'poor';

  return {
    overallScore,
    compatibility,
    breakdown: {
      petTypeMatch: {
        score: petTypeMatch,
        weight: 25,
        reason: petTypeMatch === 100
          ? `Recipe is specifically designed for ${pet.type}s`
          : `Recipe is designed for ${recipe.category}, but your pet is a ${pet.type}`
      },
      ageAppropriate: {
        score: ageScore,
        weight: 15,
        reason: ageMatch
          ? `Recipe is suitable for ${petAgeGroup} ${pet.type}s`
          : `Recipe is designed for ${recipe.ageGroup?.join(', ') || 'different age groups'}, but your pet is ${petAgeGroup}`
      },
      nutritionalFit: {
        score: speciesScore,
        weight: 30,
        reason: realNutrition.source === 'real'
          ? `Recipe uses real USDA nutritional data and meets ${pet.type} nutritional standards`
          : `Recipe meets estimated nutritional requirements for ${pet.type}s`
      },
      healthCompatibility: {
        score: healthScore,
        weight: 25,
        reason: pet.healthConcerns.length === 0
          ? 'No specific health concerns to evaluate'
          : `${effectiveHealthTags.length > 0 ? 'Recipe contains ingredients beneficial for' : 'Recipe may not address'} your pet's health concerns: ${pet.healthConcerns.join(', ')}`
      },
      allergenSafety: {
        score: allergenScore,
        weight: 10,
        reason: allRestrictions.length === 0
          ? 'No dietary restrictions or allergies specified'
          : allergenScore === 100
            ? 'Recipe avoids all known allergens and restrictions'
            : `Recipe contains ingredients that may conflict with restrictions: ${allRestrictions.join(', ')}`
      }
    },
    warnings,
    strengths,
    recommendations
  };
}

// Utility functions for pet profile management
export function savePetProfile(pet: Pet): void {
  if (typeof window === 'undefined') return;

  const pets = getUserPets();
  const existingIndex = pets.findIndex(p => p.id === pet.id);

  if (existingIndex >= 0) {
    pets[existingIndex] = pet;
  } else {
    pets.push(pet);
  }

  localStorage.setItem('userPets', JSON.stringify(pets));
}

export function getUserPets(): Pet[] {
  if (typeof window === 'undefined') return [];

  const stored = localStorage.getItem('userPets');
  return stored ? JSON.parse(stored) : [];
}

export function deletePetProfile(petId: string): void {
  if (typeof window === 'undefined') return;

  const pets = getUserPets().filter(p => p.id !== petId);
  localStorage.setItem('userPets', JSON.stringify(pets));
}

export const healthConcernOptions = [
  { value: 'kidney-disease', label: 'Kidney Disease' },
  { value: 'heart-disease', label: 'Heart Disease' },
  { value: 'diabetes', label: 'Diabetes' },
  { value: 'allergies', label: 'Food Allergies' },
  { value: 'obesity', label: 'Weight Management/Obesity' },
  { value: 'pancreatitis', label: 'Pancreatitis' },
  { value: 'digestive-issues', label: 'Digestive Issues' },
  { value: 'joint-health', label: 'Joint Problems/Arthritis' },
  { value: 'dental-issues', label: 'Dental Issues' },
  { value: 'hip-dysplasia', label: 'Hip Dysplasia' },
  { value: 'skin-conditions', label: 'Skin Conditions' }
];

export const dietaryRestrictionOptions = [
  { value: 'grain-free', label: 'Grain-Free' },
  { value: 'no-chicken', label: 'No Chicken' },
  { value: 'no-beef', label: 'No Beef' },
  { value: 'no-dairy', label: 'No Dairy' },
  { value: 'low-sodium', label: 'Low Sodium' },
  { value: 'low-phosphorus', label: 'Low Phosphorus' },
  { value: 'low-fat', label: 'Low Fat' },
  { value: 'soft-food', label: 'Soft Food Only' },
  { value: 'hypoallergenic', label: 'Hypoallergenic' }
];

export const activityLevels = [
  {
    value: 'sedentary' as const,
    label: 'Sedentary',
    description: 'Mostly inactive, minimal exercise'
  },
  {
    value: 'moderate' as const,
    label: 'Moderate',
    description: 'Regular walks, some playtime'
  },
  {
    value: 'active' as const,
    label: 'Active',
    description: 'Daily exercise, lots of playtime'
  },
  {
    value: 'very-active' as const,
    label: 'Very Active',
    description: 'Working dog, intensive daily exercise'
  }
];
</file>

<file path="lib/utils/petStorage.ts">
// lib/utils/petStorage.ts
// Abstracted pet storage layer - Migrated to Firestore
// Note: All operations are now ASYNCHRONOUS

import { Pet } from '@/lib/types'; // Updated import to use shared type
import * as firestoreService from '@/lib/services/firestoreService';

/**
 * Retrieves all pets for a given user.
 * 
 * @param userId - User identifier
 * @returns Promise<Pet[]>
 */
export async function getPets(userId: string): Promise<Pet[]> {
  if (!userId) return [];
  
  // TEMPORARY: Skip Firestore entirely if no Firebase config
  const hasFirebase = typeof process !== 'undefined' && process.env?.NEXT_PUBLIC_FIREBASE_API_KEY;
  if (!hasFirebase) {
    console.log('Firebase not configured - using localStorage only');
    if (typeof window !== 'undefined') {
      const stored = localStorage.getItem(`pets_${userId}`);
      if (stored) {
        try {
          return JSON.parse(stored);
        } catch {
          return [];
        }
      }
    }
    return [];
  }
  
  // Try Firestore first
  try {
    const pets = await firestoreService.getPets(userId);
    if (pets.length > 0) return pets;
    
    // Auto-migration: If Firestore is empty but localStorage has data, upload it
    if (typeof window !== 'undefined') {
      const stored = localStorage.getItem(`pets_${userId}`);
      if (stored) {
        try {
          const localPets: Pet[] = JSON.parse(stored);
          if (localPets.length > 0) {
            console.log('Migrating local pets to Firestore...');
            // Upload all local pets
            await Promise.all(localPets.map(p => firestoreService.savePet(userId, p)));
            return localPets;
          }
        } catch (e) {
          console.error('Migration failed:', e);
        }
      }
    }
  } catch (e) {
    console.warn('Firestore getPets failed, falling back to localStorage if available', e);
  }

  // Fallback to localStorage for smooth migration/offline (optional)
  if (typeof window !== 'undefined') {
    const stored = localStorage.getItem(`pets_${userId}`);
    if (stored) {
      try {
        return JSON.parse(stored);
      } catch {
        return [];
      }
    }
  }
  return [];
}

/**
 * Saves a pet to storage.
 * 
 * @param userId - User identifier
 * @param pet - Pet object to save
 * @returns Promise<void>
 */
export async function savePet(userId: string, pet: Pet): Promise<void> {
  if (!userId) return;
  
  // TEMPORARY: Skip Firestore entirely if no Firebase config
  const hasFirebase = typeof process !== 'undefined' && process.env?.NEXT_PUBLIC_FIREBASE_API_KEY;
  if (!hasFirebase) {
    console.log('Firebase not configured - saving to localStorage only');
    if (typeof window !== 'undefined') {
      const stored = localStorage.getItem(`pets_${userId}`);
      let localPets: Pet[] = [];
      try {
        localPets = stored ? JSON.parse(stored) : [];
      } catch {
        localPets = [];
      }
      // Update or add the pet
      const index = localPets.findIndex(p => p.id === pet.id);
      if (index >= 0) {
        localPets[index] = pet;
      } else {
        localPets.push(pet);
      }
      localStorage.setItem(`pets_${userId}`, JSON.stringify(localPets));
      
      // Dispatch custom event for same-tab updates
      if (typeof window !== 'undefined') {
        window.dispatchEvent(new CustomEvent('petsUpdated', { detail: { userId, petId: pet.id } }));
      }
    }
    return;
  }
  
  // Save to Firestore
  await firestoreService.savePet(userId, pet);
  
  // Also sync to localStorage for backup/offline compatibility
  if (typeof window !== 'undefined') {
    const pets = await getPets(userId); // Recalculate or just append?
    // Optimization: Just update local array without refetching if possible, but simplest is to fetch-update-save logic
    // Let's mimic old sync logic for localStorage mirror
    const stored = localStorage.getItem(`pets_${userId}`);
    let localPets: Pet[] = stored ? JSON.parse(stored) : [];
    
    const index = localPets.findIndex(p => p.id === pet.id);
    if (index >= 0) {
      localPets[index] = pet;
    } else {
      localPets.push(pet);
    }
    localStorage.setItem(`pets_${userId}`, JSON.stringify(localPets));
    
    // Dispatch custom event for same-tab updates
    window.dispatchEvent(new CustomEvent('petsUpdated', { detail: { userId, petId: pet.id } }));
  }
}

/**
 * Deletes a pet from storage.
 * 
 * @param userId - User identifier
 * @param petId - Pet ID to delete
 * @returns Promise<void>
 */
export async function deletePet(userId: string, petId: string): Promise<void> {
  if (!userId) return;
  
  // TEMPORARY: Skip Firestore entirely if no Firebase config
  const hasFirebase = typeof process !== 'undefined' && process.env?.NEXT_PUBLIC_FIREBASE_API_KEY;
  if (!hasFirebase) {
    console.log('Firebase not configured - deleting from localStorage only');
    if (typeof window !== 'undefined') {
      const stored = localStorage.getItem(`pets_${userId}`);
      if (stored) {
        try {
          const pets: Pet[] = JSON.parse(stored);
          const filtered = pets.filter(p => p.id !== petId);
          localStorage.setItem(`pets_${userId}`, JSON.stringify(filtered));
        } catch (e) {
          console.error('Error deleting pet from localStorage:', e);
        }
      }
    }
    return;
  }
  
  await firestoreService.deletePet(userId, petId);
  
  // Sync localStorage
  if (typeof window !== 'undefined') {
    const stored = localStorage.getItem(`pets_${userId}`);
    if (stored) {
      const pets: Pet[] = JSON.parse(stored);
      const filtered = pets.filter(p => p.id !== petId);
      localStorage.setItem(`pets_${userId}`, JSON.stringify(filtered));
    }
  }
}

/**
 * Gets a single pet by ID.
 * 
 * @param userId - User identifier
 * @param petId - Pet ID to retrieve
 * @returns Promise<Pet | null>
 */
export async function getPet(userId: string, petId: string): Promise<Pet | null> {
  const pets = await getPets(userId);
  return pets.find(p => p.id === petId) || null;
}
</file>

<file path="lib/utils/petUtils.ts">
// Utility functions for pet management
import type { Pet } from '../types';
export type { Pet } from '../types';

/**
 * Get a random name from the pet's names array
 * Falls back to the first name if array is empty
 */
export function getRandomName(names: string[]): string {
  if (!names || names.length === 0) {
    return 'Unnamed Pet';
  }
  const randomIndex = Math.floor(Math.random() * names.length);
  return names[randomIndex];
}

/**
 * Get the primary name (first in the array)
 */
export function getPrimaryName(names: string[]): string {
  if (!names || names.length === 0) {
    return 'Unnamed Pet';
  }
  return names[0];
}

/**
 * Format names for display (e.g., "Buddy, Max, Charlie")
 */
export function formatNames(names: string[]): string {
  if (!names || names.length === 0) {
    return 'Unnamed Pet';
  }
  if (names.length === 1) {
    return names[0];
  }
  return names.join(', ');
}
</file>

<file path="lib/utils/priceValidation.ts">
/**
 * Price validation utilities for vetted products
 * Prevents outlier prices from scraping errors (e.g., third-party sellers with inflated prices)
 */

export type ProductCategory = 'Meat' | 'Supplement' | 'Carb' | 'Vegetable' | 'Oil' | 'Seed' | 'Fruit' | 'Insect' | 'Hay' | 'Pellet';

/**
 * Maximum reasonable prices per category (USD)
 * These are conservative limits to catch obvious errors from third-party sellers
 */
const MAX_REASONABLE_PRICES: Record<ProductCategory, number> = {
  Vegetable: 15,      // Bulk vegetables, but $124 for collard greens is clearly wrong
  Meat: 80,           // Bulk frozen meat can be expensive
  Carb: 75,           // Bulk grains/potatoes
  Oil: 40,            // Cooking oils and supplements
  Supplement: 100,    // Supplements can be expensive but have limits
  Fruit: 30,          // Fresh fruits
  Seed: 50,           // Seeds and nuts
  Insect: 50,         // Dried insects for pets
  Hay: 50,            // Hay bales
  Pellet: 80,         // Pellet food
};

/**
 * Check if a price is reasonable for the given category
 */
export function isPriceReasonable(price: number, category?: ProductCategory | string): boolean {
  if (!category) return true; // No category = no validation
  
  const normalizedCategory = category as ProductCategory;
  if (!(normalizedCategory in MAX_REASONABLE_PRICES)) {
    // Unknown category, allow it (might be a new category)
    return true;
  }
  
  const maxPrice = MAX_REASONABLE_PRICES[normalizedCategory];
  return price <= maxPrice;
}

/**
 * Get the maximum reasonable price for a category
 */
export function getMaxReasonablePrice(category?: ProductCategory | string): number | null {
  if (!category) return null;
  
  const normalizedCategory = category as ProductCategory;
  return MAX_REASONABLE_PRICES[normalizedCategory] || null;
}

/**
 * Validate and optionally cap a price
 * Returns the original price if valid, or null if it exceeds the max
 */
export function validatePrice(
  price: number,
  category?: ProductCategory | string
): number | null {
  if (isPriceReasonable(price, category)) {
    return price;
  }
  
  // Price exceeds reasonable limit - return null to mark as invalid/unavailable
  return null;
}
</file>

<file path="lib/utils/purchaseLinks.ts">
import { ensureSellerId, isValidAmazonUrl } from '@/lib/utils/affiliateLinks';
import { getProductPriceUrl } from '@/lib/data/product-prices';

export function buildAmazonSearchUrl(query: string): string {
  const q = String(query || '').trim();
  if (!q) return '';
  return `https://www.amazon.com/s?k=${encodeURIComponent(q)}`;
}

export function getIngredientPurchaseUrl(
  ingredientName: string,
  existingUrl?: string | null,
  species?: string
): string {
  const baseName = String(ingredientName || '').trim();

  const pricedUrl = getProductPriceUrl(baseName);
  if (pricedUrl) return ensureSellerId(pricedUrl);

  const candidate = String(existingUrl || '').trim();
  if (candidate && isValidAmazonUrl(candidate)) return ensureSellerId(candidate);

  const searchUrl = buildAmazonSearchUrl(baseName);
  return searchUrl ? ensureSellerId(searchUrl) : '';
}
</file>

<file path="lib/utils/purchaseTracking.ts">
/**
 * Purchase Tracking System
 * Tracks cumulative ingredient purchases across all pets for village evolution
 * 
 * Combines:
 * - Simple API from guide (loadPurchases, addPurchase, etc.)
 * - Transaction safety from our implementation (prevents race conditions)
 * - Robust error handling and validation
 */

import { safeGetItem, safeSetItem, safeParseJSON, safeStringifyJSON, safeUpdateItem } from './localStorageSafe';
import { logger } from './logger';
import { validateUserId } from './validation';

export interface PurchaseRecord {
  ingredientId: string;
  ingredientName?: string; // Optional for backward compatibility
  purchaseDate: string; // ISO string
  confirmed: boolean;
  amazonOrderId?: string; // For Amazon API integration
}

const PREFIX = 'ingredient_purchases_';

/**
 * Get storage key for user's purchases
 */
export function getStorageKey(userId: string): string {
  return `${PREFIX}${userId}`;
}

// =================================================================
// SIMPLE API (from guide) - Transaction-safe implementation
// =================================================================

/**
 * Load all purchase records for a user
 * Simple API matching guide's interface
 */
export function loadPurchases(userId: string): PurchaseRecord[] {
  const userIdValidation = validateUserId(userId);
  if (!userIdValidation.valid) {
    logger.warn('Invalid userId in loadPurchases', { userId });
    return [];
  }
  
  const key = getStorageKey(userId);
  const raw = safeGetItem(key);
  return safeParseJSON<PurchaseRecord[]>(raw, []);
}

/**
 * Save purchase records for a user
 * Simple API matching guide's interface
 */
export function savePurchases(userId: string, records: PurchaseRecord[]): boolean {
  const userIdValidation = validateUserId(userId);
  if (!userIdValidation.valid) {
    logger.warn('Invalid userId in savePurchases', { userId });
    return false;
  }
  
  const key = getStorageKey(userId);
  const jsonString = safeStringifyJSON(records);
  if (!jsonString) {
    logger.error('Failed to stringify purchase records', undefined, { userId, recordCount: records.length });
    return false;
  }
  
  const result = safeSetItem(key, jsonString);
  if (!result.success) {
    logger.error('Failed to save purchase records', undefined, { userId, error: result.error });
  }
  
  return result.success;
}

/**
 * Add a purchase (transaction-safe)
 * Simple API matching guide's interface
 * @param confirmed - Whether purchase is confirmed (default: false)
 */
export function addPurchase(
  userId: string,
  ingredientId: string,
  confirmed: boolean = false,
  ingredientName?: string
): PurchaseRecord[] {
  const userIdValidation = validateUserId(userId);
  if (!userIdValidation.valid) {
    logger.warn('Invalid userId in addPurchase', { userId });
    return [];
  }
  
  if (!ingredientId) {
    logger.warn('Missing ingredientId in addPurchase', { userId });
    return loadPurchases(userId);
  }
  
  const key = getStorageKey(userId);
  const result = safeUpdateItem<PurchaseRecord[]>(key, (records) => {
    const currentRecords = records || [];
    
    // Add new purchase record
    return [
      ...currentRecords,
      {
        ingredientId,
        ingredientName: ingredientName || ingredientId, // Use ingredientId as fallback
        purchaseDate: new Date().toISOString(),
        confirmed
      }
    ];
  });
  
  if (!result.success) {
    logger.error('Failed to add purchase', undefined, { userId, ingredientId, error: result.error });
    return loadPurchases(userId); // Return current state on failure
  }
  
  return result.data || [];
}

/**
 * Confirm a purchase (mark as confirmed)
 * Simple API matching guide's interface
 * Uses transaction-safe update to prevent race conditions
 */
export function confirmPurchase(userId: string, ingredientId: string): PurchaseRecord[] {
  const userIdValidation = validateUserId(userId);
  if (!userIdValidation.valid) {
    logger.warn('Invalid userId in confirmPurchase', { userId });
    return [];
  }
  
  if (!ingredientId) {
    logger.warn('Missing ingredientId in confirmPurchase', { userId });
    return loadPurchases(userId);
  }
  
  const key = getStorageKey(userId);
  const result = safeUpdateItem<PurchaseRecord[]>(key, (records) => {
    const currentRecords = records || [];
    
    // Find and update existing record
    const idx = currentRecords.findIndex(r => r.ingredientId === ingredientId && !r.confirmed);
    if (idx >= 0) {
      const updated = [...currentRecords];
      updated[idx] = {
        ...updated[idx],
        confirmed: true,
        purchaseDate: new Date().toISOString() // Update timestamp
      };
      return updated;
    }
    
    // If not found, add as confirmed
    return [
      ...currentRecords,
      {
        ingredientId,
        ingredientName: ingredientId,
        purchaseDate: new Date().toISOString(),
        confirmed: true
      }
    ];
  });
  
  if (!result.success) {
    logger.error('Failed to confirm purchase', undefined, { userId, ingredientId, error: result.error });
    return loadPurchases(userId); // Return current state on failure
  }
  
  return result.data || [];
}

/**
 * Get count of confirmed purchases
 * Simple API matching guide's interface
 */
export function getConfirmedCount(userId: string): number {
  const records = loadPurchases(userId);
  return records.filter(r => r.confirmed).length;
}

/**
 * Get total purchased ingredients (alias for getConfirmedCount)
 * Simple API matching guide's interface
 */
export function getTotalPurchasedIngredients(userId: string): number {
  return getConfirmedCount(userId);
}

/**
 * Get village level from purchase count
 * Simple API matching guide's interface
 * Default: +10 per level (0-9 = level 0, 10-19 = level 1, etc.)
 */
export function getVillageLevelFromCount(count: number): number {
  if (count >= 50) return 5;
  return Math.floor(count / 10);
}

// =================================================================
// ENHANCED API (our additions) - More features, same safety
// =================================================================

/**
 * Get all purchase records for a user
 * Enhanced version with validation
 * @deprecated Use loadPurchases() for simpler API
 */
export function getPurchaseRecords(userId: string): PurchaseRecord[] {
  return loadPurchases(userId);
}

/**
 * Add a pending purchase (not yet confirmed)
 * Enhanced version - used when user clicks "Buy" button
 * Uses transaction-safe update to prevent race conditions
 */
export function addPendingPurchase(
  userId: string,
  ingredientId: string,
  ingredientName: string
): { success: boolean; error?: string } {
  const userIdValidation = validateUserId(userId);
  if (!userIdValidation.valid) {
    return { success: false, error: userIdValidation.error };
  }
  
  if (!ingredientId || !ingredientName) {
    return { success: false, error: 'Ingredient ID and name are required' };
  }
  
  const key = getStorageKey(userId);
  const result = safeUpdateItem<PurchaseRecord[]>(key, (records) => {
    const currentRecords = records || [];
    
    // Check if already exists as pending
    const exists = currentRecords.some(
      r => r.ingredientId === ingredientId && !r.confirmed
    );
    
    if (!exists) {
      return [
        ...currentRecords,
        {
          ingredientId,
          ingredientName,
          purchaseDate: new Date().toISOString(),
          confirmed: false
        }
      ];
    }
    
    return currentRecords;
  });
  
  if (!result.success) {
    logger.error('Failed to add pending purchase', undefined, { userId, ingredientId, error: result.error });
  }
  
  return result;
}

/**
 * Confirm a purchase with full details (enhanced version)
 * Enhanced version with ingredientName and amazonOrderId support
 */
export function confirmPurchaseWithDetails(
  userId: string,
  ingredientId: string,
  ingredientName: string,
  amazonOrderId?: string
): { success: boolean; error?: string } {
  const userIdValidation = validateUserId(userId);
  if (!userIdValidation.valid) {
    return { success: false, error: userIdValidation.error };
  }
  
  if (!ingredientId || !ingredientName) {
    return { success: false, error: 'Ingredient ID and name are required' };
  }
  
  const key = getStorageKey(userId);
  const result = safeUpdateItem<PurchaseRecord[]>(key, (records) => {
    const currentRecords = records || [];
    
    // Check if purchase already exists
    const existingIndex = currentRecords.findIndex(
      r => r.ingredientId === ingredientId && !r.confirmed
    );
    
    if (existingIndex >= 0) {
      // Update existing record
      const updated = [...currentRecords];
      updated[existingIndex] = {
        ...updated[existingIndex],
        ingredientName,
        confirmed: true,
        purchaseDate: new Date().toISOString(),
        ...(amazonOrderId && { amazonOrderId })
      };
      return updated;
    } else {
      // Add new purchase record
      return [
        ...currentRecords,
        {
          ingredientId,
          ingredientName,
          purchaseDate: new Date().toISOString(),
          confirmed: true,
          ...(amazonOrderId && { amazonOrderId })
        }
      ];
    }
  });
  
  if (!result.success) {
    logger.error('Failed to confirm purchase with details', undefined, { userId, ingredientId, error: result.error });
  }
  
  return result;
}

/**
 * Get village level based on purchase count
 * Every 10 ingredients = new level
 * @deprecated Use getVillageLevelFromCount() for simpler API
 */
export function getVillageLevel(purchaseCount: number): number {
  return getVillageLevelFromCount(purchaseCount);
}

/**
 * Get progress toward next village level (0-9)
 */
export function getProgressToNextLevel(purchaseCount: number): number {
  return purchaseCount % 10;
}

/**
 * Get purchase statistics for a user
 * Enhanced version with detailed stats
 */
export function getPurchaseStats(userId: string) {
  const records = loadPurchases(userId);
  const confirmed = records.filter(r => r.confirmed);
  const pending = records.filter(r => !r.confirmed);
  const total = confirmed.length;
  const level = getVillageLevelFromCount(total);
  const progress = getProgressToNextLevel(total);
  
  return {
    totalPurchases: total,
    pendingPurchases: pending.length,
    currentLevel: level,
    progressToNextLevel: progress,
    nextLevelThreshold: (level + 1) * 10,
    ingredientsRemaining: (level + 1) * 10 - total
  };
}
</file>

<file path="lib/utils/ratings.ts">
// lib/utils/ratings.ts - Core rating utilities for PetPlates

export interface RatingData {
  averageRating: number;
  totalReviews: number;
  distribution: { [key: number]: number }; // 1-5 stars count
}

export interface UserRating {
  recipeId: string;
  rating: number;
  timestamp: number;
}

// Storage keys
const USER_RATINGS_KEY = (userId: string) => `user_ratings_${userId}`;
const RECIPE_RATINGS_KEY = (recipeId: string) => `recipe_ratings_${recipeId}`;

/**
 * Save a user's rating for a recipe
 */
export const saveUserRating = (userId: string, recipeId: string, rating: number): void => {
  if (typeof window === 'undefined') return;

  const key = USER_RATINGS_KEY(userId);
  const existing = localStorage.getItem(key);
  const userRatings: UserRating[] = existing ? JSON.parse(existing) : [];

  // Remove existing rating for this recipe
  const filtered = userRatings.filter(r => r.recipeId !== recipeId);

  // Add new rating
  filtered.push({
    recipeId,
    rating,
    timestamp: Date.now()
  });

  localStorage.setItem(key, JSON.stringify(filtered));

  // Update global recipe ratings
  updateRecipeRatings(recipeId);
};

/**
 * Get a user's rating for a specific recipe
 */
export const getUserRating = (userId: string, recipeId: string): number | null => {
  if (typeof window === 'undefined') return null;

  const key = USER_RATINGS_KEY(userId);
  const existing = localStorage.getItem(key);

  if (!existing) return null;

  const userRatings: UserRating[] = JSON.parse(existing);
  const rating = userRatings.find(r => r.recipeId === recipeId);

  return rating ? rating.rating : null;
};

/**
 * Check if user has already rated a recipe
 */
export const hasUserRated = (userId: string, recipeId: string): boolean => {
  return getUserRating(userId, recipeId) !== null;
};

/**
 * Get all ratings for a recipe from all users
 */
export const getRecipeRatings = (recipeId: string): number[] => {
  if (typeof window === 'undefined') return [];

  // Optimized approach: iterate through all user_ratings keys more efficiently
  const ratings: number[] = [];

  for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    if (key && key.startsWith('user_ratings_')) {
      try {
        const userRatings: UserRating[] = JSON.parse(localStorage.getItem(key) || '[]');
        const userRating = userRatings.find(r => r.recipeId === recipeId);
        if (userRating) {
          ratings.push(userRating.rating);
        }
      } catch (error) {
        // Skip corrupted data
        console.warn(`Skipping corrupted user ratings data for key: ${key}`);
      }
    }
  }

  return ratings;
};

/**
 * Update the global recipe ratings data
 */
export const updateRecipeRatings = (recipeId: string): void => {
  if (typeof window === 'undefined') return;

  const ratings = getRecipeRatings(recipeId);
  const key = RECIPE_RATINGS_KEY(recipeId);

  if (ratings.length === 0) {
    localStorage.removeItem(key);
    return;
  }

  const averageRating = ratings.reduce((sum, r) => sum + r, 0) / ratings.length;
  const distribution = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 };

  ratings.forEach(rating => {
    distribution[rating as keyof typeof distribution]++;
  });

  const ratingData: RatingData = {
    averageRating: Math.round(averageRating * 10) / 10, // Round to 1 decimal
    totalReviews: ratings.length,
    distribution
  };

  localStorage.setItem(key, JSON.stringify(ratingData));
};

/**
 * Get rating data for a recipe
 */
export const getRecipeRatingData = (recipeId: string): RatingData => {
  if (typeof window === 'undefined') {
    return { averageRating: 0, totalReviews: 0, distribution: { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 } };
  }

  const key = RECIPE_RATINGS_KEY(recipeId);
  const stored = localStorage.getItem(key);

  // If we have stored user ratings, use those
  if (stored) {
    return JSON.parse(stored);
  }

  // Otherwise, return default data (will be handled by RecipeCard using recipe.rating/reviews)
  return { averageRating: 0, totalReviews: 0, distribution: { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 } };
};

/**
 * Calculate rating data on the fly (alternative to stored data)
 */
export const calculateRecipeRatingData = (recipeId: string): RatingData => {
  const ratings = getRecipeRatings(recipeId);

  if (ratings.length === 0) {
    return { averageRating: 0, totalReviews: 0, distribution: { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 } };
  }

  const averageRating = ratings.reduce((sum, r) => sum + r, 0) / ratings.length;
  const distribution = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 };

  ratings.forEach(rating => {
    distribution[rating as keyof typeof distribution]++;
  });

  return {
    averageRating: Math.round(averageRating * 10) / 10,
    totalReviews: ratings.length,
    distribution
  };
};

/**
 * Get star states for display (filled/empty stars)
 */
export const getStarStates = (rating: number): boolean[] => {
  const stars: boolean[] = [];
  for (let i = 1; i <= 5; i++) {
    stars.push(i <= Math.round(rating));
  }
  return stars;
};

/**
 * Get partial star fill percentage for smooth display
 */
export const getStarFillPercentage = (rating: number, starIndex: number): number => {
  const fullStars = Math.floor(rating);
  const partialStar = rating - fullStars;

  if (starIndex < fullStars) return 100;
  if (starIndex === fullStars) return partialStar * 100;
  return 0;
};
</file>

<file path="lib/utils/recipeIngredients.ts">
// lib/utils/recipeIngredients.ts
// Utility to extract and map ingredients from recipes to ingredient composition keys

import { INGREDIENT_COMPOSITIONS } from '@/lib/data/ingredientCompositions';

/**
 * Extract all unique ingredient names from all recipes
 */
export function getAllRecipeIngredients(): string[] {
  const ingredientNames = new Set<string>();
  
  recipes.forEach(recipe => {
    recipe.ingredients?.forEach(ing => {
      if (ing.name) {
        ingredientNames.add(ing.name);
      }
    });
  });
  
  return Array.from(ingredientNames).sort();
}

/**
 * Map recipe ingredient name to ingredient composition key
 * Handles variations and common naming patterns
 */
export function mapIngredientNameToKey(ingredientName: string): string | null {
  // Normalize the name
  const normalized = ingredientName
    .toLowerCase()
    .trim()
    .replace(/\s*\([^)]*\)/g, '') // Remove parentheses and contents
    .replace(/\s+/g, '_')
    .replace(/[^a-z0-9_]/g, '');
  
  // Direct lookup
  if (INGREDIENT_COMPOSITIONS[normalized]) {
    return normalized;
  }
  
  // Common mappings
  const mappings: Record<string, string | null> = {
    'ground_chicken': 'ground_turkey', // Use turkey as closest match
    'chicken_breast': 'chicken_breast',
    'chicken_liver': 'chicken_liver',
    'chicken_hearts': 'chicken_hearts',
    'beef_liver': 'beef_liver',
    'ground_beef': 'ground_beef_lean',
    'ground_turkey': 'ground_turkey',
    'turkey_breast': 'turkey_breast',
    'salmon_fillet': 'salmon_atlantic',
    'salmon': 'salmon_atlantic',
    'tuna': 'tuna_water',
    'sardines': 'sardines_water',
    'white_rice': 'brown_rice_cooked', // Use brown rice as closest match
    'brown_rice': 'brown_rice_cooked',
    'quinoa': 'quinoa_cooked',
    'sweet_potato': 'sweet_potato',
    'pumpkin': 'sweet_potato', // Use sweet potato as closest match
    'carrots': 'carrots_raw',
    'carrot': 'carrots_raw',
    'green_beans': 'broccoli_raw', // Use broccoli as closest match
    'bok_choy': 'kale_raw', // Use kale as closest match
    'broccoli': 'broccoli_raw',
    'spinach': 'spinach_raw',
    'kale': 'kale_raw',
    'celery': 'celery_raw',
    'blueberries': 'blueberries_raw',
    'bananas': 'bananas_raw',
    'eggs': 'eggs_whole',
    'fish_oil': 'fish_oil',
    'herring_oil': 'fish_oil', // Use fish oil as closest match
    'olive_oil': 'fish_oil', // Use fish oil as closest match
    'coconut_oil': 'fish_oil', // Use fish oil as closest match
    'chicken_broth': null, // No composition data
    'navy_beans': null, // No composition data
    'oats': 'oats',
    'taurine': 'taurine_powder',
    'calcium': 'calcium_carbonate',
  };
  
  // Check mappings
  if (mappings[normalized]) {
    return mappings[normalized];
  }
  
  // Try partial matches
  for (const key in INGREDIENT_COMPOSITIONS) {
    if (normalized.includes(key) || key.includes(normalized)) {
      return key;
    }
  }
  
  return null;
}

/**
 * Get all ingredients that can be used in the recipe builder
 * Returns both ingredients from recipes and existing composition ingredients
 */
export function getAvailableIngredientsForBuilder(): string[] {
  const recipeIngredients = getAllRecipeIngredients();
  const compositionKeys = Object.keys(INGREDIENT_COMPOSITIONS);
  
  // Map recipe ingredients to composition keys
  const mappedKeys = new Set<string>();
  
  recipeIngredients.forEach(name => {
    const key = mapIngredientNameToKey(name);
    if (key) {
      mappedKeys.add(key);
    }
  });
  
  // Also include all composition keys
  compositionKeys.forEach(key => mappedKeys.add(key));
  
  return Array.from(mappedKeys).sort();
}
</file>

<file path="lib/utils/recipeRecommendations.ts">
import { Recipe } from '@/lib/types';

interface Pet {
  id: string;
  name: string;
  type: string;
  breed: string;
  age: string;
  healthConcerns: string[];
  weight?: number;
  activityLevel?: 'sedentary' | 'moderate' | 'active' | 'very-active';
  allergies?: string[];
  dietaryRestrictions?: string[];
  savedRecipes?: string[];
  names?: string[];
  weightKg?: number;
}

import { normalizeToSubtype, type Subtype } from './ingredientWhitelists';
import { getHealthTemplatesForSpecies, applyHealthTemplate, type HealthConcernTemplate } from '@/lib/data/healthConcernTemplates';
import {
  calculateEnhancedCompatibility,
  type Pet as EnhancedPet,
} from './enhancedCompatibilityScoring';

/**
 * Check if recipe matches species/subtype
 * Exported so scoreRecipe can use it
 */
export function matchesSpecies(recipe: Recipe, pet: Pet): boolean {
  // Exact match
  if (recipe.category === pet.type) return true;
  
  // Subtype matching for exotics (Beta feature)
  const subtype = normalizeToSubtype(pet.type as any, pet.breed);
  
  if (pet.type === 'bird') {
    const largeBirds = ['parrot', 'cockatoo', 'african grey', 'macaw', 'conure', 'quaker'];
    const isLargeBird = largeBirds.some(lb => (pet.breed || '').toLowerCase().includes(lb));
    
    // Allow generic bird recipes for all birds
    if (recipe.category === 'birds' || recipe.category === 'bird') return true;
    
    // Allow subtype-specific recipes
    if (recipe.category === 'bird_large' && isLargeBird) return true;
    if (recipe.category === 'bird_small' && !isLargeBird) return true;
  }
  
  if (pet.type === 'reptile') {
    // Allow generic reptile recipes
    if (recipe.category === 'reptiles' || recipe.category === 'reptile') return true;
    
    // Allow subtype-specific recipes
    const subtypeCategories = [
      'reptile_herbivore', 'reptile_insectivore', 
      'reptile_omnivore', 'reptile_carnivore'
    ];
    if (subtypeCategories.includes(recipe.category)) {
      // Check if recipe category matches subtype
      return recipe.category === subtype;
    }
  }
  
  if (pet.type === 'pocket-pet') {
    // Allow generic pocket-pet recipes
    if (recipe.category === 'pocket-pets' || recipe.category === 'pocket-pet') return true;
    
    // Allow subtype-specific recipes
    const subtypeCategories = [
      'pocket_hay', 'pocket_varied', 
      'pocket_carnivore', 'pocket_insectivore'
    ];
    if (subtypeCategories.includes(recipe.category)) {
      return recipe.category === subtype;
    }
  }
  
  return false;
}

/**
 * Tiered recommendation system - ensures users never see "0 meals"
 * 
 * Tier 1: Exact match (species + age + health concern)
 * Tier 2: Subtype + health concern template match
 * Tier 3: Species + age match (no health concern)
 * Tier 4: Species match only (all ages)
 * Tier 5: Subtype match (generic)
 * Tier 6: Health template-based suggestions (always available)
 */
export interface RecipeRecommendation {
  recipe: Recipe;
  tier: number;
  tierLabel: string;
  healthConcernMatch?: string;
  template?: HealthConcernTemplate;
  warning?: string;
  score: number;
  enhancedScore?: any; // Optional improved scoring
}

/**
 * Normalize pet age to age group string
 * Handles both string ("adult") and number (5) formats
 */
function normalizePetAgeToGroup(age: string | number): string {
  if (typeof age === 'string') {
    // Already a string like "adult", "young", etc.
    const normalized = age.toLowerCase().trim();
    if (['baby', 'young', 'adult', 'senior', 'all'].includes(normalized)) {
      return normalized;
    }
    // Try to parse if it's a number string
    const numAge = parseFloat(normalized);
    if (!isNaN(numAge)) {
      if (numAge < 1) return 'baby';
      if (numAge < 2) return 'young';
      if (numAge < 7) return 'adult';
      return 'senior';
    }
    return normalized; // Return as-is if can't parse
  }
  // Convert number to age group
  if (age < 1) return 'baby';
  if (age < 2) return 'young';
  if (age < 7) return 'adult';
  return 'senior';
}

/**
 * Normalize health concern names to match recipe database format
 * Maps user-friendly names to database keys
 */
function normalizeHealthConcern(concern: string): string {
  const mapping: Record<string, string> = {
    'dental health': 'dental-issues',
    'dental-health': 'dental-issues',
    'weight management': 'weight-management',
    'weight-management': 'weight-management',
    'joint & mobility': 'joint-health',
    'joint-health': 'joint-health',
    'skin & coat': 'skin-coat',
    'skin-coat': 'skin-coat',
    'kidney/urinary support': 'kidney',
    'kidney/urinary-support': 'kidney',
    'digestive health': 'digestive',
    'digestive': 'digestive',
    'allergy support': 'allergies',
    'allergies': 'allergies',
  };
  
  const normalized = concern.toLowerCase().trim();
  return mapping[normalized] || normalized.replace(/\s+/g, '-').toLowerCase();
}

/**
 * Get recommended recipes with optional enhanced scoring
 * @param pet - Pet profile
 * @param minCount - Minimum number of recipes to return
 * @param useEnhancedScoring - Whether to use the enhanced compatibility scoring system
 * @param customRecipes - Optional custom recipes to include in recommendations
 */
export const getRecommendedRecipes = (
  pet: Pet,
  minCount: number = 20,
  useEnhancedScoring: boolean = false,
  customRecipes?: Recipe[]
): RecipeRecommendation[] => {
  const { type, age, healthConcerns } = pet;
  // Normalize health concerns to match recipe database format
  const normalizedConcerns = (healthConcerns || []).map(normalizeHealthConcern);
  const results: RecipeRecommendation[] = [];

  // Use provided recipes only - static recipes are no longer available
  const allRecipes = customRecipes || [];

  // Normalize pet age to age group string
  const petAgeGroup = normalizePetAgeToGroup(age);
  
  // Tier 1: Perfect matches (species + age) - health concerns handled in scoring, not filtering
  const tier1 = allRecipes.filter(r => {
    const speciesMatch = matchesSpecies(r, pet);
    const ageMatch = (r.ageGroup || []).includes(petAgeGroup) || (r.ageGroup || []).includes('all');
    // Health concerns are scoring modifiers, not filters
    return speciesMatch && ageMatch;
  }).map(r => {
    // Find matching health concern for display (but don't filter by it)
    const matchingConcern = normalizedConcerns.length > 0 
      ? normalizedConcerns.find(hc => r.healthConcerns?.includes(hc) || r.healthConcerns?.some(rc => rc.toLowerCase().includes(hc.toLowerCase())))
      : undefined;
    return {
      recipe: r,
      tier: 1,
      tierLabel: matchingConcern ? 'Best Match' : 'Age-Appropriate',
      healthConcernMatch: matchingConcern,
      score: 100
    };
  });
  results.push(...tier1);
  
  // Tier 2: Subtype + health concern template match - ALWAYS run when concerns exist
  if (normalizedConcerns.length > 0) {
    const subtype = normalizeToSubtype(type as any, pet.breed);
    
    // Process each health concern (use normalized version)
    normalizedConcerns.forEach(concern => {
      const templates = getHealthTemplatesForSpecies(type, pet.breed, concern);
      
      templates.forEach(template => {
        // Find recipes that match subtype and age (can be adapted)
        const subtypeRecipes = allRecipes.filter(r => {
          const speciesMatch = matchesSpecies(r, pet);
          const ageMatch = (r.ageGroup || []).includes(petAgeGroup) || (r.ageGroup || []).includes('all');
          // Don't include recipes already in results
          const notIncluded = !results.some(res => res.recipe.id === r.id);
          return speciesMatch && ageMatch && notIncluded;
        });
        
        // Actually apply the template to adapt ingredients
        subtypeRecipes.forEach(r => {
          const ingredientNames = r.ingredients.map(i => i.name);
          const adapted = applyHealthTemplate(ingredientNames, template);
          
          // Create adapted recipe
          const adaptedRecipe: Recipe = {
            ...r,
            id: `${r.id}__${template.id}`, // Avoid ID clash
            name: `${r.name} (Adapted for ${concern})`,
            description: `${r.description} Adapted using ${template.name} template.`,
            ingredients: adapted.adjustedIngredients.map((name, idx) => ({
              id: `adapted-${idx}`,
              name,
              amount: 'varies',
              asinLink: r.ingredients[0]?.asinLink || ''
            })),
            healthConcerns: Array.from(new Set([
              ...(r.healthConcerns || []),
              concern
            ])),
            tags: [...(r.tags || []), 'template-adapted']
          };
          
          results.push({
            recipe: adaptedRecipe,
            tier: 2,
            tierLabel: `Adapted for ${concern}`,
            healthConcernMatch: concern,
            template,
            warning: adapted.warnings.length > 0 
              ? `${template.warning || ''} ${adapted.warnings.join('; ')}`
              : template.warning,
            score: 80
          });
        });
      });
    });
  }
  
  // Tier 3: Species + age match (no health concern) - Fill up to minCount
  const tier3 = allRecipes.filter(r => {
    const speciesMatch = matchesSpecies(r, pet);
    const ageMatch = (r.ageGroup || []).includes(petAgeGroup) || (r.ageGroup || []).includes('all');
    const notIncluded = !results.some(res => res.recipe.id === r.id);
    return speciesMatch && ageMatch && notIncluded;
  }).slice(0, Math.max(0, minCount - results.length)) // Only take what we need
  .map(r => ({
    recipe: r,
    tier: 3,
    tierLabel: normalizedConcerns.length > 0 ? 'General Safe Meal' : 'Age-Appropriate',
    warning: normalizedConcerns.length > 0 
      ? `No ${normalizedConcerns[0]} recipes yet; this is a general safe meal`
      : undefined,
    score: 60
  }));
  results.push(...tier3);
  
  // Tier 4: Species match only (all ages) - Fill up to minCount
  // Always ensure we have at least minCount recipes
  const neededFromTier4 = Math.max(0, minCount - results.length);
  const tier4 = allRecipes.filter(r => {
    const speciesMatch = matchesSpecies(r, pet);
    const notIncluded = !results.some(res => res.recipe.id === r.id);
    return speciesMatch && notIncluded;
  }).slice(0, neededFromTier4) // Take only what we need to reach minCount
  .map(r => ({
    recipe: r,
    tier: 4,
    tierLabel: 'Species-Appropriate',
    warning: 'Not optimized for age or health concerns',
    score: 40
  }));
  results.push(...tier4);
  
  // Tier 5: Subtype match (generic) - Fill up to minCount for exotics
  if (results.length < minCount && ['bird', 'reptile', 'pocket-pet', 'birds', 'reptiles', 'pocket-pets'].includes(type)) {
    const subtype = normalizeToSubtype(type as any, pet.breed);
    const tier5 = allRecipes.filter(r => {
      const matchesSubtype = r.category === subtype || 
        (r.category && r.category.includes(subtype.split('_')[0])) ||
        matchesSpecies(r, pet); // Also include any species matches
      const notIncluded = !results.some(res => res.recipe.id === r.id);
      return matchesSubtype && notIncluded;
    }).slice(0, minCount - results.length) // Only take what we need
    .map(r => ({
      recipe: r,
      tier: 5,
      tierLabel: 'Generic ' + subtype.replace('_', ' ') + ' Template',
      warning: 'Generic template - confirm with your vet',
      score: 30
    }));
    results.push(...tier5);
  }
  
  // Tier 6: Health template-based suggestions (always ensure something shows)
  // Also run if we're below minCount for exotics
  if ((results.length === 0 || (results.length < minCount && ['bird', 'reptile', 'pocket-pet', 'birds', 'reptiles', 'pocket-pets'].includes(type))) && normalizedConcerns.length > 0) {
    const templates = getHealthTemplatesForSpecies(type, pet.breed, normalizedConcerns[0]);
    if (templates.length > 0) {
      // Create a placeholder recipe from template
      const template = templates[0];
      const placeholderRecipe: Recipe = {
        id: `template-${template.id}`,
        name: template.name,
        category: type,
        ageGroup: [age],
        healthConcerns: [normalizedConcerns[0]],
        description: template.description,
        ingredients: (template.rules.preferIngredients || []).map((ing, idx) => ({
          id: `ing-${idx}`,
          name: ing,
          amount: 'varies',
          asinLink: ''
        })),
        instructions: ['Use custom meal builder with this template', 'Follow template guidelines'],
        tags: ['template', 'health-concern'],
        rating: 0,
        reviews: 0,
        prepTime: '0 min',
        cookTime: '0 min',
        servings: 1
      };
      
      results.push({
        recipe: placeholderRecipe,
        tier: 6,
        tierLabel: 'Template-Based',
        template,
        warning: template.warning || 'Use custom meal builder with health template',
        score: 20
      });
    }
  }
  
  // Apply improved scoring if requested
  if (useEnhancedScoring) {
    results.forEach(result => {
      try {
        // Convert pet format for improved scoring
        const enhancedPet: EnhancedPet = {
          id: pet.id,
          name: pet.name,
          type: pet.type as 'dog' | 'cat' | 'bird' | 'reptile' | 'pocket-pet',
          breed: pet.breed,
          age: parseFloat(pet.age) || 1,
          weight: pet.weight || 10,
          activityLevel: pet.activityLevel,
          healthConcerns: pet.healthConcerns || [],
          dietaryRestrictions: pet.dietaryRestrictions || [],
          allergies: pet.allergies || [],
        };
        
        const enhanced = calculateEnhancedCompatibility(result.recipe, enhancedPet);
        result.enhancedScore = enhanced;
        result.score = enhanced.overallScore;
      } catch (error) {
        // If enhanced scoring fails, keep original score
        console.warn('Enhanced scoring failed for recipe:', result.recipe.id, error);
      }
    });
  }

  // Sort by score (tier or enhanced score) and return
  const sorted = results.sort((a, b) => {
    // If both have enhanced scores, use those
    if (a.enhancedScore && b.enhancedScore) {
      return b.enhancedScore.overallScore - a.enhancedScore.overallScore;
    }
    // Otherwise use tier score
    return b.score - a.score;
  });
  // Return up to minCount recipes, or all if we have fewer than minCount
  return sorted.slice(0, Math.min(minCount, sorted.length));
};

/**
 * Get count of recipes by priority level for display purposes
 * Returns empty stats since recipes are now generated dynamically
 */
export const getRecommendationStats = (pet: Pet) => {
  return {
    perfect: 0,
    typeAge: 0,
    typeOnly: 0,
    total: 0
  };
};
</file>

<file path="lib/utils/recipeScoring.ts">
// lib/utils/recipeScoring.ts
// Scoring system that ranks recipes 0-100 based on pet profile matching

import type { Recipe } from '@/lib/types';

export interface Pet {
  species: 'dogs' | 'cats' | 'birds' | 'reptiles' | 'pocket-pets';
  breed: string;
  ageGroup: 'baby' | 'young' | 'adult' | 'senior';
  weightStatus?: 'overweight' | 'underweight' | 'ideal';
  healthConcerns: string[];
  savedRecipes?: string[];
  names?: string[];
  weightKg?: number;
  weight?: number | string;
  dietaryRestrictions?: string[];
  allergies?: string[];
  dislikes?: string[];
}

export interface ScoreResult {
  compatibilityScore: number; // 0-100 (formerly matchScore)
  matchScore: number; // 0-100 (deprecated - use compatibilityScore)
  stars: number; // 1-5
  reasoning: {
    goodMatches: string[];
    conflicts: string[];
  };
}

// Common allergens to check
const ALLERGEN_KEYWORDS: Record<string, string[]> = {
  chicken: ['chicken', 'poultry', 'hen'],
  beef: ['beef', 'cow'],
  dairy: ['dairy', 'milk', 'cheese', 'yogurt'],
  grain: ['wheat', 'grain', 'corn', 'barley', 'oats'],
  egg: ['egg'],
};

function hasAllergen(recipe: Recipe, allergen: string): boolean {
  const keywords = ALLERGEN_KEYWORDS[allergen.toLowerCase()] || [allergen.toLowerCase()];
  const allText = `${recipe.name} ${recipe.description} ${recipe.ingredients.map(i => i.name).join(' ')}`.toLowerCase();
  return keywords.some(kw => allText.includes(kw));
}

function isLowCalorie(recipe: Recipe): boolean {
  const name = recipe.name.toLowerCase();
  const desc = (recipe.description || '').toLowerCase();
  return name.includes('low-fat') || name.includes('lean') || name.includes('slim') ||
         desc.includes('low-calorie') || desc.includes('weight') || desc.includes('diet');
}

function isInAAFCORange(recipe: Recipe, species: 'dogs' | 'cats'): boolean {
  if (!recipe.nutritionalInfo) return false;
  
  const protein = recipe.nutritionalInfo.protein?.min || 0;
  const fat = recipe.nutritionalInfo.fat?.min || 0;
  
  if (species === 'dogs') {
    return protein >= 18 && protein <= 30 && fat >= 5 && fat <= 20;
  } else { // cats
    return protein >= 26 && protein <= 40 && fat >= 9 && fat <= 25;
  }
}

export function scoreRecipe(recipe: Recipe, pet: Pet): ScoreResult {
  let score = 0;
  const goodMatches: string[] = [];
  const conflicts: string[] = [];

  // 1. Species Match (Required Gate - 0 if wrong species)
  if (recipe.category !== pet.species) {
    return {
      compatibilityScore: 0,
      matchScore: 0,
      stars: 1,
      reasoning: {
        goodMatches: [],
        conflicts: [`Recipe is for ${recipe.category}, but pet is ${pet.species}`]
      }
    };
  }

  // 2. Age Group Match (+20)
  if (recipe.ageGroup.includes(pet.ageGroup)) {
    score += 20;
    goodMatches.push('Age group match');
  } else {
    conflicts.push('Age group mismatch');
  }

  // 3. Breed Relevance (+10)
  if (recipe.breed) {
    const breeds = Array.isArray(recipe.breed) ? recipe.breed : [recipe.breed];
    const breedMatch = breeds.some(b =>
      b && b.toLowerCase().replace(/-/g, ' ') === pet.breed.toLowerCase().replace(/-/g, ' ')
    );
    if (breedMatch) {
      score += 10;
      goodMatches.push('Breed-specific recipe');
    }
  }

  // 4. Health Concern Overlap (+10 per match, max +40)
  if (pet.healthConcerns.length > 0 && recipe.healthConcerns.length > 0) {
    const matches = pet.healthConcerns.filter(hc => 
      recipe.healthConcerns.some(rc => 
        rc.toLowerCase().includes(hc.toLowerCase()) || 
        hc.toLowerCase().includes(rc.toLowerCase())
      )
    );
    const healthScore = Math.min(matches.length * 10, 40);
    score += healthScore;
    if (matches.length > 0) {
      goodMatches.push(`${matches.length} health concern${matches.length > 1 ? 's' : ''} addressed`);
    }
  }

  // 5. Weight Control Fit (+10)
  if (pet.weightStatus === 'overweight' && isLowCalorie(recipe)) {
    score += 10;
    goodMatches.push('Low-calorie option for weight management');
  }

  // 6. Allergy Safety (-40 penalty if allergen present)
  if (pet.healthConcerns.includes('allergies')) {
    const hasAllergy = pet.healthConcerns.some(concern => {
      const allergen = concern.toLowerCase();
      return Object.keys(ALLERGEN_KEYWORDS).some(key => 
        allergen.includes(key) && hasAllergen(recipe, key)
      );
    });
    if (hasAllergy) {
      score = Math.max(0, score - 40);
      conflicts.push('Contains common allergen');
    }
  }

  // 7. Nutrient Fit (+20 if in AAFCO range for dogs/cats)
  if ((pet.species === 'dogs' || pet.species === 'cats') && isInAAFCORange(recipe, pet.species)) {
    score += 20;
    goodMatches.push('Meets AAFCO nutritional standards');
  } else if (pet.species === 'dogs' || pet.species === 'cats') {
    // Small penalty if not in range
    score = Math.max(0, score - 5);
  }

  // Cap at 100
  score = Math.min(100, Math.max(0, score));

  // Map to stars
  let stars: number;
  if (score >= 90) stars = 5;
  else if (score >= 75) stars = 4;
  else if (score >= 50) stars = 3;
  else if (score >= 25) stars = 2;
  else stars = 1;

  return {
    compatibilityScore: score,
    matchScore: score, // Keep for backward compatibility
    stars,
    reasoning: {
      goodMatches,
      conflicts
    }
  };
}
</file>

<file path="lib/utils/scoringDiagnostics.ts">
import { Recipe, Pet } from '../types';
import { calculateEnhancedCompatibility } from './enhancedCompatibilityScoring';

export interface ScoreDistributionAnalysis {
  totalRecipes: number;
  scoreRanges: {
    '95-100': number;
    '90-94': number;
    '80-89': number;
    '70-79': number;
    '60-69': number;
    '50-59': number;
    '40-49': number;
    '30-39': number;
    '0-29': number;
  };
  perfectMatches: number;
  clustering: {
    at40: number;
    at100: number;
  };
  averageScore: number;
  medianScore: number;
  standardDeviation: number;
  isBinaryDistribution: boolean;
  recommendations: string[];
}

/**
 * Analyze score distribution for a set of recipes and a pet
 * Helps identify clustering, binary distributions, and scoring issues
 */
export function analyzeScoreDistribution(
  recipes: Recipe[],
  pet: Pet
): ScoreDistributionAnalysis {
  const scores = recipes.map(recipe => 
    calculateEnhancedCompatibility(recipe, pet).overallScore
  );
  
  // Calculate statistics
  const totalRecipes = scores.length;
  const averageScore = scores.reduce((a, b) => a + b, 0) / totalRecipes;
  const sortedScores = [...scores].sort((a, b) => a - b);
  const medianScore = totalRecipes > 0 
    ? sortedScores[Math.floor(totalRecipes / 2)]
    : 0;
  
  // Calculate standard deviation
  const variance = scores.reduce((sum, score) => {
    return sum + Math.pow(score - averageScore, 2);
  }, 0) / totalRecipes;
  const standardDeviation = Math.sqrt(variance);
  
  // Count score ranges
  const scoreRanges = {
    '95-100': scores.filter(s => s >= 95).length,
    '90-94': scores.filter(s => s >= 90 && s < 95).length,
    '80-89': scores.filter(s => s >= 80 && s < 90).length,
    '70-79': scores.filter(s => s >= 70 && s < 80).length,
    '60-69': scores.filter(s => s >= 60 && s < 70).length,
    '50-59': scores.filter(s => s >= 50 && s < 60).length,
    '40-49': scores.filter(s => s >= 40 && s < 50).length,
    '30-39': scores.filter(s => s >= 30 && s < 40).length,
    '0-29': scores.filter(s => s < 30).length,
  };
  
  // Count perfect matches (95-100)
  const perfectMatches = scoreRanges['95-100'];
  
  // Detect clustering (scores within 2 points of 40 or 100)
  const clustering = {
    at40: scores.filter(s => Math.abs(s - 40) < 2).length,
    at100: scores.filter(s => Math.abs(s - 100) < 2).length,
  };
  
  // Check for binary distribution
  // Binary if >30% at 40 and >30% at 100, or if standard deviation is very low
  const isBinaryDistribution = 
    (clustering.at40 > totalRecipes * 0.3 && clustering.at100 > totalRecipes * 0.3) ||
    (standardDeviation < 10 && (clustering.at40 > totalRecipes * 0.2 || clustering.at100 > totalRecipes * 0.2));
  
  // Generate recommendations
  const recommendations: string[] = [];
  
  if (isBinaryDistribution) {
    recommendations.push('‚ö†Ô∏è Binary distribution detected - adjust scoring granularity');
  }
  
  if (clustering.at40 > totalRecipes * 0.2) {
    recommendations.push('‚ö†Ô∏è Too many recipes clustering at 40% - lower safety floor or improve penalty granularity');
  }
  
  if (clustering.at100 > totalRecipes * 0.2) {
    recommendations.push('‚ö†Ô∏è Too many perfect scores - make isPerfectMatch() stricter or reduce perfect match bonus');
  }
  
  if (standardDeviation < 15) {
    recommendations.push('‚ö†Ô∏è Scores too similar - increase penalty/bonus differentiation');
  }
  
  if (perfectMatches > totalRecipes * 0.2) {
    recommendations.push('‚ö†Ô∏è Too many perfect matches (>20%) - tighten perfect match criteria');
  }
  
  if (perfectMatches === 0 && averageScore > 80) {
    recommendations.push('‚ÑπÔ∏è No perfect matches but high average - consider allowing some 95-100% scores');
  }
  
  if (scoreRanges['0-29'] > totalRecipes * 0.3) {
    recommendations.push('‚ö†Ô∏è Too many very low scores - check if penalties are too harsh');
  }
  
  return {
    totalRecipes,
    scoreRanges,
    perfectMatches,
    clustering,
    averageScore: Math.round(averageScore * 10) / 10,
    medianScore,
    standardDeviation: Math.round(standardDeviation * 10) / 10,
    isBinaryDistribution,
    recommendations,
  };
}

/**
 * Generate a detailed report of score distribution
 */
export function generateDistributionReport(
  recipes: Recipe[],
  pet: Pet
): string {
  const analysis = analyzeScoreDistribution(recipes, pet);
  
  let report = `\n=== Score Distribution Analysis ===\n\n`;
  report += `Total Recipes: ${analysis.totalRecipes}\n`;
  report += `Average Score: ${analysis.averageScore}%\n`;
  report += `Median Score: ${analysis.medianScore}%\n`;
  report += `Standard Deviation: ${analysis.standardDeviation}\n\n`;
  
  report += `Score Ranges:\n`;
  report += `  95-100: ${analysis.scoreRanges['95-100']} (${Math.round(analysis.scoreRanges['95-100'] / analysis.totalRecipes * 100)}%)\n`;
  report += `  90-94: ${analysis.scoreRanges['90-94']} (${Math.round(analysis.scoreRanges['90-94'] / analysis.totalRecipes * 100)}%)\n`;
  report += `  80-89: ${analysis.scoreRanges['80-89']} (${Math.round(analysis.scoreRanges['80-89'] / analysis.totalRecipes * 100)}%)\n`;
  report += `  70-79: ${analysis.scoreRanges['70-79']} (${Math.round(analysis.scoreRanges['70-79'] / analysis.totalRecipes * 100)}%)\n`;
  report += `  60-69: ${analysis.scoreRanges['60-69']} (${Math.round(analysis.scoreRanges['60-69'] / analysis.totalRecipes * 100)}%)\n`;
  report += `  50-59: ${analysis.scoreRanges['50-59']} (${Math.round(analysis.scoreRanges['50-59'] / analysis.totalRecipes * 100)}%)\n`;
  report += `  40-49: ${analysis.scoreRanges['40-49']} (${Math.round(analysis.scoreRanges['40-49'] / analysis.totalRecipes * 100)}%)\n`;
  report += `  30-39: ${analysis.scoreRanges['30-39']} (${Math.round(analysis.scoreRanges['30-39'] / analysis.totalRecipes * 100)}%)\n`;
  report += `  0-29: ${analysis.scoreRanges['0-29']} (${Math.round(analysis.scoreRanges['0-29'] / analysis.totalRecipes * 100)}%)\n\n`;
  
  report += `Clustering:\n`;
  report += `  At 40%: ${analysis.clustering.at40} recipes\n`;
  report += `  At 100%: ${analysis.clustering.at100} recipes\n\n`;
  
  report += `Binary Distribution: ${analysis.isBinaryDistribution ? 'YES ‚ö†Ô∏è' : 'NO ‚úì'}\n\n`;
  
  if (analysis.recommendations.length > 0) {
    report += `Recommendations:\n`;
    analysis.recommendations.forEach(rec => {
      report += `  ${rec}\n`;
    });
  }
  
  return report;
}
</file>

<file path="lib/utils/scoringTransparency.ts">
// lib/utils/scoringTransparency.ts
// Scoring transparency debug tool

import type { Recipe } from '@/lib/types';
import { calculateEnhancedCompatibility, type Pet, calculateBonuses, calculateRecipeNutrition } from './enhancedCompatibilityScoring';

export interface ScoringReport {
  factors: Record<string, {
    score: number;
    weight: number;
    contribution: number;
    canBe100: boolean;
    explanation: string;
    issues: string[];
  }>;
  currentScore: number;
  maxPossibleScore: number;
  canReach100: boolean;
  barriersTo100: string[];
  bonuses: number;
  penalties: number;
}

/**
 * Generate a detailed scoring report for debugging
 */
export function generateScoringReport(
  recipe: Recipe,
  pet: Pet
): ScoringReport {
  const result = calculateEnhancedCompatibility(recipe, pet);
  const bonuses = calculateBonuses(recipe, pet);
  
  const factors: ScoringReport['factors'] = {};
  let maxPossible = 0;
  const barriers: string[] = [];
  
  Object.entries(result.factors).forEach(([key, factor]) => {
    const weight = factor.weight || 0;
    const contribution = factor.score * weight;
    const canBe100 = checkIfFactorCanBe100(key, recipe, pet);
    
    if (!canBe100 && factor.score < 100) {
      barriers.push(`${key}: ${factor.reasoning}`);
    }
    
    maxPossible += canBe100 ? 100 * weight : factor.score * weight;
    
    factors[key] = {
      score: factor.score,
      weight,
      contribution,
      canBe100,
      explanation: factor.reasoning,
      issues: factor.issues
    };
  });
  
  return {
    factors,
    currentScore: result.overallScore,
    maxPossibleScore: maxPossible + bonuses,
    canReach100: maxPossible + bonuses >= 99.5,
    barriersTo100: barriers,
    bonuses,
    penalties: result.detailedBreakdown.warnings.length
  };
}

/**
 * Check if a factor can theoretically reach 100% for this recipe+pet combination
 */
function checkIfFactorCanBe100(factorName: string, recipe: Recipe, pet: Pet): boolean {
  switch (factorName) {
    case 'ingredientSafety':
      // Can be 100 if all ingredients are safe
      return true;
    case 'nutritionalAdequacy':
      // Can be 100 if nutrition is perfect and no fallback data (or pet has no concerns)
      const nutrition = calculateRecipeNutrition(recipe);
      if (pet.healthConcerns.length === 0) {
        // Perfect pets don't penalize fallback data
        return true;
      }
      return !nutrition.usesFallbackNutrition;
    case 'healthAlignment':
      // Can be 100 if pet has no health concerns
      return pet.healthConcerns.length === 0;
    case 'lifeStageFit':
      // Can be 100 if age matches
      return true;
    case 'activityFit':
      // Can be 100 if activity level not specified or matches
      return true;
    case 'allergenSafety':
      // Can be 100 if no allergens
      return (pet.allergies?.length ?? 0) === 0 && pet.dietaryRestrictions.length === 0;
    case 'ingredientQuality':
      // Can be 100 if all ingredients are premium (but this is now a bonus, not requirement)
      return true;
    default:
      return true;
  }
}
</file>

<file path="lib/utils/telemetry.ts">
// lib/utils/telemetry.ts
// Client-side telemetry for performance and quality monitoring
// Tracks: JSON load time, scoring time, validation status distribution

interface TelemetryEvent {
  type: 'json_load' | 'scoring' | 'validation_status' | 'page_load';
  timestamp: number;
  duration?: number; // milliseconds
  metadata?: Record<string, any>;
}

const TELEMETRY_KEY = 'pet_plates_telemetry';
const BATCH_SIZE = 10; // Send after N events
const BATCH_INTERVAL_MS = 30000; // Send every 30 seconds
const MAX_EVENTS = 100; // Maximum events to store

class Telemetry {
  private events: TelemetryEvent[] = [];
  private batchTimer: NodeJS.Timeout | null = null;

  constructor() {
    if (typeof window !== 'undefined') {
      this.loadEvents();
      this.startBatchTimer();
      
      // Send on page unload
      window.addEventListener('beforeunload', () => {
        this.flush();
      });
    }
  }

  private loadEvents(): void {
    if (typeof window === 'undefined') return;
    
    try {
      const stored = localStorage.getItem(TELEMETRY_KEY);
      if (stored) {
        this.events = JSON.parse(stored);
        // Keep only recent events (last 100)
        if (this.events.length > MAX_EVENTS) {
          this.events = this.events.slice(-MAX_EVENTS);
        }
      }
    } catch (error) {
      console.warn('Failed to load telemetry events:', error);
      this.events = [];
    }
  }

  private saveEvents(): void {
    if (typeof window === 'undefined') return;
    
    try {
      localStorage.setItem(TELEMETRY_KEY, JSON.stringify(this.events));
    } catch (error) {
      console.warn('Failed to save telemetry events:', error);
    }
  }

  private startBatchTimer(): void {
    if (typeof window === 'undefined') return;
    
    this.batchTimer = setInterval(() => {
      if (this.events.length >= BATCH_SIZE) {
        this.flush();
      }
    }, BATCH_INTERVAL_MS);
  }

  /**
   * Track JSON load time
   */
  trackJsonLoad(duration: number, size?: number): void {
    this.addEvent({
      type: 'json_load',
      timestamp: Date.now(),
      duration,
      metadata: size ? { size } : undefined,
    });
  }

  /**
   * Track scoring time
   */
  trackScoring(duration: number, recipeCount: number, cacheHit?: boolean): void {
    this.addEvent({
      type: 'scoring',
      timestamp: Date.now(),
      duration,
      metadata: {
        recipeCount,
        cacheHit: cacheHit || false,
      },
    });
  }

  /**
   * Track validation status
   */
  trackValidationStatus(status: 'valid' | 'needsReview' | 'invalid', recipeId?: string): void {
    this.addEvent({
      type: 'validation_status',
      timestamp: Date.now(),
      metadata: {
        status,
        recipeId,
      },
    });
  }

  /**
   * Track page load time
   */
  trackPageLoad(duration: number, page: string): void {
    this.addEvent({
      type: 'page_load',
      timestamp: Date.now(),
      duration,
      metadata: { page },
    });
  }

  private addEvent(event: TelemetryEvent): void {
    this.events.push(event);
    
    // Keep only recent events
    if (this.events.length > MAX_EVENTS) {
      this.events = this.events.slice(-MAX_EVENTS);
    }
    
    this.saveEvents();
    
    // Auto-flush if batch size reached
    if (this.events.length >= BATCH_SIZE) {
      this.flush();
    }
  }

  /**
   * Get telemetry summary statistics
   */
  getSummary(): {
    jsonLoadTimes: number[];
    scoringTimes: number[];
    validationStatuses: Record<string, number>;
    pageLoadTimes: Record<string, number[]>;
  } {
    const jsonLoadTimes: number[] = [];
    const scoringTimes: number[] = [];
    const validationStatuses: Record<string, number> = {};
    const pageLoadTimes: Record<string, number[]> = {};

    this.events.forEach(event => {
      switch (event.type) {
        case 'json_load':
          if (event.duration) jsonLoadTimes.push(event.duration);
          break;
        case 'scoring':
          if (event.duration) scoringTimes.push(event.duration);
          break;
        case 'validation_status':
          const status = event.metadata?.status || 'unknown';
          validationStatuses[status] = (validationStatuses[status] || 0) + 1;
          break;
        case 'page_load':
          const page = event.metadata?.page || 'unknown';
          if (!pageLoadTimes[page]) pageLoadTimes[page] = [];
          if (event.duration) pageLoadTimes[page].push(event.duration);
          break;
      }
    });

    return {
      jsonLoadTimes,
      scoringTimes,
      validationStatuses,
      pageLoadTimes,
    };
  }

  /**
   * Flush events to server (if endpoint available) or console
   */
  flush(): void {
    if (this.events.length === 0) return;

    const summary = this.getSummary();
    
    // Log summary to console (in development)
    if (process.env.NODE_ENV === 'development') {
      const { jsonLoadTimes, scoringTimes, validationStatuses, pageLoadTimes } = summary;
      console.log('üìä Telemetry Summary:', {
        totalEvents: this.events.length,
        jsonLoadAvg: jsonLoadTimes.length > 0 
          ? (jsonLoadTimes.reduce((a: number, b: number) => a + b, 0) / jsonLoadTimes.length).toFixed(2) + 'ms'
          : 'N/A',
        scoringAvg: scoringTimes.length > 0
          ? (scoringTimes.reduce((a: number, b: number) => a + b, 0) / scoringTimes.length).toFixed(2) + 'ms'
          : 'N/A',
        validationStatuses,
        pageLoadAvgs: Object.entries(pageLoadTimes).map(([page, times]) => ({
          page,
          avg: (Array.isArray(times) ? times.reduce((a: number, b: number) => a + b, 0) / times.length : 0).toFixed(2) + 'ms',
        })),
      });
    }

    // TODO: Send to analytics endpoint if available
    // Example:
    // fetch('/api/telemetry', {
    //   method: 'POST',
    //   headers: { 'Content-Type': 'application/json' },
    //   body: JSON.stringify({ events: this.events, summary }),
    // }).catch(() => {});

    // Clear events after flushing
    this.events = [];
    this.saveEvents();
  }

  /**
   * Clear all telemetry data
   */
  clear(): void {
    this.events = [];
    this.saveEvents();
  }
}

// Singleton instance
let telemetryInstance: Telemetry | null = null;

export function getTelemetry(): Telemetry {
  if (!telemetryInstance) {
    telemetryInstance = new Telemetry();
  }
  return telemetryInstance;
}

// Convenience functions
export const trackJsonLoad = (duration: number, size?: number) => 
  getTelemetry().trackJsonLoad(duration, size);

export const trackScoring = (duration: number, recipeCount: number, cacheHit?: boolean) =>
  getTelemetry().trackScoring(duration, recipeCount, cacheHit);

export const trackValidationStatus = (status: 'valid' | 'needsReview' | 'invalid', recipeId?: string) =>
  getTelemetry().trackValidationStatus(status, recipeId);

export const trackPageLoad = (duration: number, page: string) =>
  getTelemetry().trackPageLoad(duration, page);

export const getTelemetrySummary = () => getTelemetry().getSummary();

export const flushTelemetry = () => getTelemetry().flush();
</file>

<file path="lib/utils/validation.ts">
// lib/utils/validation.ts
// Input validation and sanitization utilities with Zod schemas

import { z } from 'zod';
import type { Pet } from '../utils/petUtils';
import type { Recipe, Ingredient, PetNutritionProfile, CustomMeal } from '../types';
import type { PurchaseRecord } from './purchaseTracking';

/**
 * Sanitizes user input to prevent XSS attacks
 */
export function sanitizeInput(input: string): string {
  if (typeof input !== 'string') return '';
  
  return input
    .trim()
    .replace(/[<>]/g, '') // Remove < and > to prevent HTML injection
    .replace(/javascript:/gi, '') // Remove javascript: protocol
    .replace(/on\w+=/gi, '') // Remove event handlers like onclick=
    .slice(0, 500); // Limit length
}

/**
 * Validates pet name
 */
export function validatePetName(name: string): { valid: boolean; error?: string } {
  if (!name || typeof name !== 'string') {
    return { valid: false, error: 'Pet name is required' };
  }
  
  const trimmed = name.trim();
  
  if (trimmed.length === 0) {
    return { valid: false, error: 'Pet name cannot be empty' };
  }
  
  if (trimmed.length > 50) {
    return { valid: false, error: 'Pet name must be 50 characters or less' };
  }
  
  // Check for potentially dangerous characters
  if (/[<>]/.test(trimmed)) {
    return { valid: false, error: 'Pet name contains invalid characters' };
  }
  
  return { valid: true };
}

/**
 * Validates pet weight
 */
export function validatePetWeight(weight: string): { valid: boolean; error?: string; value?: number } {
  if (!weight || typeof weight !== 'string') {
    return { valid: false, error: 'Weight is required' };
  }
  
  const trimmed = weight.trim();
  
  if (trimmed.length === 0) {
    return { valid: false, error: 'Weight cannot be empty' };
  }
  
  // Extract number from string (handles "10 lbs", "10kg", etc.)
  const match = trimmed.match(/(\d+\.?\d*)/);
  if (!match) {
    return { valid: false, error: 'Weight must be a number' };
  }
  
  const numValue = parseFloat(match[1]);
  
  if (isNaN(numValue) || numValue <= 0) {
    return { valid: false, error: 'Weight must be a positive number' };
  }
  
  if (numValue > 1000) {
    return { valid: false, error: 'Weight seems too high. Please check your input.' };
  }
  
  return { valid: true, value: numValue };
}

/**
 * Validates recipe ID format
 */
export function validateRecipeId(recipeId: string): { valid: boolean; error?: string } {
  if (!recipeId || typeof recipeId !== 'string') {
    return { valid: false, error: 'Recipe ID is required' };
  }
  
  // Recipe IDs should match pattern like "dog-01", "cat-11", etc.
  if (!/^[a-z]+-\d+$/.test(recipeId)) {
    return { valid: false, error: 'Invalid recipe ID format' };
  }
  
  return { valid: true };
}

/**
 * Validates user rating (1-5)
 */
export function validateRating(rating: number | string): { valid: boolean; error?: string; value?: number } {
  const numRating = typeof rating === 'string' ? parseFloat(rating) : rating;
  
  if (isNaN(numRating)) {
    return { valid: false, error: 'Rating must be a number' };
  }
  
  if (numRating < 1 || numRating > 5) {
    return { valid: false, error: 'Rating must be between 1 and 5' };
  }
  
  return { valid: true, value: Math.round(numRating) };
}

/**
 * Validates userId
 */
export function validateUserId(userId: string | null | undefined): { valid: boolean; error?: string } {
  if (!userId || typeof userId !== 'string') {
    return { valid: false, error: 'User ID is required' };
  }
  
  if (userId.trim().length === 0) {
    return { valid: false, error: 'User ID cannot be empty' };
  }
  
  return { valid: true };
}

/**
 * Validates array of strings (for health concerns, allergies, etc.)
 */
export function validateStringArray(arr: any, maxLength: number = 20): { valid: boolean; error?: string; value?: string[] } {
  if (!Array.isArray(arr)) {
    return { valid: false, error: 'Must be an array' };
  }
  
  if (arr.length > maxLength) {
    return { valid: false, error: `Maximum ${maxLength} items allowed` };
  }
  
  const validItems = arr
    .filter((item): item is string => typeof item === 'string')
    .map(item => sanitizeInput(item))
    .filter(item => item.length > 0);
  
  return { valid: true, value: validItems };
}

// =================================================================
// ZOD SCHEMAS
// =================================================================

/**
 * Zod schema for Pet validation
 */
export const PetSchema = z.object({
  id: z.string().min(1, 'Pet ID is required'),
  names: z.array(z.string().min(1).max(50)).min(1, 'At least one name is required'),
  type: z.enum(['dogs', 'cats', 'birds', 'reptiles', 'pocket-pets'], {
    errorMap: () => ({ message: 'Invalid pet type' })
  }),
  breed: z.string().min(1, 'Breed is required').max(100),
  weight: z.string().min(1, 'Weight is required').refine(
    (val) => {
      const match = val.trim().match(/(\d+\.?\d*)/);
      if (!match) return false;
      const num = parseFloat(match[1]);
      return !isNaN(num) && num > 0 && num <= 1000;
    },
    { message: 'Weight must be a positive number between 0 and 1000' }
  ),
  age: z.string().min(1, 'Age is required'),
  healthConcerns: z.array(z.string()).max(20, 'Maximum 20 health concerns allowed').default([]),
  mealPlan: z.array(z.string()).default([]),
  savedRecipes: z.array(z.string()).default([]),
  dislikes: z.array(z.string()).max(20).optional(),
  image: z.string().url().optional().or(z.literal('')),
}).refine(
  (data) => {
    // Sanitize names
    return data.names.every(name => !/[<>]/.test(name));
  },
  { message: 'Pet names contain invalid characters', path: ['names'] }
);

/**
 * Zod schema for Ingredient validation
 */
export const IngredientSchema = z.object({
  id: z.string().min(1, 'Ingredient ID is required'),
  name: z.string().min(1, 'Ingredient name is required').max(200),
  amount: z.string().min(1, 'Amount is required').max(100),
  asinLink: z.string().url().optional(),
  productName: z.string().max(200).optional(),
  vetNote: z.string().max(500).optional(),
  isVetted: z.boolean().optional(),
  isGeneric: z.boolean().optional(),
  asin: z.string().regex(/^[A-Z0-9]{10}$/, 'Invalid ASIN format').optional(),
});

/**
 * Zod schema for Recipe validation
 */
export const RecipeSchema = z.object({
  id: z.string().regex(/^[a-z]+-\d+$/, 'Invalid recipe ID format'),
  name: z.string().min(1, 'Recipe name is required').max(200),
  shortName: z.string().max(100).optional(),
  celebrityName: z.string().max(100).optional(),
  celebrityQuote: z.string().max(500).optional(),
  category: z.string().min(1),
  breed: z.union([z.string(), z.array(z.string()), z.null()]).optional(),
  ageGroup: z.array(z.string()).min(1, 'At least one age group is required'),
  healthConcerns: z.array(z.string()).default([]),
  notSuitableFor: z.array(z.string()).optional(),
  description: z.string().max(2000).optional(),
  tags: z.array(z.string()).optional(),
  imageUrl: z.string().url().optional(),
  prepTime: z.string().optional(),
  cookTime: z.string().optional(),
  servings: z.number().int().positive().optional(),
  ingredients: z.array(IngredientSchema).min(1, 'At least one ingredient is required'),
  instructions: z.array(z.string()).min(1, 'At least one instruction is required'),
  supplements: z.array(IngredientSchema).optional(),
  nutritionalInfo: z.object({
    protein: z.object({ min: z.number(), max: z.number(), unit: z.string() }).optional(),
    fat: z.object({ min: z.number(), max: z.number(), unit: z.string() }).optional(),
    fiber: z.object({ min: z.number(), max: z.number(), unit: z.string() }).optional(),
    calories: z.object({ min: z.number(), max: z.number(), unit: z.string() }).optional(),
    phosphorus: z.object({ min: z.number(), max: z.number(), unit: z.string() }).optional(),
    calcium: z.object({ min: z.number(), max: z.number(), unit: z.string() }).optional(),
  }).optional(),
  nutritionInfo: z.object({
    protein: z.string().optional(),
    fat: z.string().optional(),
    fiber: z.string().optional(),
    calories: z.string().optional(),
    calcium: z.string().optional(),
  }).optional(),
  rating: z.number().min(1).max(5).optional(),
  reviews: z.number().int().nonnegative().optional(),
});

/**
 * Zod schema for PurchaseRecord validation
 */
export const PurchaseRecordSchema = z.object({
  ingredientId: z.string().min(1, 'Ingredient ID is required'),
  ingredientName: z.string().max(200).optional(),
  purchaseDate: z.string().datetime({ message: 'Invalid ISO date format' }),
  confirmed: z.boolean(),
  amazonOrderId: z.string().max(100).optional(),
});

/**
 * Zod schema for PetNutritionProfile validation
 */
export const PetNutritionProfileSchema = z.object({
  species: z.string().min(1, 'Species is required'),
  ageGroup: z.string().min(1, 'Age group is required'),
  weightKg: z.number().positive('Weight must be positive').max(1000, 'Weight seems too high'),
  breed: z.string().nullable().optional(),
  healthConcerns: z.array(z.string()).max(20).optional(),
  allergies: z.array(z.string()).max(20).optional(),
  caloriesPerKgOverride: z.number().positive().optional(),
  petName: z.string().max(50).optional(),
});

/**
 * Zod schema for CustomMeal validation
 */
export const CustomMealSchema = z.object({
  id: z.string().min(1, 'Meal ID is required'),
  petId: z.string().min(1, 'Pet ID is required'),
  userId: z.string().min(1, 'User ID is required'),
  name: z.string().min(1, 'Meal name is required').max(200),
  createdAt: z.string().datetime({ message: 'Invalid ISO date format' }),
  updatedAt: z.string().datetime({ message: 'Invalid ISO date format' }),
  ingredients: z.array(z.object({
    key: z.string().min(1),
    grams: z.number().positive('Grams must be positive'),
  })).min(1, 'At least one ingredient is required'),
  analysis: z.object({
    score: z.number().min(0).max(100),
    nutrients: z.record(z.string(), z.number()),
    totalRecipeGrams: z.number().positive(),
    recommendedServingGrams: z.number().positive(),
    breakdown: z.object({
      nutrientCoverageScore: z.number(),
      toxicityPenalty: z.number(),
      balanceVarietyScore: z.number(),
    }),
    toxicityWarnings: z.array(z.object({
      message: z.string(),
      severity: z.enum(['low', 'medium', 'high', 'critical']),
      ingredientKey: z.string().optional(),
      ingredientName: z.string().optional(),
    })),
    allergyWarnings: z.array(z.object({
      message: z.string(),
      severity: z.enum(['low', 'medium', 'high', 'critical']),
    })),
    nutrientWarnings: z.array(z.object({
      message: z.string(),
      severity: z.enum(['low', 'medium', 'high', 'critical']),
    })),
    suggestions: z.array(z.object({
      message: z.string(),
      action: z.string().optional(),
      confidence: z.enum(['low', 'medium', 'high']).optional(),
    })),
  }),
});

// =================================================================
// VALIDATION FUNCTIONS USING ZOD
// =================================================================

/**
 * Validate a Pet object using Zod schema
 */
export function validatePetWithZod(pet: unknown): { valid: boolean; error?: string; data?: Pet } {
  try {
    const validated = PetSchema.parse(pet);
    return { valid: true, data: validated };
  } catch (error) {
    if (error instanceof z.ZodError) {
      const firstError = error.errors[0];
      return { 
        valid: false, 
        error: `${firstError.path.join('.')}: ${firstError.message}` 
      };
    }
    return { valid: false, error: 'Validation failed' };
  }
}

/**
 * Validate a Recipe object using Zod schema
 */
export function validateRecipeWithZod(recipe: unknown): { valid: boolean; error?: string; data?: Recipe } {
  try {
    const validated = RecipeSchema.parse(recipe);
    return { valid: true, data: validated };
  } catch (error) {
    if (error instanceof z.ZodError) {
      const firstError = error.errors[0];
      return { 
        valid: false, 
        error: `${firstError.path.join('.')}: ${firstError.message}` 
      };
    }
    return { valid: false, error: 'Validation failed' };
  }
}

/**
 * Validate an Ingredient object using Zod schema
 */
export function validateIngredientWithZod(ingredient: unknown): { valid: boolean; error?: string; data?: Ingredient } {
  try {
    const validated = IngredientSchema.parse(ingredient);
    return { valid: true, data: validated };
  } catch (error) {
    if (error instanceof z.ZodError) {
      const firstError = error.errors[0];
      return { 
        valid: false, 
        error: `${firstError.path.join('.')}: ${firstError.message}` 
      };
    }
    return { valid: false, error: 'Validation failed' };
  }
}

/**
 * Validate a PurchaseRecord object using Zod schema
 */
export function validatePurchaseRecordWithZod(record: unknown): { valid: boolean; error?: string; data?: PurchaseRecord } {
  try {
    const validated = PurchaseRecordSchema.parse(record);
    return { valid: true, data: validated };
  } catch (error) {
    if (error instanceof z.ZodError) {
      const firstError = error.errors[0];
      return { 
        valid: false, 
        error: `${firstError.path.join('.')}: ${firstError.message}` 
      };
    }
    return { valid: false, error: 'Validation failed' };
  }
}

/**
 * Validate a PetNutritionProfile object using Zod schema
 */
export function validatePetNutritionProfileWithZod(profile: unknown): { valid: boolean; error?: string; data?: PetNutritionProfile } {
  try {
    const validated = PetNutritionProfileSchema.parse(profile);
    return { valid: true, data: validated };
  } catch (error) {
    if (error instanceof z.ZodError) {
      const firstError = error.errors[0];
      return { 
        valid: false, 
        error: `${firstError.path.join('.')}: ${firstError.message}` 
      };
    }
    return { valid: false, error: 'Validation failed' };
  }
}

/**
 * Validate a CustomMeal object using Zod schema
 */
export function validateCustomMealWithZod(meal: unknown): { valid: boolean; error?: string; data?: CustomMeal } {
  try {
    const validated = CustomMealSchema.parse(meal);
    return { valid: true, data: validated };
  } catch (error) {
    if (error instanceof z.ZodError) {
      const firstError = error.errors[0];
      return { 
        valid: false, 
        error: `${firstError.path.join('.')}: ${firstError.message}` 
      };
    }
    return { valid: false, error: 'Validation failed' };
  }
}

/**
 * Safe parse with detailed error information
 */
export function safeParseWithZod<T>(schema: z.ZodSchema<T>, data: unknown): {
  success: boolean;
  data?: T;
  errors?: z.ZodError['errors'];
} {
  const result = schema.safeParse(data);
  if (result.success) {
    return { success: true, data: result.data };
  }
  return { success: false, errors: result.error.errors };
}
</file>

</files>
